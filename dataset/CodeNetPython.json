[
    {
        "content": [
            "# http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=4647653#1",
            "import sys",
            "sys.setrecursionlimit(10 ** 8)",
            "input = sys.stdin.readline",
            "class Graph:",
            "    def __init__(self, n, dictated=False, decrement=True, edge=[]):",
            "        self.n = n",
            "        self.dictated = dictated",
            "        self.decrement = decrement",
            "        self.edge = [set() for _ in range(self.n)]",
            "        self.parent = [-1]*self.n",
            "        self.info = [-1]*self.n",
            "        for x, y in edge:",
            "            self.add_edge(x,y)",
            "    def add_edge(self,x,y):",
            "        if self.decrement:",
            "            x -= 1",
            "            y -= 1",
            "        self.edge[x].add(y)",
            "        if self.dictated == False:",
            "            self.edge[y].add(x)",
            "    def add_adjacent_list(self,i,adjacent_list):",
            "        if self.decrement:",
            "            self.edge[i] = set(map(lambda x:x-1, adjacent_list))",
            "        else:",
            "            self.edge[i] = set(adjacent_list)",
            "    def path_detector(self, start=0, time=0):",
            "        \"\"\"",
            "        :param p: スタート地点",
            "        :return: 各点までの距離と何番目に発見したかを返す",
            "        \"\"\"",
            "        edge2= []",
            "        for i in range(self.n):",
            "            edge2.append(sorted(self.edge[i], reverse=True))",
            "        p, t = start, time",
            "        self.parent[p] = -2",
            "        full_path = [(p + self.decrement,t)]",
            "        while True:",
            "            if edge2[p]:",
            "                q = edge2[p].pop()",
            "                if q == self.parent[p] and not self.dictated:",
            "                    \"\"\" 逆流した時の処理 \"\"\"",
            "                    \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"",
            "                    continue",
            "                if self.parent[q] != -1:",
            "                    \"\"\" サイクルで同一点を訪れた時の処理 \"\"\"",
            "                    \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"",
            "                    continue",
            "                self.parent[q] = p",
            "                p, t = q, t + 1",
            "                full_path.append((p + self.decrement, t))",
            "            else:",
            "                \"\"\" 探索完了時の処理 \"\"\"",
            "                full_path.append((p + self.decrement, t))",
            "                \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"",
            "                if p == start and t == time:",
            "                    break",
            "                p, t = self.parent[p], t-1",
            "                \"\"\" 二度目に訪問時の処理 \"\"\"",
            "                \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"",
            "        return full_path",
            "    def path_list(self):",
            "        \"\"\"",
            "        :return: 探索経路を返す。",
            "        \"\"\"",
            "        self.parent = [-1]*self.n",
            "        res = []",
            "        for p in range(self.n):",
            "            if self.parent[p] == -1:",
            "                res.append(self.path_detector(start=p, time=1))",
            "        return res",
            "    def draw(self):",
            "        \"\"\"",
            "        :return: グラフを可視化",
            "        \"\"\"",
            "        import matplotlib.pyplot as plt",
            "        import networkx as nx",
            "        if self.dictated:",
            "            G = nx.DiGraph()",
            "        else:",
            "            G = nx.Graph()",
            "        for x in range(self.n):",
            "            for y in self.edge[x]:",
            "                G.add_edge(x + self.decrement, y + self.decrement)",
            "        nx.draw_networkx(G)",
            "        plt.show()",
            "def make_graph(dictated=False, decrement=True):",
            "    \"\"\"",
            "    自己ループの無いグラフを生成。N>=2",
            "    :param dictated: True = 有効グラフ",
            "    :param decrement: True = 1-indexed",
            "    :return:",
            "    \"\"\"",
            "    import random",
            "    N = random.randint(2, 5)",
            "    if N > 2:",
            "        M_max = (3*N-6)*(1+dictated)",
            "    else:",
            "        M_max = 1",
            "    graph = Graph(N, dictated, decrement)",
            "    for _ in range(random.randint(0,M_max)):",
            "        graph.add_edge(*random.sample(range(decrement, N+decrement), 2))",
            "    return graph",
            "##################################################################",
            "# 入力が隣接リストの場合",
            "##################################################################",
            "N = int(input())  # 頂点数",
            "graph = Graph(N,dictated=True, decrement=True)",
            "for i in range(N):  # [[頂点1と連結している頂点の集合], [頂点2と連結している頂点の集合],...]",
            "    points = list(map(int, input().split()))[2:]",
            "    graph.add_adjacent_list(i, points)",
            "data = graph.path_list()",
            "from itertools import chain",
            "data = list(chain.from_iterable(data))",
            "res = [[i+1,0,0] for i in range(N)]",
            "for time, a in enumerate(data, start=1):",
            "    i = a[0] - 1",
            "    if res[i][1]:",
            "        res[i][2] = time",
            "    else:",
            "        res[i][1] = time",
            "for a in res:",
            "    print(*a)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import abc",
            "class AdjacentGraph:",
            "    \"\"\"Implementation adjacency-list Graph.",
            "    Beware ids are between 1 and size.",
            "    \"\"\"",
            "    def __init__(self, size):",
            "        self.size = size",
            "        self._nodes = [[0] * (size+1) for _ in range(size+1)]",
            "    def set_adj_node(self, id_, adj_id):",
            "        self._nodes[id_][adj_id] = 1",
            "    def __iter__(self):",
            "        self._id = 0",
            "        return self",
            "    def __next__(self):",
            "        if self._id < self.size:",
            "            self._id += 1",
            "            return (self._id, self._nodes[self._id][1:])",
            "        raise StopIteration()",
            "    def dfs(self, handler=None):",
            "        def find_first():",
            "            try:",
            "                return visited.index(0) + 1",
            "            except ValueError:",
            "                return None",
            "        visited = [0] * self.size",
            "        first = 1",
            "        while first is not None:",
            "            stack = [(first, 0, 0)]",
            "            while len(stack) > 0:",
            "                i, depth, j = stack.pop()",
            "                if j == 0:",
            "                    if handler:",
            "                        handler.visit(i, depth)",
            "                    visited[i-1] = 1",
            "                    yield i",
            "                try:",
            "                    j = self._nodes[i].index(1, j+1)",
            "                    stack.append((i, depth, j))",
            "                    if visited[j-1] == 0:",
            "                        stack.append((j, depth+1, 0))",
            "                except ValueError:",
            "                    if handler:",
            "                        handler.leave(i)",
            "            first = find_first()",
            "    def bfs(self, handler=None):",
            "        def find_first():",
            "            try:",
            "                return visited.index(0) + 1",
            "            except ValueError:",
            "                return None",
            "        visited = [0] * self.size",
            "        first = 1",
            "        while first is not None:",
            "            queue = [(first, 0)]",
            "            while len(queue) > 0:",
            "                (i, depth), *queue = queue",
            "                if visited[i-1] == 0:",
            "                    if handler:",
            "                        handler.visit(i, depth)",
            "                    visited[i-1] = 1",
            "                    yield i",
            "                    try:",
            "                        j = 0",
            "                        while j < self.size:",
            "                            j = self._nodes[i].index(1, j+1)",
            "                            if visited[j-1] == 0:",
            "                                queue.append((j, depth+1))",
            "                    except ValueError:",
            "                        pass",
            "                if handler:",
            "                    handler.leave(i)",
            "            first = find_first()",
            "class EventHandler(abc.ABC):",
            "    @abc.abstractmethod",
            "    def visit(self, i, depth):",
            "        pass",
            "    @abc.abstractmethod",
            "    def leave(self, i):",
            "        pass",
            "class Logger(EventHandler):",
            "    def __init__(self, n):",
            "        self.log = [(0, 0)] * n",
            "        self.step = 0",
            "    def visit(self, i, depth):",
            "        self.step += 1",
            "        self.log[i-1] = (self.step, depth, 0)",
            "    def leave(self, i):",
            "        self.step += 1",
            "        self.log[i-1] = (self.log[i-1][0], self.log[i-1][1], self.step)",
            "    def by_node(self):",
            "        i = 1",
            "        for discover, depth, finish in self.log:",
            "            yield (i, discover, depth, finish)",
            "            i += 1",
            "def run():",
            "    n = int(input())",
            "    g = AdjacentGraph(n)",
            "    log = Logger(n)",
            "    for i in range(n):",
            "        id_, c, *links = [int(x) for x in input().split()]",
            "        for n in links:",
            "            g.set_adj_node(id_, n)",
            "    for i in g.bfs(log):",
            "        pass",
            "    reachable = None",
            "    for node in log.by_node():",
            "        id_, find, dep, exit = node",
            "        if id_ > 1 and dep == 0:",
            "            reachable = find - 1",
            "        if reachable is not None and find > reachable:",
            "            dep = -1",
            "        print(\"{} {}\".format(id_, dep))",
            "if __name__ == '__main__':",
            "    run()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "class MyQueue(object):",
            "    \"\"\"",
            "    My Queue class",
            "    Attributes:",
            "        queue: queue",
            "        head",
            "        tail",
            "    \"\"\"",
            "    def __init__(self):",
            "        \"\"\"Constructor",
            "        \"\"\"",
            "        self.length = 100010",
            "        self.queue = []",
            "        counter = 0",
            "        while counter < self.length:",
            "            self.queue.append(Process())",
            "            counter += 1",
            "        self.head = 0",
            "        self.tail = 0",
            "    def enqueue(self, name, time):",
            "        \"\"\"enqueue method",
            "        Args:",
            "            name: enqueued process name",
            "            time: enqueued process time",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        if self.is_full():",
            "            print(\"[ERROR] Queue Overflow\")",
            "        else:",
            "            self.queue[self.tail % self.length].name = name",
            "            self.queue[self.tail % self.length].time = time",
            "            self.tail += 1",
            "    def dequeue(self):",
            "        \"\"\"dequeue method",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        if self.is_empty():",
            "            print(\"[ERROR] Queue Underflow\")",
            "        else:",
            "            self.queue[self.head % self.length].name = \"\"",
            "            self.queue[self.head % self.length].time = 0",
            "            self.head += 1",
            "    def is_empty(self):",
            "        \"\"\"check queue is empty or not",
            "        Returns:",
            "            Bool",
            "        \"\"\"",
            "        if self.head == self.tail:",
            "            return True",
            "        else:",
            "            return False",
            "    def is_full(self):",
            "        \"\"\"chech whether queue is full or not\"\"\"",
            "        if self.tail - self.head >= len(self.queue):",
            "            return True",
            "        else:",
            "            return False",
            "class Process(object):",
            "    \"\"\"process class",
            "    \"\"\"",
            "    def __init__(self, name=\"\", time=0):",
            "        \"\"\"constructor",
            "        Args:",
            "            name: name",
            "            time: time",
            "        \"\"\"",
            "        self.name = name",
            "        self.time = time",
            "    def forward_time(self, time):",
            "        \"\"\"time forward method",
            "        Args:",
            "            time: forward time interval",
            "        Returns:",
            "            remain time",
            "        \"\"\"",
            "        self.time -= time",
            "        return self.time",
            "def time_forward(my_queue, interval, current_time):",
            "    \"\"\"",
            "    Args:",
            "        my_queue: queue",
            "        interval: time step interval",
            "        current_time: current time",
            "    \"\"\"",
            "    value = my_queue.queue[my_queue.head % my_queue.length].forward_time(interval)",
            "    if value < 0:",
            "        current_time += (interval + value)",
            "        print my_queue.queue[my_queue.head % my_queue.length].name, current_time",
            "        my_queue.dequeue()",
            "        return current_time",
            "    elif value == 0:",
            "        current_time += interval",
            "        print my_queue.queue[my_queue.head % my_queue.length].name, current_time",
            "        my_queue.dequeue()",
            "        return current_time",
            "    elif value > 0:",
            "        current_time += interval",
            "        copied_process = my_queue.queue[my_queue.head % my_queue.length]",
            "        name, time = copied_process.name, copied_process.time",
            "        my_queue.dequeue()",
            "        my_queue.enqueue(name, time)",
            "        return current_time",
            "my_queue = MyQueue()",
            "n, q = [int(x) for x in raw_input().split()]",
            "counter = 0",
            "while counter < n:",
            "    name, time = raw_input().split()",
            "    my_queue.enqueue(name, int(time))",
            "    counter += 1",
            "current_time = 0",
            "while not my_queue.is_empty():",
            "    current_time = time_forward(my_queue, q, current_time)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "import sys",
            "class Node:",
            "    \"\"\"",
            "    key: Value of the node",
            "    next: Pointer to the next node",
            "    prev: Pointer to the previous node",
            "    \"\"\"",
            "    def __init__(self, key):",
            "        self.key = key",
            "        self.next = None",
            "        self.prev = None",
            "class DoublyLinkedList:",
            "    def __init__(self):",
            "        \"\"\"",
            "        next always point to the very first node in a list",
            "        prev always point to the last node in a list",
            "        \"\"\"",
            "        self.next = None",
            "        self.prev = None",
            "    def insert(self, key):",
            "        \"\"\"",
            "        :param key: key to insert into a list (inserted to the first place in the list)",
            "        :return: None",
            "        \"\"\"",
            "        newNode = Node(key)",
            "        # First node ever added to the list",
            "        if self.next is None:",
            "            newNode.next = None",
            "            newNode.prev = self",
            "            self.next = newNode",
            "            self.prev = newNode",
            "        # Second nodes and forth",
            "        else:",
            "            newNode.next = self.next",
            "            newNode.prev = self",
            "            self.next.prev = newNode",
            "            self.next = newNode",
            "    def listSearch(self, key):",
            "        \"\"\"",
            "        :param key: key of a note to search for",
            "        :return: Node (the first Node from the beginning of a list)",
            "        \"\"\"",
            "        cur = self.next",
            "        while cur is not None and cur.key != key:",
            "            cur = cur.next",
            "        return cur",
            "    def deleteNode(self, node):",
            "        \"\"\"",
            "        :param node: Node to delete",
            "        :return: None",
            "        \"\"\"",
            "        if node is None:",
            "            return",
            "        # If the node is the last node",
            "        elif node.next is None:",
            "            node.prev.next = None",
            "            self.prev = node.prev",
            "        # If the node is not the last node",
            "        else:",
            "            node.prev.next = node.next",
            "            node.next.prev = node.prev",
            "    def delete(self, key):",
            "        \"\"\"",
            "        Delete the first node that has the key.",
            "        :param key: key that the node to be deleted has",
            "        :return: None",
            "        \"\"\"",
            "        self.deleteNode(self.listSearch(key))",
            "    def deleteFirst(self):",
            "        \"\"\"",
            "        Delete the first node in a list",
            "        :return: None",
            "        \"\"\"",
            "        cur = self.next",
            "        self.deleteNode(cur)",
            "    def deleteLast(self):",
            "        \"\"\"",
            "        Delete the last node in a list",
            "        :return: None",
            "        \"\"\"",
            "        cur = self.prev",
            "        self.deleteNode(cur)",
            "    def showKeys(self):",
            "        \"\"\"",
            "        Print keys of nodes in a list divided by a space",
            "        :return: None",
            "        \"\"\"",
            "        cur = self.next",
            "        keys = []",
            "        while cur is not None:",
            "            keys.append(cur.key)",
            "            cur = cur.next",
            "        keys = map(str, keys)",
            "        print(' '.join(keys))",
            "n = int(input())",
            "d = DoublyLinkedList()",
            "# input() seems to be too slow for this (result in TLE for large inputs)",
            "for i in sys.stdin:",
            "    if 'insert' in i:",
            "        x = i[7:-1]",
            "        d.insert(x)",
            "    elif 'deleteFirst' in i:",
            "        d.deleteFirst()",
            "    elif 'deleteLast' in i:",
            "        d.deleteLast()",
            "    elif 'delete' in i:",
            "        x = i[7:-1]",
            "        d.delete(x)",
            "    else:",
            "        pass",
            "d.showKeys()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            1,
            2,
            1,
            2,
            2
        ]
    },
    {
        "content": [
            "import sys",
            "input = sys.stdin.readline",
            "class Node:",
            "    def __init__(self, val):",
            "        self.val = val",
            "        self.prev, self.next = None, None",
            "class DoublyLinkedList:",
            "    def __init__(self):",
            "        self.n = 0",
            "        self.dummy = Node(None)",
            "        self.dummy.prev = self.dummy",
            "        self.dummy.next = self.dummy",
            "    def __getitem__(self, i):",
            "        if i < 0 or i >= self.n:",
            "            raise IndexError()",
            "        return self._get_node(i).val",
            "    def __setitem__(self, i):",
            "        if i < 0 or i >= self.n:",
            "            raise IndexError()",
            "        return self._get_node(i).val",
            "    def __len__(self):",
            "        return self.n",
            "    def __bool__(self):",
            "        return self.n != 0",
            "    def __iter__(self):",
            "        self.p = self.dummy",
            "        return self",
            "    def __next__(self):",
            "        self.p = self.p.next",
            "        if self.p == self.dummy:",
            "            raise StopIteration",
            "        return self.p.val",
            "    def append(self, val):",
            "        ptr = self.dummy.prev",
            "        new_ptr = Node(val)",
            "        new_ptr.prev = ptr.prev",
            "        new_ptr.next = ptr",
            "        new_ptr.next.prev = new_ptr",
            "        new_ptr.prev.next = new_ptr",
            "        self.n += 1",
            "    def appendleft(self, val):",
            "        ptr = self.dummy.next",
            "        new_ptr = Node(val)",
            "        new_ptr.prev = ptr.prev",
            "        new_ptr.next = ptr",
            "        new_ptr.next.prev = new_ptr",
            "        new_ptr.prev.next = new_ptr",
            "        self.n += 1",
            "    def pop(self):",
            "        ptr = self.dummy.prev",
            "        ptr.prev.next = ptr.next",
            "        ptr.next.prev = ptr.prev",
            "        self.n -= 1",
            "    def popleft(self):",
            "        ptr = self.dummy.next",
            "        ptr.prev.next = ptr.next",
            "        ptr.next.prev = ptr.prev",
            "        self.n -= 1",
            "    def _get_node(self, i):",
            "        if i < self.n // 2:",
            "            ptr = self.dummy.next",
            "            for _ in range(i):",
            "                ptr = ptr.next",
            "        else:",
            "            ptr = self.dummy",
            "            for _ in range(i, self.n):",
            "                ptr = ptr.prev",
            "        return ptr",
            "    def _remove(self, i):",
            "        if i < 0 or i >= self.n:",
            "            raise IndexError()",
            "        ptr = self._get_node(i)",
            "        ptr.prev.next = ptr.next",
            "        ptr.next.prev = ptr.prev",
            "        self.n -= 1",
            "        return ptr.val",
            "    def _add(self, i, val):",
            "        if i < 0 or i > self.n:",
            "            raise IndexError()",
            "        ptr = self._get_node(i)",
            "        new_ptr = Node(val)",
            "        new_ptr.prev = ptr.prev",
            "        new_ptr.next = ptr",
            "        new_ptr.next.prev = new_ptr",
            "        new_ptr.prev.next = new_ptr",
            "        self.n += 1",
            "    def delete(self, val):",
            "        ptr = self.dummy",
            "        for _ in range(self.n):",
            "            ptr = ptr.next",
            "            if ptr.val == val:",
            "                ptr.prev.next = ptr.next",
            "                ptr.next.prev = ptr.prev",
            "                self.n -= 1",
            "                return True",
            "        return False",
            "dls = DoublyLinkedList()",
            "input()",
            "for query in sys.stdin:",
            "    if query[0] == \"i\":",
            "        val = query[7:-1]",
            "        dls.appendleft(val)",
            "    elif query[6] == \"F\":",
            "        dls.popleft()",
            "    elif query[6] == \"L\":",
            "        dls.pop()",
            "    else:",
            "        val = query[7:-1]",
            "        dls.delete(val)",
            "print(*list(dls))"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            2,
            2
        ]
    },
    {
        "content": [
            "# import sys",
            "# def isHigh(str, compare):",
            "#   if len(str) <= len(compare):",
            "#     for i in range(len(str)):",
            "#       if str[i] > compare[i]:",
            "#         return True",
            "#       elif str[i] < compare[i]:",
            "#         return False",
            "#     return False",
            "#   else:",
            "#     for i in range(len(compare)):",
            "#       if str[i] > compare[i]:",
            "#         return True",
            "#       elif str[i] < compare[i]:",
            "#         return False",
            "#     return True",
            "# def isLow(str, compare):",
            "#   if len(str) <= len(compare):",
            "#     for i in range(len(str)):",
            "#       if str[i] < compare[i]:",
            "#         return True",
            "#       elif str[i] > compare[i]:",
            "#         return False",
            "#     return True",
            "#   else:",
            "#     for i in range(len(compare)):",
            "#       if str[i] < compare[i]:",
            "#         return True",
            "#       elif str[i] > compare[i]:",
            "#         return False",
            "#     return False",
            "# def main():",
            "#     dictionary = []",
            "#     n = int(input())",
            "#     for _ in range(n):",
            "#         order, str = input().split()",
            "#         if order == 'insert':",
            "#             len_dic = len(dictionary)",
            "#             if len_dic > 1:",
            "#                 L = 0",
            "#                 R = len(dictionary) - 1",
            "#                 M = (R + 1) // 2",
            "#                 while M >= L:",
            "#                     is_high = isHigh(str, dictionary[M-1])",
            "#                     is_low = isLow(str, dictionary[M])",
            "#                     if is_high and is_low:",
            "#                         dictionary.insert(M, str)",
            "#                         break",
            "#                     elif is_high and not is_low:",
            "#                         L = M",
            "#                         if L == len(dictionary) - 1:",
            "#                             dictionary.append(str)",
            "#                             break",
            "#                     elif not is_high and is_low:",
            "#                         R = M - 1",
            "#                         if R == 0:",
            "#                             dictionary.insert(0, str)",
            "#                             break",
            "#                     else:",
            "#                         print('予期せぬエラー')",
            "#                         sys.exit(1)",
            "#                     M = (L + R + 1) // 2",
            "#             elif len_dic == 1:",
            "#                 if isHigh(str, dictionary[0]):",
            "#                     dictionary.append(str)",
            "#                 else:",
            "#                     dictionary.insert(0, str)",
            "#             elif len_dic == 0:",
            "#                 dictionary.append(str)",
            "#             else:",
            "#                 print('予期せぬエラー')",
            "#                 sys.exit(1)",
            "#         elif order == 'find':",
            "#             len_dic = len(dictionary)",
            "#             if len_dic > 1:",
            "#                 L = 0",
            "#                 R = len(dictionary) - 1",
            "#                 M = (R + 1) // 2",
            "#                 while M >= L:",
            "#                     # print(L,R,M)",
            "#                     if dictionary[M] == str:",
            "#                         print('yes')",
            "#                         break",
            "#                     is_high = isHigh(str, dictionary[M])",
            "#                     if is_high:",
            "#                         L = M + 1",
            "#                         if L > R:",
            "#                             print('no')",
            "#                             break",
            "#                     else:",
            "#                         R = M - 1",
            "#                         if R < L:",
            "#                             print('no')",
            "#                             break",
            "#                     M = (L + R + 1) // 2",
            "#             elif len_dic == 1:",
            "#                 if dictionary[0] == str:",
            "#                     print('yes')",
            "#                 else:",
            "#                     print('no')",
            "#             elif len_dic == 0:",
            "#                 print('no')",
            "#             else:",
            "#                 print('予期せぬエラー')",
            "#                 sys.exit(1)",
            "#         else:",
            "#             print('入力に誤りがあります。')",
            "#             sys.exit(1)",
            "# if __name__ == '__main__':",
            "#     main()",
            "SIZE = 13",
            "POW = [1] * SIZE",
            "for i in range(1, SIZE):",
            "    POW[i] = POW[i-1] * 4",
            "index = {'A': 1, 'G': 2, 'C': 3, 'T': 4}",
            "DICT = [False]*POW[12] # 4^12個の要素",
            "def getNum(s):",
            "    global POW, index",
            "    n = -1",
            "    for i in range(len(s)):",
            "        n += index[s[i]]*POW[i]",
            "    return n",
            "def main():",
            "    global DICT",
            "    n = int(input())",
            "    for _ in range(n):",
            "        c, s = input().split()",
            "        if c == 'insert':",
            "            DICT[getNum(s)] = True",
            "        else:",
            "            if DICT[getNum(s)]:",
            "                print('yes')",
            "            else:",
            "                print('no')",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "\"\"\"",
            "ソートテク関連の基本的な関数の詰め合わせ (命名は C++ STL algorithm による)",
            "stable_partition(seq, func):",
            "    O(n)",
            "    空間計算量も O(n)",
            "    述語が True を返す全ての要素が、述語が False を返す全ての要素よりも前になるようにシーケンスを並び替える (破壊、安定)",
            "nth_element(seq, k, begin, end):",
            "    O(n)",
            "    E = seq[k] とする",
            "    特定の要素 E よりも小さい全ての要素が E よりも前になり、 E 以上の全ての要素がEよりも後になるように seq[begin:end] を並び替える (破壊、不安定)",
            "    heapq の nlargest とは異なるので注意",
            "ith_order_statistic(seq, i, begin, end):",
            "    O(n)",
            "    nth_element を用いて (seq[begin:end] に存在することがわかっている) i 番目の順序統計量を求める (i = 0, 1, ..., n-1)",
            "simple_quick_sort(seq, begin, end):",
            "    O(nlgn)",
            "    nth_element を用いて seq[begin:end] をソートする (破壊、不安定)",
            "modified_merge_sort(seq, begin, end):",
            "    O(nlgn)",
            "    _modified_merge を用いて seq[begin:end] をソートする (非破壊、安定)",
            "    転倒数とソート済み配列を返す",
            "count_inversion(seq):",
            "    O(nlgn)",
            "    modified_merge_sort を用いて seq の転倒数を求める",
            "    (転倒数: seq[i] > seq[j] (i < j) なる (i, j) の組み合わせの数のこと)",
            "\"\"\"",
            "import random",
            "from typing import TypeVar, Callable, List, Tuple, Union",
            "T = TypeVar('T')",
            "Num = Union[int, float]",
            "def _modified_merge(left: List[Num], right: List[Num]) -> Tuple[int, List[Num]]:",
            "    \"\"\"",
            "    ソート済み配列 left, right を受け取り、全体のソート済み配列を生成する (O(n))",
            "    マージの過程で転倒数をメモして返す",
            "    Args:",
            "        left (list): ソート済み",
            "        right (list): ソート済み",
            "    Returns:",
            "        inv (int): 転倒数",
            "        sorted_list (list): ソート済み",
            "    Examples:",
            "        >>> _modified_merge([1, 5, 7], [2, 3, 3])",
            "        (6, [1, 2, 3, 3, 5, 7])",
            "    \"\"\"",
            "    sorted_list = []",
            "    i, j, inv = 0, 0, 0",
            "    buf_1 = left[:] + [float('inf')]",
            "    buf_2 = right[:] + [float('inf')]",
            "    for _ in range(len(left) + len(right)):",
            "        if buf_1[i] < buf_2[j]:",
            "            sorted_list.append(buf_1[i])",
            "            i += 1",
            "        else:",
            "            sorted_list.append(buf_2[j])",
            "            j += 1",
            "        inv += 1",
            "    return inv, sorted_list",
            "def modified_merge_sort(L, begin, end):",
            "    \"\"\"",
            "    L[begin:end] を 非破壊的かつ安定にマージソートする (O(nlgn))",
            "    マージソートの過程で転倒数をメモして返す",
            "    Args:",
            "        L (list)",
            "        begin, end (int)",
            "    Returns:",
            "        inv (int): 転倒数",
            "        sorted_list (list): ソート済み",
            "    Examples:",
            "        >>> modified_merge_sort([3, 5, 2, 1, 0], 0, 5)",
            "        (9, [0, 1, 2, 3, 5])",
            "    \"\"\"",
            "    if end - begin == 1:",
            "        return 0, [L[begin]]",
            "    mid = (begin + end) // 2",
            "    left_inv_cnt, left = modified_merge_sort(L, begin, mid)",
            "    right_inv_cnt, right = modified_merge_sort(L, mid, end)",
            "    merge_inv_cnt, sorted_list = _modified_merge(left, right)",
            "    return left_inv_cnt + right_inv_cnt + merge_inv_cnt, sorted_list",
            "# verified @AOJ ALDS1_5_D",
            "# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_5_D&lang=ja",
            "def count_inversion(L):",
            "    \"\"\"",
            "    modified_merge_sort() を用いて L の要素の転倒数を求める (O(nlgn))",
            "    Examples:",
            "        >>> count_inversion([1, 9, 2, 7, 5, 6, 4, 8, 3, 0])",
            "        26",
            "    \"\"\"",
            "    cnt, _ = modified_merge_sort(L, 0, len(L))",
            "    return cnt",
            "if __name__ == \"__main__\":",
            "    n = int(input())",
            "    L = list(map(int, input().split()))",
            "    num, seq = modified_merge_sort(L, 0, n)",
            "    print(*seq, sep=' ')",
            "    print(num)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "content": [
            "class Dice:",
            "    # constructor",
            "    def __init__(self, eye1, eye2, eye3, eye4, eye5, eye6):",
            "        self.__eyes = {",
            "            \"top\": eye1,",
            "            \"front\": eye2,",
            "            \"right\": eye3,",
            "            \"left\": eye4,",
            "            \"back\": eye5,",
            "            \"bottom\": eye6",
            "        }",
            "    # setter",
            "    def set_eyes(self, eye1, eye2, eye3, eye4, eye5, eye6):",
            "        self.__eyes[\"top\"] = eye1",
            "        self.__eyes[\"front\"] = eye2",
            "        self.__eyes[\"right\"] = eye3",
            "        self.__eyes[\"left\"] = eye4",
            "        self.__eyes[\"back\"] = eye5",
            "        self.__eyes[\"bottom\"] = eye6",
            "    # getter",
            "    def get_eyes(self, key):",
            "        return self.__eyes[key]",
            "    def N(self):",
            "        self.set_eyes(",
            "            self.get_eyes(\"front\"),",
            "            self.get_eyes(\"bottom\"),",
            "            self.get_eyes(\"right\"),",
            "            self.get_eyes(\"left\"),",
            "            self.get_eyes(\"top\"),",
            "            self.get_eyes(\"back\")",
            "            )",
            "    def S(self):",
            "        self.set_eyes(",
            "            self.get_eyes(\"back\"),",
            "            self.get_eyes(\"top\"),",
            "            self.get_eyes(\"right\"),",
            "            self.get_eyes(\"left\"),",
            "            self.get_eyes(\"bottom\"),",
            "            self.get_eyes(\"front\")",
            "            )",
            "    def E(self):",
            "        self.set_eyes(",
            "            self.get_eyes(\"left\"),",
            "            self.get_eyes(\"front\"),",
            "            self.get_eyes(\"top\"),",
            "            self.get_eyes(\"bottom\"),",
            "            self.get_eyes(\"back\"),",
            "            self.get_eyes(\"right\")",
            "            )",
            "    def W(self):",
            "        self.set_eyes(",
            "            self.get_eyes(\"right\"),",
            "            self.get_eyes(\"front\"),",
            "            self.get_eyes(\"bottom\"),",
            "            self.get_eyes(\"top\"),",
            "            self.get_eyes(\"back\"),",
            "            self.get_eyes(\"left\")",
            "            )",
            "    def print_top(self):",
            "        print(self.get_eyes(\"top\"))",
            "    def guess_right_from_top_front(self, top, front):",
            "        key_top = None",
            "        key_front = None",
            "        keys = [",
            "        \"top\",",
            "        \"front\",",
            "        \"right\",",
            "        \"left\",",
            "        \"back\",",
            "        \"bottom\"",
            "        ]",
            "        for key in keys:",
            "            if top == self.get_eyes(key):",
            "                key_top = key",
            "            if front == self.get_eyes(key):",
            "                key_front = key",
            "        keys_for_top = [",
            "            [\"front\", \"right\", \"back\", \"left\"],",
            "            [\"bottom\", \"right\", \"top\", \"left\"],",
            "            [\"bottom\", \"back\", \"top\", \"front\"],",
            "            [\"bottom\", \"front\", \"top\", \"back\"],",
            "            [\"bottom\", \"left\", \"top\", \"right\"],",
            "            [\"front\", \"left\", \"back\", \"right\"]",
            "        ]",
            "        for i in range(6):",
            "            if key_top == keys[i]:",
            "                for j in range(4):",
            "                    if key_front == keys_for_top[i][j]:",
            "                        return keys_for_top[i][(j + 1) % 4]",
            "eye1, eye2, eye3, eye4, eye5, eye6 = map(int, input().split())",
            "q = int(input())",
            "dice = Dice(eye1, eye2, eye3, eye4, eye5, eye6)",
            "for _ in range(q):",
            "    top, front = map(int, input().split())",
            "    print(dice.get_eyes(dice.guess_right_from_top_front(top, front)))"
        ],
        "label": [
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "class Dice():",
            "    def __init__(self, nums):",
            "        self.__indexTop__ = 1",
            "        self.__indexFront__ = 2",
            "        self.__indexRight__ = 3",
            "        self.__indexLeft__ = 4",
            "        self.__indexBack__ = 5",
            "        self.__indexBottom__ = 6",
            "        self.__sides__ = {1:nums[0], 2:nums[1], 3:nums[2], 4:nums[3], 5:nums[4], 6:nums[5]}",
            "    def getTopSideNum(self):",
            "        return self.__sides__[self.__indexTop__]",
            "    def getFrontSideNum(self):",
            "        return self.__sides__[self.__indexFront__]",
            "    def getRightSideNum(self):",
            "        return self.__sides__[self.__indexRight__]",
            "    def roll(self, direction):",
            "        initTop = self.__indexTop__",
            "        initFront = self.__indexFront__",
            "        initRight = self.__indexRight__",
            "        initLeft = self.__indexLeft__",
            "        initBack = self.__indexBack__",
            "        initBottom = self.__indexBottom__",
            "        if direction == 'N':",
            "            self.__indexTop__ = initFront",
            "            self.__indexFront__ = initBottom",
            "            self.__indexRight__ = initRight",
            "            self.__indexLeft__ = initLeft",
            "            self.__indexBack__ = initTop",
            "            self.__indexBottom__ = initBack",
            "        elif direction == 'E':",
            "            self.__indexTop__ = initLeft",
            "            self.__indexFront__ = initFront",
            "            self.__indexRight__ = initTop",
            "            self.__indexLeft__ = initBottom",
            "            self.__indexBack__ = initBack",
            "            self.__indexBottom__ = initRight",
            "        elif direction == 'S':",
            "            self.__indexTop__ = initBack",
            "            self.__indexFront__ = initTop",
            "            self.__indexRight__ = initRight",
            "            self.__indexLeft__ = initLeft",
            "            self.__indexBack__ = initBottom",
            "            self.__indexBottom__ = initFront",
            "        elif direction == 'W':",
            "            self.__indexTop__ = initRight",
            "            self.__indexFront__ = initFront",
            "            self.__indexRight__ = initBottom",
            "            self.__indexLeft__ = initTop",
            "            self.__indexBack__ = initBack",
            "            self.__indexBottom__ = initLeft",
            "    def pivot(self, direction):",
            "        initTop = self.__indexTop__",
            "        initFront = self.__indexFront__",
            "        initRight = self.__indexRight__",
            "        initLeft = self.__indexLeft__",
            "        initBack = self.__indexBack__",
            "        initBottom = self.__indexBottom__",
            "        if direction == 'C':",
            "            self.__indexTop__ = initTop",
            "            self.__indexFront__ = initRight",
            "            self.__indexRight__ = initBack",
            "            self.__indexLeft__ = initFront",
            "            self.__indexBack__ = initLeft",
            "            self.__indexBottom__ = initBottom",
            "        elif direction == 'CC':",
            "            self.__indexTop__ = initTop",
            "            self.__indexFront__ = initLeft",
            "            self.__indexRight__ = initFront",
            "            self.__indexLeft__ = initBack",
            "            self.__indexBack__ = initRight",
            "            self.__indexBottom__ = initBottom",
            "die = Dice([int(i) for i in input().split()])",
            "q = int(input())",
            "for i in range(q):",
            "    top, front = (int(i) for i in input().split())",
            "    while True:",
            "        if die.getTopSideNum() == top:",
            "            break",
            "        die.roll('N')",
            "        if die.getTopSideNum() == top:",
            "            break",
            "        die.roll('W')",
            "    while True:",
            "        if die.getFrontSideNum() == front:",
            "            break",
            "        die.pivot('C')",
            "    print(die.getRightSideNum())"
        ],
        "label": [
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            0,
            1,
            2,
            1,
            0,
            1,
            2
        ]
    },
    {
        "content": [
            "import math",
            "import itertools",
            "import sys",
            "class Dice:",
            "  numbers = []",
            "  faces = {",
            "    'top': None,",
            "    'back': None,",
            "    'right': None,",
            "    'left': None,",
            "    'front': None,",
            "    'bottom': None,",
            "  }",
            "  def __init__(self, int_array):",
            "    self.numbers = int_array",
            "    self.faces['top'] = self.numbers[0]",
            "    self.faces['back'] = self.numbers[1]",
            "    self.faces['right'] = self.numbers[2]",
            "    self.faces['left'] = self.numbers[3]",
            "    self.faces['front'] = self.numbers[4]",
            "    self.faces['bottom'] = self.numbers[5]",
            "  def getNum(self, n):",
            "    return self.numbers[n-1]",
            "  def getFace(self, f):",
            "    return self.faces[f]",
            "  def getRightFace(self, t, b):",
            "    top = self.faces['top']",
            "    back = self.faces['back']",
            "    right = self.faces['right']",
            "    left = self.faces['left']",
            "    front = self.faces['front']",
            "    bottom = self.faces['bottom']",
            "    if t == self.getNum(2):",
            "      self.rotate('N')",
            "    elif t == self.getNum(4):",
            "      self.rotate('E')",
            "    elif t == self.getNum(5):",
            "      self.rotate('S')",
            "    elif t == self.getNum(3):",
            "      self.rotate('W')",
            "    elif t == self.getNum(6):",
            "      for _ in range(2):",
            "        self.rotate('N')",
            "    while self.getFace('back') != b:",
            "      self.rotate('R')",
            "    result = self.getFace('right')",
            "    self.faces['top'] = top",
            "    self.faces['back'] = back",
            "    self.faces['right'] = right",
            "    self.faces['left'] = left",
            "    self.faces['front'] = front",
            "    self.faces['bottom'] = bottom",
            "    return result",
            "  def rotate(self, direction):",
            "    if direction == 'N': # 前回り",
            "      top = self.getFace('top') #一時保存",
            "      self.faces['top'] = self.faces['back']",
            "      self.faces['back'] = self.faces['bottom']",
            "      self.faces['bottom'] = self.faces['front']",
            "      self.faces['front'] = top",
            "    elif direction == 'E': # 右回り",
            "      top = self.faces['top'] #一時保存",
            "      self.faces['top'] = self.faces['left']",
            "      self.faces['left'] = self.faces['bottom']",
            "      self.faces['bottom'] = self.faces['right']",
            "      self.faces['right'] = top",
            "    elif direction == 'S': # 後ろ回り",
            "      top = self.faces['top'] #一時保存",
            "      self.faces['top'] = self.faces['front']",
            "      self.faces['front'] = self.faces['bottom']",
            "      self.faces['bottom'] = self.faces['back']",
            "      self.faces['back'] = top",
            "    elif direction == 'W': # 左回り",
            "      top = self.faces['top'] #一時保存",
            "      self.faces['top'] = self.faces['right']",
            "      self.faces['right'] = self.faces['bottom']",
            "      self.faces['bottom'] = self.faces['left']",
            "      self.faces['left'] = top",
            "    elif direction == 'R': # その場右回り",
            "      back = self.faces['back'] #一時保存",
            "      self.faces['back'] = self.faces['left']",
            "      self.faces['left'] = self.faces['front']",
            "      self.faces['front'] = self.faces['right']",
            "      self.faces['right'] = back",
            "    else: # その場左回り",
            "      back = self.faces['back'] #一時保存",
            "      self.faces['back'] = self.faces['right']",
            "      self.faces['right'] = self.faces['front']",
            "      self.faces['front'] = self.faces['left']",
            "      self.faces['left'] = back",
            "def main():",
            "  number = list(map(int, input().split()))",
            "  q = int(input())",
            "  dice = Dice(number)",
            "  for _ in range(q):",
            "    t, b = map(int, input().split())",
            "    print(dice.getRightFace(t,b))",
            "if __name__ == '__main__':",
            "  main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "class Dice:",
            "    def __init__(self):",
            "        self.side = {\"top\": 0, \"front\": 0, \"right\": 0, \"left\": 0, \"back\": 0, \"bottom\": 0}",
            "    # サイコロを東西南北、どちらか一方に転がした時、それぞれの面の変化",
            "    def roll(self, direction):",
            "        self.direction = direction",
            "        if self.direction == \"N\":",
            "            w = self.side[\"top\"]",
            "            self.side[\"top\"] = self.side[\"front\"]",
            "            self.side[\"front\"] = self.side[\"bottom\"]",
            "            self.side[\"bottom\"] = self.side[\"back\"]",
            "            self.side[\"back\"] = w",
            "        elif self.direction == \"S\":",
            "            w = self.side[\"top\"]",
            "            self.side[\"top\"] = self.side[\"back\"]",
            "            self.side[\"back\"] = self.side[\"bottom\"]",
            "            self.side[\"bottom\"] = self.side[\"front\"]",
            "            self.side[\"front\"] = w",
            "        elif self.direction == \"E\":",
            "            w = self.side[\"top\"]",
            "            self.side[\"top\"] = self.side[\"left\"]",
            "            self.side[\"left\"] = self.side[\"bottom\"]",
            "            self.side[\"bottom\"] = self.side[\"right\"]",
            "            self.side[\"right\"] = w",
            "        elif self.direction == \"W\":",
            "            w = self.side[\"top\"]",
            "            self.side[\"top\"] = self.side[\"right\"]",
            "            self.side[\"right\"] = self.side[\"bottom\"]",
            "            self.side[\"bottom\"] = self.side[\"left\"]",
            "            self.side[\"left\"] = w",
            "    # サイコロの面の位置関係",
            "    def position_relation(self, top, front):",
            "        # 北に転がした場合",
            "        if top == \"top\" and front == \"front\"\\",
            "        or top == \"front\" and front == \"bottom\"\\",
            "        or top == \"bottom\" and front == \"back\"\\",
            "        or top == \"back\" and front == \"top\":",
            "            self.right = self.side[\"right\"]",
            "        # 北に転がした時の\"top\"と\"front\"を入れ替えた場合",
            "        if top == \"top\" and front == \"back\"\\",
            "        or top == \"back\" and front == \"bottom\"\\",
            "        or top == \"bottom\" and front == \"front\"\\",
            "        or top == \"front\" and front == \"top\":",
            "            self.right = self.side[\"left\"]",
            "        # 東に転がした場合",
            "        if top == \"top\" and front == \"right\"\\",
            "        or top == \"right\" and front == \"bottom\"\\",
            "        or top == \"bottom\" and front == \"left\"\\",
            "        or top == \"left\" and front == \"top\":",
            "            self.right = self.side[\"back\"]",
            "        # 東に転がした時の\"top\"と\"front\"を入れ替えた場合",
            "        if top == \"top\" and front == \"left\"\\",
            "        or top == \"left\" and front == \"bottom\"\\",
            "        or top == \"bottom\" and front == \"right\"\\",
            "        or top == \"right\" and front == \"top\":",
            "            self.right = self.side[\"front\"]",
            "        # 西に転がした場合",
            "        if top == \"front\" and front == \"right\"\\",
            "        or top == \"right\" and front == \"back\"\\",
            "        or top == \"back\" and front == \"left\"\\",
            "        or top == \"left\" and front == \"front\":",
            "            self.right = self.side[\"top\"]",
            "        # 西に転がした時の\"top\"と\"front\"を入れ替えた場合",
            "        if top == \"front\" and front == \"left\"\\",
            "        or top == \"left\" and front == \"back\"\\",
            "        or top == \"back\" and front == \"right\"\\",
            "        or top == \"right\" and front == \"front\":",
            "            self.right = self.side[\"bottom\"]",
            "dice = Dice()",
            "for s, n in zip(dice.side, input().split()):",
            "    dice.side[s] = int(n)",
            "q = int(input())",
            "for i in range(q):",
            "    t, f = map(int, input().split())",
            "    for k, v in dice.side.items():",
            "        if t == v:",
            "            top = k",
            "        if f == v:",
            "            front = k",
            "    dice.position_relation(top, front)",
            "    print(dice.right)"
        ],
        "label": [
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            2,
            2
        ]
    },
    {
        "content": [
            "class Dise():",
            "    def __init__(self, aLabelList):",
            "        self.LabelList = aLabelList",
            "        self.LabelsRelationship = [[0 for i in range(5)] for j in range(6)]",
            "        for i in range(6):",
            "            if i == 0:",
            "                self.LabelsRelationship[i][0] = self.LabelList[2 -1] #下1",
            "                self.LabelsRelationship[i][1] = self.LabelList[3 -1] #下2",
            "                self.LabelsRelationship[i][2] = self.LabelList[5 -1] #下3",
            "                self.LabelsRelationship[i][3] = self.LabelList[4 -1] #下4",
            "                self.LabelsRelationship[i][4] = self.LabelList[6 -1] #対面",
            "            elif i == 1:",
            "                self.LabelsRelationship[i][0] = self.LabelList[6 -1] #下1",
            "                self.LabelsRelationship[i][1] = self.LabelList[3 -1] #下2",
            "                self.LabelsRelationship[i][2] = self.LabelList[1 -1] #下3",
            "                self.LabelsRelationship[i][3] = self.LabelList[4 -1] #下4",
            "                self.LabelsRelationship[i][4] = self.LabelList[5 -1] #対面",
            "            elif i == 2:",
            "                self.LabelsRelationship[i][0] = self.LabelList[6 -1] #下1",
            "                self.LabelsRelationship[i][1] = self.LabelList[5 -1] #下2",
            "                self.LabelsRelationship[i][2] = self.LabelList[1 -1] #下3",
            "                self.LabelsRelationship[i][3] = self.LabelList[2 -1] #下4",
            "                self.LabelsRelationship[i][4] = self.LabelList[4 -1] #対面",
            "            elif i == 3:",
            "                self.LabelsRelationship[i][0] = self.LabelList[2 -1] #下1",
            "                self.LabelsRelationship[i][1] = self.LabelList[1 -1] #下2",
            "                self.LabelsRelationship[i][2] = self.LabelList[5 -1] #下3",
            "                self.LabelsRelationship[i][3] = self.LabelList[6 -1] #下4",
            "                self.LabelsRelationship[i][4] = self.LabelList[3 -1] #対面",
            "            elif i == 4:",
            "                self.LabelsRelationship[i][0] = self.LabelList[1 -1] #下1",
            "                self.LabelsRelationship[i][1] = self.LabelList[3 -1] #下2",
            "                self.LabelsRelationship[i][2] = self.LabelList[6 -1] #下3",
            "                self.LabelsRelationship[i][3] = self.LabelList[4 -1] #下4",
            "                self.LabelsRelationship[i][4] = self.LabelList[2 -1] #対面",
            "            elif i == 5:",
            "                self.LabelsRelationship[i][0] = self.LabelList[5 -1] #下1",
            "                self.LabelsRelationship[i][1] = self.LabelList[3 -1] #下2",
            "                self.LabelsRelationship[i][2] = self.LabelList[2 -1] #下3",
            "                self.LabelsRelationship[i][3] = self.LabelList[4 -1] #下4",
            "                self.LabelsRelationship[i][4] = self.LabelList[1 -1] #対面",
            "    def DisePrintRight(self,aTopItem,aFront):",
            "        xTopIndex = self.LabelList.index(str(aTopItem))",
            "        for i in range(4):",
            "            if int(self.LabelsRelationship[xTopIndex][i]) == aFront:",
            "                if i + 1 == 4:",
            "                    idxR = int(self.LabelsRelationship[xTopIndex][0])",
            "                else:",
            "                    idxR = int(self.LabelsRelationship[xTopIndex][i+1])",
            "                print(idxR)",
            "                break",
            "myInstance = Dise(input().split())",
            "x = int(input())",
            "for i in range(x):",
            "    a,b = map(int, input().split())",
            "    myInstance.DisePrintRight(a,b)"
        ],
        "label": [
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1
        ]
    },
    {
        "content": [
            "class Dice:",
            "    def __init__(self, a, b, c, d, e, f):",
            "        # サイコロの現在一番上にある面",
            "        self.a = a",
            "        self.b = b",
            "        self.c = c",
            "        self.d = d",
            "        self.e = e",
            "        self.f = f",
            "        self.n_list = [0, self.a, self.b, self.c, self.d, self.e, self.f]",
            "    def is_right_surface(self, top, front):",
            "        swapped = False",
            "        \"\"\"",
            "        print(f\"{top=}\")",
            "        print(f\"{front=}\")",
            "        print(f\"{self.n_list.index(top)=}\")",
            "        print(f\"{self.n_list.index(front)=}\")",
            "        \"\"\"",
            "        if self.n_list.index(top) > self.n_list.index(front):",
            "            tmp = front",
            "            front = top",
            "            top = tmp",
            "            swapped = True",
            "        if self.n_list.index(top) == 1 and self.n_list.index(front) == 2:",
            "            return self.c, self.d, swapped",
            "        if self.n_list.index(top) == 1 and self.n_list.index(front) == 3:",
            "            return self.e, self.b, swapped",
            "        if self.n_list.index(top) == 1 and self.n_list.index(front) == 4:",
            "            return self.b, self.e, swapped",
            "        if self.n_list.index(top) == 1 and self.n_list.index(front) == 5:",
            "            return self.d, self.c, swapped",
            "        if self.n_list.index(top) == 2 and self.n_list.index(front) == 3:",
            "            return self.a, self.f, swapped",
            "        if self.n_list.index(top) == 2 and self.n_list.index(front) == 4:",
            "            return self.f, self.a, swapped",
            "        if self.n_list.index(top) == 2 and self.n_list.index(front) == 6:",
            "            return self.c, self.d, swapped",
            "        if self.n_list.index(top) == 3 and self.n_list.index(front) == 5:",
            "            return self.a, self.f, swapped",
            "        if self.n_list.index(top) == 3 and self.n_list.index(front) == 6:",
            "            return self.e, self.b, swapped",
            "        if self.n_list.index(top) == 4 and self.n_list.index(front) == 5:",
            "            return self.f, self.a, swapped",
            "        if self.n_list.index(top) == 4 and self.n_list.index(front) == 6:",
            "            return self.b, self.e, swapped",
            "        if self.n_list.index(top) == 5 and self.n_list.index(front) == 6:",
            "            return self.d, self.c, swapped",
            "    def move(self, move_str):",
            "        for i in move_str:",
            "            if i == \"N\":",
            "                self.move_N()",
            "            elif i == \"E\":",
            "                self.move_E()",
            "            elif i == \"W\":",
            "                self.move_W()",
            "            elif i == \"S\":",
            "                self.move_S()",
            "    def move_N(self):",
            "        tmp1 = self.a",
            "        tmp2 = self.e",
            "        self.a = self.b",
            "        self.b = self.f",
            "        self.e = tmp1",
            "        self.f = tmp2",
            "    def move_E(self):",
            "        tmp1 = self.a",
            "        tmp2 = self.c",
            "        self.a = self.d",
            "        self.c = tmp1",
            "        self.d = self.f",
            "        self.f = tmp2",
            "    def move_W(self):",
            "        tmp1 = self.a",
            "        tmp2 = self.d",
            "        self.a = self.c",
            "        self.c = self.f",
            "        self.d = tmp1",
            "        self.f = tmp2",
            "    def move_S(self):",
            "        tmp1 = self.a",
            "        tmp2 = self.b",
            "        self.a = self.e",
            "        self.b = tmp1",
            "        self.e = self.f",
            "        self.f = tmp2",
            "a, b, c, d, e, f = map(int, input().split())",
            "dice = Dice(a, b, c, d, e, f)",
            "n = int(input())",
            "for i in range(n):",
            "    x, y = map(int, input().split())",
            "    right, left, is_swap = dice.is_right_surface(x, y)",
            "    if is_swap:",
            "        print(left)",
            "    else:",
            "        print(right)"
        ],
        "label": [
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1
        ]
    },
    {
        "content": [
            "class Dice:",
            "    def __init__(self,num):",
            "        self.top = num[0]",
            "        self.front = num[1]",
            "        self.right = num[2]",
            "        self.left = num[3]",
            "        self.back = num[4]",
            "        self.bottom = num[5]",
            "    def south_direction(self):",
            "        front = self.top",
            "        bottom = self.front",
            "        back = self.bottom",
            "        top = self.back",
            "        right = self.right",
            "        left = self.left",
            "        self.top = top",
            "        self.front = front",
            "        self.bottom = bottom",
            "        self.back = back",
            "        self.right = right",
            "        self.left = left",
            "    def north_direction(self):",
            "        back = self.top",
            "        top = self.front",
            "        front = self.bottom",
            "        bottom = self.back",
            "        right = self.right",
            "        left = self.left",
            "        self.top = top",
            "        self.front = front",
            "        self.bottom = bottom",
            "        self.back = back",
            "        self.right = right",
            "        self.left = left",
            "    def east_direction(self):",
            "        right = self.top",
            "        front = self.front",
            "        left = self.bottom",
            "        back = self.back",
            "        bottom = self.right",
            "        top = self.left",
            "        self.top = top",
            "        self.front = front",
            "        self.bottom = bottom",
            "        self.back = back",
            "        self.right = right",
            "        self.left = left",
            "    def west_direction(self):",
            "        left = self.top",
            "        front = self.front",
            "        right = self.bottom",
            "        back = self.back",
            "        top = self.right",
            "        bottom = self.left",
            "        self.top = top",
            "        self.front = front",
            "        self.bottom = bottom",
            "        self.back = back",
            "        self.right = right",
            "        self.left = left",
            "    def clockwise_rotate(self):",
            "        top = self.top",
            "        left = self.front",
            "        bottom = self.bottom",
            "        right = self.back",
            "        front = self.right",
            "        back = self.left",
            "        self.top = top",
            "        self.front = front",
            "        self.bottom = bottom",
            "        self.back = back",
            "        self.right = right",
            "        self.left = left",
            "    def print_top(self):",
            "        print(self.top)",
            "    def judge_right(self, top, front):",
            "        while True:",
            "            if self.top == top and self.front == front:",
            "                print(self.right)",
            "                break",
            "            elif top==self.front:",
            "                self.north_direction()",
            "            elif top == self.left:",
            "                self.east_direction()",
            "            elif top == self.back:",
            "                self.south_direction()",
            "            elif top == self.right:",
            "                self.west_direction()",
            "            elif top == self.bottom:",
            "                self.north_direction()",
            "                self.north_direction()",
            "            elif front == self.front:",
            "                pass",
            "            elif front == self.left:",
            "                self.clockwise_rotate()",
            "                self.clockwise_rotate()",
            "                self.clockwise_rotate()",
            "            elif front == self.back:",
            "                self.clockwise_rotate()",
            "                self.clockwise_rotate()",
            "            elif front == self.right:",
            "                self.clockwise_rotate()",
            "num = list(map(int,input().split()))",
            "rep=int(input())",
            "d = Dice(num)",
            "for i in range(rep):",
            "    top, front = map(int, input().split())",
            "    d.judge_right(top, front)"
        ],
        "label": [
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "from enum import IntEnum",
            "class Face(IntEnum):",
            "    One=1",
            "    Two=2",
            "    Three=3",
            "    Four=4",
            "    Five=5",
            "    Six=6",
            "class Dice:",
            "    def __init__(self):",
            "        self.top=Face.One",
            "        self.bottom=Face.Six",
            "        self.back=Face.Two",
            "        self.front=Face.Five",
            "        self.left=Face.Four",
            "        self.right=Face.Three",
            "    def roll(self,command):",
            "        if command==\"E\":",
            "            #back-frontを軸として右回転",
            "            temp=self.top",
            "            self.top=self.left",
            "            self.left=self.bottom",
            "            self.bottom=self.right",
            "            self.right=temp",
            "        elif command==\"N\":",
            "            #right-leftを固定して前転",
            "            temp=self.top",
            "            self.top=self.back",
            "            self.back=self.bottom",
            "            self.bottom=self.front",
            "            self.front=temp",
            "        elif command==\"S\":",
            "            #right-leftを固定して後転",
            "            temp=self.top",
            "            self.top=self.front",
            "            self.front=self.bottom",
            "            self.bottom=self.back",
            "            self.back=temp",
            "        elif command==\"W\":",
            "            #back-frontを軸として左回転",
            "            temp=self.top",
            "            self.top=self.right",
            "            self.right=self.bottom",
            "            self.bottom=self.left",
            "            self.left=temp",
            "def num_pattern_match(num_list,pattern):",
            "    for i,x in enumerate(num_list):",
            "        is_match=True",
            "        for j,y in enumerate(pattern):",
            "            if num_list[(i+j) % len(num_list)] == pattern[j]:",
            "                pass",
            "            else:",
            "                is_match=False",
            "        if is_match:",
            "            return True",
            "    return False",
            "def build_dice(top,back):",
            "    #2つの面からさいころの状態を初期化する",
            "    dice=Dice()",
            "    dice.top=top",
            "    dice.back=back",
            "    dice.bottom=Face(7-int(dice.top))",
            "    dice.front=Face(7-int(dice.back))",
            "    #left-rightはどう計算する?",
            "    #難しく考えないで確実にできる簡単な方法を実行する",
            "    exist_dice_list=[int(dice.top),",
            "    int(dice.bottom),",
            "    int(dice.front),",
            "    int(dice.back)]",
            "    left_face_num=set([i+1 for i in range(6)]) - set(exist_dice_list)",
            "    #top->front->bottom->backの面のリストを作成する",
            "    #泥臭いプログラミングできるかどうかにかかっている",
            "    face_list=[int(dice.top),int(dice.front),int(dice.bottom),int(dice.back)]",
            "    #泥臭くても手を動かせば完了するときはさっさと手を動かして完了させる",
            "    if 1 in left_face_num:",
            "        #1,5が残されているパターン",
            "        pattern=[2,3,5,4]",
            "        if num_pattern_match(face_list,pattern):",
            "            #top->front->bottom->backに走査したとき、2354に一致するとき",
            "            #左に1が来る",
            "            dice.right=Face.Six",
            "            dice.left=Face.One",
            "        else:",
            "            dice.right=Face.One",
            "            dice.left=Face.Six",
            "    elif 2 in left_face_num:",
            "        pattern=[1,4,6,3]",
            "        if num_pattern_match(face_list,pattern):",
            "            dice.right=Face.Five",
            "            dice.left=Face.Two",
            "        else:",
            "            dice.right=Face.Two",
            "            dice.left=Face.Five",
            "    elif 3 in left_face_num:",
            "        pattern=[2,6,5,1]",
            "        if num_pattern_match(face_list,pattern):",
            "            dice.right=Face.Four",
            "            dice.left=Face.Three",
            "        else:",
            "            dice.right=Face.Three",
            "            dice.left=Face.Four",
            "    return dice",
            "def run():",
            "    dice_score_ls=list(map(int,input().split()))",
            "    dice_score_dict={i+1:score for i,score in enumerate(dice_score_ls)}",
            "    d_inv={v:k for k,v in dice_score_dict.items()}",
            "    query_num=int(input())",
            "    for i in range(query_num):",
            "        top,back=tuple(map(int,input().split()))",
            "        top=d_inv[top]",
            "        back=d_inv[back]",
            "        dice=build_dice(top,back)",
            "        # print(int(dice.right))",
            "        print(dice_score_dict[int(dice.right)])",
            "run()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "# -*- coding: utf-8 -*-",
            "import bisect",
            "import heapq",
            "import math",
            "import random",
            "from collections import Counter, defaultdict, deque",
            "from decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal",
            "from fractions import Fraction",
            "from functools import lru_cache, reduce",
            "from itertools import combinations, combinations_with_replacement, product, permutations, accumulate",
            "from operator import add, mul, sub, itemgetter, attrgetter",
            "import sys",
            "sys.setrecursionlimit(10**6)",
            "# readline = sys.stdin.buffer.readline",
            "readline = sys.stdin.readline",
            "INF = 1 << 60",
            "def read_int():",
            "    return int(readline())",
            "def read_int_n():",
            "    return list(map(int, readline().split()))",
            "def read_float():",
            "    return float(readline())",
            "def read_float_n():",
            "    return list(map(float, readline().split()))",
            "def read_str():",
            "    return readline().strip()",
            "def read_str_n():",
            "    return readline().strip().split()",
            "def ep(*args):",
            "    print(*args, file=sys.stderr)",
            "def mt(f):",
            "    import time",
            "    def wrap(*args, **kwargs):",
            "        s = time.perf_counter()",
            "        ret = f(*args, **kwargs)",
            "        e = time.perf_counter()",
            "        ep(e - s, 'sec')",
            "        return ret",
            "    return wrap",
            "MOD = 998244353",
            "class ModInt:",
            "    def __init__(self, x=0):",
            "        self.x = x % MOD",
            "    def __str__(self):",
            "        return str(self.x)",
            "    __repr__ = __str__",
            "    def __add__(self, other):",
            "        return (",
            "            ModInt(self.x + other.x) if isinstance(other, ModInt) else",
            "            ModInt(self.x + other)",
            "        )",
            "    def __sub__(self, other):",
            "        return (",
            "            ModInt(self.x - other.x) if isinstance(other, ModInt) else",
            "            ModInt(self.x - other)",
            "        )",
            "    def __mul__(self, other):",
            "        return (",
            "            ModInt(self.x * other.x) if isinstance(other, ModInt) else",
            "            ModInt(self.x * other)",
            "        )",
            "    def __truediv__(self, other):",
            "        return (",
            "            ModInt(self.x * pow(other.x, MOD - 2)) if isinstance(other, ModInt) else",
            "            ModInt(self.x * pow(other, MOD - 2))",
            "        )",
            "    def __pow__(self, other):",
            "        return (",
            "            ModInt(pow(self.x, other.x)) if isinstance(other, ModInt) else",
            "            ModInt(pow(self.x, other))",
            "        )",
            "    __radd__ = __add__",
            "    def __rsub__(self, other):",
            "        return (",
            "            ModInt(other.x - self.x) if isinstance(other, ModInt) else",
            "            ModInt(other - self.x)",
            "        )",
            "    __rmul__ = __mul__",
            "    def __rtruediv__(self, other):",
            "        return (",
            "            ModInt(other.x * pow(self.x, MOD - 2)) if isinstance(other, ModInt) else",
            "            ModInt(other * pow(self.x, MOD - 2))",
            "        )",
            "    def __rpow__(self, other):",
            "        return (",
            "            ModInt(pow(other.x, self.x)) if isinstance(other, ModInt) else",
            "            ModInt(pow(other, self.x))",
            "        )",
            "@mt",
            "def slv(N, K, LR):",
            "    memo = [ModInt(0)] * (N+2)",
            "    memo[1] = 1",
            "    memo[1+1] = -1",
            "    for i in range(1, N+1):",
            "        memo[i] += memo[i-1]",
            "        for l, r in LR:",
            "            ll = min(N+1, i+l)",
            "            rr = min(N+1, i+r+1)",
            "            memo[ll] += memo[i]",
            "            memo[rr] -= memo[i]",
            "    return memo[N]",
            "def main():",
            "    N, K = read_int_n()",
            "    LR = [read_int_n() for _ in range(K)]",
            "    print(slv(N, K, LR))",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env PyPy3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math, cmath",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import _heapify_max, _heappop_max, _siftdown_max",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    Num = Union[int, float]",
            "    # mod = 1000000007                # 10^9+7",
            "    mod = 998244353",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input():  return sys.stdin.readline().rstrip()",
            "    def ii():     return int(input())",
            "    def isp():    return input().split()",
            "    def mi():     return map(int, input().split())",
            "    def mi_0():   return map(lambda x: int(x)-1, input().split())",
            "    def lmi():    return list(map(int, input().split()))",
            "    def lmi_0():  return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():     return list(input())",
            "    def debug(x): print(x, file=sys.stderr)",
            "    # def _heappush_max(h, item): h.append(item); _siftdown_max(h, 0, len(h)-1)",
            "    n, k = mi()",
            "    L = [lmi() for _ in range(k)]",
            "    dp = [0] * n",
            "    dp[0] = 1",
            "    acc = [0] * (n + 1)    # acc[i] = sum(dp[:i])",
            "    acc[1] = 1",
            "    for i in range(1, n):",
            "        s = 0",
            "        for l, r in L:",
            "            # sum(dp[i-r:i-l+1]) を足していく",
            "            s = (s + acc[max(0, i - l + 1)] - acc[max(0, i - r)]) % mod",
            "        dp[i] = s",
            "        acc[i+1] = (acc[i] + dp[i]) % mod",
            "        # debug(dp)",
            "        # debug(acc)",
            "    print(dp[n-1])",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#from bisect import bisect_left as bl                #c++ lowerbound bl(array,element)",
            "#from bisect import bisect_right as br               #c++ upperbound br(array,element)",
            "#from __future__ import print_function, division    #while using python2",
            "# from itertools import accumulate",
            "# from collections import defaultdict, Counter",
            "def modinv(n,p):",
            "    return pow(n,p-2,p)",
            "def main():",
            "    #sys.stdin = open('input.txt', 'r')",
            "    # sys.stdout = open('output.txt', 'w')",
            "    n, x, m = [int(x) for x in input().split()]",
            "    series = []",
            "    prev = set()",
            "    repeat = []",
            "    ans = 0",
            "    y = x",
            "    repeat_key = -1",
            "    while True:",
            "        if y not in prev:",
            "            prev.add(y)",
            "            series.append(y)",
            "            y = (y * y) % m",
            "        else:",
            "            break",
            "    repeat_key = y",
            "    while True:",
            "        repeat.append(y)",
            "        y = (y * y) % m",
            "        if y == repeat_key:",
            "            break",
            "    # print(series)",
            "    # print(repeat)",
            "    if n <= len(series):",
            "        print(sum(series[:n]))",
            "    else:",
            "        n -= len(series)",
            "        s1 = sum(series)",
            "        s2 = sum(repeat) * (n//len(repeat))",
            "        n %= len(repeat)",
            "        print(s1 + s2 + sum(repeat[:n]))",
            "#------------------ Python 2 and 3 footer by Pajenegod and c1729-----------------------------------------",
            "py2 = round(0.5)",
            "if py2:",
            "    from future_builtins import ascii, filter, hex, map, oct, zip",
            "    range = xrange",
            "import os, sys",
            "from io import IOBase, BytesIO",
            "BUFSIZE = 8192",
            "class FastIO(BytesIO):",
            "    newlines = 0",
            "    def __init__(self, file):",
            "        self._file = file",
            "        self._fd = file.fileno()",
            "        self.writable = \"x\" in file.mode or \"w\" in file.mode",
            "        self.write = super(FastIO, self).write if self.writable else None",
            "    def _fill(self):",
            "        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
            "        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])",
            "        return s",
            "    def read(self):",
            "        while self._fill(): pass",
            "        return super(FastIO,self).read()",
            "    def readline(self):",
            "        while self.newlines == 0:",
            "            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)",
            "        self.newlines -= 1",
            "        return super(FastIO, self).readline()",
            "    def flush(self):",
            "        if self.writable:",
            "            os.write(self._fd, self.getvalue())",
            "            self.truncate(0), self.seek(0)",
            "class IOWrapper(IOBase):",
            "    def __init__(self, file):",
            "        self.buffer = FastIO(file)",
            "        self.flush = self.buffer.flush",
            "        self.writable = self.buffer.writable",
            "        if py2:",
            "            self.write = self.buffer.write",
            "            self.read = self.buffer.read",
            "            self.readline = self.buffer.readline",
            "        else:",
            "            self.write = lambda s:self.buffer.write(s.encode('ascii'))",
            "            self.read = lambda:self.buffer.read().decode('ascii')",
            "            self.readline = lambda:self.buffer.readline().decode('ascii')",
            "sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)",
            "input = lambda: sys.stdin.readline().rstrip('\\r\\n')",
            "if __name__ == '__main__':",
            "   main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "def resolve():",
            "    import sys",
            "    sys.setrecursionlimit(10 ** 6)  # 再帰関数の再帰の深さを設定",
            "    to_index = lambda x: int(x) - 1  # 入力した数字に1を引いたものを返す",
            "    print_list_in_2D = lambda x: print(*x, sep=\"\\n\")  # リストの要素を改行を挟んで表示する関数",
            "    # 入力を整数に変換して受け取る",
            "    def input_int():",
            "        return int(input())",
            "    def map_int_input():",
            "        return map(int, input())",
            "    MII = map_int_input",
            "    def MII_split():",
            "        return map(int, input().split())",
            "    def MII_to_index():",
            "        return map(to_index, input())",
            "    def MII_split_to_index():",
            "        return map(to_index, input().split())",
            "    # 入力全てを整数に変換したものの配列を受け取る",
            "    def list_int_inputs():",
            "        return list(map(int, input()))",
            "    LII = list_int_inputs",
            "    def LII_split():",
            "        return list(map(int, input().split()))",
            "    # 2次元リスト化",
            "    def LII_2D(rows_number):",
            "        return [LII() for _ in range(rows_number)]",
            "    def LII_split_2D(rows_number):",
            "        return [LII_split() for _ in range(rows_number)]",
            "    class UnionFind:",
            "        def __init__(self, n):",
            "            \"\"\"",
            "            :param n: 人数",
            "            :type n: int",
            "            \"\"\"",
            "            self.n = n",
            "            self.parents = [-1] * n",
            "        def find(self, x):",
            "            if self.parents[x] < 0:",
            "                return x",
            "            else:",
            "                self.parents[x] = self.find(self.parents[x])",
            "                return self.parents[x]",
            "        def union(self, x, y):",
            "            x = self.find(x)",
            "            y = self.find(y)",
            "            if x == y:",
            "                return",
            "            if self.parents[x] > self.parents[y]:",
            "                x, y = y, x",
            "            self.parents[x] += self.parents[y]",
            "            self.parents[y] = x",
            "        def size(self, x):",
            "            return -self.parents[self.find(x)]",
            "        def same(self, x, y):",
            "            return self.find(x) == self.find(y)",
            "        def members(self, x):",
            "            root = self.find(x)",
            "            return [i for i in range(self.n) if self.find(i) == root]",
            "        def roots(self):",
            "            return [i for i, x in enumerate(self.parents) if x < 0]",
            "        def group_count(self):",
            "            return len(self.roots())",
            "        def all_group_members(self):",
            "            return {r: self.members(r) for r in self.roots()}",
            "        def __str__(self):",
            "            return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())",
            "    N, M = MII_split()",
            "    # groups = []",
            "    uf = UnionFind(N)",
            "    for _ in range(M):",
            "        A, B = MII_split()",
            "        uf.union(A-1, B-1)  # unionfindを使い、結合の計算量を減らす",
            "        # is_in_groups = False",
            "        # for group in groups:",
            "        #     if A in group and B not in group:",
            "        #         group.append(B)",
            "        #         break",
            "        #     elif B in group and A not in group:",
            "        #         group.append(A)",
            "        #         break",
            "        #     elif A in group and B in group:",
            "        #         is_in_groups = True",
            "        #         break",
            "        # if not is_in_groups:",
            "        #     groups.append([A, B])",
            "    print(max(uf.size(x) for x in range(uf.group_count())))",
            "resolve()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "# input()",
            "# int(input())",
            "# map(int, input().split())",
            "# list(map(int, input().split()))",
            "# list(map(int, list(input()))) # スペースがない数字リストを読み込み",
            "import math",
            "import fractions",
            "import sys",
            "import bisect",
            "import heapq  # 優先度付きキュー(最小値取り出し)",
            "import collections",
            "from collections import Counter",
            "from collections import deque",
            "import pprint",
            "import itertools",
            "\"\"\"nを素因数分解\"\"\"",
            "\"\"\"2以上の整数n => [[素因数, 指数], ...]の2次元リスト\"\"\"",
            "def factorization(n):",
            "    arr = []",
            "    temp = n",
            "    if n == 1:",
            "        return arr",
            "    for i in range(2, int(-(-n ** 0.5 // 1)) + 1):",
            "        if temp % i == 0:",
            "            cnt = 0",
            "            while temp % i == 0:",
            "                cnt += 1",
            "                temp //= i",
            "            arr.append([i, cnt])",
            "    if temp != 1:",
            "        arr.append([temp, 1])",
            "    if arr == []:",
            "        arr.append([n, 1])",
            "    return arr",
            "# a^n",
            "def power(a, n, mod):",
            "    x = 1",
            "    while n:",
            "        if n & 1:",
            "            x *= a % mod",
            "        n >>= 1",
            "        a *= a % mod",
            "    return x % mod",
            "# n*(n-1)*...*(l+1)*l",
            "def kaijo(n, l, mod):",
            "    if n == 0:",
            "        return 1",
            "    a = n",
            "    tmp = n - 1",
            "    while (tmp >= l):",
            "        a = a * tmp % mod",
            "        tmp -= 1",
            "    return a",
            "# Union Find",
            "class UnionFind():",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parents = [-1] * n",
            "    def find(self, x):",
            "        if self.parents[x] < 0:",
            "            return x",
            "        else:",
            "            self.parents[x] = self.find(self.parents[x])",
            "            return self.parents[x]",
            "    def union(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "        if x == y:",
            "            return",
            "        if self.parents[x] > self.parents[y]:",
            "            x, y = y, x",
            "        self.parents[x] += self.parents[y]",
            "        self.parents[y] = x",
            "    def size(self, x):",
            "        return -self.parents[self.find(x)]",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "    def members(self, x):",
            "        root = self.find(x)",
            "        return [i for i in range(self.n) if self.find(i) == root]",
            "    def roots(self):",
            "        return [i for i, x in enumerate(self.parents) if x < 0]",
            "    def group_count(self):",
            "        return len(self.roots())",
            "    def all_group_members(self):",
            "        return {r: self.members(r) for r in self.roots()}",
            "    def __str__(self):",
            "        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())",
            "# 約数生成",
            "def make_divisors(n):",
            "    divisors = []",
            "    for i in range(1, int(n**0.5)+1):",
            "        if n % i == 0:",
            "            divisors.append(i)",
            "            if i != n // i:",
            "                divisors.append(n//i)",
            "    divisors.sort()",
            "    return divisors",
            "inf = 10 ** 18",
            "mod = 10 ** 9 + 7",
            "_INPUT = \"\"\"\\",
            "5 3",
            "1 2",
            "3 4",
            "5 1",
            "\"\"\"",
            "def main(*, input=input):",
            "    sr = lambda: input()",
            "    ir = lambda: int(sr())",
            "    lr = lambda: list(map(int, sr().split()))",
            "    n,m = lr()",
            "    uf = UnionFind(n)",
            "    for i in range(m):",
            "        a,b = lr()",
            "        a-=1",
            "        b-=1",
            "        uf.union(a,b)",
            "    ans = min(uf.parents)",
            "    print(-ans)",
            "if __name__ == \"__main__\":",
            "    import io, sys",
            "    # sys.stdin = io.StringIO(_INPUT)",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "content": [
            "from __future__ import print_function",
            "from functools import reduce",
            "from operator import mul",
            "from collections import Counter",
            "from collections import deque",
            "from itertools import accumulate",
            "from queue import Queue",
            "from queue import PriorityQueue as pq",
            "from heapq import heapreplace",
            "from heapq import heapify",
            "from heapq import heappushpop",
            "from heapq import heappop",
            "from heapq import heappush",
            "import heapq",
            "import time",
            "import random",
            "import bisect",
            "import itertools",
            "import collections",
            "from fractions import Fraction",
            "import fractions",
            "import string",
            "import math",
            "import operator",
            "import functools",
            "import copy",
            "import array",
            "import re",
            "import sys",
            "sys.setrecursionlimit(500000)",
            "input = sys.stdin.readline",
            "def eprint(*args, **kwargs):",
            "    print(*args, file=sys.stderr, **kwargs)",
            "    return",
            "# from fractions import gcd",
            "# from math import gcd",
            "# def lcm(n, m):",
            "#     return int(n * m / gcd(n, m))",
            "# def coprimize(p, q):",
            "#     common = gcd(p, q)",
            "#     return (p // common, q // common)",
            "# def find_gcd(list_l):",
            "#     x = reduce(gcd, list_l)",
            "#     return x",
            "def combinations_count(n, r):",
            "    r = min(r, n - r)",
            "    numer = reduce(mul, range(n, n - r, -1), 1)",
            "    denom = reduce(mul, range(1, r + 1), 1)",
            "    return numer // denom",
            "mod = 1000000007",
            "def combinations_count_mod(n, r):",
            "    r = min(r, n - r)",
            "    numer = reduce(lambda x, y: x * y % mod, range(n, n - r, -1), 1)",
            "    denom = pow(reduce(lambda x, y: x * y % mod, range(1, r + 1), 1), mod - 2, mod)",
            "    return numer * denom % mod",
            "class UnionFind():",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parents = [-1] * n",
            "    def find(self, x):",
            "        if self.parents[x] < 0:",
            "            return x",
            "        else:",
            "            self.parents[x] = self.find(self.parents[x])",
            "            return self.parents[x]",
            "    def union(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "        if x == y:",
            "            return",
            "        if self.parents[x] > self.parents[y]:",
            "            x, y = y, x",
            "        self.parents[x] += self.parents[y]",
            "        self.parents[y] = x",
            "    def size(self, x):",
            "        return -self.parents[self.find(x)]",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "    def members(self, x):",
            "        root = self.find(x)",
            "        return [i for i in range(self.n) if self.find(i) == root]",
            "    def roots(self):",
            "        return [i for i, x in enumerate(self.parents) if x < 0]",
            "    def group_count(self):",
            "        return len(self.roots())",
            "    def all_group_members(self):",
            "        return {r: self.members(r) for r in self.roots()}",
            "    def __str__(self):",
            "        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())",
            "def solve():",
            "    pass",
            "def main():",
            "    n, m = map(int, input().strip().split())",
            "    uf = UnionFind(n)",
            "    ans = 1",
            "    for i in range(m):",
            "        a, b = map(lambda x: int(x)-1, input().strip().split())",
            "        if a > b:",
            "            c = a",
            "            a = b",
            "            b = c",
            "        uf.union(a,b)",
            "        ans = max(ans,uf.size(a))",
            "    print(ans)",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env pypy3",
            "# N,M = map(int,sys.stdin.readline().split())",
            "# a = tuple(map(int,sys.stdin.readline().split())) # single line with multi param",
            "# a = tuple(int(sys.stdin.readline()) for _ in range(N)) # multi line with single param",
            "# a = tuple(tuple(map(int,sys.stdin.readline().rstrip().split())) for _ in range(N)) # multi line with multi param",
            "# s = sys.stdin.readline().rstrip()",
            "# N = int(sys.stdin.readline())",
            "# INF = float(\"inf\")",
            "import math",
            "from collections import defaultdict",
            "pc = True",
            "n = int(input())",
            "a = list(map(int,input().split()))",
            "g = math.gcd(a[0],a[1])",
            "for i in range(2,n):",
            "    g = math.gcd(g,a[i])",
            "M = max(a)",
            "LIMIT=max(a)",
            "minPrime = [0]*(LIMIT+1)",
            "minPrime[1] = 1",
            "def make():",
            "    for i in range(2,LIMIT+1):",
            "        if minPrime[i] == 0:",
            "            minPrime[i] = i",
            "            #print(i)",
            "            for j in range(i+i,LIMIT+1,i):",
            "                #print(i,j)",
            "                if minPrime[j] == 0:",
            "                    minPrime[j] = i",
            "make()",
            "class Sieve_of_Eratosthenes:",
            "    def __init__(self, N):",
            "        self.sieve = [-1] * (N+1)",
            "        for i in range(2,N+1):",
            "            if self.sieve[i] == -1:",
            "                for j in range(1,1+N//i):",
            "                    self.sieve[i*j] = i",
            "    def isprime(self, num):",
            "        if num <= 1:",
            "            return False",
            "        else:",
            "            return self.sieve[num] == num",
            "    def factorization(self, num):",
            "        ret = set([])",
            "        while num != 1:",
            "            div = self.sieve[num]",
            "            ret.add(div)",
            "            num //= div",
            "        return ret",
            "def factrial(N):",
            "    ret = set()",
            "    while 1 != N:",
            "        ret.add(minPrime[N])",
            "        N = N//minPrime[N]",
            "    if N != 1:",
            "        ret.add(N)",
            "    return ret",
            "sofe = Sieve_of_Eratosthenes(M)",
            "ddic = defaultdict()",
            "judge = set([])",
            "for i in a:",
            "    if not pc:",
            "        break",
            "    #asf = sofe.factorization(i)",
            "    asf = factrial(i)",
            "    if judge & asf != set():",
            "        pc = False",
            "    judge |= asf",
            "if pc:",
            "    print(\"pairwise coprime\")",
            "elif g == 1:",
            "    print(\"setwise coprime\")",
            "else:",
            "    print(\"not coprime\")",
            "# import sys,collections",
            "# N = int(sys.stdin.readline())",
            "# #a = tuple(map(int,sys.stdin.readline().split())) # single line with multi param",
            "# a = list(map(int,input().split()))",
            "# import math",
            "# # def factrial(N):",
            "# #     ret = []",
            "# #     while minPrime[N] != N:",
            "# #         ret.append(minPrime[N])",
            "# #         N = N//minPrime[N]",
            "# #     if N != 1:",
            "# #         ret.append(N)",
            "# #     return ret",
            "# def factrial(N):",
            "#     ret = set()",
            "#     while 1 != N:",
            "#         ret.add(minPrime[N])",
            "#         N = N//minPrime[N]",
            "#     if N != 1:",
            "#         ret.add(N)",
            "#     return ret",
            "# for i in range(N):",
            "#     acc = math.gcd(acc,a[i])",
            "# if acc != 1:",
            "#     print(\"not coprime\")",
            "#     exit()",
            "# pairwise = True",
            "# p = set() #all prime",
            "# for e in a:",
            "#     if not pairwise:",
            "#         break",
            "#     f = factrial(e)",
            "#     if p & f != set():",
            "#         pairwise = False",
            "#         print(\"setwise coprime\")",
            "#         exit(0)",
            "#     p = p | f",
            "# if pairwise:",
            "#     print(\"pairwise coprime\")",
            "# else:",
            "#     print(\"setwise coprime\")"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "# input()",
            "# int(input())",
            "# map(int, input().split())",
            "# list(map(int, input().split()))",
            "# list(map(int, list(input()))) # スペースがない数字リストを読み込み",
            "import math",
            "import fractions",
            "import sys",
            "import bisect",
            "import heapq  # 優先度付きキュー(最小値取り出し)",
            "import collections",
            "from collections import Counter",
            "from collections import deque",
            "import pprint",
            "import itertools",
            "\"\"\"nを素因数分解\"\"\"",
            "\"\"\"2以上の整数n => [[素因数, 指数], ...]の2次元リスト\"\"\"",
            "def factorization(n):",
            "    arr = []",
            "    temp = n",
            "    if n == 1:",
            "        return arr",
            "    for i in range(2, int(-(-n ** 0.5 // 1)) + 1):",
            "        if temp % i == 0:",
            "            cnt = 0",
            "            while temp % i == 0:",
            "                cnt += 1",
            "                temp //= i",
            "            arr.append([i, cnt])",
            "    if temp != 1:",
            "        arr.append([temp, 1])",
            "    if arr == []:",
            "        arr.append([n, 1])",
            "    return arr",
            "# a^n",
            "def power(a, n, mod):",
            "    x = 1",
            "    while n:",
            "        if n & 1:",
            "            x *= a % mod",
            "        n >>= 1",
            "        a *= a % mod",
            "    return x % mod",
            "# n*(n-1)*...*(l+1)*l",
            "def kaijo(n, l, mod):",
            "    if n == 0:",
            "        return 1",
            "    a = n",
            "    tmp = n - 1",
            "    while (tmp >= l):",
            "        a = a * tmp % mod",
            "        tmp -= 1",
            "    return a",
            "# Union Find",
            "class UnionFind():",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parents = [-1] * n",
            "    def find(self, x):",
            "        if self.parents[x] < 0:",
            "            return x",
            "        else:",
            "            self.parents[x] = self.find(self.parents[x])",
            "            return self.parents[x]",
            "    def union(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "        if x == y:",
            "            return",
            "        if self.parents[x] > self.parents[y]:",
            "            x, y = y, x",
            "        self.parents[x] += self.parents[y]",
            "        self.parents[y] = x",
            "    def size(self, x):",
            "        return -self.parents[self.find(x)]",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "    def members(self, x):",
            "        root = self.find(x)",
            "        return [i for i in range(self.n) if self.find(i) == root]",
            "    def roots(self):",
            "        return [i for i, x in enumerate(self.parents) if x < 0]",
            "    def group_count(self):",
            "        return len(self.roots())",
            "    def all_group_members(self):",
            "        return {r: self.members(r) for r in self.roots()}",
            "    def __str__(self):",
            "        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())",
            "# 約数生成",
            "def make_divisors(n):",
            "    divisors = []",
            "    for i in range(1, int(n**0.5)+1):",
            "        if n % i == 0:",
            "            divisors.append(i)",
            "            if i != n // i:",
            "                divisors.append(n//i)",
            "    divisors.sort()",
            "    return divisors",
            "inf = 10 ** 18",
            "mod = 10 ** 9 + 7",
            "_INPUT = \"\"\"\\",
            "3",
            "6 10 15",
            "\"\"\"",
            "def main(*, input=input):",
            "    sr = lambda: input()",
            "    ir = lambda: int(sr())",
            "    lr = lambda: list(map(int, sr().split()))",
            "    n = ir()",
            "    a = lr()",
            "    factors = [i for i in range(10**6+1)]",
            "    primes = []",
            "    for i in range(2, (10**6+2)//2):",
            "        if i == factors[i]:",
            "            primes.append(i)",
            "        for num in primes:",
            "            if i*num < 10**6+1:",
            "                factors[i*num] = factors[i]",
            "            else:",
            "                break",
            "    pairwise = True",
            "    judge = [False for i in range(10**6+1)]",
            "    a.reverse()",
            "    for num in a:",
            "        if num != 1:",
            "            tmp = num",
            "            fac = -1",
            "            f = []",
            "            while tmp != 1:",
            "                if fac != factors[tmp]:",
            "                    fac = factors[tmp]",
            "                    f.append(fac)",
            "                tmp //= factors[tmp]",
            "            for h in f:",
            "                if judge[h]:",
            "                    # 被った",
            "                    pairwise = False",
            "                    break",
            "                else:",
            "                    judge[h] = True",
            "        if not pairwise:",
            "            break",
            "    if pairwise:",
            "        print('pairwise coprime')",
            "    else:",
            "        tmp = a[0]",
            "        for num in a[1:]:",
            "            tmp = math.gcd(tmp, num)",
            "            if tmp == 1:",
            "                print('setwise coprime')",
            "                sys.exit()",
            "        print('not coprime')",
            "if __name__ == \"__main__\":",
            "    import io, sys",
            "    # sys.stdin = io.StringIO(_INPUT)",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "content": [
            "# ρ法でとおるかためす。",
            "# 参考1: https://qiita.com/Kiri8128/items/eca965fe86ea5f4cbb98",
            "# 参考2: https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test",
            "# 参考3: https://ja.wikipedia.org/wiki/%E3%83%9D%E3%83%A9%E3%83%BC%E3%83%89%E3%83%BB%E3%83%AD%E3%83%BC%E7%B4%A0%E5%9B%A0%E6%95%B0%E5%88%86%E8%A7%A3%E6%B3%95",
            "def gcd(a, b):",
            "    while b:",
            "        a, b = b, a % b",
            "    return a",
            "def is_prime(n):",
            "    \"Miller Rabin primality test. 2 <= n <= 2 ** 64 is required\"",
            "    if n % 2 == 0:",
            "        return n == 2",
            "    d = n - 1",
            "    r = (d & -d).bit_length() - 1",
            "    d >>= r",
            "    # witnesses をいい感じに決める。",
            "    if n < 2152302898747:",
            "        if n < 9080191:",
            "            if n < 2047:",
            "                witnesses = [2]",
            "            else:",
            "                witnesses = [31, 73]",
            "        else:",
            "            if n < 4759123141:",
            "                witnesses = [2, 7, 61]",
            "            else:",
            "                witnesses = [2, 3, 5, 7, 11]",
            "    else:",
            "        if n < 341550071728321:",
            "            if n < 3474749660383:",
            "                witnesses = [2, 3, 5, 7, 11, 13]",
            "            else:",
            "                witnesses = [2, 3, 5, 7, 11, 13, 17]",
            "        else:",
            "            if n < 3825123056546413051:",
            "                witnesses = [2, 3, 5, 7, 11, 13, 17, 19]",
            "            else:",
            "                witnesses = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]",
            "    # witnesses の決定終了",
            "    for a in witnesses:",
            "        x = pow(a, d, n)",
            "        if x == 1 or x == n - 1:",
            "            continue",
            "        for _ in range(r - 1):",
            "            x *= x",
            "            x %= n",
            "            if x == n - 1:",
            "                break",
            "        else:",
            "            return False",
            "    return True",
            "def find_factor(n):",
            "    \"Find a non-trivial factor of n by using Pollard's rho algorithm.\"",
            "    m = int(n ** 0.125) + 1",
            "    c = 1",
            "    while True:",
            "        y = 1",
            "        r = 1",
            "        q = 1",
            "        g = 1",
            "        while g == 1:",
            "            x = y",
            "            for _ in range(r):",
            "                y = (y * y + c) % n",
            "            for k in range(0, r, m):",
            "                ys = y",
            "                for _ in range(m):",
            "                    y = (y * y + c) % n",
            "                    q = q * (x - y) % n",
            "                g = gcd(q, n)",
            "                if g != 1:",
            "                    break",
            "            else:  # 残りの k から r までをやる",
            "                ys = y",
            "                for _ in range(r-k):",
            "                    y = (y * y + c) % n",
            "                    q = q * (x - y) % n",
            "                g = gcd(q, n)",
            "            r *= 2",
            "        if g == n:",
            "            g = 1",
            "            while g == 1:",
            "                ys = (ys * ys + c) % n",
            "                g = gcd(x - ys, n)",
            "        if g == n:",
            "            c += 1  # c を変えて続行。",
            "        else:  # g は n の非自明な素因数。",
            "            return g",
            "def fac(n):",
            "    \"計算量は O(n ^ 1/4) 程度。\"",
            "    if n == 1:",
            "        return []",
            "    if is_prime(n):",
            "        return [n]",
            "    ret = []",
            "    for p in [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]:",
            "        while n % p == 0:",
            "            ret.append(p)",
            "            n //= p",
            "        if n == 1:",
            "            return ret",
            "    while n != 1 and not is_prime(n):",
            "        f = find_factor(n)",
            "        if is_prime(f):",
            "            while n % f == 0:",
            "                ret.append(f)",
            "                n //= f",
            "        elif is_prime(n // f):",
            "            ret.append(n // f)",
            "            n = f",
            "        else:",
            "            return sorted(ret + fac(f) + fac(n // f))",
            "    if n == 1:",
            "        return sorted(ret)",
            "    else:",
            "        ret.append(n)",
            "        return sorted(ret)",
            "N = int(input())",
            "As = list(map(int, input().split()))",
            "g = 0",
            "for A in As:",
            "    g = gcd(g, A)",
            "if g != 1:",
            "    print(\"not coprime\")",
            "    exit()",
            "primes = set()",
            "for A in As:",
            "    ps = set(fac(A))",
            "    if ps & primes:",
            "        print(\"setwise coprime\")",
            "        exit()",
            "    else:",
            "        primes |= ps",
            "print(\"pairwise coprime\")"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            0,
            2,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from collections import defaultdict",
            "sys.setrecursionlimit(10**6)",
            "INF = 10 ** 9 + 1  # sys.maxsize # float(\"inf\")",
            "MOD = 10 ** 9 + 7",
            "def debug(*x):",
            "    print(*x, file=sys.stderr)",
            "def solve(N, K, PS, CS):",
            "    PS = [x - 1 for x in PS]",
            "    CS = [CS[PS[i]] for i in range(N)]",
            "    visited = {}",
            "    loops = []",
            "    loopScore = []",
            "    for i in range(N):",
            "        loop = []",
            "        c = 0",
            "        while i not in visited:",
            "            visited[i] = True",
            "            c += CS[i]",
            "            i = PS[i]",
            "            loop.append(i)",
            "        if loop:",
            "            loops.append(loop)",
            "            loopScore.append(c)",
            "    pos = list(range(N))",
            "    ret = -INF",
            "    for i, loop in enumerate(loops):",
            "        if loopScore[i] > 0:",
            "            baseScore = loopScore[i] * (K // len(loop))",
            "            r = K % len(loop)",
            "            if r == 0:",
            "                r = len(loop)",
            "                baseScore -= loopScore[i]",
            "            maxscore = 0",
            "            scores = defaultdict(int)",
            "            for i in range(r):",
            "                for x in loop:",
            "                    scores[x] += CS[pos[x]]",
            "                    pos[x] = PS[pos[x]]",
            "                maxscore = max(maxscore, max(scores.values()))",
            "            ret = max(maxscore + baseScore, ret)",
            "        else:",
            "            r = len(loop)",
            "            maxscore = -INF",
            "            scores = defaultdict(int)",
            "            for i in range(r):",
            "                for x in loop:",
            "                    scores[x] += CS[pos[x]]",
            "                    pos[x] = PS[pos[x]]",
            "                maxscore = max(maxscore, max(scores.values()))",
            "            ret = max(maxscore, ret)",
            "    return ret",
            "def main():",
            "    # parse input",
            "    N, K = map(int, input().split())",
            "    PS = list(map(int, input().split()))",
            "    CS = list(map(int, input().split()))",
            "    print(solve(N, K, PS, CS))",
            "# tests",
            "T1 = \"\"\"",
            "5 2",
            "2 4 5 1 3",
            "3 4 -10 -8 8",
            "\"\"\"",
            "TEST_T1 = \"\"\"",
            ">>> as_input(T1)",
            ">>> main()",
            "8",
            "\"\"\"",
            "T2 = \"\"\"",
            "2 3",
            "2 1",
            "10 -7",
            "\"\"\"",
            "TEST_T2 = \"\"\"",
            ">>> as_input(T2)",
            ">>> main()",
            "13",
            "\"\"\"",
            "T3 = \"\"\"",
            "3 3",
            "3 1 2",
            "-1000 -2000 -3000",
            "\"\"\"",
            "TEST_T3 = \"\"\"",
            ">>> as_input(T3)",
            ">>> main()",
            "-1000",
            "\"\"\"",
            "T4 = \"\"\"",
            "10 58",
            "9 1 6 7 8 4 3 2 10 5",
            "695279662 988782657 -119067776 382975538 -151885171 -177220596 -169777795 37619092 389386780 980092719",
            "\"\"\"",
            "TEST_T4 = \"\"\"",
            ">>> as_input(T4)",
            ">>> main()",
            "29507023469",
            "\"\"\"",
            "T5 = \"\"\"",
            "3 1000",
            "2 3 1",
            "1 0 2",
            "\"\"\"",
            "TEST_T5 = \"\"\"",
            ">>> as_input(T5)",
            ">>> main()",
            "1001",
            "\"\"\"",
            "T6 = \"\"\"",
            "3 1000",
            "2 3 1",
            "1 1 -3",
            "\"\"\"",
            "TEST_T6 = \"\"\"",
            ">>> as_input(T6)",
            ">>> main()",
            "2",
            "\"\"\"",
            "T7 = \"\"\"",
            "4 1000",
            "2 1 4 3",
            "1 1 -10000 10000",
            "\"\"\"",
            "TEST_T7 = \"\"\"",
            ">>> as_input(T7)",
            ">>> main()",
            "10000",
            "\"\"\"",
            "T8 = \"\"\"",
            "4 1000",
            "2 1 4 3",
            "1 1 -10000 10001",
            "\"\"\"",
            "TEST_T8 = \"\"\"",
            ">>> as_input(T8)",
            ">>> main()",
            "10500",
            "\"\"\"",
            "def _test():",
            "    import doctest",
            "    doctest.testmod()",
            "    g = globals()",
            "    for k in sorted(g):",
            "        if k.startswith(\"TEST_\"):",
            "            doctest.run_docstring_examples(g[k], g, name=k)",
            "def as_input(s):",
            "    \"use in test, use given string as input file\"",
            "    import io",
            "    f = io.StringIO(s.strip())",
            "    g = globals()",
            "    g[\"input\"] = lambda: bytes(f.readline(), \"ascii\")",
            "    g[\"read\"] = lambda: bytes(f.read(), \"ascii\")",
            "input = sys.stdin.buffer.readline",
            "read = sys.stdin.buffer.read",
            "if sys.argv[-1] == \"-t\":",
            "    print(\"testing\")",
            "    _test()",
            "    sys.exit()",
            "main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "sys.setrecursionlimit(10**6)",
            "INF = 10 ** 9 + 1  # sys.maxsize # float(\"inf\")",
            "MOD = 10 ** 9 + 7",
            "def debug(*x):",
            "    print(*x, file=sys.stderr)",
            "def solve0(N, K, PS, CS):",
            "    PS = [x - 1 for x in PS]",
            "    debug(\": PS\", PS)",
            "    CS = [CS[PS[i]] for i in range(N)]",
            "    PSS = [PS]",
            "    CSS = [CS]",
            "    prevPS = PS",
            "    prevCS = CS",
            "    for i in range(30):",
            "        PS2 = [prevPS[prevPS[i]] for i in range(N)]",
            "        CS2 = [prevCS[i] + prevCS[prevPS[i]] for i in range(N)]",
            "        PSS.append(PS2)",
            "        CSS.append(CS2)",
            "        prevPS = PS2",
            "        prevCS = CS2",
            "    score = [0] * N",
            "    pos = list(range(N))",
            "    length = [0] * N",
            "    maxbit = K.bit_length() - 1",
            "    for i in range(maxbit, -1, -1):",
            "        # debug(\": i\", i)",
            "        # debug(\": 2**i\", 2**i)",
            "        # debug(\": CSS[i]\", CSS[i])",
            "        # debug(\": PSS[i]\", PSS[i])",
            "        # debug(\": score\", score)",
            "        # debug(\": length\", length)",
            "        for j in range(N):",
            "            # debug(\": length[j] + 2 ** i <= K\", length[j] + 2 ** i <= K)",
            "            # debug(\": CSS[i][pos[j]]\", CSS[i][pos[j]])",
            "            if length[j] + 2 ** i <= K and CSS[i][pos[j]] > 0:",
            "                # debug(\"add: j\", j)",
            "                score[j] += CSS[i][pos[j]]",
            "                pos[j] = PSS[i][pos[j]]",
            "                length[j] += 2 ** i",
            "            # if CSS[i][j] > score[j]:",
            "            #     # debug(\"reset: j\", j)",
            "            #     # debug(\": CSS[i][i], score[j]\", CSS[i][i], score[j])",
            "            #     pos[j] = PSS[i][j]",
            "            #     score[j] = CSS[i][j]",
            "            #     length[j] = 2 ** i",
            "    # debug(\"finish: score\", score)",
            "    ret = max(score)",
            "    if ret == 0:",
            "        ret = max(CS)",
            "    return ret",
            "def solve(N, K, PS, CS):",
            "    PS = [x - 1 for x in PS]",
            "    CS = [CS[PS[i]] for i in range(N)]",
            "    visited = {}",
            "    loops = []",
            "    loopScore = []",
            "    for i in range(N):",
            "        loop = []",
            "        c = 0",
            "        while i not in visited:",
            "            visited[i] = True",
            "            c += CS[i]",
            "            i = PS[i]",
            "            loop.append(i)",
            "        if loop:",
            "            loops.append(loop)",
            "            loopScore.append(c)",
            "    # debug(\": loops\", loops)",
            "    # debug(\": loopScore\", loopScore)",
            "    scores = [0] * N",
            "    pos = list(range(N))",
            "    from collections import defaultdict",
            "    ret = 0",
            "    for i, loop in enumerate(loops):",
            "        if loopScore[i] > 0:",
            "            baseScore = loopScore[i] * (K // len(loop))",
            "            r = K % len(loop)",
            "            if r == 0:",
            "                r = len(loop)",
            "                baseScore -= loopScore[i]",
            "                # debug(\"r==0: baseScore\", baseScore)",
            "            maxscore = 0",
            "            scores = defaultdict(int)",
            "            for i in range(r):",
            "                for x in loop:",
            "                    scores[x] += CS[pos[x]]",
            "                    pos[x] = PS[pos[x]]",
            "                maxscore = max(maxscore, max(scores.values()))",
            "                # debug(\"posi: maxscores\", scores)",
            "            ret = max(maxscore + baseScore, ret)",
            "        else:",
            "            r = len(loop)",
            "            maxscore = -INF",
            "            scores = defaultdict(int)",
            "            for i in range(r):",
            "                for x in loop:",
            "                    scores[x] += CS[pos[x]]",
            "                    pos[x] = PS[pos[x]]",
            "                # debug(\"neg: scores\", scores)",
            "                maxscore = max(maxscore, max(scores.values()))",
            "            ret = max(maxscore, ret)",
            "    if ret == 0:",
            "        ret = max(CS)",
            "    return ret",
            "def main():",
            "    # parse input",
            "    N, K = map(int, input().split())",
            "    PS = list(map(int, input().split()))",
            "    CS = list(map(int, input().split()))",
            "    print(solve(N, K, PS, CS))",
            "# tests",
            "T1 = \"\"\"",
            "5 2",
            "2 4 5 1 3",
            "3 4 -10 -8 8",
            "\"\"\"",
            "TEST_T1 = \"\"\"",
            ">>> as_input(T1)",
            ">>> main()",
            "8",
            "\"\"\"",
            "T2 = \"\"\"",
            "2 3",
            "2 1",
            "10 -7",
            "\"\"\"",
            "TEST_T2 = \"\"\"",
            ">>> as_input(T2)",
            ">>> main()",
            "13",
            "\"\"\"",
            "T3 = \"\"\"",
            "3 3",
            "3 1 2",
            "-1000 -2000 -3000",
            "\"\"\"",
            "TEST_T3 = \"\"\"",
            ">>> as_input(T3)",
            ">>> main()",
            "-1000",
            "\"\"\"",
            "T4 = \"\"\"",
            "10 58",
            "9 1 6 7 8 4 3 2 10 5",
            "695279662 988782657 -119067776 382975538 -151885171 -177220596 -169777795 37619092 389386780 980092719",
            "\"\"\"",
            "TEST_T4 = \"\"\"",
            ">>> as_input(T4)",
            ">>> main()",
            "29507023469",
            "\"\"\"",
            "T5 = \"\"\"",
            "3 1000",
            "2 3 1",
            "1 0 2",
            "\"\"\"",
            "TEST_T5 = \"\"\"",
            ">>> as_input(T5)",
            ">>> main()",
            "1001",
            "\"\"\"",
            "T6 = \"\"\"",
            "3 1000",
            "2 3 1",
            "1 1 -3",
            "\"\"\"",
            "TEST_T6 = \"\"\"",
            ">>> as_input(T6)",
            ">>> main()",
            "2",
            "\"\"\"",
            "T7 = \"\"\"",
            "4 1000",
            "2 1 4 3",
            "1 1 -10000 10000",
            "\"\"\"",
            "TEST_T7 = \"\"\"",
            ">>> as_input(T7)",
            ">>> main()",
            "10000",
            "\"\"\"",
            "T8 = \"\"\"",
            "4 1000",
            "2 1 4 3",
            "1 1 -10000 10001",
            "\"\"\"",
            "TEST_T8 = \"\"\"",
            ">>> as_input(T8)",
            ">>> main()",
            "10001",
            "\"\"\"",
            "def _test():",
            "    import doctest",
            "    doctest.testmod()",
            "    g = globals()",
            "    for k in sorted(g):",
            "        if k.startswith(\"TEST_\"):",
            "            doctest.run_docstring_examples(g[k], g, name=k)",
            "def as_input(s):",
            "    \"use in test, use given string as input file\"",
            "    import io",
            "    f = io.StringIO(s.strip())",
            "    g = globals()",
            "    g[\"input\"] = lambda: bytes(f.readline(), \"ascii\")",
            "    g[\"read\"] = lambda: bytes(f.read(), \"ascii\")",
            "input = sys.stdin.buffer.readline",
            "read = sys.stdin.buffer.read",
            "if sys.argv[-1] == \"-t\":",
            "    print(\"testing\")",
            "    _test()",
            "    sys.exit()",
            "main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2
        ]
    },
    {
        "content": [
            "import sys, math",
            "def calcweight_tree(N_vertices, edges, times, inf):",
            "    \"\"\"",
            "    edges: [start, dest, cost] -> [cost, start, end]",
            "    \"\"\"",
            "    distance = 0",
            "    passed = [False] * N_vertices",
            "    travel_max = -inf",
            "    for i in range(N_vertices):",
            "        if(passed[i] == False):",
            "            distance = 0",
            "            left = i",
            "            cost_sum = 0",
            "            costs = []",
            "            min_distance = inf",
            "            while(True):",
            "                dest = edges[left][1]",
            "                cost = edges[dest][0]",
            "                if(passed[dest]==False):",
            "                    #passed[left] = True",
            "                    passed[dest] = True",
            "                    cost_sum += cost",
            "                    costs.append(cost_sum)",
            "                    left = dest",
            "                    if(min_distance > cost):",
            "                        min_distance = cost",
            "                else:",
            "                    period = len(costs)",
            "                    increase_period = cost_sum",
            "                    break",
            "            # 2 period項準備",
            "            remainder = times%period",
            "            cost_minus = [0]",
            "            for j in range(period-1):",
            "                cost_minus.append(costs[j])",
            "            if(increase_period <= 0):",
            "                \"\"\"",
            "                for j in range(period):",
            "                    costs.append(costs[j]+increase_period)",
            "                maxindex = 0",
            "                maxindex_start = 0",
            "                maxvalue = -inf",
            "                if(remainder==0):",
            "                    remainder += period",
            "                for st in range(period):",
            "                    maxvalue_candidate = max(costs[st:st+period])",
            "                    if(maxvalue_candidate - cost_minus[st] > maxvalue):",
            "                        maxvalue = maxvalue_candidate - cost_minus[st]",
            "                        maxindex = costs[st:st+period].index(maxvalue_candidate) + st",
            "                        maxindex_start = st",
            "                \"\"\"",
            "                costs_last = []",
            "                # a_0は0なので。そしてこれは最大値を考えるときには数えないので",
            "                remainder2 = remainder % period",
            "                #print(\"x\", costs, increase_period, remainder2)",
            "                \"\"\"",
            "                for j in range(remainder2, period):",
            "                    costs_last.append(costs[j])",
            "                for j in range(0, remainder2):",
            "                    costs_last.append(costs[j]+increase_period)",
            "                for j in range(period):",
            "                    costs_last.append(costs_last[j]+increase_period)",
            "                \"\"\"",
            "                for j in range(period):",
            "                    costs_last.append(costs[j])",
            "                for j in range(period):",
            "                    costs_last.append(costs_last[j]+increase_period)",
            "                maxvalue = -inf",
            "                #print(costs_last, cost_minus)",
            "                for j in range(period):",
            "                    maxvalue_candidate = max(costs_last[j:j+period])",
            "                    if(maxvalue_candidate-cost_minus[j] > maxvalue):",
            "                        maxvalue = maxvalue_candidate-cost_minus[j]",
            "                travel_max = max(maxvalue, travel_max)",
            "            else:",
            "                costs_last = []",
            "                # a_0は0なので。そしてこれは最大値を考えるときには数えないので",
            "                remainder2 = remainder % period",
            "                times_period = times//period-1",
            "                add_n = times_period * increase_period",
            "                #print(costs, increase_period, remainder2, times_period, add_n)",
            "                for j in range(remainder2, period):",
            "                    costs_last.append(costs[j]+add_n)",
            "                for j in range(0, remainder2):",
            "                    costs_last.append(costs[j]+add_n+increase_period)",
            "                for j in range(period):",
            "                    costs_last.append(costs_last[j]+increase_period)",
            "                maxvalue = -inf",
            "                #print(costs_last, cost_minus)",
            "                for j in range(period):",
            "                    maxvalue_candidate = max(costs_last[j:j+period])",
            "                    if(maxvalue_candidate-cost_minus[j] > maxvalue):",
            "                        maxvalue = maxvalue_candidate-cost_minus[j]",
            "                travel_max = max(maxvalue, travel_max)",
            "    return travel_max",
            "if(__name__ == \"__main__\"):",
            "    \"\"\"",
            "    N = int( input().strip() )",
            "    Length = list( map(int, input().strip().split() ) )",
            "    edges = [ [] for _ in range(N+2) ]",
            "    for i in range(N):",
            "        edges[0].append([0, i]) #[cost, edge]",
            "    for i in range(1, N+1):",
            "        edges[i].append([0, N+1])",
            "    for i in range(N):",
            "        edges[i].append([ CList[i]*(-1), PList[i] ])",
            "    \"\"\"",
            "    N, K= map(int, input().strip().split() )",
            "    PList = list( map(int, input().strip().split() ) )",
            "    CList = list( map(int, input().strip().split() ) )",
            "    inf = 10**10",
            "    N_vertices = N",
            "    edges3 = []",
            "    costs = []",
            "    for i in range(N):",
            "        edges3.append([ CList[i], PList[i]-1 ])",
            "    weight = calcweight_tree(N_vertices, edges3, K, inf)",
            "    #weight= calcweight_bellman_ford(N_vertices, 0, edges3, K+2, cost, inf)",
            "    print( weight)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "#D",
            "class UnionFind():",
            "    # https://www.slideshare.net/chokudai/union-find-49066733",
            "    # 作りたい要素数nで初期化",
            "    # 使用するインスタンス変数の初期化",
            "    def __init__(self, n):",
            "        self.n = n",
            "        # root[x]<0ならそのノードが根かつその値が木の要素数",
            "        # rootノードでその木の要素数を記録する",
            "        # root[x]>=0の場合は、特に直接的な意味を持たない気がする。計算に寄与するので意味はあるのだろうが。",
            "        self.root = [-1]*(n+1)",
            "        # 木をくっつける時にアンバランスにならないように調整する",
            "        # 無結合の時はRank=0,結合して1つ木が深くなると根がRank+=1",
            "        self.rnk = [0]*(n+1)",
            "    # ノードxのrootノードを見つける",
            "    #",
            "    def Find_Root(self, x):",
            "        if(self.root[x] < 0):",
            "            return x",
            "        else:",
            "            # ここで代入しておくことで、後の繰り返しを避ける",
            "            self.root[x] = self.Find_Root(self.root[x])",
            "            return self.root[x]",
            "    # 木の併合、入力は併合したい各ノード",
            "    def Unite(self, x, y):",
            "        # 入力ノードのrootノードを見つける",
            "        x = self.Find_Root(x)",
            "        y = self.Find_Root(y)",
            "        # すでに同じ木に属していた場合",
            "        if(x == y):",
            "            return",
            "        # 違う木に属していた場合rnkを見てくっつける方を決める",
            "        # (1)xのランクの方が大きい(位置が深い)場合",
            "        elif(self.rnk[x] > self.rnk[y]):",
            "            self.root[x] += self.root[y]",
            "            self.root[y] = x",
            "        # (2)yのランクの方が大きい(位置が深い)場合 or 等しい場合",
            "        # また等しい場合、引数の2つめのyの方のランクを1つ増やす",
            "        else:",
            "            self.root[y] += self.root[x]",
            "            self.root[x] = y",
            "            # rnkが同じ（深さに差がない場合）は1増やす",
            "            if(self.rnk[x] == self.rnk[y]):",
            "                self.rnk[y] += 1",
            "    # xとyが同じグループに属するか判断",
            "    # Return: True or False",
            "    def isSameGroup(self, x, y):",
            "        return self.Find_Root(x) == self.Find_Root(y)",
            "    # ノードxが属する木のサイズを返す",
            "    def Count(self, x):",
            "        return -self.root[self.Find_Root(x)]",
            "###################################################################",
            "N,K=map(int,input().split())",
            "UN=UnionFind(N)",
            "P=list(map(int,input().split()))",
            "C=list(map(int,input().split()))",
            "for i,num in enumerate(P):",
            "    UN.Unite(i+1,num)",
            "root=set()",
            "loop_score=dict()",
            "loop_len=dict()",
            "#print(UN.root)",
            "for i,node in enumerate(UN.root):",
            "    if i==0:",
            "        pass",
            "    else:",
            "        if node<0:",
            "            #print(i,\"is root\")",
            "            root.add(i)",
            "            score=0",
            "            ini=i",
            "            leng=0",
            "            while True:",
            "                ret=P[ini-1]",
            "                score += C[ret-1]",
            "                leng +=1",
            "                if ret==i:",
            "                    break",
            "                else:",
            "                    ini=ret",
            "            loop_score[i]=score",
            "            loop_len[i] = leng",
            "#print(loop_score)",
            "#print(loop_len)",
            "ans_list=[]",
            "ans=float(\"-inf\")",
            "for i in range(1,N+1):",
            "    t=K",
            "    p=UN.Find_Root(i)",
            "    #ループした方がいいかの確認",
            "    if loop_score[p]>0:",
            "        tmp=0",
            "        pos=i",
            "        tmp += ((t//loop_len[p])-1)*loop_score[p]",
            "        if tmp>0:",
            "            ans=max(tmp,ans)",
            "        t = (t%loop_len[p])+loop_len[p]",
            "        for j in range(t):",
            "            pos = P[pos-1]",
            "            tmp += C[pos-1]",
            "            ans=max(tmp,ans)",
            "    else:",
            "        tmp=0",
            "        pos=i",
            "        for j in range(min(t,loop_len[p]-1)):",
            "            pos = P[pos-1]",
            "            tmp += C[pos-1]",
            "            ans=max(tmp,ans)",
            "print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            2,
            2
        ]
    },
    {
        "content": [
            "## coding: UTF-8",
            "#ループ構造を見つけたらやめるところまで実装",
            "#freshを用意して、Falseになったらやめる実装",
            "N, K = map(int,input().split())",
            "P = list(map(int,input().split()))",
            "C = list(map(int,input().split()))",
            "#log = [1] #訪れた地点を記録するもの",
            "#last  = 1 #最後に訪れた地点を記録するもの（ここから次に行くところを検索する）",
            "fresh = [False] + [True] * N #まだついたことのない場所をTrueにしている",
            "#fresh[1] = False",
            "#turn = ['a'] + [0] * N #なん回目におとづれたか記録する",
            "#status = True",
            "def search_loop(start):",
            "    log = [start] #訪れた地点を記録するもの",
            "    last  = start #最後に訪れた地点を記録するもの（ここから次に行くところを検索する）",
            "    score = [C[start-1]]",
            "    counter = 0",
            "    while True:",
            "        next_spot = P[last - 1]",
            "        counter += 1",
            "        #print(next_spot)",
            "        if(fresh[next_spot]):",
            "            #処理を書く",
            "            log.append(next_spot)",
            "            score.append(C[next_spot-1])",
            "            last = next_spot",
            "            fresh[next_spot] = False",
            "            #turn[next_spot] = counter",
            "        else:",
            "            #log.append(next_spot)",
            "            last = next_spot",
            "            fresh[next_spot] = False",
            "            #最後の人処理をする",
            "            break",
            "    del log[-1]",
            "    del score[-1]",
            "    #print('hit')",
            "    return log, counter-1, sum(score), score",
            "    #last, counter#turn, counter",
            "status = True",
            "list_loop = []",
            "list_elements = []",
            "list_sum = []",
            "list_score = []",
            "while status:",
            "    for i in range(N+1):",
            "        if(fresh[i]):",
            "            #print(search_loop(i))",
            "            a = search_loop(i)",
            "            list_loop.append(a[0])",
            "            list_elements.append(a[1])",
            "            list_sum.append(a[2])",
            "            list_score.append(a[3])",
            "            break",
            "        if(i == N):",
            "            status = False",
            "#print('loop', list_loop, 'elements', list_elements, 'sum', list_sum, 'score', list_score)",
            "#print(search_loop(1))",
            "'''",
            "def count_sum(score,elements,start,goal):",
            "    #歩数, 合計値でreturn",
            "    if(start==goal):",
            "        return 0, 0",
            "    elif(goal > start):",
            "        #print(score[start+1:goal+1])",
            "        #ret = sum(score[start+1:goal+1])",
            "        return goal-start, sum(score[start+1:goal+1])",
            "    else:",
            "        l = score + score",
            "        #print(l)",
            "        #print(l[start+1:goal+elements+1])",
            "        return goal+elements-start, sum(l[start+1:goal+elements+1])",
            "'''",
            "#各ループに対して始点終点全探索",
            "def zentansaku(loop, elements, sum, score):",
            "    #ループを入力して、最大値を出力する",
            "    #最終的にはループごとの最大値を出力する",
            "    best = (-1)*(10**10)",
            "    for start in range(elements):",
            "        #step = 0",
            "        now = 0",
            "        for step in range(elements):",
            "            #print(start, (step+start)%elements)",
            "            #print(count_sum(score, elements, start, goal))",
            "            #ret = (count_sum(score, elements, start, goal))",
            "            '''",
            "            if(start != goal):",
            "                step += 1",
            "                now += score[goal]",
            "            '''",
            "            if(step > 0):",
            "                now += score[(step+start)%elements]",
            "            #print('step',step, 'now',now)",
            "            if(step > K):",
            "                #歩きすぎ",
            "                result = (-1)*(10**10)",
            "            else:",
            "                if(sum > 0):",
            "                    #ループの合計値が正の場合、残りは歩けるだけ回る",
            "                    available_looping = (K-step) // elements",
            "                    #print('available_looping', available_looping)",
            "                    result = sum * available_looping + now",
            "                else:",
            "                    if(step > 0):",
            "                        result = now",
            "                    else:",
            "                        result = (-1)*(10**10)",
            "            best = max(result, best)",
            "            #print('result', result, 'best', best)",
            "            #print(score[start:goal])",
            "            #now = sum(score[start:goal])",
            "    return best",
            "ans = (-1)*(10**10)",
            "for i in range(len(list_elements)):",
            "    #print(list_loop[i], list_elements[i], list_sum[i], list_score[i])",
            "    ans = max(ans, zentansaku(list_loop[i], list_elements[i], list_sum[i], list_score[i]))",
            "    #print(list_loop[i], list_elements[i], list_sum[i], list_score[i], 'ans', ans)",
            "    #print('~~~')",
            "print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2
        ]
    },
    {
        "content": [
            "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools",
            "from collections import deque",
            "sys.setrecursionlimit(10**7)",
            "inf = 10**20",
            "mod = 10**9 + 7",
            "DR = [1, -1, 0, 0]",
            "DC = [0, 0, 1, -1]",
            "def LI(): return [int(x) for x in sys.stdin.readline().split()]",
            "def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]",
            "def LF(): return [float(x) for x in sys.stdin.readline().split()]",
            "def LS(): return sys.stdin.readline().split()",
            "def I(): return int(sys.stdin.readline())",
            "def F(): return float(sys.stdin.readline())",
            "def S(): return input()",
            "def main():",
            "    N, K = LI()",
            "    P = LI_()",
            "    C = LI()",
            "    G = [-1 for _ in range(N)]",
            "    for i, p in enumerate(P):",
            "        G[i] = p",
            "    seen = set()",
            "    loop_score = []",
            "    loop_size = []",
            "    loop_id2node = collections.defaultdict(list)",
            "    _id = 0",
            "    def calc_one_loop(v):",
            "        nodes = set()",
            "        if G[v] == -1:",
            "            return -1, -1",
            "        # calc loop, and return score",
            "        score = 0",
            "        size = 0",
            "        while G[v] not in seen:",
            "            v = G[v]",
            "            seen.add(v)",
            "            nodes.add(v)",
            "            score += C[v]",
            "            size += 1",
            "        return score, size, nodes",
            "    for i in range(N):",
            "        if i in seen:",
            "            continue",
            "        score, size, nodes = calc_one_loop(i)",
            "        if score == -1 and size == -1:",
            "            continue",
            "        loop_score.append(score)",
            "        loop_size.append(size)",
            "        loop_id2node[_id].extend(list(nodes))",
            "        seen.add(i)",
            "        _id += 1",
            "    # print('loop_size: ', loop_size)",
            "    # print('loop_score: ', loop_score)",
            "    ans = -inf",
            "    for i in range(_id):",
            "        # i: id",
            "        n_loop = K // loop_size[i]",
            "        # score_afterを作る",
            "        score_after = [[0] for _ in range(N)]",
            "        for v in loop_id2node[i]:",
            "            max_move_cnt = loop_size[i] + 1",
            "            move_cnt = 0",
            "            cum_score = 0",
            "            cur_v = v",
            "            while move_cnt < max_move_cnt:",
            "                cur_v = G[cur_v]",
            "                cum_score += C[cur_v]",
            "                score_after[v].append(cum_score)",
            "                move_cnt += 1",
            "        # print('score_after: ', score_after)",
            "        if loop_score[i] <= 0:",
            "            max_step = min(K, loop_size[i])",
            "            score = 0",
            "        else:",
            "            # 先に回る",
            "            # ちょうど1周だったら、回らない",
            "            score = 0",
            "            max_step = loop_size[i]",
            "            # if K == loop_size[i]:",
            "            #     max_step = K",
            "            #     score = 0",
            "            # else:",
            "            #     K -= n_loop * loop_size[i]",
            "            #     max_step = K",
            "            #     score = n_loop * loop_score[i]",
            "        # loop_size[i]より小さい数で全探索",
            "        for l in range(1, max_step + 1):",
            "            for v in loop_id2node[i]:",
            "                cp_score = score",
            "                cnt = 0",
            "                cp_score += score_after[v][l]",
            "                # 実現不可能なら飛ばす",
            "                if l > K:",
            "                    continue",
            "                # 回った時も試してみる",
            "                if K - l >= loop_size[i]:",
            "                    cp_score = max(cp_score, cp_score + loop_score[i] * ((K - l) // loop_size[i]))",
            "                ans = max(ans, cp_score)",
            "    print(ans)",
            "main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2
        ]
    },
    {
        "content": [
            "# https://atcoder.jp/contests/abc175/tasks/abc175_d",
            "# ダブリングで解く",
            "# K>ループ長の場合、累積の最後の値が負ならmaxを取ればいいし、正ならば 累積の最後の値*周数をかけてから計算",
            "import sys",
            "sys.setrecursionlimit(1 << 25)",
            "readline = sys.stdin.buffer.readline",
            "read = sys.stdin.readline  # 文字列読み込む時はこっち",
            "ra = range",
            "enu = enumerate",
            "def exit(*argv, **kwarg):",
            "    print(*argv, **kwarg)",
            "    sys.exit()",
            "def mina(*argv, sub=1): return list(map(lambda x: x - sub, argv))",
            "# 受け渡されたすべての要素からsubだけ引く.リストを*をつけて展開しておくこと",
            "def a_int(): return int(readline())",
            "def ints(): return list(map(int, readline().split()))",
            "def read_col(H):",
            "    '''H is number of rows",
            "    A列、B列が与えられるようなとき",
            "    ex1)A,B=read_col(H)    ex2) A,=read_col(H) #一列の場合'''",
            "    ret = []",
            "    for _ in range(H):",
            "        ret.append(list(map(int, readline().split())))",
            "    return tuple(map(list, zip(*ret)))",
            "def read_tuple(H):",
            "    '''H is number of rows'''",
            "    ret = []",
            "    for _ in range(H):",
            "        ret.append(tuple(map(int, readline().split())))",
            "    return ret",
            "def read_matrix(H):",
            "    '''H is number of rows'''",
            "    ret = []",
            "    for _ in range(H):",
            "        ret.append(list(map(int, readline().split())))",
            "    return ret",
            "    # return [list(map(int, read().split())) for _ in range(H)] # 内包表記はpypyでは遅いため",
            "MOD = 10**9 + 7",
            "INF = 2**31  # 2147483648 > 10**9",
            "# default import",
            "from collections import defaultdict, Counter, deque",
            "from operator import itemgetter, xor, add",
            "from itertools import product, permutations, combinations, accumulate",
            "from bisect import bisect_left, bisect_right  # , insort_left, insort_right",
            "from functools import reduce",
            "from math import gcd",
            "def lcm(a, b):",
            "    # 最小公倍数",
            "    g = gcd(a, b)",
            "    return a // g * b",
            "N, K = ints()",
            "P = mina(*ints())",
            "C = ints()",
            "next = [[-1] * N for _ in range(32)]  # next[k][i] ノードiから2^k回移動するときのノード",
            "score = [[0] * N for _ in range(32)]  # score[k][i] ノードiから2^k回移動するときに加算されるスコア",
            "# nextの構築",
            "next[0] = P",
            "for k in range(31):",
            "    for i in range(N):",
            "        next[k + 1][i] = next[k][next[k][i]]",
            "# scoreの構築",
            "for i in range(N):",
            "    score[0][i] = C[P[i]]",
            "for k in range(31):",
            "    for i in range(N):",
            "        score[k + 1][i] = score[k][i] + score[k][next[k][i]]",
            "# これじゃ道中がわからない...",
            "# 一点しか求まらない",
            "def get_score(i, k):  # 途中の1点のscoreを算出",
            "    now = i",
            "    ret = 0",
            "    for j in range(k.bit_length()):",
            "        if (k >> j) & 1:",
            "            ret += score[j][now]",
            "            now = next[j][now]",
            "    return ret, now",
            "# 各ノードからK回移動したときのscoreを計算する",
            "ans = -10**10",
            "for i in range(N):",
            "    # print(i, 'について')",
            "    if K <= N:",
            "        # 素直に最初からK回シミュレーションする",
            "        tmp = 0",
            "        now = i",
            "        for _ in range(K):",
            "            tmp += score[0][now]",
            "            now = next[0][now]",
            "            ans = max(tmp, ans)",
            "            # print(tmp)",
            "    else:",
            "        # 最初からN回シミュレーション + K-NからN回シミュレーション",
            "        tmp = 0",
            "        now = i",
            "        for j in range(N):",
            "            tmp += score[0][now]",
            "            now = next[0][now]",
            "            ans = max(tmp, ans)",
            "            # print(tmp)",
            "        tmp, now = get_score(i, K - N)",
            "        for j in range(N):",
            "            tmp += score[0][now]",
            "            now = next[0][now]",
            "            ans = max(tmp, ans)",
            "            # print(tmp)",
            "print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            2,
            2,
            1,
            2,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "def main():",
            "    examC()",
            "def examA():",
            "    S = SI()",
            "    S = \">\" + S + \"<\"",
            "    N = len(S)",
            "    A = [0]*N",
            "    i = 0",
            "    while(i<N-1):",
            "        r = i + 1",
            "        if S[i]==\">\" and S[i+1]==\"<\":",
            "            A[i] = 0",
            "            l = i-1",
            "            cur = 0",
            "            while(1<=l):",
            "                cur += 1",
            "                A[l] = max(A[l], cur)",
            "                l -= 1",
            "                if S[l+1]==\"<\":",
            "                    #print(\"break\",l,A)",
            "                    break",
            "            r = i+1",
            "            cur = 0",
            "            while(r<N-1):",
            "                cur += 1",
            "                A[r] = max(A[r], cur)",
            "                r += 1",
            "                if r==N-1:",
            "                    break",
            "                if S[r]==\">\":",
            "                    break",
            "        #print(i,A)",
            "        i = r",
            "    #print(A)",
            "    A[0] = 0; A[-1] = 0",
            "    ans = sum(A)",
            "    print(ans)",
            "    return",
            "def examB():",
            "    H, W = LI()",
            "    A = [SI()for _ in range(H)]",
            "    C = defaultdict(int)",
            "    for a in A:",
            "        for s in a:",
            "            C[s] += 1",
            "    B = sorted(C.items())",
            "    # print(B)",
            "    flag_odd = not (H%2==1 and W%2==1)",
            "    upper_2 = (H%2==1) * (W//2) + (W%2==1) * (H//2)",
            "    for s,c in B:",
            "        if c%2==1:",
            "            if flag_odd:",
            "                print(\"No\")",
            "                return",
            "            flag_odd = True",
            "        elif c%4==2:",
            "            upper_2 -= 1",
            "            if upper_2<0:",
            "                print(\"No\")",
            "                return",
            "    print(\"Yes\")",
            "    return",
            "def examC():",
            "    N, K = LI()",
            "    P = LI()",
            "    C = LI()",
            "    if max(C)<0:",
            "        print(max(C))",
            "        return",
            "    loop = [[0,0]for _ in range(N)]",
            "    for i in range(N):",
            "        checked = set()",
            "        now = i",
            "        score = 0",
            "        while(now not in checked):",
            "            checked.add(now)",
            "            now = P[now]-1",
            "            score += C[now]",
            "        n = len(checked)",
            "        for j in checked:",
            "            loop[j] = [n,score]",
            "    # print(loop)",
            "    ans = 0",
            "    for i in range(N):",
            "        n,s = loop[i]",
            "        score = 0",
            "        if s>0:",
            "            score += (K//n - 1) * s",
            "        ans = max(ans,score)",
            "        now = i",
            "        for j in range(n + K%n):",
            "            now = P[now] - 1",
            "            score += C[now]",
            "            ans = max(ans,score)",
            "    print(ans)",
            "    return",
            "def examD():",
            "    ans = 0",
            "    print(ans)",
            "    return",
            "def examE():",
            "    ans = 0",
            "    print(ans)",
            "    return",
            "def examF():",
            "    ans = 0",
            "    print(ans)",
            "    return",
            "def test():",
            "    i = I()",
            "    li = LI()",
            "    lsi = LSI()",
            "    si = LS()",
            "    print(i)",
            "    print(li)",
            "    print(lsi)",
            "    print(si)",
            "    return",
            "from decimal import getcontext,Decimal as dec",
            "import sys,bisect,itertools,heapq,math,random",
            "from copy import deepcopy",
            "from heapq import heappop,heappush,heapify",
            "from collections import Counter,defaultdict,deque",
            "read = sys.stdin.buffer.read",
            "readline = sys.stdin.buffer.readline",
            "readlines = sys.stdin.buffer.readlines",
            "def I(): return int(input())",
            "def LI(): return list(map(int,sys.stdin.readline().split()))",
            "def DI(): return dec(input())",
            "def LDI(): return list(map(dec,sys.stdin.readline().split()))",
            "def LSI(): return list(map(str,sys.stdin.readline().split()))",
            "def LS(): return sys.stdin.readline().split()",
            "def SI(): return sys.stdin.readline().strip()",
            "global mod,mod2,inf,alphabet,alphabet_convert,_ep",
            "mod = 10**9 + 7",
            "mod2 = 998244353",
            "inf = 1<<31",
            "_ep = dec(\"0.000000000001\")",
            "alphabet = [chr(ord('a') + i) for i in range(26)]",
            "alphabet_convert = {chr(ord('a') + i): i for i in range(26)}",
            "getcontext().prec = 28",
            "sys.setrecursionlimit(10**7)",
            "if __name__ == '__main__':",
            "    main()",
            "\"\"\"",
            "142",
            "12 9 1445 0 1",
            "asd dfg hj o o",
            "aidn",
            "\"\"\""
        ],
        "label": [
            2,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "import sys",
            "import numpy as np",
            "# from numba import njit",
            "# @njit(cache=True)",
            "def calcCycle(N,K,P,C,cycleIDs,cycleItemCnts,cycleTotalScores):",
            "\tcycleID = 0",
            "\tfor n in range(N):",
            "\t\tv = n",
            "\t\tcurrentCycleItemCnt = 0",
            "\t\tcurrentCycleTotal = 0",
            "\t\tif cycleIDs[v] != -1:",
            "\t\t\tcontinue",
            "\t\t\t# print(currentCycleItemCnt, currentCycleTotal)",
            "\t\telse:",
            "\t\t\twhile True:",
            "\t\t\t\t# 全頂点について、属するサイクルを計算する",
            "\t\t\t\tcurrentCycleItemCnt += 1",
            "\t\t\t\tcurrentCycleTotal += C[v]",
            "\t\t\t\tv = P[v]",
            "\t\t\t\tif v == n:",
            "\t\t\t\t\t# サイクル発見",
            "\t\t\t\t\tcycleIDs[v] = cycleID",
            "\t\t\t\t\tcycleItemCnts[cycleID] = currentCycleItemCnt",
            "\t\t\t\t\tcycleTotalScores[cycleID] = currentCycleTotal",
            "\t\t\t\t\tcycleID += 1",
            "\t\t\t\t\tbreak",
            "\t\t\t\t# 一応、一度サイクルを計算した頂点については、",
            "\t\t\t\t# その頂点の属するサイクルの情報をメモっておく。。。",
            "\t\t\t\tcycleIDs[v] = cycleID",
            "def upd(P,C,K,v,ans,currentCycleItemCnt,currentCycleTotal):",
            "\t# procCnt = 0",
            "\tcurrentCycleSumTmp = 0",
            "\tfor k in range(min(K,currentCycleItemCnt)):",
            "\t\t# 頂点vにコマが置かれた時の最高スコアを計算し、",
            "\t\t# これまでの最高スコアを上回ったら、これまでの最高スコアを更新する",
            "\t\tprocCnt = k+1",
            "\t\tcurrentCycleSumTmp += C[v]",
            "\t\tcycleLoopCnt = 0",
            "\t\tif 0 < currentCycleTotal:",
            "\t\t\tcycleLoopCnt = ( K - procCnt ) // currentCycleItemCnt",
            "\t\t# print(\"v=\", v, \"currentCycleSumTmp=\", currentCycleSumTmp, \"procCnt, cycleLoopCnt, currentCycleTotal=\", procCnt, cycleLoopCnt, currentCycleTotal)",
            "\t\tans = max( ans, currentCycleSumTmp + cycleLoopCnt * currentCycleTotal )",
            "\t\tv = P[v]",
            "\treturn ans",
            "def main(N,K,P,C,cycleIDs,cycleItemCnts,cycleTotalScores):",
            "\tans = -1e18",
            "\tfor n in range(N):",
            "\t\tv = n",
            "\t\tcurrentCycleItemCnt, currentCycleTotal = cycleItemCnts[ cycleIDs[v] ], cycleTotalScores[ cycleIDs[v] ]",
            "\t\tans=upd(P,C,K,v,ans,currentCycleItemCnt,currentCycleTotal)",
            "\t\t# currentCycleSumTmp = 0",
            "\t\t# for k in range(min(K,currentCycleItemCnt)):",
            "\t\t# \tprocCnt = k+1",
            "\t\t# \tcurrentCycleSumTmp += C[v]",
            "\t\t# \tcycleLoopCnt = 0",
            "\t\t# \tif 0 < currentCycleTotal:",
            "\t\t# \t\tcycleLoopCnt = ( K - procCnt ) // currentCycleItemCnt",
            "\t\t# \t# print(\"v=\", v, \"currentCycleSumTmp=\", currentCycleSumTmp, \"procCnt, cycleLoopCnt, currentCycleTotal=\", procCnt, cycleLoopCnt, currentCycleTotal)",
            "\t\t# \tans = max( ans, currentCycleSumTmp + cycleLoopCnt * currentCycleTotal )",
            "\t\t# \tv = P[v]",
            "\tprint(int(ans))",
            "if sys.argv[-1]=='ONLINE_JUDGE':",
            "\t# from numba import njit",
            "\tfrom numba.pycc import CC",
            "\tcc=CC('my_module')",
            "\tcc.export('calcCycle','void(i8,i8,i8[:],i8[:],i8[:],i8[:],i8[:])')(calcCycle)",
            "\t# cc.export('main','void(i8,i8,i8[:],i8[:],i8[:],i8[:],i8[:])')(main)",
            "\tcc.export('upd','i8(i8[:],i8[:],i8,i8,i8,i8,i8)')(upd)",
            "\t# cc.export('upd','UniTuple(i8,3)(i8[:],i8[:],i8,i8,i8,i8,i8)')(upd)",
            "\t# main=njit(main, cache=True)",
            "\tcc.compile()",
            "\texit(0)",
            "from my_module import upd,calcCycle",
            "# from my_module import main,calcCycle",
            "# from my_module import calcCycle",
            "if __name__ == \"__main__\":",
            "\tN,K = map(int,input().split())",
            "\tP = np.array( input().split(), np.int64 )",
            "\tP -= 1",
            "\tC = np.array( input().split(), np.int64 )",
            "\t# 一度計算したサイクル情報を一応キャッシュしておく。。。",
            "\t# あんまり意味なさそう",
            "\tcycleIDs = np.full( N, -1, dtype=np.int64 )",
            "\tcycleItemCnts = np.full( N, -1, dtype=np.int64 )",
            "\tcycleTotalScores = np.full( N, -1, dtype=np.int64 )",
            "\tcalcCycle(N,K,P,C,cycleIDs,cycleItemCnts,cycleTotalScores)",
            "\t# print(cycleItemCnts)",
            "\tmain(N,K,P,C,cycleIDs,cycleItemCnts,cycleTotalScores)",
            "\t#print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "import numpy as np",
            "# from numba import njit",
            "# @njit(cache=True)",
            "def calcCycle(N,K,P,C,cycleIDs,cycleItemCnts,cycleTotalScores):",
            "\tcycleID = 0",
            "\tfor n in range(N):",
            "\t\tv = n",
            "\t\tcurrentCycleItemCnt = 0",
            "\t\tcurrentCycleTotal = 0",
            "\t\tif cycleIDs[v] != -1:",
            "\t\t\tcontinue",
            "\t\t\t# print(currentCycleItemCnt, currentCycleTotal)",
            "\t\telse:",
            "\t\t\twhile True:",
            "\t\t\t\t# 全頂点について、属するサイクルを計算する",
            "\t\t\t\tcurrentCycleItemCnt += 1",
            "\t\t\t\tcurrentCycleTotal += C[v]",
            "\t\t\t\tv = P[v]",
            "\t\t\t\tif v == n:",
            "\t\t\t\t\t# サイクル発見",
            "\t\t\t\t\tcycleIDs[v] = cycleID",
            "\t\t\t\t\tcycleItemCnts[cycleID] = currentCycleItemCnt",
            "\t\t\t\t\tcycleTotalScores[cycleID] = currentCycleTotal",
            "\t\t\t\t\tcycleID += 1",
            "\t\t\t\t\tbreak",
            "\t\t\t\t# 一応、一度サイクルを計算した頂点については、",
            "\t\t\t\t# その頂点の属するサイクルの情報をメモっておく。。。",
            "\t\t\t\tcycleIDs[v] = cycleID",
            "def upd(P,C,K,v,ans,currentCycleItemCnt,currentCycleTotal):",
            "\t# procCnt = 0",
            "\tcurrentCycleSumTmp = 0",
            "\tfor k in range(min(K,currentCycleItemCnt)):",
            "\t\t# 頂点vにコマが置かれた時の最高スコアを計算し、",
            "\t\t# これまでの最高スコアを上回ったら、これまでの最高スコアを更新する",
            "\t\tprocCnt = k+1",
            "\t\tcurrentCycleSumTmp += C[v]",
            "\t\tcycleLoopCnt = 0",
            "\t\tif 0 < currentCycleTotal:",
            "\t\t\tcycleLoopCnt = ( K - procCnt ) // currentCycleItemCnt",
            "\t\t# print(\"v=\", v, \"currentCycleSumTmp=\", currentCycleSumTmp, \"procCnt, cycleLoopCnt, currentCycleTotal=\", procCnt, cycleLoopCnt, currentCycleTotal)",
            "\t\tans = max( ans, currentCycleSumTmp + cycleLoopCnt * currentCycleTotal )",
            "\t\tv = P[v]",
            "\treturn ans",
            "def main(ans,N,K,P,C,cycleIDs,cycleItemCnts,cycleTotalScores):",
            "\tfor n in range(N):",
            "\t\tv = n",
            "\t\tcurrentCycleItemCnt, currentCycleTotal = cycleItemCnts[ cycleIDs[v] ], cycleTotalScores[ cycleIDs[v] ]",
            "\t\t# ans=upd(P,C,K,v,ans,currentCycleItemCnt,currentCycleTotal)",
            "\t\tcurrentCycleSumTmp = 0",
            "\t\tfor k in range(min(K,currentCycleItemCnt)):",
            "\t\t\tprocCnt = k+1",
            "\t\t\tcurrentCycleSumTmp += C[v]",
            "\t\t\tcycleLoopCnt = 0",
            "\t\t\tif 0 < currentCycleTotal:",
            "\t\t\t\tcycleLoopCnt = ( K - procCnt ) // currentCycleItemCnt",
            "\t\t\t# print(\"v=\", v, \"currentCycleSumTmp=\", currentCycleSumTmp, \"procCnt, cycleLoopCnt, currentCycleTotal=\", procCnt, cycleLoopCnt, currentCycleTotal)",
            "\t\t\tans = max( ans, currentCycleSumTmp + cycleLoopCnt * currentCycleTotal )",
            "\t\t\tv = P[v]",
            "\tprint(int(ans))",
            "if sys.argv[-1]=='ONLINE_JUDGE':",
            "\t# from numba import njit",
            "\tfrom numba.pycc import CC",
            "\tcc=CC('my_module')",
            "\tcc.export('calcCycle','void(i8,i8,i8[:],i8[:],i8[:],i8[:],i8[:])')(calcCycle)",
            "\tcc.export('main','void(i8,i8,i8,i8[:],i8[:],i8[:],i8[:],i8[:])')(main)",
            "\t# cc.export('upd','i8(i8[:],i8[:],i8,i8,i8,i8,i8)')(upd)",
            "\t# cc.export('upd','UniTuple(i8,3)(i8[:],i8[:],i8,i8,i8,i8,i8)')(upd)",
            "\t# main=njit(main, cache=True)",
            "\tcc.compile()",
            "\texit(0)",
            "# from my_module import upd,calcCycle",
            "from my_module import main,calcCycle",
            "# from my_module import calcCycle",
            "if __name__ == \"__main__\":",
            "\tN,K = map(int,input().split())",
            "\tP = np.array( input().split(), np.int64 )",
            "\tP -= 1",
            "\tC = np.array( input().split(), np.int64 )",
            "\t# 一度計算したサイクル情報を一応キャッシュしておく。。。",
            "\t# あんまり意味なさそう",
            "\tcycleIDs = np.full( N, -1, dtype=np.int64 )",
            "\tcycleItemCnts = np.full( N, -1, dtype=np.int64 )",
            "\tcycleTotalScores = np.full( N, -1, dtype=np.int64 )",
            "\tcalcCycle(N,K,P,C,cycleIDs,cycleItemCnts,cycleTotalScores)",
            "\t# print(cycleItemCnts)",
            "\tans = -1e18",
            "\tmain(ans,N,K,P,C,cycleIDs,cycleItemCnts,cycleTotalScores)",
            "\t#print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "content": [
            "import sys,bisect,string,math,time,functools,random,fractions",
            "from heapq import heappush,heappop,heapify",
            "from collections import deque,defaultdict,Counter",
            "from itertools import permutations,combinations,groupby",
            "rep=range;R=range",
            "def Golf():n,*t=map(int,open(0).read().split())",
            "def I():return int(input())",
            "def S_():return input()",
            "def IS():return input().split()",
            "def LS():return [i for i in input().split()]",
            "def MI():return map(int,input().split())",
            "def LI():return [int(i) for i in input().split()]",
            "def LI_():return [int(i)-1 for i in input().split()]",
            "def NI(n):return [int(input()) for i in range(n)]",
            "def NI_(n):return [int(input())-1 for i in range(n)]",
            "def StoLI():return [ord(i)-97 for i in input()]",
            "def ItoS(n):return chr(n+97)",
            "def LtoS(ls):return ''.join([chr(i+97) for i in ls])",
            "def RA():return map(int,open(0).read().split())",
            "def RLI(n=8,a=1,b=10):return [random.randint(a,b)for i in range(n)]",
            "def RI(a=1,b=10):return random.randint(a,b)",
            "def Rtest(T):",
            "    case,err=0,0",
            "    for i in range(T):",
            "        inp=INP()",
            "        a1,ls=naive(*inp)",
            "        a2=solve(*inp)",
            "        if a1!=a2:",
            "            print((a1,a2),inp)",
            "            err+=1",
            "        case+=1",
            "    print('Tested',case,'case with',err,'errors')",
            "def GI(V,E,ls=None,Directed=False,index=1):",
            "    org_inp=[];g=[[] for i in range(V)]",
            "    FromStdin=True if ls==None else False",
            "    for i in range(E):",
            "        if FromStdin:",
            "            inp=LI()",
            "            org_inp.append(inp)",
            "        else:",
            "            inp=ls[i]",
            "        if len(inp)==2:",
            "            a,b=inp;c=1",
            "        else:",
            "            a,b,c=inp",
            "        if index==1:a-=1;b-=1",
            "        aa=(a,c);bb=(b,c);g[a].append(bb)",
            "        if not Directed:g[b].append(aa)",
            "    return g,org_inp",
            "def GGI(h,w,search=None,replacement_of_found='.',mp_def={'#':1,'.':0},boundary=1):",
            "    #h,w,g,sg=GGI(h,w,search=['S','G'],replacement_of_found='.',mp_def={'#':1,'.':0},boundary=1) # sample usage",
            "    mp=[boundary]*(w+2);found={}",
            "    for i in R(h):",
            "        s=input()",
            "        for char in search:",
            "            if char in s:",
            "                found[char]=((i+1)*(w+2)+s.index(char)+1)",
            "                mp_def[char]=mp_def[replacement_of_found]",
            "        mp+=[boundary]+[mp_def[j] for j in s]+[boundary]",
            "    mp+=[boundary]*(w+2)",
            "    return h+2,w+2,mp,found",
            "def TI(n):return GI(n,n-1)",
            "def accum(ls):",
            "    rt=[0]",
            "    for i in ls:rt+=[rt[-1]+i]",
            "    return rt",
            "def bit_combination(n,base=2):",
            "    rt=[]",
            "    for tb in R(base**n):s=[tb//(base**bt)%base for bt in R(n)];rt+=[s]",
            "    return rt",
            "def gcd(x,y):",
            "    if y==0:return x",
            "    if x%y==0:return y",
            "    while x%y!=0:x,y=y,x%y",
            "    return y",
            "def YN(x):print(['NO','YES'][x])",
            "def Yn(x):print(['No','Yes'][x])",
            "def show(*inp,end='\\n'):",
            "    if show_flg:print(*inp,end=end)",
            "mo=10**9+7",
            "inf=float('inf')",
            "FourNb=[(-1,0),(1,0),(0,1),(0,-1)];EightNb=[(-1,0),(1,0),(0,1),(0,-1),(1,1),(-1,-1),(1,-1),(-1,1)];compas=dict(zip('WENS',FourNb));cursol=dict(zip('LRUD',FourNb))",
            "l_alp=string.ascii_lowercase",
            "#sys.setrecursionlimit(10**9)",
            "read=sys.stdin.buffer.read;readline=sys.stdin.buffer.readline;input=lambda:sys.stdin.readline().rstrip()",
            "show_flg=False",
            "show_flg=True",
            "ans=0",
            "h,w,k=LI()",
            "v=[[0]*(w+1) for i in range(h+1)]",
            "for i in rep(k):",
            "    a,b,x=LI()",
            "    v[a][b]=x",
            "dp=[[[0]*(w+1) for i in range(h+1)] for i in range(4)]",
            "for i in range(1,h+1):",
            "    for j in range(1,w+1):",
            "        up_max=max(dp[x][i-1][j]for x in range(4))",
            "        dp[0][i][j]=up_max",
            "        if v[i][j]!=0:",
            "            dp[1][i][j]=max(dp[1][i][j],up_max+v[i][j])",
            "        dp[0][i][j]=max(dp[0][i][j],dp[0][i][j-1])",
            "        for x in range(1,4)[::-1]:",
            "            dp[x][i][j]=max(dp[x][i][j],dp[x][i][j-1],dp[x-1][i][j-1]+v[i][j])",
            "ans=max([dp[x][h][w]for x in range(4)])",
            "print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            2,
            1,
            1,
            1,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "import sys,collections as cl,bisect as bs,heapq as hq",
            "sys.setrecursionlimit(100000)",
            "input = sys.stdin.readline",
            "mod = 10**9+7",
            "Max = sys.maxsize",
            "def l(): #intのlist",
            "    return list(map(int,input().split()))",
            "def m(): #複数文字",
            "    return map(int,input().split())",
            "def onem(): #Nとかの取得",
            "    return int(input())",
            "def s(x): #圧縮",
            "    a = []",
            "    if len(x) == 0:",
            "        return []",
            "    aa = x[0]",
            "    su = 1",
            "    for i in range(len(x)-1):",
            "        if aa != x[i+1]:",
            "            a.append([aa,su])",
            "            aa = x[i+1]",
            "            su = 1",
            "        else:",
            "            su += 1",
            "    a.append([aa,su])",
            "    return a",
            "def jo(x): #listをスペースごとに分ける",
            "    return \" \".join(map(str,x))",
            "def max2(x): #他のときもどうように作成可能",
            "    return max(map(max,x))",
            "def In(x,a): #aがリスト(sorted)",
            "    k = bs.bisect_left(a,x)",
            "    if k != len(a) and a[k] ==  x:",
            "        return True",
            "    else:",
            "        return False",
            "def pow_k(x, n):",
            "    ans = 1",
            "    while n:",
            "        if n % 2:",
            "            ans *= x",
            "        x *= x",
            "        n >>= 1",
            "    return ans",
            "\"\"\"",
            "def nibu(x,n,r):",
            "    ll = 0",
            "    rr = r",
            "    while True:",
            "        mid = (ll+rr)//2",
            "    if rr == mid:",
            "        return ll",
            "    if (ここに評価入れる):",
            "        rr = mid",
            "    else:",
            "        ll = mid+1",
            "\"\"\"",
            "r,c,k = m()",
            "item = [[0 for j in range(c)] for i in range(r)]",
            "for i in range(k):",
            "    R,C,V = m()",
            "    item[R-1][C-1] = V",
            "dp = [[0 for k in range(4)] for j in range(c)]",
            "dpo = [[0 for k in range(4)] for j in range(c)]",
            "for i in range(r):",
            "    for j in range(c):",
            "        if j == 0:",
            "            if item[i][j] != 0:",
            "                po = 0",
            "                for kk in range(4):",
            "                    po = max(po,dpo[j][kk])",
            "                for k in range(4):",
            "                    if k == 0:",
            "                        dp[j][k] = po",
            "                    elif k == 1:",
            "                        dp[j][k] = po + item[i][j]",
            "                    else:",
            "                        dp[j][k] = 0",
            "            else:",
            "                po = 0",
            "                for kk in range(4):",
            "                    po = max(po,dpo[j][kk])",
            "                for k in range(4):",
            "                    if k == 0:",
            "                        dp[j][k] = po",
            "                    else:",
            "                        dp[j][k] = 0",
            "        else:",
            "            if item[i][j] != 0:",
            "                po = 0",
            "                for kk in range(4):",
            "                    po = max(po,dpo[j][kk])",
            "                for k in range(4):",
            "                    if k == 0:",
            "                        dp[j][k] = max(dp[j-1][k],po)",
            "                    elif k == 1:",
            "                        dp[j][k] = max(dp[j-1][k],dp[j-1][0] + item[i][j],po + item[i][j])",
            "                    else:",
            "                        dp[j][k] = max(dp[j-1][k],dp[j-1][k-1] + item[i][j])",
            "            else:",
            "                po = 0",
            "                for kk in range(4):",
            "                    po = max(po,dpo[j][kk])",
            "                for k in range(4):",
            "                    if k == 0:",
            "                        dp[j][k] = max(dp[j-1][k],po)",
            "                    else:",
            "                        dp[j][k] = dp[j-1][k]",
            "    for j in range(c):",
            "        for k in range(4):",
            "            dpo[j][k] = dp[j][k]",
            "            dp[j][k] = 0",
            "ans = 0",
            "for i in range(4):",
            "    ans = max(ans,dpo[-1][i])",
            "print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            1,
            2
        ]
    },
    {
        "content": [
            "import sys",
            "sys.setrecursionlimit(10**7) #再帰関数の上限,10**5以上の場合python",
            "import math",
            "from copy import copy, deepcopy",
            "from copy import deepcopy as dcp",
            "from operator import itemgetter",
            "from bisect import bisect_left, bisect, bisect_right#2分探索",
            "#bisect_left(l,x), bisect(l,x)#aはソート済みである必要あり。aの中からx未満の要素数を返す。rightだと以下",
            "from collections import deque, defaultdict",
            "#deque(l), pop(), append(x), popleft(), appendleft(x)",
            "#q.rotate(n)で → にn回ローテート",
            "from collections import Counter#文字列を個数カウント辞書に、",
            "#S=Counter(l),S.most_common(x),S.keys(),S.values(),S.items()",
            "from itertools import accumulate,combinations,permutations,product#累積和",
            "#list(accumulate(l))",
            "from heapq import heapify,heappop,heappush",
            "#heapify(q),heappush(q,a),heappop(q) #q=heapify(q)としないこと、返り値はNone",
            "#import fractions#古いatcoderコンテストの場合GCDなどはここからimportする",
            "from functools import reduce,lru_cache#pypyでもうごく",
            "#@lru_cache(maxsize = None)#maxsizeは保存するデータ数の最大値、2**nが最も高効率",
            "from decimal import Decimal",
            "def input():",
            "    x=sys.stdin.readline()",
            "    return x[:-1] if x[-1]==\"\\n\" else x",
            "def printe(*x):print(\"## \",*x,file=sys.stderr)",
            "def printl(li): _=print(*li, sep=\"\\n\") if li else None",
            "def argsort(s, return_sorted=False):",
            "    inds=sorted(range(len(s)), key=lambda k: s[k])",
            "    if return_sorted: return inds, [s[i] for i in inds]",
            "    return inds",
            "def alp2num(c,cap=False): return ord(c)-97 if not cap else ord(c)-65",
            "def num2alp(i,cap=False): return chr(i+97) if not cap else chr(i+65)",
            "def matmat(A,B):",
            "    K,N,M=len(B),len(A),len(B[0])",
            "    return [[sum([(A[i][k]*B[k][j]) for k in range(K)]) for j in range(M)] for i in range(N)]",
            "def matvec(M,v):",
            "    N,size=len(v),len(M)",
            "    return [sum([M[i][j]*v[j] for j in range(N)]) for i in range(size)]",
            "def T(M):",
            "    n,m=len(M),len(M[0])",
            "    return [[M[j][i] for j in range(n)] for i in range(m)]",
            "def main():",
            "    mod = 1000000007",
            "    #w.sort(key=itemgetter(1),reverse=True)  #二個目の要素で降順並び替え",
            "    N = int(input())",
            "    s = input()",
            "    #N, K = map(int, input().split())",
            "    #A = tuple(map(int, input().split())) #1行ベクトル",
            "    #L = tuple(int(input()) for i in range(N)) #改行ベクトル",
            "    #S = tuple(tuple(map(int, input().split())) for i in range(N)) #改行行列",
            "    def bin(x): return format(x, 'b')",
            "    def bitcount(x): #xは64bit整数",
            "      x= x - ((x >> 1) & 0x5555555555555555)",
            "      x= (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)",
            "      x= (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f",
            "      x+= (x >> 8); x+= (x >> 16); x+= (x >> 32)",
            "      return x & 0x7f",
            "    @lru_cache(None)",
            "    def r(n):",
            "        if n==0:",
            "            return 0",
            "        bc=bitcount(n)",
            "        return r(n%bc)+1",
            "    mod=s.count(\"1\")",
            "    c1=0",
            "    c2=0",
            "    cur1=1%(mod+1)",
            "    if mod>1:",
            "        cur2=1%(mod-1)",
            "        for i in range(N):",
            "            if s[-1-i]==\"1\":",
            "                c1+=cur1",
            "                c1%=(mod+1)",
            "                c2+=cur2",
            "                c2%=(mod-1)",
            "            cur1=cur1*2%(mod+1)",
            "            cur2=cur2*2%(mod-1)",
            "    else:",
            "        for i in range(N):",
            "            if s[-1-i]==\"1\":",
            "                c1+=cur1",
            "                c1%=(mod+1)",
            "            cur1=cur1*2%(mod+1)",
            "    for i in range(N):",
            "        if s[i]==\"1\":",
            "            f=-1",
            "            cmod=mod-1",
            "        else:",
            "            f=1",
            "            cmod=mod+1",
            "        if cmod==0:",
            "            print(0)",
            "            continue",
            "        if f==1:",
            "            n=c1+pow(2,N-1-i,cmod)",
            "            n%=cmod",
            "        else:",
            "            n=c2-pow(2,N-1-i,cmod)",
            "            n%=cmod",
            "        print(1+r(n))",
            "    #printe(c1,c2)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "sys.setrecursionlimit(10**7) #再帰関数の上限,10**5以上の場合python",
            "import math",
            "from copy import copy, deepcopy",
            "from copy import deepcopy as dcp",
            "from operator import itemgetter",
            "from bisect import bisect_left, bisect, bisect_right#2分探索",
            "#bisect_left(l,x), bisect(l,x)#aはソート済みである必要あり。aの中からx未満の要素数を返す。rightだと以下",
            "from collections import deque, defaultdict",
            "#deque(l), pop(), append(x), popleft(), appendleft(x)",
            "#q.rotate(n)で → にn回ローテート",
            "from collections import Counter#文字列を個数カウント辞書に、",
            "#S=Counter(l),S.most_common(x),S.keys(),S.values(),S.items()",
            "from itertools import accumulate,combinations,permutations,product#累積和",
            "#list(accumulate(l))",
            "from heapq import heapify,heappop,heappush",
            "#heapify(q),heappush(q,a),heappop(q) #q=heapify(q)としないこと、返り値はNone",
            "#import fractions#古いatcoderコンテストの場合GCDなどはここからimportする",
            "from functools import reduce,lru_cache#pypyでもうごく",
            "#@lru_cache(maxsize = None)#maxsizeは保存するデータ数の最大値、2**nが最も高効率",
            "from decimal import Decimal",
            "def input():",
            "    x=sys.stdin.readline()",
            "    return x[:-1] if x[-1]==\"\\n\" else x",
            "def printe(*x):print(\"## \",*x,file=sys.stderr)",
            "def printl(li): _=print(*li, sep=\"\\n\") if li else None",
            "def argsort(s, return_sorted=False):",
            "    inds=sorted(range(len(s)), key=lambda k: s[k])",
            "    if return_sorted: return inds, [s[i] for i in inds]",
            "    return inds",
            "def alp2num(c,cap=False): return ord(c)-97 if not cap else ord(c)-65",
            "def num2alp(i,cap=False): return chr(i+97) if not cap else chr(i+65)",
            "def matmat(A,B):",
            "    K,N,M=len(B),len(A),len(B[0])",
            "    return [[sum([(A[i][k]*B[k][j]) for k in range(K)]) for j in range(M)] for i in range(N)]",
            "def matvec(M,v):",
            "    N,size=len(v),len(M)",
            "    return [sum([M[i][j]*v[j] for j in range(N)]) for i in range(size)]",
            "def T(M):",
            "    n,m=len(M),len(M[0])",
            "    return [[M[j][i] for j in range(n)] for i in range(m)]",
            "def main():",
            "    mod = 1000000007",
            "    #w.sort(key=itemgetter(1),reverse=True)  #二個目の要素で降順並び替え",
            "    N = int(input())",
            "    s = input()",
            "    #N, K = map(int, input().split())",
            "    #A = tuple(map(int, input().split())) #1行ベクトル",
            "    #L = tuple(int(input()) for i in range(N)) #改行ベクトル",
            "    #S = tuple(tuple(map(int, input().split())) for i in range(N)) #改行行列",
            "    def bin(x): return format(x, 'b')",
            "    def bitcount(x): return bin(x).count(\"1\")",
            "    #@lru_cache(None)",
            "    def r(n):",
            "        if n==0:",
            "            return 0",
            "        bc=bitcount(n)",
            "        return r(n%bc)+1",
            "    mod=s.count(\"1\")",
            "    c1=0",
            "    c2=0",
            "    cur1=1%(mod+1)",
            "    if mod>1:",
            "        cur2=1%(mod-1)",
            "        for i in range(N):",
            "            if s[-1-i]==\"1\":",
            "                c1+=cur1",
            "                c1%=(mod+1)",
            "                c2+=cur2",
            "                c2%=(mod-1)",
            "            cur1=cur1*2%(mod+1)",
            "            cur2=cur2*2%(mod-1)",
            "    else:",
            "        for i in range(N):",
            "            if s[-1-i]==\"1\":",
            "                c1+=cur1",
            "                c1%=(mod+1)",
            "            cur1=cur1*2%(mod+1)",
            "    for i in range(N):",
            "        if s[i]==\"1\":",
            "            f=-1",
            "            cmod=mod-1",
            "        else:",
            "            f=1",
            "            cmod=mod+1",
            "        if cmod==0:",
            "            print(0)",
            "            continue",
            "        if f==1:",
            "            n=c1+pow(2,N-1-i,cmod)",
            "            n%=cmod",
            "        else:",
            "            n=c2-pow(2,N-1-i,cmod)",
            "            n%=cmod",
            "        print(1+r(n))",
            "    #printe(c1,c2)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# ------------------- fast io --------------------",
            "import os",
            "import sys",
            "from io import BytesIO, IOBase",
            "BUFSIZE = 8192",
            "class FastIO(IOBase):",
            "    newlines = 0",
            "    def __init__(self, file):",
            "        self._fd = file.fileno()",
            "        self.buffer = BytesIO()",
            "        self.writable = \"x\" in file.mode or \"r\" not in file.mode",
            "        self.write = self.buffer.write if self.writable else None",
            "    def read(self):",
            "        while True:",
            "            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
            "            if not b:",
            "                break",
            "            ptr = self.buffer.tell()",
            "            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
            "        self.newlines = 0",
            "        return self.buffer.read()",
            "    def readline(self):",
            "        while self.newlines == 0:",
            "            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
            "            self.newlines = b.count(b\"\\n\") + (not b)",
            "            ptr = self.buffer.tell()",
            "            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
            "        self.newlines -= 1",
            "        return self.buffer.readline()",
            "    def flush(self):",
            "        if self.writable:",
            "            os.write(self._fd, self.buffer.getvalue())",
            "            self.buffer.truncate(0), self.buffer.seek(0)",
            "class IOWrapper(IOBase):",
            "    def __init__(self, file):",
            "        self.buffer = FastIO(file)",
            "        self.flush = self.buffer.flush",
            "        self.writable = self.buffer.writable",
            "        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))",
            "        self.read = lambda: self.buffer.read().decode(\"ascii\")",
            "        self.readline = lambda: self.buffer.readline().decode(\"ascii\")",
            "sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)",
            "input = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")",
            "# ------------------- fast io --------------------",
            "from math import gcd, ceil",
            "def pre(s):",
            "    n = len(s)",
            "    pi = [0] * n",
            "    for i in range(1, n):",
            "        j = pi[i - 1]",
            "        while j and s[i] != s[j]:",
            "            j = pi[j - 1]",
            "        if s[i] == s[j]:",
            "            j += 1",
            "        pi[i] = j",
            "    return pi",
            "def prod(a):",
            "    ans = 1",
            "    for each in a:",
            "        ans = (ans * each)",
            "    return ans",
            "def lcm(a, b): return a * b // gcd(a, b)",
            "def binary(x, length=16):",
            "    y = bin(x)[2:]",
            "    return y if len(y) >= length else \"0\" * (length - len(y)) + y",
            "for _ in range(int(input()) if not True else 1):",
            "    #n, k = map(int, input().split())",
            "    #a, b = map(int, input().split())",
            "    #c, d = map(int, input().split())",
            "    #a = list(map(int, input().split()))",
            "    #b = list(map(int, input().split()))",
            "    h, w, k = map(int, input().split())",
            "    a = []",
            "    for __ in range(h):",
            "        a += [[k for k in input()]]",
            "    ans = 0",
            "    for ch1 in range(2**h):",
            "        for ch2 in range(2**w):",
            "            rowchosen = binary(ch1, h)",
            "            colchosen = binary(ch2, w)",
            "            count = 0",
            "            for i in range(h):",
            "                for j in range(w):",
            "                    if rowchosen[i] != '1' and colchosen[j] != '1' and a[i][j] == '#':",
            "                        count += 1",
            "            if count == k:ans+=1",
            "    print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": [
            "from logging import *",
            "basicConfig(level=DEBUG, format='%(levelname)s: %(message)s')",
            "disable(CRITICAL)",
            "MOD = 10**9 + 7",
            "INF = MOD",
            "def mmul(a, b): return a*b%MOD",
            "n, k = map(int, input().split())",
            "A = [*map(int, input().split())]",
            "P, M = [], [] # plus, minus",
            "for a in A:",
            "    if a < 0: M.append(a)",
            "    else: P.append(a)",
            "debug('A {}'.format(sorted(A, reverse=True, key=lambda x:abs(x))))",
            "def mix():",
            "    len_p = len(P); len_m = len(M)",
            "    P.sort(reverse=True); M.sort()",
            "    P.append(-1); M.append( 1) # add endpoint",
            "    debug('P {}'.format(P));debug('M {}'.format(M))",
            "    pa, ma = [], []",
            "    while len(pa) + len(ma) < k:",
            "        if P[len(pa)] < -M[len(ma)]: ma.append(M[len(ma)])",
            "        else: pa.append(P[len(pa)])",
            "    debug('pa {}'.format(pa));debug('ma {}'.format(ma))",
            "    if len(ma)%2 == 0: return pa + ma",
            "    exist_pa = len(pa) > 0; exist_ma = len(ma) > 0",
            "    remain_p = len_p - len(pa) > 0; remain_m = len_m - len(ma) > 0",
            "    debug('exist_pa {}'.format(exist_pa));debug('exist_ma {}'.format(exist_ma))",
            "    debug('remain_p {}'.format(remain_p));debug('remain_m {}'.format(remain_m))",
            "    if exist_pa & exist_ma & remain_p & remain_m:",
            "        p_in = pa[-1]; p_out = P[len(pa)]",
            "        m_in = ma[-1]; m_out = M[len(ma)]",
            "        if abs(p_in*p_out) < abs(m_in*m_out): pa.pop(); ma.append(m_out)",
            "        else: ma.pop(); pa.append(p_out)",
            "        debug('pa {}'.format(pa));debug('ma {}'.format(ma))",
            "        return pa + ma",
            "    # if (not exist_pa) & exist_ma & remain_p & (not remain_m):",
            "    # if exist_ma & remain_p & (not remain_m):",
            "    if exist_ma & remain_p:",
            "        m_in = ma[-1]; p_out = P[len(pa)]",
            "        ma.pop(); pa.append(p_out)",
            "        debug('pa {}'.format(pa));debug('ma {}'.format(ma))",
            "        return pa + ma",
            "    # if exist_pa & (not exist_ma) & (not remain_p) & remain_m:",
            "    # if exist_pa & (not remain_p) & remain_m:",
            "    if exist_pa & remain_m:",
            "        p_in = pa[-1]; m_out = M[len(ma)]",
            "        pa.pop(); ma.append(m_out)",
            "        debug('pa {}'.format(pa));debug('ma {}'.format(ma))",
            "        return pa + ma",
            "    # --------------------------------",
            "    P.pop(); M.pop()",
            "    P.sort(); M.sort(reverse=True)",
            "    P.append(-1); M.append( 1) # add endpoint",
            "    debug('---')",
            "    debug('P {}'.format(P));debug('M {}'.format(M))",
            "    pa, ma = [], []",
            "    while len(pa) + len(ma) < k:",
            "        if P[len(pa)] >= -M[len(ma)]: ma.append(M[len(ma)])",
            "        else: pa.append(P[len(pa)])",
            "    debug('pa {}'.format(pa));debug('ma {}'.format(ma))",
            "    if len(ma)%2 == 1: return pa + ma",
            "    exist_pa = len(pa) > 0; exist_ma = len(ma) > 0",
            "    remain_p = len_p - len(pa) > 0; remain_m = len_m - len(ma) > 0",
            "    debug('exist_pa {}'.format(exist_pa));debug('exist_ma {}'.format(exist_ma))",
            "    debug('remain_p {}'.format(remain_p));debug('remain_m {}'.format(remain_m))",
            "    if exist_pa & exist_ma & remain_p & remain_m:",
            "        p_in = pa[-1]; p_out = P[len(pa)]",
            "        m_in = ma[-1]; m_out = M[len(ma)]",
            "        if abs(p_in*p_out) >= abs(m_in*m_out): pa.pop(); ma.append(m_out)",
            "        else: ma.pop(); pa.append(p_out)",
            "        debug('pa {}'.format(pa));debug('ma {}'.format(ma))",
            "        return pa + ma",
            "    # if (not exist_pa) & exist_ma & remain_p & (not remain_m):",
            "    if exist_ma & remain_p:",
            "        m_in = ma[-1]; p_out = P[len(pa)]",
            "        ma.pop(); pa.append(p_out)",
            "        debug('pa {}'.format(pa));debug('ma {}'.format(ma))",
            "        return pa + ma",
            "    # if exist_pa & (not exist_ma) & (not remain_p) & remain_m:",
            "    if exist_pa & remain_m:",
            "        p_in = pa[-1]; m_out = M[len(ma)]",
            "        pa.pop(); ma.append(m_out)",
            "        debug('pa {}'.format(pa));debug('ma {}'.format(ma))",
            "        return pa + ma",
            "    # return [0]",
            "    return pa + ma",
            "ans = 1",
            "if k==n:",
            "    debug('k==n: {} == {} '.format(k,n))",
            "    debug('A {}'.format(A))",
            "    for a in A: ans = mmul(ans, a)",
            "else:",
            "    debug('k<n: {} < {} '.format(k,n))",
            "    if len(P) == n:",
            "        debug('n({}) all plus({})'.format(n,len(P)))",
            "        P.sort(reverse=True)",
            "        debug('P[:k] {}'.format(P[:k]))",
            "        for a in P[:k]: ans = mmul(ans, a)",
            "    elif len(M) == n:",
            "        debug('n({}) all minus({})'.format(n,len(M)))",
            "        if k%2:",
            "            debug('k({}) is odd ({})'.format(k,k%2))",
            "            M.sort(reverse=True)",
            "        else:",
            "            debug('k({}) is even ({})'.format(k,k%2))",
            "            M.sort()",
            "        debug('M[:k] {}'.format(M[:k]))",
            "        for a in M[:k]: ans = mmul(ans, a)",
            "    else:",
            "        debug('n({}) mix plus({}):minus({})'.format(n,len(P),len(M)))",
            "        for a in mix(): ans = mmul(ans, a)",
            "ans += MOD; ans %= MOD",
            "debug('ans {}'.format(ans))",
            "print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "import sys",
            "def resolve(in_):",
            "    n, k = map(int, in_.readline().split())",
            "    a = list(map(int, in_.readline().split()))",
            "    mod = 10 ** 9 + 7",
            "    assert n == len(a)",
            "    # print(f'{n=} {k=} {len(a)=}')",
            "    m = sorted(filter(lambda x: x < 0, a))",
            "    p = sorted(filter(lambda x: x >= 0, a), reverse=True)",
            "    if len(p) == 0:",
            "        # print(f'{m=}')",
            "        if k % 2:",
            "            ans = m[-1] % mod",
            "            for v in m[-k:-1]:",
            "                v %= mod",
            "                ans *= v",
            "                ans %= mod",
            "            return ans",
            "        else:",
            "            ans = m[0] % mod",
            "            for v in m[1:k]:",
            "                v %= mod",
            "                ans *= v",
            "                ans %= mod",
            "            return ans",
            "    elif len(m) == 0:",
            "        ans = p[0] % mod",
            "        for v in p[1:k]:",
            "            v %= mod",
            "            ans *= v",
            "            ans %= mod",
            "        return ans",
            "    values = []",
            "    p_index = 0",
            "    m_index = 0",
            "    for _ in range(k):",
            "        if p_index < len(p) and m_index < len(m):",
            "            if p[p_index] >= abs(m[m_index]):",
            "                values.append(p[p_index])",
            "                p_index += 1",
            "            else:",
            "                values.append(m[m_index])",
            "                m_index += 1",
            "        elif p_index >= len(p):",
            "            values.append(m[m_index])",
            "            m_index += 1",
            "        elif m_index >= len(m):",
            "            values.append(p[p_index])",
            "            p_index += 1",
            "        else:",
            "            raise ValueError(f'{p_index=} {m_index=}')",
            "    # print(f'{values[:10]=} {p[:10]=} {m[:10]=}')",
            "    if any(v == 0 for v in values):",
            "        return 0",
            "    minus_values = sum(1 for v in values if v < 0)",
            "    # print(f'{minus_values > 0 and minus_values % 2=}')",
            "    if minus_values > 0 and minus_values % 2:",
            "        x = None",
            "        y = None",
            "        minus_max = max((value for value in values if value < 0), default=None)",
            "        plus_min = min((value for value in values if value >= 0), default=None)",
            "        if len(p) > p_index and minus_max:",
            "            # print(f'{p[p_index]=}')",
            "            x = abs(p[p_index] + minus_max)",
            "        if len(m) > m_index and plus_min:",
            "            # print(f'{m[m_index]=}')",
            "            y = abs(m[m_index] + plus_min)",
            "        # print(f'{x=} {y=} {minus_max=} {plus_min=}')",
            "        if x is None and y is None:",
            "            pass",
            "        elif x is None or y is None:",
            "            if x is None:",
            "                values.remove(plus_min)",
            "                values.append(m[m_index])",
            "            elif y is None:",
            "                values.remove(minus_max)",
            "                values.append(p[p_index])",
            "        else:",
            "            if x < y:",
            "                values.remove(minus_max)",
            "                values.append(p[p_index])",
            "            elif x > y:",
            "                values.remove(plus_min)",
            "                values.append(m[m_index])",
            "            elif abs(minus_max) < plus_min:",
            "                values.remove(plus_min)",
            "                values.append(m[m_index])",
            "            else:",
            "                values.remove(minus_max)",
            "                values.append(p[p_index])",
            "    ans = values[0] % mod",
            "    for v in values[1:k]:",
            "        v %= mod",
            "        ans *= v",
            "        ans %= mod",
            "    return ans",
            "def main():",
            "    answer = resolve(sys.stdin.buffer)",
            "    print(answer)",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "# encoding:utf-8",
            "import copy",
            "import random",
            "import bisect #bisect_left　これで二部探索の大小検索が行える",
            "import fractions #最小公倍数などはこっち",
            "import math",
            "import sys",
            "import collections",
            "from decimal import Decimal # 10進数で考慮できる",
            "mod = 10**9+7",
            "sys.setrecursionlimit(mod) # 再帰回数上限はでdefault1000",
            "d = collections.deque()",
            "def LI(): return list(map(int, sys.stdin.readline().split()))",
            "\"\"\"",
            "N, K = LI()",
            "A = LI()",
            "def abssort(A):",
            "    return sorted(A, key = lambda x:abs(x), reverse= True)",
            "tmps = []",
            "A_abs = abssort(A)",
            "cnt = 0",
            "while len(tmps) > K:",
            "# for i in range(K):",
            "    if A_abs[cnt] != 0:",
            "        tmps.append(A_abs[i])",
            "        cnt += 1",
            "cnt = 0",
            "for i in range(K):",
            "    if tmps[i] < 0:",
            "        cnt += 1",
            "if cnt % 2 == 0:",
            "    ans = 1",
            "    for i in range(K):",
            "        ans *= tmps[i]",
            "        ans = ans % mod",
            "    print(ans)",
            "    sys.exit()",
            "else:",
            "    tmp_1 = copy.deepcopy(tmps)",
            "    tmp_2 = copy.deepcopy(tmps)",
            "    tmp_1.reverse()",
            "    tmp_2.reverse()",
            "    tmp_2_ = 0",
            "    tmp_1_ = 0",
            "    # -を一つ消す",
            "    for i in range(K):",
            "        if tmp_1[i] < 0:",
            "            tmp_1.remove(tmp_1[i])",
            "            break",
            "    # + を一つたす",
            "    for i in range(K, N):",
            "        if A_abs[i] > 0:",
            "            tmp_1.append(A_abs[i])",
            "            tmp_1_ = 1",
            "            break",
            "    else:",
            "        # +がなかった時",
            "        tmp_1 = []",
            "        tmp_1_ = -1",
            "        A_abs.reverse()",
            "        for i in range(K):",
            "            tmp_1.append(A_abs[i])",
            "    # +を消して-を追加",
            "    cnt = 0",
            "    for i in range(K):",
            "        if tmp_2[i] > 0:",
            "            tmp_2.remove(tmp_2[i])",
            "            cnt += 1",
            "            break",
            "    if cnt == 1:",
            "        for i in range(K, N):",
            "            if A_abs[i] < 0:",
            "                tmp_2.append(A_abs[i])",
            "                tmp_2_ = 1",
            "                break",
            "        else:",
            "            tmp_2_ = 0",
            "    else:",
            "        tmp_2_ = -1",
            "# print(tmp_1, tmp_2)",
            "tmp_1_m = 1",
            "tmp_2_m = 1",
            "for i in range(K):",
            "    tmp_1_m *= tmp_1[i]",
            "    tmp_1_m = tmp_1_m % mod",
            "if tmp_2_ == 0:",
            "    pass",
            "else:",
            "    for i in range(K):",
            "        tmp_2_m *= tmp_2[i]",
            "        tmp_2_m = tmp_2_m % mod",
            "# print(tmp_1_, tmp_2_)",
            "if tmp_2_ == 0:",
            "    print(tmp_1_m)",
            "elif tmp_1_ == 1 and tmp_2_ == -1:",
            "    print(tmp_1_m)",
            "elif tmp_1_ == -1 and tmp_2_ == 1:",
            "    print(tmp_2_m)",
            "elif tmp_1_ == 1 and tmp_2_ == 1:",
            "    for i in range(K):",
            "        if tmp_1[i] == tmp_2[i]:",
            "            pass",
            "        elif abs(tmp_1[i]) > abs(tmp_2[i]):",
            "            print(tmp_2_m)",
            "            sys.exit()",
            "        else:",
            "            print(tmp_1_m)",
            "            sys.exit()",
            "else:",
            "    print(tmp_1_m)",
            "    # for i in range(K):",
            "    #     if tmp_1[i] == tmp_2[i]:",
            "    #         pass",
            "    #     elif abs(tmp_1[i]) > abs(tmp_2[i]):",
            "    #         print(tmp_2_m)",
            "    #         sys.exit()",
            "    #     else:",
            "    #         print(tmp_1_m)",
            "    #         sys.exit()",
            "    \"\"\"",
            "N,K = list(map(int, input().split()))",
            "A = list(map(int, input().split()))",
            "# 正負に関係なくsort",
            "A_abs = sorted(A, key = lambda x:abs(x))",
            "A_p = [] # plusを入れる",
            "A_n = [] # -を入れる",
            "for i in range(N):",
            "    if A[i] < 0:",
            "        A_n.append(A[i])",
            "    else:",
            "        A_p.append(A[i])",
            "A_n.sort()",
            "A_p.sort(reverse = True)",
            "ok = True",
            "if len(A_p) > 0:",
            "    # 正の数が存在している",
            "    if N == K:",
            "        # 選択肢がない時",
            "        ok = (len(A_n) % 2 == 0)",
            "        # 負の数が偶数個",
            "    else:",
            "        ok = True",
            "else:",
            "    ok = (K % 2 == 0)",
            "ans = 1",
            "if ok == False:",
            "    for i in range(K):",
            "        ans *= A_abs[i]",
            "        ans = ans % mod",
            "else:",
            "    if K % 2 == 1:",
            "        # 奇数個選ぶ",
            "        ans *= A_p[0]",
            "        ans = ans % mod",
            "        A_p = A_p[1:]",
            "    position = 0",
            "    pairs = []",
            "    cnt_p = len(A_p)",
            "    cnt_n = len(A_n)",
            "    while cnt_p - position > 1:",
            "        pairs.append(A_p[position] * A_p[position + 1])",
            "        position += 2",
            "    position = 0",
            "    while cnt_n - position > 1:",
            "        pairs.append(A_n[position] * A_n[position + 1])",
            "        position += 2",
            "    pairs.sort(reverse=True)",
            "    for i in range(K // 2):",
            "        ans *= pairs[i]",
            "        ans = ans % mod",
            "print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            2,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            2,
            1,
            0,
            0,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            2,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            2,
            2
        ]
    },
    {
        "content": [
            "# Contest No.: ABC173",
            "# Problem No.: E",
            "# Solver:      JEMINI",
            "# Date:        20200705",
            "import sys",
            "import heapq",
            "def main():",
            "    modVal = 10 ** 9 + 7",
            "    # parsing",
            "    n, k = map(int, sys.stdin.readline().split())",
            "    nums = list(map(int, sys.stdin.readline().split()))",
            "    # edge case; n == k",
            "    if n == k:",
            "        ans = 1",
            "        for i in nums:",
            "            ans *= i % modVal",
            "            ans %= modVal",
            "        print(ans % modVal)",
            "        return",
            "    # edge case; all neg",
            "    if max(nums) < 0:",
            "        nums.sort()",
            "        ans = 1",
            "        # odd k",
            "        if k % 2:",
            "            for i in range(k):",
            "                ans *= nums[-i - 1] % modVal",
            "                ans %= modVal",
            "        # even k",
            "        else:",
            "            for i in range(k):",
            "                ans *= nums[i] % modVal",
            "                ans %= modVal",
            "        print(ans % modVal)",
            "        return",
            "    # convert to absolute value & count zeros",
            "    absNums = []",
            "    zeroCnt = 0",
            "    for i in nums:",
            "        if i == 0:",
            "            zeroCnt += 1",
            "        else:",
            "            absNums.append([abs(i), i])",
            "    absNums.sort()  # sorted by absolute value",
            "    # edge case; non-zero cnt is less than k",
            "    if len(absNums) < k:",
            "        print(0)",
            "        return",
            "    # separate non-zero int to 4 sorted lists; all values are absolute value",
            "    posOverK = []",
            "    negOverK = []",
            "    posLessK = []",
            "    negLessK = []",
            "    for _ in range(k):",
            "        temp = absNums.pop()",
            "        if temp[1] > 0:",
            "            posOverK.append(temp[0])",
            "        else:",
            "            negOverK.append(temp[0])",
            "    while absNums:",
            "        temp = absNums.pop()",
            "        if temp[1] > 0:",
            "            posLessK.append(temp[0])",
            "        else:",
            "            negLessK.append(temp[0])",
            "    posOverK.sort()",
            "    negOverK.sort()",
            "    posLessK.sort()",
            "    negLessK.sort()",
            "    # odd negative numbers; if able, change to even",
            "    if len(negOverK) % 2:",
            "        minNeg = None",
            "        minPos = None",
            "        maxNeg = None",
            "        maxPos = None",
            "        if posOverK:",
            "            minPos = posOverK[0]",
            "        if negOverK:",
            "            minNeg = negOverK[0]",
            "        if posLessK:",
            "            maxPos = posLessK[-1]",
            "        if negLessK:",
            "            maxNeg = negLessK[-1]",
            "        # both case available; pos -> neg or neg -> pos",
            "        if (minNeg and maxPos) and (minPos and maxNeg):",
            "            # compare ratio",
            "            if maxPos * minPos > maxNeg * minNeg:",
            "                negOverK[0] = maxPos",
            "            else:",
            "                posOverK[0] = maxNeg",
            "        # one case available",
            "        elif not (minNeg and maxPos) and (minPos and maxNeg):",
            "            posOverK[0] = maxNeg",
            "        elif (minNeg and maxPos) and not (minPos and maxNeg):",
            "            negOverK[0] = maxPos",
            "        # unchangable, zero exists",
            "        elif zeroCnt > 0:",
            "            print(0)",
            "            return",
            "    # answer building",
            "    ans = 1",
            "    for i in posOverK:",
            "        ans *= i % modVal",
            "        ans = ans % modVal",
            "    for i in negOverK:",
            "        ans *= i % modVal",
            "        ans = ans % modVal",
            "    print(ans % modVal)",
            "    return",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            2,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "# Template 1.0",
            "import sys, re",
            "from collections import deque, defaultdict, Counter, OrderedDict",
            "from math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians",
            "from heapq import heappush, heappop, heapify, nlargest, nsmallest",
            "def STR(): return list(input())",
            "def INT(): return int(input())",
            "def MAP(): return map(int, input().split())",
            "def LIST(): return list(map(int, input().split()))",
            "def list2d(a, b, c): return [[c] * b for i in range(a)]",
            "def sortListWithIndex(listOfTuples, idx):   return (sorted(listOfTuples, key=lambda x: x[idx]))",
            "def sortDictWithVal(passedDic):",
            "    temp = sorted(passedDic.items(), key=lambda kv: (kv[1], kv[0]))",
            "    toret = {}",
            "    for tup in temp:",
            "        toret[tup[0]] = tup[1]",
            "    return toret",
            "def sortDictWithKey(passedDic):",
            "    return dict(OrderedDict(sorted(passedDic.items())))",
            "sys.setrecursionlimit(10 ** 9)",
            "INF = float('inf')",
            "mod = 10 ** 9 + 7",
            "n, k = MAP()",
            "a = LIST()",
            "pos = []",
            "neg = []",
            "zero = []",
            "for el in a:",
            "    if(el<0):",
            "        neg.append(el)",
            "    elif(el>0):",
            "        pos.append(el)",
            "    else:",
            "        zero.append(el)",
            "pos = sorted(pos)[::-1]",
            "neg = sorted(neg)[::-1]",
            "ans = 1",
            "if(k==n or k>len(pos)+len(neg)):",
            "    for el in a:",
            "        ans = (ans%mod*el%mod)%mod",
            "elif(len(pos)+len(neg)==k):",
            "    if(len(neg)%2!=0):",
            "        ans = 0",
            "    else:",
            "        for el in pos:",
            "            ans = (ans%mod*el%mod)%mod",
            "        for el in neg:",
            "            ans = (ans%mod*el%mod)%mod",
            "else:",
            "    if(len(pos)==0):",
            "        if(k%2==0):",
            "            temp = 0",
            "            for i in range(len(neg)-1, -1, -1):",
            "                if(temp==k):",
            "                    break",
            "                ans = (ans%mod*neg[i]%mod)%mod",
            "                temp+=1",
            "            if(temp<k):",
            "                ans = 0",
            "        else:",
            "            temp = 0",
            "            if(0 in a):",
            "                ans = 0",
            "            else:",
            "                for i in range(len(neg) - 1):",
            "                    if (temp == k):",
            "                        break",
            "                    ans = (ans%mod * neg[i]%mod) % mod",
            "                    temp += 1",
            "                if (temp < k):",
            "                    ans = 0",
            "    else:",
            "        left = k",
            "        i,j = 0, len(neg)-1",
            "        while(left>1):",
            "            temp, temp1 = 0, 0",
            "            if(i<len(pos)-1):",
            "                temp = pos[i]*pos[i+1]",
            "                # i+=2",
            "            if(j>=1):",
            "                temp1 = neg[j]*neg[j-1]",
            "                # j-=2",
            "            if(temp==0 and temp1==0):",
            "                break",
            "            if(temp1>temp):",
            "                ans = (ans*(temp1%mod))%mod",
            "                j-=2",
            "            else:",
            "                ans = (ans*(temp%mod))%mod",
            "                i+=2",
            "            left -= 2",
            "        # print(ans,i,j)",
            "        if(left>1):",
            "            ans = 0",
            "        elif(left==1):",
            "            if(i<len(pos)):",
            "                ans = ((ans%mod)*pos[i])%mod",
            "            else:",
            "                ans1 = 1",
            "                for b in range(i-1):",
            "                    ans1 = (ans1%mod*(pos[b]))%mod",
            "                for c in range(len(neg)-1, j-2,-1):",
            "                    ans1 = (ans1%mod*neg[c])%mod",
            "                ans = max(ans, ans1)",
            "        if(k%2!=0):",
            "            ans1 = 1",
            "            if(i-2>=0 and j-2>=-1 and i-2<=len(pos)-1 and j-2<=len(neg)-1):",
            "                for b in range(i-1):",
            "                    ans1 = (ans1%mod*(pos[b]))%mod",
            "                for c in range(len(neg)-1, j-2,-1):",
            "                    ans1 = (ans1%mod*neg[c])%mod",
            "            # print(ans, ans1)",
            "            ans = max(ans, ans1)",
            "print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "from collections import defaultdict, Counter",
            "from itertools import product, groupby, count, permutations, combinations",
            "from math import pi, sqrt",
            "from collections import deque",
            "from bisect import bisect, bisect_left, bisect_right",
            "from string import ascii_lowercase",
            "from functools import lru_cache",
            "import sys",
            "sys.setrecursionlimit(10000)",
            "INF = float(\"inf\")",
            "YES, Yes, yes, NO, No, no = \"YES\", \"Yes\", \"yes\", \"NO\", \"No\", \"no\"",
            "dy4, dx4 = [0, 1, 0, -1], [1, 0, -1, 0]",
            "dy8, dx8 = [0, -1, 0, 1, 1, -1, -1, 1], [1, 0, -1, 0, 1, 1, -1, -1]",
            "def inside(y, x, H, W):",
            "    return 0 <= y < H and 0 <= x < W",
            "def ceil(a, b):",
            "    return (a + b - 1) // b",
            "def sum_of_arithmetic_progression(s, d, n):",
            "    return n * (2 * s + (n - 1) * d) // 2",
            "def gcd(a, b):",
            "    if b == 0:",
            "        return a",
            "    return gcd(b, a % b)",
            "def lcm(a, b):",
            "    g = gcd(a, b)",
            "    return a / g * b",
            "def solve():",
            "    N, K = map(int, input().split())",
            "    A = list(map(int, input().split()))",
            "    MOD = 10**9 + 7",
            "    num_zero = 0",
            "    neg_list = []",
            "    pos_list = []",
            "    for a in A:",
            "        if a == 0:",
            "            num_zero += 1",
            "        elif a < 0:",
            "            neg_list.append(a)",
            "        else:",
            "            pos_list.append(a)",
            "    # 0にしかできない",
            "    if len(pos_list) + len(neg_list) < K:",
            "        print(0)",
            "    else:",
            "        min_num_neg = K - len(pos_list)",
            "        max_num_neg = min(K, len(neg_list))",
            "        # 負にしかできない",
            "        if min_num_neg == max_num_neg and min_num_neg % 2 == 1:",
            "            if num_zero > 0:",
            "                print(0)",
            "                return",
            "            ans = 1",
            "            neg_list.sort()",
            "            pos_list.sort(reverse=True)",
            "            for i in range(K):",
            "                use_pos = False",
            "                if len(neg_list) == 0 or len(pos_list) == 0:",
            "                    if len(neg_list) == 0:",
            "                        use_pos = True",
            "                    else:",
            "                        use_pos = False",
            "                elif abs(neg_list[-1]) < pos_list[-1]:",
            "                    use_pos = False",
            "                else:",
            "                    use_pos = True",
            "                if use_pos:",
            "                    ans *= pos_list[-1]",
            "                    pos_list.pop()",
            "                else:",
            "                    ans *= neg_list[-1]",
            "                    neg_list.pop()",
            "                ans %= MOD",
            "            print(ans)",
            "        else:",
            "            # 正にできる",
            "            ans = 1",
            "            neg_list.sort(reverse=True)",
            "            pos_list.sort()",
            "            if K % 2 == 1:",
            "                K -= 1",
            "                ans *= pos_list[-1]",
            "                pos_list.pop()",
            "            # posもnegも偶数個ずつ使う",
            "            for _ in range(0, K, 2):",
            "                use_pos = False",
            "                if len(neg_list) <= 1 or len(pos_list) <= 1:",
            "                    if len(neg_list) <= 1:",
            "                        use_pos = True",
            "                    else:",
            "                        use_pos = False",
            "                elif abs(neg_list[-1] * neg_list[-2]) > (pos_list[-1] * pos_list[-2]):",
            "                    use_pos = False",
            "                else:",
            "                    use_pos = True",
            "                if use_pos:",
            "                    ans *= pos_list[-1] * pos_list[-2]",
            "                    pos_list.pop()",
            "                    pos_list.pop()",
            "                else:",
            "                    ans *= neg_list[-1] * neg_list[-2]",
            "                    neg_list.pop()",
            "                    neg_list.pop()",
            "                ans %= MOD",
            "            print(ans)",
            "def main():",
            "    solve()",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "from heapq import *",
            "from collections import deque",
            "N,K,*A = map(int, open(0).read().split())",
            "pos = []",
            "zero = 0",
            "neg = []",
            "count = K",
            "m = 1000000007",
            "for x in A:",
            "    if x > 0:",
            "        pos.append(x)",
            "    elif x == 0:",
            "        zero += 1",
            "    else:",
            "        neg.append(x)",
            "if K == N:",
            "    ans = A[0] % m",
            "    for x in A[1:]:",
            "        ans = (ans*x) % m",
            "    print(ans)",
            "elif K % 2 == 1 and len(pos) == 0:",
            "    if zero > 0:",
            "        print(0)",
            "    else:",
            "        ai = [x * (-1) for x in A]",
            "        heapify(ai)",
            "        ans = (heappop(ai)*(-1)) % m",
            "        for i in range(K-1):",
            "            ans = (ans*heappop(ai)*(-1)) % m",
            "        print(ans)",
            "elif K > N - zero:",
            "    print(0)",
            "else:",
            "    heapify(neg)",
            "    ans = 1",
            "    negpos = []",
            "    for i in range(len(neg)//2):",
            "        temp = heappop(neg)",
            "        negpos.append(temp*heappop(neg))",
            "    dnp = deque(negpos)",
            "    posi = [x * (-1) for x in pos]",
            "    heapify(posi)",
            "    if len(posi) > 0:",
            "        t1 = heappop(posi) * (-1)",
            "    else:",
            "        t1 = 1",
            "    if len(posi) > 0:",
            "        t2 = heappop(posi) * (-1)",
            "    else:",
            "        t2 = 1",
            "    for i in range(K):",
            "        if count > 1:",
            "            if len(dnp) > 0:",
            "                if t1 > dnp[0]:",
            "                    if count > 2:",
            "                        ans = (ans*t1) % m",
            "                        t1 = t2",
            "                        if len(posi) > 0:",
            "                            t2 = heappop(posi) * (-1)",
            "                        else:",
            "                            t2 = 1",
            "                        count -= 1",
            "                    else:",
            "                        if t2 == 1 and len(posi) == 0:",
            "                            ans = (ans*dnp.popleft()) % m",
            "                            count -= 2",
            "                        else:",
            "                            ans = (ans*t1) % m",
            "                            t1 = t2",
            "                            if len(posi) > 0:",
            "                                t2 = heappop(posi) * (-1)",
            "                            else:",
            "                                t2 = 1",
            "                            count -= 1",
            "                else:",
            "                    if t1 * t2 > dnp[0]:",
            "                        if count != 3:",
            "                            ans = (ans*t1*t2) % m",
            "                            if len(posi) > 0:",
            "                                t1 = heappop(posi) * (-1)",
            "                            else:",
            "                                t1 = 1",
            "                            if len(posi) > 0:",
            "                                t2 = heappop(posi) * (-1)",
            "                            else:",
            "                                t2 = 1",
            "                            count -= 2",
            "                        else:",
            "                            if len(posi) > 0:",
            "                                t3 = heappop(posi) * (-1)",
            "                                M = max(t1*t2*t3,dnp[0]*t1)",
            "                                ans = (ans*M) % m",
            "                                break",
            "                            else:",
            "                                ans = (ans*dnp.popleft()*t1) % m",
            "                                break",
            "                    else:",
            "                        ans = (ans*dnp.popleft()) % m",
            "                        count -= 2",
            "            else:",
            "                ans = (ans*t1) % m",
            "                if len(posi) > 0:",
            "                    t1 = t2",
            "                    t2 = heappop(posi) * (-1)",
            "                else:",
            "                    t1 = t2",
            "                count -= 1",
            "        elif count == 1:",
            "            ans = (ans*t1) % m",
            "            break",
            "        else:",
            "            break",
            "    print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            2
        ]
    },
    {
        "content": [
            "## necessary imports",
            "import sys",
            "input = sys.stdin.readline",
            "# from math import ceil, floor, factorial;",
            "def ceil(x):",
            "    if x != int(x):",
            "        x = int(x) + 1;",
            "    return x;",
            "# swap_array function",
            "def swaparr(arr, a,b):",
            "    temp = arr[a];",
            "    arr[a] = arr[b];",
            "    arr[b] = temp",
            "## gcd function",
            "def gcd(a,b):",
            "    if b == 0:",
            "        return a",
            "    return gcd(b, a % b);",
            "## nCr function efficient using Binomial Cofficient",
            "def nCr(n, k):",
            "    if(k > n - k):",
            "        k = n - k",
            "    res = 1",
            "    for i in range(k):",
            "        res = res * (n - i)",
            "        res = res / (i + 1)",
            "    return int(res)",
            "## upper bound function code -- such that e in a[:i] e < x;",
            "def upper_bound(a, x, lo=0, hi = None):",
            "    if hi == None:",
            "        hi = len(a);",
            "    while lo < hi:",
            "        mid = (lo+hi)//2",
            "        if a[mid] < x:",
            "            lo = mid+1",
            "        else:",
            "            hi = mid",
            "    return lo",
            "## prime factorization",
            "def primefs(n):",
            "    ## if n == 1    ## calculating primes",
            "    primes = {}",
            "    while(n%2 == 0 and n > 0):",
            "        primes[2] = primes.get(2, 0) + 1",
            "        n = n//2",
            "    for i in range(3, int(n**0.5)+2, 2):",
            "        while(n%i == 0 and n > 0):",
            "            primes[i] = primes.get(i, 0) + 1",
            "            n = n//i",
            "    if n > 2:",
            "        primes[n] = primes.get(n, 0) + 1",
            "    ## prime factoriazation of n is stored in dictionary",
            "    ## primes and can be accesed. O(sqrt n)",
            "    return primes",
            "## MODULAR EXPONENTIATION FUNCTION",
            "def power(x, y, p):",
            "    res = 1",
            "    x = x % p",
            "    if (x == 0) :",
            "        return 0",
            "    while (y > 0) :",
            "        if ((y & 1) == 1) :",
            "            res = (res * x) % p",
            "        y = y >> 1",
            "        x = (x * x) % p",
            "    return res",
            "## DISJOINT SET UNINON FUNCTIONS",
            "def swap(a,b):",
            "    temp = a",
            "    a = b",
            "    b = temp",
            "    return a,b",
            "# find function with path compression included (recursive)",
            "# def find(x, link):",
            "#     if link[x] == x:",
            "#         return x",
            "#     link[x] = find(link[x], link);",
            "#     return link[x];",
            "# find function with path compression (ITERATIVE)",
            "def find(x, link):",
            "    p = x;",
            "    while( p != link[p]):",
            "        p = link[p];",
            "    while( x != p):",
            "        nex = link[x];",
            "        link[x] = p;",
            "        x = nex;",
            "    return p;",
            "# the union function which makes union(x,y)",
            "# of two nodes x and y",
            "def union(x, y, link, size):",
            "    x = find(x, link)",
            "    y = find(y, link)",
            "    if size[x] < size[y]:",
            "        x,y = swap(x,y)",
            "    if x != y:",
            "        size[x] += size[y]",
            "        link[y] = x",
            "## returns an array of boolean if primes or not USING SIEVE OF ERATOSTHANES",
            "def sieve(n):",
            "    prime = [True for i in range(n+1)]",
            "    p = 2",
            "    while (p * p <= n):",
            "        if (prime[p] == True):",
            "            for i in range(p * p, n+1, p):",
            "                prime[i] = False",
            "        p += 1",
            "    return prime",
            "#### PRIME FACTORIZATION IN O(log n) using Sieve ####",
            "MAXN = int(1e5 + 5)",
            "def spf_sieve():",
            "    spf[1] = 1;",
            "    for i in range(2, MAXN):",
            "        spf[i] = i;",
            "    for i in range(4, MAXN, 2):",
            "        spf[i] = 2;",
            "    for i in range(3, ceil(MAXN ** 0.5), 2):",
            "        if spf[i] == i:",
            "            for j in range(i*i, MAXN, i):",
            "                if spf[j] == j:",
            "                    spf[j] = i;",
            "    ## function for storing smallest prime factors (spf) in the array",
            "################## un-comment below 2 lines when using factorization #################",
            "# spf = [0 for i in range(MAXN)]",
            "# spf_sieve();",
            "def factoriazation(x):",
            "    ret = {};",
            "    while x != 1:",
            "        ret[spf[x]] = ret.get(spf[x], 0) + 1;",
            "        x = x//spf[x]",
            "    return ret",
            "    ## this function is useful for multiple queries only, o/w use",
            "    ## primefs function above. complexity O(log n)",
            "## taking integer array input",
            "def int_array():",
            "    return list(map(int, input().strip().split()))",
            "## taking string array input",
            "def str_array():",
            "    return input().strip().split();",
            "#defining a couple constants",
            "MOD = int(1e9)+7;",
            "CMOD = 998244353;",
            "INF = float('inf'); NINF = -float('inf');",
            "################### ---------------- TEMPLATE ENDS HERE ---------------- ###################",
            "n, k = int_array(); a = int_array();",
            "pos = []; neg = []; ans = 1;",
            "for i in a:",
            "    if i < 0:",
            "        neg.append(i);",
            "    else:",
            "        pos.append(i);",
            "if n == k:",
            "    for i in a:",
            "        ans = (ans * i) % MOD;",
            "elif not pos:",
            "    if k & 1:",
            "        neg.sort(reverse = 1);",
            "    else:",
            "        neg.sort();",
            "    for i in range(k):",
            "        ans = (ans * neg[i]) % MOD;",
            "else:",
            "    pos.sort(); neg.sort(reverse = 1);",
            "    if k & 1:",
            "        ans = pos.pop();",
            "    for _ in range(k // 2):",
            "        if len(pos) > 1 and len(neg) > 1:",
            "            if pos[-1] * pos[-2] >= neg[-1] * neg[-2]:",
            "                ans = (ans * pos.pop()) % MOD;",
            "                ans = (ans * pos.pop()) % MOD;",
            "            else:",
            "                ans = (ans * neg.pop()) % MOD;",
            "                ans = (ans * neg.pop()) % MOD;",
            "        elif len(pos) > 1:",
            "            ans = (ans * pos.pop()) % MOD;",
            "            ans = (ans * pos.pop()) % MOD;",
            "        else:",
            "            ans = (ans * neg.pop()) % MOD;",
            "            ans = (ans * neg.pop()) % MOD;",
            "print(ans);"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            2,
            2,
            1,
            0,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "import heapq",
            "MOD = 1000000007  # type: int",
            "def containPositive(arr):",
            "    for a in arr:",
            "        if a >= 0:",
            "            return True",
            "    return False",
            "def solve(N: int, K: int, A: \"List[int]\"):",
            "    if N == K:",
            "        m = 1",
            "        for a in A:",
            "            m = m*a%MOD",
            "        print(m)",
            "    elif not containPositive(A) and K%2 == 1:",
            "        A = list(reversed(sorted(A)))",
            "        m = 1",
            "        for i in range(K):",
            "            m = m*A[i]%MOD",
            "        print(m)",
            "    else:",
            "        m = 1",
            "        B = [(abs(a),a) for a in A]",
            "        B = list(reversed(sorted(B)))",
            "        lastNegative = 0",
            "        lastPositive = 1",
            "        hadPositive = False",
            "        for i in range(K):",
            "            a = B[i][1]",
            "            if a < 0:",
            "                if lastNegative == 0:",
            "                    lastNegative = a",
            "                else:",
            "                    m = m*lastNegative*a%MOD",
            "                    lastNegative = 0",
            "            else:",
            "                if a > 0 and lastPositive != 1:",
            "                    m = m*lastPositive%MOD",
            "                if a > 0:",
            "                    lastPositive = a",
            "                    hadPositive = True",
            "                else:",
            "                    m=m*a%MOD",
            "        if lastNegative == 0:",
            "            print(m*lastPositive%MOD)",
            "        else:",
            "            nextNegative = 0",
            "            for i in range(K,N):",
            "                b = B[i][1]",
            "                if b < 0:",
            "                    nextNegative = b",
            "                    break",
            "            if nextNegative == 0:",
            "                m = m*B[K][1]",
            "                print(m*lastPositive%MOD)",
            "            else:",
            "                c1 = lastNegative*nextNegative",
            "                nextPositive = 0",
            "                k = K",
            "                while k < N:",
            "                    a = B[k][1]",
            "                    if a >=0:",
            "                        nextPositive = a",
            "                        break",
            "                    k+=1",
            "                c2 = nextPositive*lastPositive",
            "                if not hadPositive: # This array contain some non-negative value. This means the result value could be positive. But if there were no positive values in the first K values sorted by the absolute value, use just next positive value instead of the last negative values.",
            "                    m = m*nextPositive%MOD",
            "                    print(m)",
            "                    exit()",
            "                if c1 > c2:",
            "                    m = m*lastNegative*nextNegative%MOD",
            "                    print(m)",
            "                else:",
            "                    m =m*nextPositive*lastPositive%MOD",
            "                    print(m)",
            "# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)",
            "def main():",
            "    def iterate_tokens():",
            "        for line in sys.stdin:",
            "            for word in line.split():",
            "                yield word",
            "    tokens = iterate_tokens()",
            "    N = int(next(tokens))  # type: int",
            "    K = int(next(tokens))  # type: int",
            "    A = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"",
            "    solve(N, K, A)",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            2,
            1,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "# でつoO(YOU PLAY WITH THE CARDS YOU'RE DEALT..)",
            "import sys",
            "MOD = 10**9 + 7",
            "def main(N, K, A):",
            "    neg = pos = zer = 0",
            "    for a in A:",
            "        if a < 0: neg += 1",
            "        elif a > 0: pos += 1",
            "        else: zer += 1",
            "    # print(neg, pos, zer, N - K)",
            "    if N - K < zer:",
            "        # ゼロになっちゃう",
            "        return 0",
            "    N -= zer",
            "    A = sorted([a for a in A if a != 0], key=lambda x: abs(x))",
            "    if (pos == 0 and K & 1) or (neg & 1 and N == K):",
            "        # マイナスになっちゃう",
            "        if zer:",
            "            # ゼロにもできるじゃん",
            "            return 0",
            "        else:",
            "            ans = Mint(1)",
            "            for i in range(K):",
            "                ans *= abs(A[i])",
            "            return -ans",
            "    # プラスにできる",
            "    A.reverse()",
            "    positives = []",
            "    negatives = []",
            "    # 絶対値の大きい方からK個取る",
            "    for i in range(K):",
            "        if A[i] > 0: positives.append(A[i])",
            "        else: negatives.append(A[i])",
            "    if len(negatives) & 1:",
            "        # マイナスになっちゃった",
            "        # マイナスを1手戻す",
            "        nn = [negatives.pop()]",
            "        pp = []",
            "        rem = 1",
            "        if positives:",
            "            # プラスも1手戻す",
            "            pp.append(positives.pop())",
            "            rem = 2",
            "        # 残りの人たちを探索",
            "        for i in range(K, N):",
            "            if A[i] < 0: nn.append(A[i])",
            "            else: pp.append(A[i])",
            "        # print(pp[:5])",
            "        # print(nn[:5])",
            "        if rem == 2:",
            "            # マイナスのペアかプラスのペアを作る",
            "            if len(nn) >= 2 and len(pp) < 2:",
            "                # マイナスのペアだけ作れる",
            "                negatives.append(nn[0])",
            "                negatives.append(nn[1])",
            "            elif len(pp) >= 2 and len(nn) < 2:",
            "                # プラスのペアだけ作れる",
            "                positives.append(pp[0])",
            "                positives.append(pp[1])",
            "            elif len(pp) >= 2 and len(nn) >= 2:",
            "                # どっちも作れるなら掛けて大きい方",
            "                if pp[0] * pp[1] > nn[0] * nn[1]:",
            "                    positives.append(pp[0])",
            "                    positives.append(pp[1])",
            "                else:",
            "                    negatives.append(nn[0])",
            "                    negatives.append(nn[1])",
            "            else:",
            "                # どっちも作れないなんてことはない",
            "                assert False",
            "        else:",
            "            # プラスをもう一つ選ぶ",
            "            positives.append(pp[0])",
            "    # 答えを計算",
            "    ans = Mint(1)",
            "    for p in positives:",
            "        ans *= p",
            "    for n in negatives:",
            "        ans *= abs(n)",
            "    return ans",
            "class Mint:",
            "    def __init__(self, value=0):",
            "        self.value = value % MOD",
            "        if self.value < 0: self.value += MOD",
            "    @staticmethod",
            "    def get_value(x): return x.value if isinstance(x, Mint) else x",
            "    def inverse(self):",
            "        a, b = self.value, MOD",
            "        u, v = 1, 0",
            "        while b:",
            "            t = a // b",
            "            b, a = a - t * b, b",
            "            v, u = u - t * v, v",
            "        if u < 0: u += MOD",
            "        return u",
            "    def __repr__(self): return str(self.value)",
            "    def __eq__(self, other): return self.value == other.value",
            "    def __neg__(self): return Mint(-self.value)",
            "    def __hash__(self): return hash(self.value)",
            "    def __bool__(self): return self.value != 0",
            "    def __iadd__(self, other):",
            "        self.value = (self.value + Mint.get_value(other)) % MOD",
            "        return self",
            "    def __add__(self, other):",
            "        new_obj = Mint(self.value)",
            "        new_obj += other",
            "        return new_obj",
            "    __radd__ = __add__",
            "    def __isub__(self, other):",
            "        self.value = (self.value - Mint.get_value(other)) % MOD",
            "        if self.value < 0: self.value += MOD",
            "        return self",
            "    def __sub__(self, other):",
            "        new_obj = Mint(self.value)",
            "        new_obj -= other",
            "        return new_obj",
            "    def __rsub__(self, other):",
            "        new_obj = Mint(Mint.get_value(other))",
            "        new_obj -= self",
            "        return new_obj",
            "    def __imul__(self, other):",
            "        self.value = self.value * Mint.get_value(other) % MOD",
            "        return self",
            "    def __mul__(self, other):",
            "        new_obj = Mint(self.value)",
            "        new_obj *= other",
            "        return new_obj",
            "    __rmul__ = __mul__",
            "    def __ifloordiv__(self, other):",
            "        other = other if isinstance(other, Mint) else Mint(other)",
            "        self *= other.inverse()",
            "        return self",
            "    def __floordiv__(self, other):",
            "        new_obj = Mint(self.value)",
            "        new_obj //= other",
            "        return new_obj",
            "    def __rfloordiv__(self, other):",
            "        new_obj = Mint(Mint.get_value(other))",
            "        new_obj //= self",
            "        return new_obj",
            "if __name__ == '__main__':",
            "    input = sys.stdin.readline",
            "    N, K = map(int, input().split())",
            "    *A, = map(int, input().split())",
            "    print(main(N, K, A))"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "#import sys",
            "#input = sys.stdin.readline",
            "Q = 10**9+7",
            "def main():",
            "    N, K = map( int, input().split())",
            "    A = list( map( int, input().split()))",
            "    if K == 1:",
            "        print(max(A))",
            "        return",
            "    positive = 0",
            "    zero = 0",
            "    negative = 0",
            "    for a in A:",
            "        if a > 0:",
            "            positive += 1",
            "        elif a == 0:",
            "            zero += 1",
            "        else:",
            "            negative += 1",
            "    # print(positive, negative, zero)",
            "    # print(positive+negative, K)",
            "    if positive+negative < K:",
            "        print(0)",
            "        return",
            "    if positive == 0:",
            "        if K%2 == 1:",
            "            if zero > 0:",
            "                print(0)",
            "                return",
            "            else:",
            "                A.sort(reverse=True)",
            "                ans = 1",
            "                for a in A[:K]:",
            "                    ans *= a",
            "                    ans %= Q",
            "                print(ans)",
            "                return",
            "        else:",
            "            A.sort()",
            "            ans = 1",
            "            for a in A[:K]:",
            "                ans *= a",
            "                ans %= Q",
            "            print(ans)",
            "            return",
            "    # if K == 2:",
            "    #     if negative <= 1:",
            "    #         A.sort(reverse=True)",
            "    #         print(A[0]*A[1]%Q)",
            "    #         return",
            "    if negative <= 1:",
            "        A.sort(reverse=True)",
            "        ans = 1",
            "        for a in A[:K]:",
            "            ans *= a",
            "            ans %= Q",
            "        print(ans)",
            "        return",
            "    if K == negative + positive:",
            "        if negative%2 == 1:",
            "            if zero > 0:",
            "                print(0)",
            "                return",
            "        ans = 1",
            "        for a in A:",
            "            if a != 0:",
            "                ans *= a",
            "                ans %= Q",
            "        print(ans)",
            "        return",
            "    B = [(abs(a), a) for a in A]",
            "    B.sort(reverse = True)",
            "    minus = False",
            "    minus_value = 0",
            "    plus_value = 0",
            "    ans = 1",
            "    for b in B[:K]:",
            "        ans *= b[0]",
            "        ans %= Q",
            "        if b[1] < 0:",
            "            minus = not minus",
            "            minus_value = b[0]",
            "        elif b[1] > 0:",
            "            plus_value = b[0]",
            "    # print(plus_value, minus_value)",
            "    if minus:",
            "        ans_plus = ans_minus = ans",
            "        plus_replaced_value = 0",
            "        minus_replaced_value = 0",
            "        if minus_value > 0:",
            "            for b in B[K:]:",
            "                if b[1] > 0:",
            "                    ans_plus = ans*pow(minus_value,Q-2,Q)%Q*b[0]%Q",
            "                    if plus_value == 0:",
            "                        plus_replaced_value = b[0]",
            "                    else:",
            "                        plus_replaced_value = plus_value*b[0]",
            "                    break",
            "        if plus_value > 0:",
            "            for b in B[K:]:",
            "                if b[1] < 0:",
            "                    ans_minus = ans*pow(plus_value,Q-2,Q)%Q*b[0]%Q",
            "                    if minus_value == 0:",
            "                        minus_replaced_value = b[0]",
            "                    else:",
            "                        minus_replaced_value = minus_value*b[0]",
            "                    break",
            "        if plus_replaced_value == 0 and minus_replaced_value == 0:",
            "            pass",
            "        elif plus_replaced_value < minus_replaced_value:",
            "            ans = ans_minus",
            "        else:",
            "            ans = ans_plus",
            "    # print(plus_replaced_value, minus_replaced_value)",
            "    # print(ans, ans_minus, ans_plus)",
            "    print(ans)",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "MOD = 1000000007  # type: int",
            "def solve(N: int, K: int, A: \"List[int]\"):",
            "    if N == K:",
            "        m = 1",
            "        for a in A:",
            "            m = m*a%MOD",
            "        print(m)",
            "    elif len(list(filter(lambda x: x>=0,A))) == 0 and K%2 == 1: # Can't be made positive, use from lower absolute value",
            "        A = list(reversed(sorted(A)))",
            "        m = 1",
            "        for i in range(K):",
            "            m = m*A[i]%MOD",
            "        print(m)",
            "    else: # We can make some combination to make positive result in this condition",
            "        m = 1",
            "        B = list(reversed(sorted([(abs(a),a) for a in A]))) # Make a sorted array with absolute value",
            "        lastNegative = 0",
            "        lastPositive = 1",
            "        hadPositive = False",
            "        for i in range(K): # Fill K elements with keeping the result positive.",
            "            a = B[i][1]",
            "            if a < 0:",
            "                if lastNegative == 0: # If got a negative value and there are no last negative value kept aside",
            "                    lastNegative = a # Keep this value aside and won't multiply to the result.",
            "                else: # If got a negative value and there are negative value aside last time the loop found negative value, just multiply these 2 values to mul and reset the kept value.",
            "                    m = m*lastNegative*a%MOD",
            "                    lastNegative = 0",
            "            else:",
            "                if a > 0: # If we got positive value, the value need to be kept aside for once to be swapped another negative value.",
            "                    if hadPositive: # If there is positive value kept aside before, multiply that value to the result",
            "                        m = m*lastPositive%MOD",
            "                    lastPositive = a # The newest value need to be kept aside",
            "                    hadPositive = True",
            "                else:",
            "                    m=m*a%MOD # Only for zero",
            "        if lastNegative == 0: # This assumes the result is already positive. No need to tweak. But need to multiply the last positive value",
            "            print(m*lastPositive%MOD)",
            "        else:",
            "            # Find next negative/positive value after Kth elements",
            "            nextNegative = 0",
            "            nextPositive = 0",
            "            for i in range(K,N):",
            "                b = B[i][1]",
            "                if b < 0:",
            "                    nextNegative = b",
            "                    break",
            "            for i in range(K,N):",
            "                a = B[i][1]",
            "                if a >=0:",
            "                    nextPositive = a",
            "                    break",
            "            if not hadPositive: # This array must contain some non-negative value. This means the result value could be positive. But if there were no positive values in the first K values sorted by the absolute value, use just next positive value instead of the last negative values.",
            "                print(m*nextPositive%MOD)",
            "            elif lastNegative*nextNegative > nextPositive*lastPositive:",
            "                print(m*lastNegative*nextNegative%MOD)",
            "            else:",
            "                print(m*nextPositive*lastPositive%MOD)",
            "# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)",
            "def main():",
            "    def iterate_tokens():",
            "        for line in sys.stdin:",
            "            for word in line.split():",
            "                yield word",
            "    tokens = iterate_tokens()",
            "    N = int(next(tokens))  # type: int",
            "    K = int(next(tokens))  # type: int",
            "    A = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"",
            "    solve(N, K, A)",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            1,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "# AFTER EDITORIAL, WIP",
            "def solve(ls, k, debug=0):",
            "    modulo = 10 ** 9 + 7",
            "    n = len(ls)",
            "    n_neg = 0",
            "    for i in range(n):",
            "        n_neg += ls[i] < 0",
            "    n_pos = n - n_neg",
            "    # Sort by abs",
            "    ls_abs = [abs(x) for x in ls]",
            "    ls_abs_argsort = sorted(list(range(n)), key=lambda i: -ls_abs[i])",
            "    # Check if positive result is impossible",
            "    if n_neg >= k:",
            "        positive = (k % 2 == 0) or (n_pos > 0)",
            "    else:",
            "        positive = (n_neg % 2 == 0) or (n > k)",
            "    # If positive is impossible, pick \"abs\" small ones",
            "    if not positive:",
            "        p = 1",
            "        for i in range(k):",
            "            x = ls[ls_abs_argsort[-1 - i]]",
            "            p *= x",
            "            p %= modulo",
            "        return p",
            "    #",
            "    # If positive is possible, ...",
            "    #",
            "    # PROP.",
            "    #   At most one swap is needed for making product non-negative.",
            "    #   PROOF. TODO",
            "    #",
            "    # Check sign when we pick \"abs\" large ones",
            "    s = 1",
            "    for i in range(k):",
            "        x = ls[ls_abs_argsort[i]]",
            "        s *= -1 if x < 0 else 1",
            "    # If non-negative, we take as it is",
            "    if s > 0:",
            "        p = 1",
            "        for i in range(k):",
            "            x = ls[ls_abs_argsort[i]]",
            "            p *= x",
            "            p %= modulo",
            "        return p",
            "    # If negative, ...",
            "    #   1. replace small negative with large positive, or",
            "    #   2. replace small positive with large negative",
            "    opt1 = None",
            "    opt2 = None",
            "    neg1 = pos1 = None",
            "    pos2 = neg2 = None",
            "    # Check if \"1\" is possible",
            "    swap_pos = None",
            "    for i in range(k, n):",
            "        if ls[ls_abs_argsort[i]] >= 0:",
            "            swap_pos = i",
            "            pos1 = ls[ls_abs_argsort[i]]",
            "            break",
            "    swap_neg = None",
            "    for i in range(k)[::-1]:",
            "        if ls[ls_abs_argsort[i]] < 0:",
            "            swap_neg = i",
            "            neg1 = ls[ls_abs_argsort[i]]",
            "            break",
            "    if swap_pos is not None and swap_neg is not None:",
            "        p = 1",
            "        p *= ls[ls_abs_argsort[swap_pos]]",
            "        p %= modulo",
            "        for i in range(k):",
            "            if i == swap_neg:",
            "                continue",
            "            x = ls[ls_abs_argsort[i]]",
            "            p *= x",
            "            p %= modulo",
            "        opt1 = p",
            "    # Check if \"2\" is possible",
            "    swap_pos = None",
            "    for i in range(k)[::-1]:",
            "        if ls[ls_abs_argsort[i]] >= 0:",
            "            swap_pos = i",
            "            pos2 = ls[ls_abs_argsort[i]]",
            "            break",
            "    swap_neg = None",
            "    for i in range(k, n):",
            "        if ls[ls_abs_argsort[i]] < 0:",
            "            swap_neg = i",
            "            neg2 = ls[ls_abs_argsort[i]]",
            "            break",
            "    if swap_pos is not None and swap_neg is not None:",
            "        p = 1",
            "        p *= ls[ls_abs_argsort[swap_neg]]",
            "        p %= modulo",
            "        for i in range(k):",
            "            if i == swap_pos:",
            "                continue",
            "            x = ls[ls_abs_argsort[i]]",
            "            p *= x",
            "            p %= modulo",
            "            opt2 = p",
            "    # Pick opt1 or opt2",
            "    if opt1 is None:",
            "        return opt2",
            "    if opt2 is None:",
            "        return opt1",
            "    if pos1 * pos2 > neg1 * neg2:",
            "        return opt1",
            "    return opt2",
            "def main(istr, ostr):",
            "    n, k = list(map(int, istr.readline().strip().split()))",
            "    ls = list(map(int, istr.readline().strip().split()))",
            "    result = solve(ls, k)",
            "    print(result, file=ostr)",
            "if __name__ == \"__main__\":",
            "    import sys",
            "    main(sys.stdin, sys.stdout)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "# ------------------- fast io --------------------",
            "import os",
            "import sys",
            "from io import BytesIO, IOBase",
            "BUFSIZE = 8192",
            "class FastIO(IOBase):",
            "    newlines = 0",
            "    def __init__(self, file):",
            "        self._fd = file.fileno()",
            "        self.buffer = BytesIO()",
            "        self.writable = \"x\" in file.mode or \"r\" not in file.mode",
            "        self.write = self.buffer.write if self.writable else None",
            "    def read(self):",
            "        while True:",
            "            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
            "            if not b:",
            "                break",
            "            ptr = self.buffer.tell()",
            "            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
            "        self.newlines = 0",
            "        return self.buffer.read()",
            "    def readline(self):",
            "        while self.newlines == 0:",
            "            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
            "            self.newlines = b.count(b\"\\n\") + (not b)",
            "            ptr = self.buffer.tell()",
            "            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
            "        self.newlines -= 1",
            "        return self.buffer.readline()",
            "    def flush(self):",
            "        if self.writable:",
            "            os.write(self._fd, self.buffer.getvalue())",
            "            self.buffer.truncate(0), self.buffer.seek(0)",
            "class IOWrapper(IOBase):",
            "    def __init__(self, file):",
            "        self.buffer = FastIO(file)",
            "        self.flush = self.buffer.flush",
            "        self.writable = self.buffer.writable",
            "        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))",
            "        self.read = lambda: self.buffer.read().decode(\"ascii\")",
            "        self.readline = lambda: self.buffer.readline().decode(\"ascii\")",
            "sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)",
            "input = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")",
            "# ------------------- fast io --------------------",
            "from math import gcd, ceil",
            "def pre(s):",
            "    n = len(s)",
            "    pi = [0] * n",
            "    for i in range(1, n):",
            "        j = pi[i - 1]",
            "        while j and s[i] != s[j]:",
            "            j = pi[j - 1]",
            "        if s[i] == s[j]:",
            "            j += 1",
            "        pi[i] = j",
            "    return pi",
            "def prod(a):",
            "    ans = 1",
            "    for each in a:",
            "        ans = (ans * each)",
            "    return ans",
            "def lcm(a, b): return a * b // gcd(a, b)",
            "def binary(x, length=16):",
            "    y = bin(x)[2:]",
            "    return y if len(y) >= length else \"0\" * (length - len(y)) + y",
            "for _ in range(int(input()) if not True else 1):",
            "    n, k = map(int, input().split())",
            "    #a, b = map(int, input().split())",
            "    #c, d = map(int, input().split())",
            "    a = list(map(int, input().split()))",
            "    di = {}",
            "    x = []",
            "    for i in a:",
            "        ab = abs(i)",
            "        x += [ab]",
            "        if ab not in di:",
            "            di[ab] = []",
            "        di[ab] += [1 if i>=0 else -1]",
            "    x = sorted(x, reverse=True)",
            "    signs = []",
            "    for each in x:",
            "        signs += [di[each].pop()]",
            "    cursign = 1",
            "    ans = 1",
            "    firstpos = -1",
            "    firstneg = 0",
            "    nextpos = None",
            "    nextneg = None",
            "    for i in range(k):",
            "        ans = (ans * x[i]) % (10**9+7)",
            "        cursign *= signs[i]",
            "        if signs[i] == 1:",
            "            firstpos = i",
            "        if signs[i] == -1:",
            "            firstneg = i",
            "    if cursign == 1:",
            "        print(ans)",
            "        quit()",
            "    for i in range(k, len(x)):",
            "        if signs[i] == 1 and nextpos is None:",
            "            nextpos = i",
            "        if signs[i] == -1 and nextneg is None:",
            "            nextneg = i",
            "    ansdex = [i for i in range(k)]",
            "    from math import inf",
            "    ans = ans*-1",
            "    #print(ans)",
            "    #print(nextpos)",
            "    ans1, ans2 = -10**18, -10**18",
            "    if nextpos is not None:",
            "        ansd = [i for i in range(k)]",
            "        ans22 = 1",
            "        ansd[firstneg] = nextpos",
            "        for each in ansd:",
            "            ans22 = (ans22 * x[each]) % (10**9+7)",
            "        ans2 = ans22",
            "    if nextneg is not None and firstpos != -1:",
            "        ansd = [i for i in range(k)]",
            "        ans22 = 1",
            "        ansd[firstpos] = nextneg",
            "        for each in ansd:",
            "            ans22 = (ans22 * x[each]) % (10 ** 9 + 7)",
            "        ans1 = ans22",
            "    if ans1 != -10**18 and ans2 != -10**18:",
            "        print(ans1 if x[nextneg]/x[firstpos] > x[nextpos]/x[firstneg] else ans2 if x[nextneg]/x[firstpos] < x[nextpos]/x[firstneg] else max(ans1, ans2))",
            "        quit()",
            "    if ans1 != -10**18 or ans2 != -10**18:",
            "        print(max(ans1, ans2))",
            "        quit()",
            "    a = sorted(a, reverse=True)",
            "    ans=1",
            "    for i in range(k):ans=(ans*(a[i])) % (10**9+7)",
            "    print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "content": [
            "# annealing is all you need",
            "# hyper parameter tune is all you need",
            "from time import time",
            "t0 = time()",
            "import sys",
            "sys.setrecursionlimit(1 << 25)",
            "read = sys.stdin.readline",
            "ra = range",
            "enu = enumerate",
            "def exit(*argv, **kwarg):",
            "    print(*argv, **kwarg)",
            "    sys.exit()",
            "def mina(*argv, sub=1): return list(map(lambda x: x - sub, argv))",
            "# 受け渡されたすべての要素からsubだけ引く.リストを*をつけて展開しておくこと",
            "def a_int(): return int(read())",
            "def ints(): return list(map(int, read().split()))",
            "def read_col(H):",
            "    '''H is number of rows",
            "    A列、B列が与えられるようなとき",
            "    ex1)A,B=read_col(H)    ex2) A,=read_col(H) #一列の場合'''",
            "    ret = []",
            "    for _ in range(H):",
            "        ret.append(list(map(int, read().split())))",
            "    return tuple(map(list, zip(*ret)))",
            "def read_tuple(H):",
            "    '''H is number of rows'''",
            "    ret = []",
            "    for _ in range(H):",
            "        ret.append(tuple(map(int, read().split())))",
            "    return ret",
            "MOD = 10**9 + 7",
            "INF = 2**31  # 2147483648 > 10**9",
            "# default import",
            "from itertools import product, permutations, combinations",
            "from bisect import bisect_left, bisect_right, insort_left",
            "from functools import reduce",
            "from random import randint, random",
            "from math import exp",
            "D = a_int()",
            "C = ints()",
            "S = read_tuple(D)",
            "def annealing(oldscore, newscore, T):",
            "    '''p(newscore-oldscore,T)=min(1,exp((newscore-oldscore)/T)) の確率でnewscoreを採用する",
            "    newが選ばれた時はTrueを返す'''",
            "    if oldscore < newscore:",
            "        return True",
            "    else:",
            "        p = exp((newscore - oldscore) / T)",
            "        return random() < p",
            "def T_to_date_by_contest(T):",
            "    '''Tを日付形式にしつつscoreも計算'''",
            "    date_by_contest = [[-1] for _ in range(26)]",
            "    for d, t in enumerate(T):",
            "        date_by_contest[t].append(d)",
            "    for i in range(26):",
            "        date_by_contest[i].append(D)  # 番兵",
            "    return date_by_contest",
            "def eval(D, C, S, date_by_contest):",
            "    '''2~3*D回のループでスコアを計算する'''",
            "    score = 0",
            "    for c, dates in enu(date_by_contest):",
            "        for d in dates[1:-1]:",
            "            score += S[d][c]",
            "        for i in range(len(dates) - 1):",
            "            dd = (dates[i + 1] - dates[i])",
            "            # for ddd in range(dd):",
            "            #     score -= C[c] * (ddd)",
            "            score -= C[c] * (dd - 1) * dd // 2",
            "    return score",
            "def maximizer(newT, bestT, bestscore):",
            "    '''具体的なTの最大化用'''",
            "    tmpscore = eval(D, C, S, T_to_date_by_contest(newT))",
            "    if tmpscore > bestscore:",
            "        return newT, tmpscore",
            "    else:",
            "        return bestT, bestscore",
            "def ret_init_T():",
            "    '''greedyで作ったTを初期値とする。",
            "    return",
            "    ----------",
            "    T, score ... 初期のTとそのTで得られるscore",
            "    '''",
            "    def _make_T(n_days):",
            "        # editorialよりd日目の改善は、改善せずにd+n_days経過したときの関数にしたほうが",
            "        # 最終的なスコアと相関があるんじゃない？",
            "        T = []",
            "        last = [-1] * 26",
            "        for d in range(D):",
            "            ma = -INF",
            "            for i in range(26):",
            "                tmp = S[d][i]",
            "                dd = d - last[i]",
            "                tmp += C[i] * (((dd + n_days + dd) * (n_days) // 2))",
            "                if tmp > ma:",
            "                    t = i",
            "                    ma = tmp",
            "            last[t] = d  # Tを選んだあとで決める",
            "            T.append(t)",
            "        return T",
            "    T = _make_T(2)",
            "    sco = eval(D, C, S, T_to_date_by_contest(T))",
            "    for i in range(3, 16):",
            "        T, sco = maximizer(_make_T(i), T, sco)",
            "    return T, sco",
            "class Schedule:",
            "    def __init__(self, T: list, date_by_contest, score: int):",
            "        self.T = T",
            "        self.date_by_contest = date_by_contest",
            "        self.score = score",
            "    def try_change_contest(self, d, j):",
            "        '''d日目をjに変更したときのscore'''",
            "        score = self.score",
            "        i = self.T[d]  # コンテストi→jに変化する",
            "        if i == j:",
            "            return score  # 変化しないので",
            "        score += S[d][j] - S[d][i]",
            "        # iの変化についてscoreを計算し直す",
            "        # d_i_idx = bisect_left(self.date_by_contest[i], d)  # iにおけるdのindex",
            "        d_i_idx = self.date_by_contest[i].index(d)  # iにおけるdのindex",
            "        dd = self.date_by_contest[i][d_i_idx + 1] - \\",
            "            self.date_by_contest[i][d_i_idx - 1]",
            "        score -= C[i] * (dd - 1) * dd // 2",
            "        dd = self.date_by_contest[i][d_i_idx + 1] - d",
            "        score += C[i] * (dd - 1) * dd // 2",
            "        dd = d - self.date_by_contest[i][d_i_idx - 1]",
            "        score += C[i] * (dd - 1) * dd // 2",
            "        # jの変化についてscoreを計算し直す",
            "        d_j_idx = bisect_left(self.date_by_contest[j], d)",
            "        dd = self.date_by_contest[j][d_j_idx] - \\",
            "            self.date_by_contest[j][d_j_idx - 1]",
            "        score += C[j] * (dd - 1) * dd // 2",
            "        dd = self.date_by_contest[j][d_j_idx] - d",
            "        score -= C[j] * (dd - 1) * dd // 2",
            "        dd = d - self.date_by_contest[j][d_j_idx - 1]",
            "        score -= C[j] * (dd - 1) * dd // 2",
            "        return score",
            "    def change_contest(self, d, j):",
            "        '''d日目をjに変更する'''",
            "        self.score = self.try_change_contest(d, j)",
            "        i = self.T[d]",
            "        self.T[d] = j",
            "        self.date_by_contest[i].remove(d)",
            "        insort_left(self.date_by_contest[j], d)",
            "def trial(sche, thre_p, days_near, Tt):",
            "    '''確率的にどちらかの操作を行ってよかったらScheduleを更新する",
            "    1.日付dとコンテストqをランダムに選びd日目に開催するコンテストのタイプをqに変更する",
            "    2.10日以内の点でコンテストを入れ替える",
            "    thre_pはどちらの行動を行うかを調節、days_nearは近さのパラメータ'''",
            "    if random() < thre_p:",
            "        # 一点更新",
            "        d = randint(0, D - 1)",
            "        q = randint(0, 25)",
            "        if annealing(sche.score, sche.try_change_contest(d, q), Tt):",
            "            sche.change_contest(d, q)",
            "        return sche  # 参照渡しだから変わらんけどね",
            "    else:",
            "        T = sche.T.copy()",
            "        i = randint(0, D - 2)",
            "        j = randint(i - days_near, i + days_near)",
            "        j = max(j, 0)",
            "        j = min(j, D - 1)",
            "        if i == j:",
            "            j += 1",
            "        T[i], T[j] = T[j], T[i]",
            "        new_score = eval(D, C, S, T_to_date_by_contest(T))",
            "        if annealing(sche.score, new_score, Tt):",
            "            return Schedule(T, T_to_date_by_contest(T), new_score)",
            "        else:",
            "            return sche",
            "bestT, bestscore = ret_init_T()",
            "sche = Schedule(bestT, T_to_date_by_contest(bestT), bestscore)",
            "T0 = 200",
            "T1 = 0.1",
            "TL = 1.915",
            "now = time()",
            "while now - t0 < TL:",
            "    Tt = (T0**((now - t0) / TL)) * (T1**(1 - (now - t0) / TL))",
            "    for _ in range(2000):",
            "        sche = trial(sche, 0.9, 20, Tt)",
            "    now = time()",
            "# print(sche.score)",
            "# print(score(D, C, S, T))",
            "print(*mina(*sche.T, sub=-1), sep='\\n')"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "import copy",
            "import random",
            "import sys",
            "import time",
            "from collections import deque",
            "t1 = time.time()",
            "readline = sys.stdin.buffer.readline",
            "global NN",
            "NN = 26",
            "def evaluate(D, C, S, out, k):",
            "    score = 0",
            "    last = [0 for _ in range(NN)]",
            "    for d in range(len(out)):",
            "        last[out[d]] = d + 1",
            "        for i in range(NN):",
            "            score -= (d + 1 - last[i]) * C[i]",
            "        score += S[d][out[d]]",
            "    for d in range(len(out), min(D, len(out) + k)):",
            "        for i in range(NN):",
            "            score -= (d + 1 - last[i]) * C[i]",
            "    return score",
            "def compute_score(D, C, S, out):",
            "    score = 0",
            "    last = [0 for _ in range(NN)]",
            "    for d in range(len(out)):",
            "        p = out[d]",
            "        last[p] = d + 1",
            "        last[out[d]] = d + 1",
            "        for i in range(NN):",
            "            score -= (d + 1 - last[i]) * C[i]",
            "        score += S[d][out[d]]",
            "    return score",
            "def solve(D, C, S, k):",
            "    out = deque()",
            "    for _ in range(D):",
            "        max_score = -10 ** 8",
            "        best_i = 0",
            "        for i in range(NN):",
            "            out.append(i)",
            "            score = evaluate(D, C, S, out, k)",
            "            if max_score < score:",
            "                max_score = score",
            "                best_i = i",
            "            out.pop()",
            "        out.append(best_i)",
            "    return out, score",
            "# 1箇所ランダムに変える",
            "def random_change(D, C, S, out, score):",
            "    new_out = copy.deepcopy(out)",
            "    d = random.randrange(0, D)",
            "    new_out[d] = random.randrange(0, NN)",
            "    new_score = compute_score(D, C, S, new_out)",
            "    if new_score > score:",
            "        score = new_score",
            "        out = new_out",
            "    return out, score",
            "def random_change0(D, C, S, out, score):",
            "    new_out = copy.deepcopy(out)",
            "    d = random.randrange(0, 10)",
            "    new_out[d] = random.randrange(0, NN)",
            "    new_score = compute_score(D, C, S, new_out)",
            "    if new_score > score:",
            "        score = new_score",
            "        out = new_out",
            "    return out, score",
            "# N箇所ランダムに変える",
            "def random_changeN(D, C, S, out, score, N):",
            "    new_out = copy.deepcopy(out)",
            "    for _ in range(N):",
            "        d = random.randrange(0, D)",
            "        new_out[d] = random.randrange(0, NN)",
            "    new_score = compute_score(D, C, S, new_out)",
            "    if new_score > score:",
            "        score = new_score",
            "        out = new_out",
            "    return out, score",
            "# 2つswap",
            "def random_swap2(D, C, S, out, score):",
            "    d1 = random.randrange(0, D - 1)",
            "    d2 = random.randrange(d1 + 1, min(d1 + 16, D))",
            "    new_out = copy.deepcopy(out)",
            "    new_out[d1], new_out[d2] = out[d2], out[d1]",
            "    new_score = compute_score(D, C, S, out)",
            "    if new_score > score:",
            "        score = new_score",
            "        out = new_out",
            "    return out, score",
            "# ３つswap",
            "def random_swap3(D, C, S, out, score):",
            "    d1 = random.randrange(0, D - 1)",
            "    d2 = random.randrange(d1 + 1, min(d1 + 8, D))",
            "    d3 = random.randrange(max(d1 - 8, 0), d1 + 1)",
            "    new_out = copy.deepcopy(out)",
            "    new_out[d1], new_out[d2], new_out[d3] = out[d2], out[d3], out[d1]",
            "    new_score = compute_score(D, C, S, out)",
            "    if new_score > score:",
            "        score = new_score",
            "        out = new_out",
            "    return out, score",
            "def random_swap0(D, C, S, out, score):",
            "    d1 = random.randrange(0, 6)",
            "    d2 = random.randrange(6, 13)",
            "    new_out = copy.deepcopy(out)",
            "    new_out[d1], new_out[d2] = out[d2], out[d1]",
            "    new_score = compute_score(D, C, S, out)",
            "    if new_score > score:",
            "        score = new_score",
            "        out = new_out",
            "    return out, score",
            "def main():",
            "    D = int(readline())",
            "    C = list(map(int, readline().split()))",
            "    S = [list(map(int, readline().split())) for _ in range(D)]",
            "    # ランダムな初期値",
            "    # out = [random.randrange(0, NN) for _ in range(D)]",
            "    # 貪欲法で初期値を決める",
            "    max_score = -10 ** 8",
            "    max_k = 0",
            "    for k in range(6):",
            "        out, score = solve(D, C, S, k)",
            "        if score > max_score:",
            "            max_score = score",
            "            max_out = out",
            "            max_k = k",
            "    # # local minimumを避けるため,outを少し変える",
            "    out = max_out",
            "    score = max_score",
            "    out, score = solve(D, C, S, max_k)",
            "    out[0] = random.randrange(NN)",
            "    for cnt in range(10 ** 10):",
            "        out, score = random_changeN(D, C, S, out, score, N=1)",
            "        out, score = random_swap3(D, C, S, out, score)",
            "        t2 = time.time()",
            "        if t2 - t1 > 1.85:",
            "            break",
            "    ans = [str(i + 1) for i in out]",
            "    print(\"\\n\".join(ans))",
            "main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "from sys import stdin",
            "input = stdin.readline",
            "from time import time",
            "from random import randint",
            "from copy import deepcopy",
            "start_time = time()",
            "def calcScore(t, s, c):",
            "    scores = [0]*26",
            "    lasts = [0]*26",
            "    for i in range(1, len(t)):",
            "        scores[t[i]] += s[i][t[i]]",
            "        dif = i - lasts[t[i]]",
            "        scores[t[i]] -= c[t[i]] * dif * (dif-1) // 2",
            "        lasts[t[i]] = i",
            "    for i in range(26):",
            "        dif = len(t) - lasts[i]",
            "        scores[i] -= c[i] * dif * (dif-1) // 2",
            "    return scores",
            "def greedy(c, s):",
            "    day_lim = len(s)",
            "    socres = [0]*26",
            "    t = [0]*day_lim",
            "    lasts = [0]*26",
            "    for i in range(1, day_lim):",
            "        pls = [v for v in socres]",
            "        mns = [v for v in socres]",
            "        for j in range(26):",
            "            pls[j] += s[i][j]",
            "            mns[j] -= c[j] * (i - lasts[j])",
            "        sum_mns = sum(mns)",
            "        pt = sum_mns - mns[0] + pls[0]",
            "        idx = 0",
            "        for j in range(1, 26):",
            "            tmp = sum_mns - mns[j] + pls[j]",
            "            if pt < tmp:",
            "                pt = tmp",
            "                idx = j",
            "        t[i] = idx",
            "        lasts[idx] = i",
            "        for j in range(26):",
            "            if j == idx:",
            "                socres[j] = pls[j]",
            "            else:",
            "                socres[j] = mns[j]",
            "    return socres, t",
            "def subGreedy(c, s, t, day):",
            "    day_lim = len(s)",
            "    socres = [0]*26",
            "    t = [0]*day_lim",
            "    lasts = [0]*26",
            "    for i in range(1, day_lim):",
            "        if day <= i:",
            "            pls = [v for v in socres]",
            "            mns = [v for v in socres]",
            "            for j in range(26):",
            "                pls[j] += s[i][j]",
            "                mns[j] -= c[j] * (i - lasts[j])",
            "            sum_mns = sum(mns)",
            "            pt = sum_mns - mns[0] + pls[0]",
            "            idx = 0",
            "            for j in range(1, 26):",
            "                tmp = sum_mns - mns[j] + pls[j]",
            "                if pt < tmp:",
            "                    pt = tmp",
            "                    idx = j",
            "            t[i] = idx",
            "            lasts[idx] = i",
            "            for j in range(26):",
            "                if j == idx:",
            "                    socres[j] = pls[j]",
            "                else:",
            "                    socres[j] = mns[j]",
            "        else:",
            "            scores[t[i]] += s[i][t[i]]",
            "            lasts[t[i]] = i",
            "            for j in range(26):",
            "                dif = i - lasts[j]",
            "                scores[j] -= c[j] * dif",
            "    return socres, t",
            "def shuffle(t):",
            "    rng = len(t)//2",
            "    for _ in range(50):",
            "        idx = randint(1, rng)",
            "        t[idx], t[idx+1] = t[idx+1], t[idx]",
            "    return t",
            "D = int(input())",
            "c = list(map(int, input().split()))",
            "s = [[0]*26 for _ in range(D+1)]",
            "for i in range(1, D+1):",
            "    s[i] = list(map(int, input().split()))",
            "scores, t = greedy(c, s)",
            "t = shuffle(t)",
            "scores = calcScore(t, s, c)",
            "sum_score = sum(scores)",
            "while time() - start_time < 1.86:",
            "    typ = randint(1, 100)",
            "    if typ <= 70:",
            "        for _ in range(100):",
            "            tmp_t = deepcopy(t)",
            "            tmp_t[randint(1, D)] = randint(0, 25)",
            "            tmp_scores = calcScore(tmp_t, s, c)",
            "            sum_tmp_score = sum(tmp_scores)",
            "            if sum_score < sum_tmp_score:",
            "                sum_score = sum_tmp_score",
            "                t = deepcopy(tmp_t)",
            "                scores = deepcopy(tmp_scores)",
            "    elif typ <= 97:",
            "        for _ in range(100):",
            "            tmp_t = deepcopy(t)",
            "            dist = randint(1, 15)",
            "            p = randint(1, D-dist)",
            "            q = p + dist",
            "            tmp_t[p], tmp_t[q] = tmp_t[q], tmp_t[p]",
            "            tmp_scores = calcScore(tmp_t, s, c)",
            "            sum_tmp_score = sum(tmp_scores)",
            "            if sum_score < sum_tmp_score:",
            "                sum_score = sum_tmp_score",
            "                t = deepcopy(tmp_t)",
            "                scores = deepcopy(tmp_scores)",
            "    elif typ <= 100:",
            "        tmp_t = deepcopy(t)",
            "        day = randint(D//4*3, D)",
            "        tmp_scores, tmp_t = subGreedy(c, s, tmp_t, day)",
            "        sum_tmp_score = sum(tmp_scores)",
            "        if sum_score < sum_tmp_score:",
            "            sum_score = sum_tmp_score",
            "            t = deepcopy(tmp_t)",
            "            scores = deepcopy(tmp_scores)",
            "for v in t[1:]:",
            "    print(v+1)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "from sys import stdin",
            "input = stdin.readline",
            "from time import time",
            "from random import randint",
            "from copy import deepcopy",
            "start_time = time()",
            "def calcScore(t, s, c):",
            "    scores = [0]*26",
            "    lasts = [0]*26",
            "    for i in range(1, len(t)):",
            "        scores[t[i]] += s[i][t[i]]",
            "        dif = i - lasts[t[i]]",
            "        scores[t[i]] -= c[t[i]] * dif * (dif-1) // 2",
            "        lasts[t[i]] = i",
            "    for i in range(26):",
            "        dif = len(t) - lasts[i]",
            "        scores[i] -= c[i] * dif * (dif-1) // 2",
            "    return scores",
            "def greedy(c, s):",
            "    day_lim = len(s)",
            "    socres = [0]*26",
            "    t = [0]*day_lim",
            "    lasts = [0]*26",
            "    for i in range(1, day_lim):",
            "        pls = [v for v in socres]",
            "        mns = [v for v in socres]",
            "        for j in range(26):",
            "            pls[j] += s[i][j]",
            "            mns[j] -= c[j] * (i - lasts[j])",
            "        sum_mns = sum(mns)",
            "        pt = sum_mns - mns[0] + pls[0]",
            "        idx = 0",
            "        for j in range(1, 26):",
            "            tmp = sum_mns - mns[j] + pls[j]",
            "            if pt < tmp:",
            "                pt = tmp",
            "                idx = j",
            "        t[i] = idx",
            "        lasts[idx] = i",
            "        for j in range(26):",
            "            if j == idx:",
            "                socres[j] = pls[j]",
            "            else:",
            "                socres[j] = mns[j]",
            "    return socres, t",
            "def subGreedy(c, s, t, day):",
            "    day_lim = len(s)",
            "    socres = [0]*26",
            "    t = [0]*day_lim",
            "    lasts = [0]*26",
            "    for i in range(1, day_lim):",
            "        if day <= i:",
            "            pls = [v for v in socres]",
            "            mns = [v for v in socres]",
            "            for j in range(26):",
            "                pls[j] += s[i][j]",
            "                mns[j] -= c[j] * (i - lasts[j])",
            "            sum_mns = sum(mns)",
            "            pt = sum_mns - mns[0] + pls[0]",
            "            idx = 0",
            "            for j in range(1, 26):",
            "                tmp = sum_mns - mns[j] + pls[j]",
            "                if pt < tmp:",
            "                    pt = tmp",
            "                    idx = j",
            "            t[i] = idx",
            "            lasts[idx] = i",
            "            for j in range(26):",
            "                if j == idx:",
            "                    socres[j] = pls[j]",
            "                else:",
            "                    socres[j] = mns[j]",
            "        else:",
            "            scores[t[i]] += s[i][t[i]]",
            "            lasts[t[i]] = i",
            "            for j in range(26):",
            "                dif = i - lasts[j]",
            "                scores[j] -= c[j] * dif",
            "    return socres, t",
            "D = int(input())",
            "c = list(map(int, input().split()))",
            "s = [[0]*26 for _ in range(D+1)]",
            "for i in range(1, D+1):",
            "    s[i] = list(map(int, input().split()))",
            "scores, t = greedy(c, s)",
            "sum_score = sum(scores)",
            "tm = time() - start_time",
            "while tm < 1.86:",
            "    typ = randint(1, 100)",
            "    if typ <= 40:",
            "        for _ in range(500):",
            "            tmp_t = deepcopy(t)",
            "            tmp_t[randint(1, D)] = randint(0, 25)",
            "            tmp_scores = calcScore(tmp_t, s, c)",
            "            sum_tmp_score = sum(tmp_scores)",
            "            if sum_score < sum_tmp_score or (tm < 1.0 and randint(1, 1000) <= 1):",
            "                sum_score = sum_tmp_score",
            "                t = deepcopy(tmp_t)",
            "                scores = deepcopy(tmp_scores)",
            "    elif typ <= 99:",
            "        for _ in range(100):",
            "            tmp_t = deepcopy(t)",
            "            dist = randint(1, 15)",
            "            p = randint(1, D-dist)",
            "            q = p + dist",
            "            tmp_t[p], tmp_t[q] = tmp_t[q], tmp_t[p]",
            "            tmp_scores = calcScore(tmp_t, s, c)",
            "            sum_tmp_score = sum(tmp_scores)",
            "            if sum_score < sum_tmp_score or (tm < 1.0 and randint(1, 200) <= 1):",
            "                sum_score = sum_tmp_score",
            "                t = deepcopy(tmp_t)",
            "                scores = deepcopy(tmp_scores)",
            "    elif typ <= 100:",
            "        tmp_t = deepcopy(t)",
            "        day = randint(D//4*3, D)",
            "        tmp_scores, tmp_t = subGreedy(c, s, tmp_t, day)",
            "        sum_tmp_score = sum(tmp_scores)",
            "        if sum_score < sum_tmp_score:",
            "            sum_score = sum_tmp_score",
            "            t = deepcopy(tmp_t)",
            "            scores = deepcopy(tmp_scores)",
            "    tm = time() - start_time",
            "for v in t[1:]:",
            "    print(v+1)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "import numpy as np",
            "from numba import njit",
            "@njit('(i8[:],)', cache=True)",
            "def solve(inp):",
            "    def bitree_sum(bit, t, i):",
            "        s = 0",
            "        while i > 0:",
            "            s += bit[t, i]",
            "            i ^= i & -i",
            "        return s",
            "    def bitree_add(bit, n, t, i, x):",
            "        while i <= n:",
            "            bit[t, i] += x",
            "            i += i & -i",
            "    def bitree_lower_bound(bit, n, d, t, x):",
            "        sum_ = 0",
            "        pos = 0",
            "        for i in range(d, -1, -1):",
            "            k = pos + (1 << i)",
            "            if k <= n and sum_ + bit[t, k] < x:",
            "                sum_ += bit[t, k]",
            "                pos += 1 << i",
            "        return pos + 1",
            "    def initial_score(d, ccc, sss):",
            "        bit_n = d + 3",
            "        bit = np.zeros((26, bit_n), dtype=np.int64)",
            "        INF = 10 ** 18",
            "        for t in range(26):",
            "            bitree_add(bit, bit_n, t, bit_n - 1, INF)",
            "        ttt = np.zeros(d, dtype=np.int64)",
            "        last = np.full(26, -1, dtype=np.int64)",
            "        score = 0",
            "        for i in range(d):",
            "            best_t = 0",
            "            best_diff = -INF",
            "            costs = ccc * (i - last)",
            "            costs_sum = costs.sum()",
            "            for t in range(26):",
            "                tmp_diff = sss[i, t] - costs_sum + costs[t]",
            "                if best_diff < tmp_diff:",
            "                    best_t = t",
            "                    best_diff = tmp_diff",
            "            ttt[i] = best_t",
            "            last[best_t] = i",
            "            score += best_diff",
            "            bitree_add(bit, bit_n, best_t, i + 2, 1)",
            "        return bit, score, ttt",
            "    def calculate_score(d, ccc, sss, ttt):",
            "        last = np.full(26, -1, dtype=np.int64)",
            "        score = 0",
            "        for i in range(d):",
            "            t = ttt[i]",
            "            last[t] = i",
            "            score += sss[i, t] - (ccc * (i - last)).sum()",
            "        return score",
            "    def pinpoint_change(bit, bit_n, bit_d, d, ccc, sss, ttt, permissible):",
            "        cd = np.random.randint(0, d)",
            "        ct = np.random.randint(0, 26)",
            "        while ttt[cd] == ct:",
            "            ct = np.random.randint(0, 26)",
            "        diff = 0",
            "        t = ttt[cd]",
            "        k = bitree_sum(bit, t, cd + 2)",
            "        c = bitree_lower_bound(bit, bit_n, bit_d, t, k - 1) - 2",
            "        e = bitree_lower_bound(bit, bit_n, bit_d, t, k + 1) - 2",
            "        b = ccc[t]",
            "        diff -= b * (cd - c) * (e - cd)",
            "        diff -= sss[cd, t]",
            "        k = bitree_sum(bit, ct, cd + 2)",
            "        c = bitree_lower_bound(bit, bit_n, bit_d, ct, k) - 2",
            "        e = bitree_lower_bound(bit, bit_n, bit_d, ct, k + 1) - 2",
            "        b = ccc[ct]",
            "        diff += b * (cd - c) * (e - cd)",
            "        diff += sss[cd, ct]",
            "        if diff > permissible:",
            "            bitree_add(bit, bit_n, t, cd + 2, -1)",
            "            bitree_add(bit, bit_n, ct, cd + 2, 1)",
            "            ttt[cd] = ct",
            "        else:",
            "            diff = 0",
            "        return diff",
            "    def swap_change(bit, bit_n, bit_d, d, ccc, sss, ttt, permissible):",
            "        cd1 = np.random.randint(0, d - 1)",
            "        cd2 = cd1 + 1",
            "        ct1 = ttt[cd1]",
            "        ct2 = ttt[cd2]",
            "        if ct1 == ct2:",
            "            return 0",
            "        diff = 0",
            "        k = bitree_sum(bit, ct1, cd1 + 2)",
            "        c = bitree_lower_bound(bit, bit_n, bit_d, ct1, k - 1) - 2",
            "        e = bitree_lower_bound(bit, bit_n, bit_d, ct1, k + 1) - 2",
            "        diff += ccc[ct1] * (e + c - cd1 - cd2)",
            "        k = bitree_sum(bit, ct2, cd2 + 2)",
            "        c = bitree_lower_bound(bit, bit_n, bit_d, ct2, k - 1) - 2",
            "        e = bitree_lower_bound(bit, bit_n, bit_d, ct2, k + 1) - 2",
            "        diff -= ccc[ct2] * (e + c - cd1 - cd2)",
            "        diff -= sss[cd1, ct1] + sss[cd2, ct2]",
            "        diff += sss[cd1, ct2] + sss[cd2, ct1]",
            "        if diff > permissible:",
            "            bitree_add(bit, bit_n, ct1, cd1 + 2, -1)",
            "            bitree_add(bit, bit_n, ct1, cd2 + 2, 1)",
            "            bitree_add(bit, bit_n, ct2, cd1 + 2, 1)",
            "            bitree_add(bit, bit_n, ct2, cd2 + 2, -1)",
            "            ttt[cd1] = ct2",
            "            ttt[cd2] = ct1",
            "        else:",
            "            diff = 0",
            "        return diff",
            "    d = inp[0]",
            "    ccc = inp[1:27]",
            "    sss = np.zeros((d, 26), dtype=np.int64)",
            "    for r in range(d):",
            "        sss[r] = inp[27 + r * 26:27 + (r + 1) * 26]",
            "    bit, score, ttt = initial_score(d, ccc, sss)",
            "    bit_n = d + 3",
            "    bit_d = int(np.log2(bit_n))",
            "    loop = 4 * 10 ** 6",
            "    permissible_min = -3000.0",
            "    method_border = 0.5",
            "    best_score = score",
            "    best_ttt = ttt.copy()",
            "    for lp in range(loop):",
            "        permissible = (1 - lp / loop) * permissible_min",
            "        if np.random.random() < method_border:",
            "            diff = pinpoint_change(bit, bit_n, bit_d, d, ccc, sss, ttt, permissible)",
            "        else:",
            "            diff = swap_change(bit, bit_n, bit_d, d, ccc, sss, ttt, permissible)",
            "        score += diff",
            "        # print(lp, score, calculate_score(d, ccc, sss, ttt))",
            "        if score > best_score:",
            "            best_score = score",
            "            best_ttt = ttt.copy()",
            "    return best_ttt + 1",
            "inp = np.fromstring(sys.stdin.read(), dtype=np.int64, sep=' ')",
            "ans = solve(inp)",
            "print('\\n'.join(map(str, ans)))"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "import sys",
            "import numpy as np",
            "from numba import njit",
            "@njit('(i8[:],)', cache=True)",
            "def solve(inp):",
            "    def bitree_sum(bit, t, i):",
            "        s = 0",
            "        while i > 0:",
            "            s += bit[t, i]",
            "            i ^= i & -i",
            "        return s",
            "    def bitree_add(bit, n, t, i, x):",
            "        while i <= n:",
            "            bit[t, i] += x",
            "            i += i & -i",
            "    def bitree_lower_bound(bit, n, d, t, x):",
            "        sum_ = 0",
            "        pos = 0",
            "        for i in range(d, -1, -1):",
            "            k = pos + (1 << i)",
            "            if k <= n and sum_ + bit[t, k] < x:",
            "                sum_ += bit[t, k]",
            "                pos += 1 << i",
            "        return pos + 1",
            "    def initial_score(d, ccc, sss):",
            "        bit_n = d + 3",
            "        bit = np.zeros((26, bit_n), dtype=np.int64)",
            "        INF = 10 ** 18",
            "        for t in range(26):",
            "            bitree_add(bit, bit_n, t, bit_n - 1, INF)",
            "        ttt = np.zeros(d, dtype=np.int64)",
            "        last = np.full(26, -1, dtype=np.int64)",
            "        score = 0",
            "        for i in range(d):",
            "            best_t = 0",
            "            best_diff = -INF",
            "            costs = ccc * (i - last)",
            "            costs_sum = costs.sum()",
            "            for t in range(26):",
            "                tmp_diff = sss[i, t] - costs_sum + costs[t]",
            "                if best_diff < tmp_diff:",
            "                    best_t = t",
            "                    best_diff = tmp_diff",
            "            ttt[i] = best_t",
            "            last[best_t] = i",
            "            score += best_diff",
            "            bitree_add(bit, bit_n, best_t, i + 2, 1)",
            "        return bit, score, ttt",
            "    def calculate_score(d, ccc, sss, ttt):",
            "        last = np.full(26, -1, dtype=np.int64)",
            "        score = 0",
            "        for i in range(d):",
            "            t = ttt[i]",
            "            last[t] = i",
            "            score += sss[i, t] - (ccc * (i - last)).sum()",
            "        return score",
            "    def update_score(bit, bit_n, bit_d, ccc, sss, ttt, d, q):",
            "        diff = 0",
            "        t = ttt[d]",
            "        k = bitree_sum(bit, t, d + 2)",
            "        c = bitree_lower_bound(bit, bit_n, bit_d, t, k - 1) - 2",
            "        e = bitree_lower_bound(bit, bit_n, bit_d, t, k + 1) - 2",
            "        b = ccc[t]",
            "        diff -= b * (d - c) * (e - d)",
            "        diff -= sss[d, t]",
            "        k = bitree_sum(bit, q, d + 2)",
            "        c = bitree_lower_bound(bit, bit_n, bit_d, q, k) - 2",
            "        e = bitree_lower_bound(bit, bit_n, bit_d, q, k + 1) - 2",
            "        b = ccc[q]",
            "        diff += b * (d - c) * (e - d)",
            "        diff += sss[d, q]",
            "        return diff",
            "    d = inp[0]",
            "    ccc = inp[1:27]",
            "    sss = np.zeros((d, 26), dtype=np.int64)",
            "    for r in range(d):",
            "        sss[r] = inp[27 + r * 26:27 + (r + 1) * 26]",
            "    bit, score, ttt = initial_score(d, ccc, sss)",
            "    bit_n = d + 3",
            "    bit_d = int(np.log2(bit_n))",
            "    loop = 6 * 10 ** 6",
            "    tolerant_min = -3000.0",
            "    best_score = score",
            "    best_ttt = ttt.copy()",
            "    for lp in range(loop):",
            "        cd = np.random.randint(0, d)",
            "        ct = np.random.randint(0, 26)",
            "        while ttt[cd] == ct:",
            "            ct = np.random.randint(0, 26)",
            "        diff = update_score(bit, bit_n, bit_d, ccc, sss, ttt, cd, ct)",
            "        progress = lp / loop",
            "        if diff > (1 - progress) * tolerant_min:",
            "            score += diff",
            "            bitree_add(bit, bit_n, ttt[cd], cd + 2, -1)",
            "            bitree_add(bit, bit_n, ct, cd + 2, 1)",
            "            ttt[cd] = ct",
            "        if score > best_score:",
            "            best_score = score",
            "            best_ttt = ttt.copy()",
            "    return best_ttt + 1",
            "inp = np.fromstring(sys.stdin.read(), dtype=np.int64, sep=' ')",
            "ans = solve(inp)",
            "print('\\n'.join(map(str, ans)))"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "import sys",
            "input = sys.stdin.readline",
            "sys.setrecursionlimit(10 ** 7)",
            "from time import time",
            "from random import randint",
            "from copy import deepcopy",
            "start_time = time()",
            "def calcScore(t, s, c):",
            "    scores = [0]*26",
            "    lasts = [0]*26",
            "    for i in range(1, len(t)):",
            "        scores[t[i]] += s[i][t[i]]",
            "        dif = i - lasts[t[i]]",
            "        scores[t[i]] -= c[t[i]] * dif * (dif-1) // 2",
            "        lasts[t[i]] = i",
            "    for i in range(26):",
            "        dif = len(t) - lasts[i]",
            "        scores[i] -= c[i] * dif * (dif-1) // 2",
            "    return scores",
            "def greedy(c, s):",
            "    day_lim = len(s)",
            "    socres = [0]*26",
            "    t = [0]*day_lim",
            "    lasts = [0]*26",
            "    for i in range(1, day_lim):",
            "        pls = [v for v in socres]",
            "        mns = [v for v in socres]",
            "        for j in range(26):",
            "            pls[j] += s[i][j]",
            "            mns[j] -= c[j] * (i - lasts[j])",
            "        sum_mns = sum(mns)",
            "        pt = sum_mns - mns[0] + pls[0]",
            "        idx = 0",
            "        for j in range(1, 26):",
            "            tmp = sum_mns - mns[j] + pls[j]",
            "            if pt < tmp:",
            "                pt = tmp",
            "                idx = j",
            "        t[i] = idx",
            "        lasts[idx] = i",
            "        for j in range(26):",
            "            if j == idx:",
            "                socres[j] = pls[j]",
            "            else:",
            "                socres[j] = mns[j]",
            "    return socres, t",
            "def subGreedy(c, s, t, day):",
            "    day_lim = len(s)",
            "    socres = [0]*26",
            "    t = [0]*day_lim",
            "    lasts = [0]*26",
            "    for i in range(1, day_lim):",
            "        if day <= i:",
            "            pls = [v for v in socres]",
            "            mns = [v for v in socres]",
            "            for j in range(26):",
            "                pls[j] += s[i][j]",
            "                mns[j] -= c[j] * (i - lasts[j])",
            "            sum_mns = sum(mns)",
            "            pt = sum_mns - mns[0] + pls[0]",
            "            idx = 0",
            "            for j in range(1, 26):",
            "                tmp = sum_mns - mns[j] + pls[j]",
            "                if pt < tmp:",
            "                    pt = tmp",
            "                    idx = j",
            "            t[i] = idx",
            "            lasts[idx] = i",
            "            for j in range(26):",
            "                if j == idx:",
            "                    socres[j] = pls[j]",
            "                else:",
            "                    socres[j] = mns[j]",
            "        else:",
            "            scores[t[i]] += s[i][t[i]]",
            "            lasts[t[i]] = i",
            "            for j in range(26):",
            "                dif = i - lasts[j]",
            "                scores[j] -= c[j] * dif",
            "    return socres, t",
            "D = int(input())",
            "c = list(map(int, input().split()))",
            "s = [[0]*26 for _ in range(D+1)]",
            "for i in range(1, D+1):",
            "    s[i] = list(map(int, input().split()))",
            "scores, t = greedy(c, s)",
            "sum_score = sum(scores)",
            "while time() - start_time < 1.86:",
            "    typ = randint(1, 90)",
            "    if typ <= 70:",
            "        for _ in range(100):",
            "            tmp_t = deepcopy(t)",
            "            tmp_t[randint(1, D)] = randint(0, 25)",
            "            tmp_scores = calcScore(tmp_t, s, c)",
            "            sum_tmp_score = sum(tmp_scores)",
            "            if sum_score < sum_tmp_score:",
            "                sum_score = sum_tmp_score",
            "                t = deepcopy(tmp_t)",
            "                scores = deepcopy(tmp_scores)",
            "    elif typ <= 90:",
            "        for _ in range(30):",
            "            tmp_t = deepcopy(t)",
            "            dist = randint(1, 20)",
            "            p = randint(1, D-dist)",
            "            q = p + dist",
            "            tmp_t[p], tmp_t[q] = tmp_t[q], tmp_t[p]",
            "            tmp_scores = calcScore(tmp_t, s, c)",
            "            sum_tmp_score = sum(tmp_scores)",
            "            if sum_score < sum_tmp_score:",
            "                sum_score = sum_tmp_score",
            "                t = deepcopy(tmp_t)",
            "                scores = deepcopy(tmp_scores)",
            "    elif typ <= 100:",
            "        tmp_t = deepcopy(t)",
            "        day = randint(D//4*3, D)",
            "        tmp_scores, tmp_t = subGreedy(c, s, tmp_t, day)",
            "        sum_tmp_score = sum(tmp_scores)",
            "        if sum_score < sum_tmp_score:",
            "            sum_score = sum_tmp_score",
            "            t = tmp_t",
            "            scores = tmp_scores",
            "for v in t[1:]:",
            "    print(v+1)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import time",
            "START = time.time()",
            "import random",
            "import sys",
            "input = sys.stdin.readline",
            "Days = int(input())",
            "C = list(map(int, input().split())) # 満足度低下",
            "Ss = [list(map(int, input().split())) for _ in range(Days)]",
            "# Ss[d][i]: d日目にiを開催したときの満足度",
            "INF = 10**18",
            "TIMELIMIT = 1.9",
            "def outputToScore(T):",
            "    last = [0]*26",
            "    satisfied = 0",
            "    for d, t in enumerate(T):",
            "        t -= 1; d += 1",
            "        satisfied += Ss[d-1][t]",
            "        last[t] = d",
            "        for i, c in enumerate(C):",
            "            satisfied -= c*(d-last[i])",
            "        # print(satisfied)",
            "    return satisfied",
            "def outputToScore2(T):",
            "    last = [0]*26",
            "    used = [[] for _ in range(26)]",
            "    satisfied = 0",
            "    for d, t in enumerate(T):",
            "        t -= 1; d += 1",
            "        satisfied += Ss[d-1][t]",
            "        used[t].append(d)",
            "        last[t] = d",
            "        for i, c in enumerate(C):",
            "            satisfied -= c*(d-last[i])",
            "        # print(satisfied)",
            "    return satisfied, used",
            "def greedy():",
            "    last = [0]*26",
            "    T = []",
            "    for d in range(Days):",
            "        satisfied_max = -INF",
            "        selected = -1",
            "        for t in range(26):",
            "            score_t = Ss[d][t]",
            "            for j, c in enumerate(C):",
            "                if t != j:",
            "                    score_t -= c*(d+1-last[j])",
            "            if score_t > satisfied_max:",
            "                satisfied_max = score_t",
            "                selected = t",
            "        T.append(selected+1)",
            "        last[selected] = d+1",
            "    return T",
            "def modifiedScore(d, aft, Used, T):",
            "    aft -= 1",
            "    bef = T[d-1]-1",
            "    deltaSatis = Ss[d-1][aft] - Ss[d-1][bef]",
            "    # d日目のコンテストをbefからaftに変える",
            "    # bi-1 -> bi -> bi+1 を bi-1 -> bi+1",
            "    befind = Used[bef].index(d)",
            "    befday0 = 0 if befind == 0 else Used[bef][befind-1]",
            "    befday2 = Days+1 if befind == len(Used[bef])-1 else Used[bef][befind+1]",
            "    befd01 = d - befday0",
            "    befd12 = befday2 - d",
            "    befd02 = befday2-befday0",
            "    deltaSatis -= C[bef]*(befd02*(befd02-1)//2) - C[bef]*(befd01*(befd01-1)//2 + befd12*(befd12-1)//2)",
            "    # ai -> ai+1 を ai -> (insert) -> ai+1",
            "    if len(Used[aft]) > 0:",
            "        aftday0 = 0",
            "        aftday2 = Days+1",
            "        for i,a in enumerate(Used[aft]):",
            "            if a < d:",
            "                aftday0 = a",
            "            elif aftday2 == Days+1:",
            "                aftday2 = a",
            "        aftd01 = d - aftday0",
            "        aftd12 = aftday2 - d",
            "        aftd02 = aftd01 + aftd12",
            "        deltaSatis += C[aft]*(aftd02*(aftd02-1)//2) - C[aft]*(aftd01*(aftd01-1)//2 + aftd12*(aftd12-1)//2)",
            "    else:",
            "        d01 = d",
            "        d12 = Days+1 - d",
            "        deltaSatis += C[aft] * Days*(Days+1)//2 - C[aft]*(d01*(d01-1)//2 + d12*(d12-1)//2)",
            "    return deltaSatis",
            "def update(Used, T, bef, aft, d):",
            "    Used[bef].remove(d)",
            "    inserted = False",
            "    new = []",
            "    for a in Used[aft]:",
            "        if a > d and not inserted:",
            "            inserted = True",
            "            new.append(d)",
            "        new.append(a)",
            "    if not inserted:",
            "        new.append(d)",
            "    Used[aft] = new",
            "    T[d-1] = aft+1",
            "    return T, Used",
            "def goingup(T, Used):",
            "    d = random.randint(1, Days)",
            "    bef = T[d-1]-1",
            "    aft = random.randint(0, 25)",
            "    if bef == aft:",
            "        return T, Used",
            "    if modifiedScore(d, aft, Used, T) > 0:",
            "        T, Used = update(Used, T, bef, aft, d)",
            "    return T, Used",
            "# T = [random.randint(1, 26) for _ in range(Days)]",
            "def main():",
            "    T = greedy()",
            "    Satisfied, Used = outputToScore2(T)",
            "    while time.time() - START < TIMELIMIT:",
            "        T, Used = goingup(T, Used)",
            "    print(*T, sep=\"\\n\")",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import os",
            "import sys",
            "import numpy as np",
            "def solve(inp):",
            "    def bitree_sum(bit, t, i):",
            "        s = 0",
            "        while i > 0:",
            "            s += bit[t, i]",
            "            i ^= i & -i",
            "        return s",
            "    def bitree_add(bit, n, t, i, x):",
            "        while i <= n:",
            "            bit[t, i] += x",
            "            i += i & -i",
            "    def bitree_lower_bound(bit, n, d, t, x):",
            "        sum_ = 0",
            "        pos = 0",
            "        for i in range(d, -1, -1):",
            "            k = pos + (1 << i)",
            "            if k <= n and sum_ + bit[t, k] < x:",
            "                sum_ += bit[t, k]",
            "                pos += 1 << i",
            "        return pos + 1",
            "    def initial_score(d, ccc, sss):",
            "        bit_n = d + 3",
            "        bit = np.zeros((26, bit_n), dtype=np.int64)",
            "        INF = 10 ** 18",
            "        for t in range(26):",
            "            bitree_add(bit, bit_n, t, bit_n - 1, INF)",
            "        ttt = np.zeros(d, dtype=np.int64)",
            "        last = np.full(26, -1, dtype=np.int64)",
            "        score = 0",
            "        for i in range(d):",
            "            best_t = 0",
            "            best_diff = -INF",
            "            costs = ccc * (i - last)",
            "            costs_sum = costs.sum()",
            "            for t in range(26):",
            "                tmp_diff = sss[i, t] - costs_sum + costs[t]",
            "                if best_diff < tmp_diff:",
            "                    best_t = t",
            "                    best_diff = tmp_diff",
            "            ttt[i] = best_t",
            "            last[best_t] = i",
            "            score += best_diff",
            "            bitree_add(bit, bit_n, best_t, i + 2, 1)",
            "        return bit, score, ttt",
            "    def calculate_score(d, ccc, sss, ttt):",
            "        last = np.full(26, -1, dtype=np.int64)",
            "        score = 0",
            "        for i in range(d):",
            "            t = ttt[i]",
            "            last[t] = i",
            "            score += sss[i, t] - (ccc * (i - last)).sum()",
            "        return score",
            "    def pinpoint_change(bit, bit_n, bit_d, d, ccc, sss, ttt, permissible):",
            "        cd = np.random.randint(0, d)",
            "        ct = np.random.randint(0, 26)",
            "        while ttt[cd] == ct:",
            "            ct = np.random.randint(0, 26)",
            "        diff = 0",
            "        t = ttt[cd]",
            "        k = bitree_sum(bit, t, cd + 2)",
            "        c = bitree_lower_bound(bit, bit_n, bit_d, t, k - 1) - 2",
            "        e = bitree_lower_bound(bit, bit_n, bit_d, t, k + 1) - 2",
            "        b = ccc[t]",
            "        diff -= b * (cd - c) * (e - cd)",
            "        diff -= sss[cd, t]",
            "        k = bitree_sum(bit, ct, cd + 2)",
            "        c = bitree_lower_bound(bit, bit_n, bit_d, ct, k) - 2",
            "        e = bitree_lower_bound(bit, bit_n, bit_d, ct, k + 1) - 2",
            "        b = ccc[ct]",
            "        diff += b * (cd - c) * (e - cd)",
            "        diff += sss[cd, ct]",
            "        if diff > permissible:",
            "            bitree_add(bit, bit_n, t, cd + 2, -1)",
            "            bitree_add(bit, bit_n, ct, cd + 2, 1)",
            "            ttt[cd] = ct",
            "        else:",
            "            diff = 0",
            "        return diff",
            "    def swap_change(bit, bit_n, bit_d, d, ccc, sss, ttt, permissible):",
            "        dd = np.random.randint(1, 14)",
            "        cd1 = np.random.randint(0, d - dd)",
            "        cd2 = cd1 + dd",
            "        ct1 = ttt[cd1]",
            "        ct2 = ttt[cd2]",
            "        if ct1 == ct2:",
            "            return 0",
            "        diff = 0",
            "        k = bitree_sum(bit, ct1, cd1 + 2)",
            "        c = bitree_lower_bound(bit, bit_n, bit_d, ct1, k - 1) - 2",
            "        e = bitree_lower_bound(bit, bit_n, bit_d, ct1, k + 1) - 2",
            "        diff += ccc[ct1] * (e + c - cd1 - cd2)",
            "        k = bitree_sum(bit, ct2, cd2 + 2)",
            "        c = bitree_lower_bound(bit, bit_n, bit_d, ct2, k - 1) - 2",
            "        e = bitree_lower_bound(bit, bit_n, bit_d, ct2, k + 1) - 2",
            "        diff -= ccc[ct2] * (e + c - cd1 - cd2)",
            "        diff -= sss[cd1, ct1] + sss[cd2, ct2]",
            "        diff += sss[cd1, ct2] + sss[cd2, ct1]",
            "        if diff > permissible:",
            "            bitree_add(bit, bit_n, ct1, cd1 + 2, -1)",
            "            bitree_add(bit, bit_n, ct1, cd2 + 2, 1)",
            "            bitree_add(bit, bit_n, ct2, cd1 + 2, 1)",
            "            bitree_add(bit, bit_n, ct2, cd2 + 2, -1)",
            "            ttt[cd1] = ct2",
            "            ttt[cd2] = ct1",
            "        else:",
            "            diff = 0",
            "        return diff",
            "    d = inp[0]",
            "    ccc = inp[1:27]",
            "    sss = np.zeros((d, 26), dtype=np.int64)",
            "    for r in range(d):",
            "        sss[r] = inp[27 + r * 26:27 + (r + 1) * 26]",
            "    bit, score, ttt = initial_score(d, ccc, sss)",
            "    bit_n = d + 3",
            "    bit_d = int(np.log2(bit_n))",
            "    loop = 5 * 10 ** 6",
            "    permissible_min = -2000.0",
            "    method_border = 0.8",
            "    best_score = score",
            "    best_ttt = ttt.copy()",
            "    for lp in range(loop):",
            "        permissible = (1 - lp / loop) * permissible_min",
            "        if np.random.random() < method_border:",
            "            diff = pinpoint_change(bit, bit_n, bit_d, d, ccc, sss, ttt, permissible)",
            "        else:",
            "            diff = swap_change(bit, bit_n, bit_d, d, ccc, sss, ttt, permissible)",
            "        score += diff",
            "        # print(lp, score, calculate_score(d, ccc, sss, ttt))",
            "        if score > best_score:",
            "            best_score = score",
            "            best_ttt = ttt.copy()",
            "    return best_ttt + 1",
            "if sys.argv[-1] == 'ONLINE_JUDGE':",
            "    from numba.pycc import CC",
            "    cc = CC('my_module')",
            "    cc.export('solve', '(i8[:],)')(solve)",
            "    cc.compile()",
            "    exit()",
            "if os.name == 'posix':",
            "    # noinspection PyUnresolvedReferences",
            "    from my_module import solve",
            "else:",
            "    from numba import njit",
            "    solve = njit('(i8[:],)', cache=True)(solve)",
            "    print('compiled', file=sys.stderr)",
            "inp = np.fromstring(sys.stdin.read(), dtype=np.int64, sep=' ')",
            "ans = solve(inp)",
            "print('\\n'.join(map(str, ans)))"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "# local search is all you need",
            "# 「日付 d とコンテストタイプ q をランダムに選び、d 日目に開催するコンテストをタイプ q に変更する」",
            "# このデメリット→変化させる量が小さすぎるとすぐに行き止まり (局所最適解) に陥ってしまい、逆に、変化させる量が 大きすぎると闇雲に探す状態に近くなって、改善できる確率が低くなってしまう。",
            "# 今回ならば、開催日が全体的に遠すぎず近すぎない感じのlocal minimumに収束する∵d日目のコンテストをi→jに変更したとする。iの開催期間はすごく伸びると2乗でスコアが下がるため、iの開催期間が比較的近いところのiしか選ばれない",
            "# →じゃ2点スワップを導入して改善してみよう",
            "# あといっぱい回すためにinitやscoreも若干高速化",
            "from time import time",
            "t0 = time()",
            "import sys",
            "sys.setrecursionlimit(1 << 25)",
            "read = sys.stdin.readline",
            "ra = range",
            "enu = enumerate",
            "def exit(*argv, **kwarg):",
            "    print(*argv, **kwarg)",
            "    sys.exit()",
            "def mina(*argv, sub=1): return list(map(lambda x: x - sub, argv))",
            "# 受け渡されたすべての要素からsubだけ引く.リストを*をつけて展開しておくこと",
            "def a_int(): return int(read())",
            "def ints(): return list(map(int, read().split()))",
            "def read_col(H):",
            "    '''H is number of rows",
            "    A列、B列が与えられるようなとき",
            "    ex1)A,B=read_col(H)    ex2) A,=read_col(H) #一列の場合'''",
            "    ret = []",
            "    for _ in range(H):",
            "        ret.append(list(map(int, read().split())))",
            "    return tuple(map(list, zip(*ret)))",
            "def read_tuple(H):",
            "    '''H is number of rows'''",
            "    ret = []",
            "    for _ in range(H):",
            "        ret.append(tuple(map(int, read().split())))",
            "    return ret",
            "MOD = 10**9 + 7",
            "INF = 2**31  # 2147483648 > 10**9",
            "# default import",
            "from itertools import product, permutations, combinations",
            "from bisect import bisect_left, bisect_right  # , insort_left, insort_right",
            "from functools import reduce",
            "from random import randint, random",
            "def score(D, C, S, T):",
            "    '''2~3*D回のループでスコアを計算する'''",
            "    # last = [-1] * 26",
            "    date_by_contest = [[-1] for _ in range(26)]",
            "    for d, t in enumerate(T):",
            "        date_by_contest[t].append(d)",
            "    for i in range(26):",
            "        date_by_contest[i].append(D)  # 番兵",
            "    # print(*date_by_contest, sep='\\n')",
            "    score = 0",
            "    for d in range(D):",
            "        score += S[d][T[d]]",
            "    for c, dates in enu(date_by_contest):",
            "        for i in range(len(dates) - 1):",
            "            dd = (dates[i + 1] - dates[i])",
            "            # for ddd in range(dd):",
            "            #     score -= C[c] * (ddd)",
            "            score -= C[c] * (dd - 1) * dd // 2",
            "    return score",
            "D = a_int()",
            "C = ints()",
            "S = read_tuple(D)",
            "def maximizer(newT, bestT, bestscore):",
            "    tmpscore = score(D, C, S, newT)",
            "    if tmpscore > bestscore:",
            "        return newT, tmpscore",
            "    else:",
            "        return bestT, bestscore",
            "def ret_init_T():",
            "    '''greedyで作ったTを初期値とする。",
            "    return",
            "    ----------",
            "    T, score ... 初期のTとそのTで得られるscore",
            "    '''",
            "    def _make_T(n_days):",
            "        # editorialよりd日目の改善は、改善せずにd+n_days経過したときの関数にしたほうが",
            "        # 最終的なスコアと相関があるんじゃない？",
            "        T = []",
            "        last = [-1] * 26",
            "        for d in range(D):",
            "            ma = -INF",
            "            for i in range(26):",
            "                tmp = S[d][i]",
            "                dd = d - last[i]",
            "                tmp += C[i] * (((dd + n_days + dd) * (n_days) // 2))",
            "                if tmp > ma:",
            "                    t = i",
            "                    ma = tmp",
            "            last[t] = d  # Tを選んだあとで決める",
            "            T.append(t)",
            "        return T",
            "    T = _make_T(2)",
            "    sco = score(D, C, S, T)",
            "    for i in range(3, 16):",
            "        T, sco = maximizer(_make_T(i), T, sco)",
            "    return T, sco",
            "bestT, bestscore = ret_init_T()",
            "def add_noise(T, thre_p, days_near):",
            "    '''確率的にどちらかの操作を行う",
            "    1.日付dとコンテストqをランダムに選びd日目に開催するコンテストのタイプをqに変更する",
            "    2.10日以内の点でコンテストを入れ替える",
            "    thre_pはどちらの行動を行うかを調節、days_nearは近さのパラメータ'''",
            "    ret = T.copy()",
            "    if random() < thre_p:",
            "        d = randint(0, D - 1)",
            "        q = randint(0, 25)",
            "        ret[d] = q",
            "        return ret",
            "    else:",
            "        i = randint(0, D - 2)",
            "        j = randint(i - days_near, i + days_near)",
            "        j = max(j, 0)",
            "        j = min(j, D - 1)",
            "        if i == j:",
            "            j += 1",
            "        ret[i], ret[j] = ret[j], ret[i]",
            "        return ret",
            "while time() - t0 < 1.9:",
            "    for _ in range(100):",
            "        bestT, bestscore = maximizer(",
            "            add_noise(bestT, 0.8, 8), bestT, bestscore)",
            "# print(bestscore)",
            "# print(score(D, C, S, T))",
            "print(*mina(*bestT, sub=-1), sep='\\n')"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "import copy",
            "import random",
            "import sys",
            "import time",
            "from collections import deque",
            "t1 = time.time()",
            "readline = sys.stdin.buffer.readline",
            "global NN",
            "NN = 26",
            "def evaluate(D, C, S, out, k):",
            "    score = 0",
            "    last = [0 for _ in range(NN)]",
            "    for d in range(len(out)):",
            "        last[out[d]] = d + 1",
            "        for i in range(NN):",
            "            score -= (d + 1 - last[i]) * C[i]",
            "        score += S[d][out[d]]",
            "    for d in range(len(out), min(D, len(out) + k)):",
            "        for i in range(NN):",
            "            score -= (d + 1 - last[i]) * C[i]",
            "    return score",
            "def compute_score(D, C, S, out):",
            "    score = 0",
            "    last = [0 for _ in range(NN)]",
            "    for d in range(len(out)):",
            "        p = out[d]",
            "        last[p] = d + 1",
            "        last[out[d]] = d + 1",
            "        for i in range(NN):",
            "            score -= (d + 1 - last[i]) * C[i]",
            "        score += S[d][out[d]]",
            "    return score",
            "def solve(D, C, S, k):",
            "    out = deque()",
            "    for _ in range(D):",
            "        max_score = -10 ** 8",
            "        best_i = 0",
            "        for i in range(NN):",
            "            out.append(i)",
            "            score = evaluate(D, C, S, out, k)",
            "            if max_score < score:",
            "                max_score = score",
            "                best_i = i",
            "            out.pop()",
            "        out.append(best_i)",
            "    return out",
            "# 1箇所ランダムに変える",
            "def random_change(D, C, S, out, score):",
            "    new_out = copy.deepcopy(out)",
            "    d = random.randrange(0, D)",
            "    new_out[d] = random.randrange(0, NN)",
            "    new_score = compute_score(D, C, S, new_out)",
            "    if new_score > score:",
            "        score = new_score",
            "        out = new_out",
            "    return out, score",
            "# N箇所ランダムに変える",
            "def random_changeN(D, C, S, out, score):",
            "    N = 2",
            "    new_out = copy.deepcopy(out)",
            "    for _ in range(N):",
            "        d = random.randrange(0, D)",
            "        new_out[d] = random.randrange(0, NN)",
            "    new_score = compute_score(D, C, S, new_out)",
            "    if new_score > score:",
            "        score = new_score",
            "        out = new_out",
            "    return out, score",
            "# 2つswap",
            "def random_swap2(D, C, S, out, score):",
            "    d1 = random.randrange(0, D - 1)",
            "    d2 = random.randrange(d1 + 1, min(d1 + 16, D))",
            "    new_out = copy.deepcopy(out)",
            "    new_out[d1], new_out[d2] = out[d2], out[d1]",
            "    new_score = compute_score(D, C, S, out)",
            "    if new_score > score:",
            "        score = new_score",
            "        out = new_out",
            "    return out, score",
            "# ３つswap",
            "def random_swap3(D, C, S, out, score):",
            "    d1 = random.randrange(0, D - 1)",
            "    d2 = random.randrange(d1 + 1, min(d1 + 8, D))",
            "    d3 = random.randrange(max(d1 - 8, 0), d1 + 1)",
            "    new_out = copy.deepcopy(out)",
            "    new_out[d1], new_out[d2], new_out[d3] = out[d2], out[d3], out[d1]",
            "    new_score = compute_score(D, C, S, out)",
            "    if new_score > score:",
            "        score = new_score",
            "        out = new_out",
            "    return out, score",
            "def main():",
            "    D = int(readline())",
            "    C = list(map(int, readline().split()))",
            "    S = [list(map(int, readline().split())) for _ in range(D)]",
            "    # ランダムな初期値",
            "    # out = [random.randrange(0, NN) for _ in range(D)]",
            "    # 貪欲法で初期値を決める",
            "    # k = 18  # kを大きくして，局所解から遠いものを得る",
            "    k = 26  # kを大きくして，局所解から遠いものを得る",
            "    out = solve(D, C, S, k)",
            "    # 初期値を数カ所変える",
            "    # np = 0.2  # 変えすぎ？",
            "    # np = 0.1",
            "    np = 0.05",
            "    n = int(D * np)",
            "    queue = [random.randrange(0, D) for _ in range(n)]",
            "    for q in queue:",
            "        out[q] = random.randrange(0, NN)",
            "    score = compute_score(D, C, S, out)",
            "    for cnt in range(10 ** 10):",
            "        bl = [random.randint(0, 1) for _ in range(5)]",
            "        for b in bl:",
            "            if b:",
            "                out, score = random_change(D, C, S, out, score)",
            "                # out, score = random_changeN(D, C, S, out, score)",
            "            else:",
            "                # out, score = random_swap2(D, C, S, out, score)",
            "                out, score = random_swap3(D, C, S, out, score)",
            "        t2 = time.time()",
            "        if t2 - t1 > 1.85:",
            "            break",
            "    ans = [str(i + 1) for i in out]",
            "    print(\"\\n\".join(ans))",
            "main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "import time",
            "start = time.time()",
            "import random",
            "from typing import List",
            "def score_by_simple_method(schedule, loss_list, satisfied_matrix):",
            "    prev_list = [-1] * 26",
            "    plus = 0",
            "    minus = 0",
            "    for day, open_contest in enumerate(schedule):",
            "        prev_list[open_contest] = day",
            "        plus += satisfied_matrix[day][open_contest]",
            "        for contest, prev_day in enumerate(prev_list):",
            "            spend = day - prev_day",
            "            loss_base = loss_list[contest]",
            "            minus += loss_base * spend",
            "    return plus - minus",
            "def schedule_to_dict(schedule, days):",
            "    dict = {contest: [-1] for contest in range(26)}",
            "    for day, contest in enumerate(schedule):",
            "        dict[contest].append(day)",
            "    for contest in range(26):",
            "        dict[contest].appned(days)",
            "    return dict",
            "class Node:",
            "    def __init__(self, contest, last_day):",
            "        self.contest = contest",
            "        self.prev_day = -1",
            "        self.next_day = last_day",
            "def schedule_to_linked(schedule, last_day):",
            "    linked_schedule = []",
            "    prev_list = [-1] * 26",
            "    for day, contest in enumerate(schedule):",
            "        cur_node = Node(contest, last_day)",
            "        prev_day = prev_list[contest]",
            "        cur_node.prev_day = prev_day",
            "        if prev_day != -1:",
            "            prev_node = linked_schedule[prev_day]",
            "            prev_node.next_day = day",
            "        prev_list[contest] = day",
            "        linked_schedule.append(cur_node)",
            "    return linked_schedule",
            "def is_exchangeable(day1, day2, linked_schedule: List[Node]):",
            "    \"\"\"",
            "    swap先が同じコンテストの時 False",
            "    swap先が同コンテストの前後開催を超えている場合 False",
            "    ex. schedule: [1, 2, 3, 4, 3, 5, 6]",
            "        swap target:     ^        ^",
            "    day1 = 2 (0-indexed)",
            "    day2 = 5",
            "    schedule[day1].next = 4",
            "    \"\"\"",
            "    if linked_schedule[day1].contest == linked_schedule[day2].contest:",
            "        return False",
            "    node1 = linked_schedule[day1]",
            "    node1_prev = node1.prev_day",
            "    node1_next = node1.next_day",
            "    if day2 < node1_prev or node1_next < day2:",
            "        return False",
            "    node2 = linked_schedule[day2]",
            "    node2_prev = node2.prev_day",
            "    node2_next = node2.next_day",
            "    if day1 < node2_prev or node2_next < day1:",
            "        return False",
            "    return True",
            "def swap_contests_in_linked_schedule(day1, day2, linked_schedule: List[Node], last_day):",
            "    node1 = linked_schedule[day1]",
            "    node1_prev = node1.prev_day",
            "    node1_next = node1.next_day",
            "    node2 = linked_schedule[day2]",
            "    node2_prev = node2.prev_day",
            "    node2_next = node2.next_day",
            "    linked_schedule[day1], linked_schedule[day2] = linked_schedule[day2], linked_schedule[day1]  # swap",
            "    if node1_prev != -1:",
            "        linked_schedule[node1_prev].next_day = day2",
            "    if node1_next != last_day:",
            "        linked_schedule[node1_next].prev_day = day2",
            "    if node2_prev != -1:",
            "        linked_schedule[node2_prev].next_day = day1",
            "    if node2_next != last_day:",
            "        linked_schedule[node2_next].prev_day = day1",
            "def calc_score_change_by_shift(contest, prev, before_center, after_center, next, loss_list, satisfied_matrix):",
            "    loss_base = loss_list[contest]",
            "    before_spend1 = before_center - prev",
            "    before_spend2 = next - before_center",
            "    before_loss = loss_base * (before_spend1 * (before_spend1-1) + before_spend2 * (before_spend2-1)) // 2",
            "    before_get = satisfied_matrix[before_center][contest]",
            "    before_score = before_get - before_loss",
            "    after_spend1 = after_center - prev",
            "    after_spend2 = next - after_center",
            "    after_loss = loss_base * (after_spend1 * (after_spend1-1) + after_spend2 * (after_spend2-1)) // 2",
            "    after_get = satisfied_matrix[after_center][contest]",
            "    after_score = after_get - after_loss",
            "    score_change = after_score - before_score",
            "    return score_change",
            "def calc_score_change_by_swap(day1, day2, linked_schedule: List[Node], loss_list, satisfied_matrix):",
            "    node1 = linked_schedule[day1]",
            "    change_score1 = calc_score_change_by_shift(node1.contest, node1.prev_day, day1, day2, node1.next_day, loss_list, satisfied_matrix)",
            "    node2 = linked_schedule[day2]",
            "    change_score2 = calc_score_change_by_shift(node2.contest, node2.prev_day, day2, day1, node2.next_day, loss_list, satisfied_matrix)",
            "    return change_score1 + change_score2",
            "days = int(input())",
            "loss_list = list(map(int, input().split()))",
            "satisfied_matrix = [list(map(int, input().split())) for _ in range(days)]",
            "schedule = [i % 26 for i in range(days)]",
            "linked_schedule = schedule_to_linked(schedule, days)",
            "base_score = score_by_simple_method(schedule, loss_list, satisfied_matrix)",
            "loops = 0",
            "while time.time() - start < 1.8:",
            "    loops += 1",
            "    day1 = random.randint(0, days - 25)",
            "    swap = []",
            "    best = 0",
            "    for day2 in range(day1+1, day1+25):",
            "        if is_exchangeable(day1, day2, linked_schedule):",
            "            change_score = calc_score_change_by_swap(day1, day2, linked_schedule, loss_list, satisfied_matrix)",
            "            if change_score > best:",
            "                swap = [day1, day2]",
            "                best = change_score",
            "    if swap:",
            "        day1, day2 = swap",
            "        swap_contests_in_linked_schedule(day1, day2, linked_schedule, days)",
            "        base_score += best",
            "ans = [node.contest + 1 for node in linked_schedule]",
            "print(*ans, sep=\"\\n\")"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "from sys import stdin",
            "input = stdin.readline",
            "from time import time",
            "from random import randint",
            "from copy import deepcopy",
            "start_time = time()",
            "def calcScore(t, s, c):",
            "    scores = [0]*26",
            "    lasts = [0]*26",
            "    for i in range(1, len(t)):",
            "        scores[t[i]] += s[i][t[i]]",
            "        dif = i - lasts[t[i]]",
            "        scores[t[i]] -= c[t[i]] * dif * (dif-1) // 2",
            "        lasts[t[i]] = i",
            "    for i in range(26):",
            "        dif = len(t) - lasts[i]",
            "        scores[i] -= c[i] * dif * (dif-1) // 2",
            "    return scores",
            "def greedy(c, s):",
            "    day_lim = len(s)",
            "    socres = [0]*26",
            "    t = [0]*day_lim",
            "    lasts = [0]*26",
            "    for i in range(1, day_lim):",
            "        pls = [v for v in socres]",
            "        mns = [v for v in socres]",
            "        for j in range(26):",
            "            pls[j] += s[i][j]",
            "            mns[j] -= c[j] * (i - lasts[j])",
            "        sum_mns = sum(mns)",
            "        pt = sum_mns - mns[0] + pls[0]",
            "        idx = 0",
            "        for j in range(1, 26):",
            "            tmp = sum_mns - mns[j] + pls[j]",
            "            if pt < tmp:",
            "                pt = tmp",
            "                idx = j",
            "        t[i] = idx",
            "        lasts[idx] = i",
            "        for j in range(26):",
            "            if j == idx:",
            "                socres[j] = pls[j]",
            "            else:",
            "                socres[j] = mns[j]",
            "    return socres, t",
            "def subGreedy(c, s, t, day):",
            "    day_lim = len(s)",
            "    socres = [0]*26",
            "    t = [0]*day_lim",
            "    lasts = [0]*26",
            "    for i in range(1, day_lim):",
            "        if day <= i:",
            "            pls = [v for v in socres]",
            "            mns = [v for v in socres]",
            "            for j in range(26):",
            "                pls[j] += s[i][j]",
            "                mns[j] -= c[j] * (i - lasts[j])",
            "            sum_mns = sum(mns)",
            "            pt = sum_mns - mns[0] + pls[0]",
            "            idx = 0",
            "            for j in range(1, 26):",
            "                tmp = sum_mns - mns[j] + pls[j]",
            "                if pt < tmp:",
            "                    pt = tmp",
            "                    idx = j",
            "            t[i] = idx",
            "            lasts[idx] = i",
            "            for j in range(26):",
            "                if j == idx:",
            "                    socres[j] = pls[j]",
            "                else:",
            "                    socres[j] = mns[j]",
            "        else:",
            "            scores[t[i]] += s[i][t[i]]",
            "            lasts[t[i]] = i",
            "            for j in range(26):",
            "                dif = i - lasts[j]",
            "                scores[j] -= c[j] * dif",
            "    return socres, t",
            "D = int(input())",
            "c = list(map(int, input().split()))",
            "s = [[0]*26 for _ in range(D+1)]",
            "for i in range(1, D+1):",
            "    s[i] = list(map(int, input().split()))",
            "scores, t = greedy(c, s)",
            "sum_score = sum(scores)",
            "while time() - start_time < 1.86:",
            "    typ = randint(1, 100)",
            "    if typ <= 70:",
            "        for _ in range(300):",
            "            tmp_t = deepcopy(t)",
            "            tmp_t[randint(1, D)] = randint(0, 25)",
            "            tmp_scores = calcScore(tmp_t, s, c)",
            "            sum_tmp_score = sum(tmp_scores)",
            "            if sum_score < sum_tmp_score:",
            "                sum_score = sum_tmp_score",
            "                t = deepcopy(tmp_t)",
            "                scores = deepcopy(tmp_scores)",
            "    elif typ <= 98:",
            "        for _ in range(100):",
            "            tmp_t = deepcopy(t)",
            "            dist = randint(1, 15)",
            "            p = randint(1, D-dist)",
            "            q = p + dist",
            "            tmp_t[p], tmp_t[q] = tmp_t[q], tmp_t[p]",
            "            tmp_scores = calcScore(tmp_t, s, c)",
            "            sum_tmp_score = sum(tmp_scores)",
            "            if sum_score < sum_tmp_score or randint(1, 100) <= 3:",
            "                sum_score = sum_tmp_score",
            "                t = deepcopy(tmp_t)",
            "                scores = deepcopy(tmp_scores)",
            "    elif typ <= 100:",
            "        tmp_t = deepcopy(t)",
            "        day = randint(D//4*3, D)",
            "        tmp_scores, tmp_t = subGreedy(c, s, tmp_t, day)",
            "        sum_tmp_score = sum(tmp_scores)",
            "        if sum_score < sum_tmp_score:",
            "            sum_score = sum_tmp_score",
            "            t = deepcopy(tmp_t)",
            "            scores = deepcopy(tmp_scores)",
            "for v in t[1:]:",
            "    print(v+1)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# -*- coding: utf-8 -*-",
            "import sys",
            "import math",
            "from bisect import bisect_left",
            "from bisect import bisect_right",
            "from collections import defaultdict",
            "from heapq import heappop, heappush",
            "import itertools",
            "import random",
            "from decimal import *",
            "input = sys.stdin.readline",
            "def inputInt(): return int(input())",
            "def inputMap(): return map(int, input().split())",
            "def inputList(): return list(map(int, input().split()))",
            "def inputStr(): return input()[:-1]",
            "inf = float('inf')",
            "mod = 1000000007",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "def main():",
            "\tD = inputInt()",
            "\tC = inputList()",
            "\tS = []",
            "\tfor i in range(D):",
            "\t\ts = inputList()",
            "\t\tS.append(s)",
            "\tans1 = []",
            "\tans2 = []",
            "\tans3 = []",
            "\tans4 = []",
            "\tans5 = []",
            "\tfor i in range(D):",
            "\t\tbestSco1 = 0",
            "\t\tbestSco2 = 0",
            "\t\tbestSco3 = 0",
            "\t\tbestSco4 = 0",
            "\t\tbestSco5 = 0",
            "\t\tbestI1 = 1",
            "\t\tbestI2 = 1",
            "\t\tbestI3 = 1",
            "\t\tbestI4 = 1",
            "\t\tbestI5 = 1",
            "\t\tfor j,val in enumerate(S[i]):",
            "\t\t\tif j == 0:",
            "\t\t\t\ttmpAns = ans1 + [j+1]",
            "\t\t\t\ttmpSco = findScore(tmpAns, S, C)",
            "\t\t\t\tif bestSco1 < tmpSco:",
            "\t\t\t\t\tbestSco5 = bestSco4",
            "\t\t\t\t\tbestI5 = bestI4",
            "\t\t\t\t\tbestSco4 = bestSco3",
            "\t\t\t\t\tbestI4 = bestI3",
            "\t\t\t\t\tbestSco3 = bestSco2",
            "\t\t\t\t\tbestI3 = bestI2",
            "\t\t\t\t\tbestSco2 = bestSco1",
            "\t\t\t\t\tbestI2 = bestI1",
            "\t\t\t\t\tbestSco1 = tmpSco",
            "\t\t\t\t\tbestI1 = j+1",
            "\t\t\telse:",
            "\t\t\t\ttmpAns1 = ans1 + [j+1]",
            "\t\t\t\ttmpAns2 = ans2 + [j+1]",
            "\t\t\t\ttmpAns3 = ans3 + [j+1]",
            "\t\t\t\ttmpAns4 = ans4 + [j+1]",
            "\t\t\t\ttmpAns5 = ans5 + [j+1]",
            "\t\t\t\ttmpSco1 = findScore(tmpAns1, S, C)",
            "\t\t\t\ttmpSco2 = findScore(tmpAns2, S, C)",
            "\t\t\t\ttmpSco3 = findScore(tmpAns3, S, C)",
            "\t\t\t\ttmpSco4 = findScore(tmpAns4, S, C)",
            "\t\t\t\ttmpSco5 = findScore(tmpAns5, S, C)",
            "\t\t\t\tif bestSco1 < tmpSco1:",
            "\t\t\t\t\tbestSco5 = bestSco4",
            "\t\t\t\t\tbestI5 = bestI4",
            "\t\t\t\t\tbestSco4 = bestSco3",
            "\t\t\t\t\tbestI4 = bestI3",
            "\t\t\t\t\tbestSco3 = bestSco2",
            "\t\t\t\t\tbestI3 = bestI2",
            "\t\t\t\t\tbestSco2 = bestSco1",
            "\t\t\t\t\tbestI2 = bestI1",
            "\t\t\t\t\tbestSco1 = tmpSco1",
            "\t\t\t\t\tbestI1 = j+1",
            "\t\t\t\tif bestSco1 < tmpSco2:",
            "\t\t\t\t\tbestSco5 = bestSco4",
            "\t\t\t\t\tbestI5 = bestI4",
            "\t\t\t\t\tbestSco4 = bestSco3",
            "\t\t\t\t\tbestI4 = bestI3",
            "\t\t\t\t\tbestSco3 = bestSco2",
            "\t\t\t\t\tbestI3 = bestI2",
            "\t\t\t\t\tbestSco2 = bestSco1",
            "\t\t\t\t\tbestI2 = bestI1",
            "\t\t\t\t\tbestSco1 = tmpSco1",
            "\t\t\t\t\tbestI1 = j+1",
            "\t\t\t\tif bestSco1 < tmpSco3:",
            "\t\t\t\t\tbestSco5 = bestSco4",
            "\t\t\t\t\tbestI5 = bestI4",
            "\t\t\t\t\tbestSco4 = bestSco3",
            "\t\t\t\t\tbestI4 = bestI3",
            "\t\t\t\t\tbestSco3 = bestSco2",
            "\t\t\t\t\tbestI3 = bestI2",
            "\t\t\t\t\tbestSco2 = bestSco1",
            "\t\t\t\t\tbestI2 = bestI1",
            "\t\t\t\t\tbestSco1 = tmpSco1",
            "\t\t\t\t\tbestI1 = j+1",
            "\t\t\t\tif bestSco1 < tmpSco4:",
            "\t\t\t\t\tbestSco5 = bestSco4",
            "\t\t\t\t\tbestI5 = bestI4",
            "\t\t\t\t\tbestSco4 = bestSco3",
            "\t\t\t\t\tbestI4 = bestI3",
            "\t\t\t\t\tbestSco3 = bestSco2",
            "\t\t\t\t\tbestI3 = bestI2",
            "\t\t\t\t\tbestSco2 = bestSco1",
            "\t\t\t\t\tbestI2 = bestI1",
            "\t\t\t\t\tbestSco1 = tmpSco1",
            "\t\t\t\t\tbestI1 = j+1",
            "\t\t\t\tif bestSco1 < tmpSco5:",
            "\t\t\t\t\tbestSco5 = bestSco4",
            "\t\t\t\t\tbestI5 = bestI4",
            "\t\t\t\t\tbestSco4 = bestSco3",
            "\t\t\t\t\tbestI4 = bestI3",
            "\t\t\t\t\tbestSco3 = bestSco2",
            "\t\t\t\t\tbestI3 = bestI2",
            "\t\t\t\t\tbestSco2 = bestSco1",
            "\t\t\t\t\tbestI2 = bestI1",
            "\t\t\t\t\tbestSco1 = tmpSco1",
            "\t\t\t\t\tbestI1 = j+1",
            "\t\tans1.append(bestI1)",
            "\t\tans2.append(bestI2)",
            "\t\tans3.append(bestI3)",
            "\t\tans4.append(bestI4)",
            "\t\tans5.append(bestI5)",
            "\tfor i in ans1:",
            "\t\tprint(i)",
            "def findScore(ans, S, C):",
            "\tscezhu = [inf for i in range(26)]",
            "\tsco = 0",
            "\tfor i,val in enumerate(ans):",
            "\t\ttmp = S[i][val-1]",
            "\t\tscezhu[val-1] = i",
            "\t\tmins = 0",
            "\t\tfor j,vol in enumerate(C):",
            "\t\t\tif scezhu[j] == inf:",
            "\t\t\t\tmins = mins + (vol * (i+1))",
            "\t\t\telse:",
            "\t\t\t\tmins = mins + (vol * ((i+1)-(scezhu[j]+1)))",
            "\t\ttmp -= mins",
            "\t\tsco += tmp",
            "\treturn sco",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "if __name__ == \"__main__\":",
            "\tmain()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# local search is all you need",
            "# 「日付 d とコンテストタイプ q をランダムに選び、d 日目に開催するコンテストをタイプ q に変更する」",
            "# このデメリット→変化させる量が小さすぎるとすぐに行き止まり (局所最適解) に陥ってしまい、逆に、変化させる量が 大きすぎると闇雲に探す状態に近くなって、改善できる確率が低くなってしまう。",
            "# 今回ならば、開催日が全体的に遠すぎず近すぎない感じのlocal minimumに収束する∵d日目のコンテストをi→jに変更したとする。iの開催期間はすごく伸びると2乗でスコアが下がるため、iの開催期間が比較的近いところのiしか選ばれない",
            "# →じゃ2点スワップを導入して改善してみよう",
            "# あといっぱい回すためにinitやscoreも若干高速化",
            "from time import time",
            "t0 = time()",
            "import sys",
            "sys.setrecursionlimit(1 << 25)",
            "read = sys.stdin.readline",
            "ra = range",
            "enu = enumerate",
            "def exit(*argv, **kwarg):",
            "    print(*argv, **kwarg)",
            "    sys.exit()",
            "def mina(*argv, sub=1): return list(map(lambda x: x - sub, argv))",
            "# 受け渡されたすべての要素からsubだけ引く.リストを*をつけて展開しておくこと",
            "def a_int(): return int(read())",
            "def ints(): return list(map(int, read().split()))",
            "def read_col(H):",
            "    '''H is number of rows",
            "    A列、B列が与えられるようなとき",
            "    ex1)A,B=read_col(H)    ex2) A,=read_col(H) #一列の場合'''",
            "    ret = []",
            "    for _ in range(H):",
            "        ret.append(list(map(int, read().split())))",
            "    return tuple(map(list, zip(*ret)))",
            "def read_tuple(H):",
            "    '''H is number of rows'''",
            "    ret = []",
            "    for _ in range(H):",
            "        ret.append(tuple(map(int, read().split())))",
            "    return ret",
            "MOD = 10**9 + 7",
            "INF = 2**31  # 2147483648 > 10**9",
            "# default import",
            "from itertools import product, permutations, combinations",
            "from bisect import bisect_left, bisect_right  # , insort_left, insort_right",
            "from functools import reduce",
            "from random import randint, random",
            "def score(D, C, S, T):",
            "    '''2~3*D回のループでスコアを計算する'''",
            "    # last = [-1] * 26",
            "    date_by_contest = [[-1] for _ in range(26)]",
            "    for d, t in enumerate(T):",
            "        date_by_contest[t].append(d)",
            "    for i in range(26):",
            "        date_by_contest[i].append(D)  # 番兵",
            "    # print(*date_by_contest, sep='\\n')",
            "    score = 0",
            "    for d in range(D):",
            "        score += S[d][T[d]]",
            "    for c, dates in enu(date_by_contest):",
            "        for i in range(len(dates) - 1):",
            "            dd = (dates[i + 1] - dates[i])",
            "            # for ddd in range(dd):",
            "            #     score -= C[c] * (ddd)",
            "            score -= C[c] * (dd - 1) * dd // 2",
            "    return score",
            "D = a_int()",
            "C = ints()",
            "S = read_tuple(D)",
            "def maximizer(newT, bestT, bestscore):",
            "    tmpscore = score(D, C, S, newT)",
            "    if tmpscore > bestscore:",
            "        return newT, tmpscore",
            "    else:",
            "        return bestT, bestscore",
            "def ret_init_T():",
            "    '''greedyで作ったTを初期値とする。",
            "    return",
            "    ----------",
            "    T, score ... 初期のTとそのTで得られるscore",
            "    '''",
            "    def _make_T(n_days):",
            "        # editorialよりd日目の改善は、改善せずにd+n_days経過したときの関数にしたほうが",
            "        # 最終的なスコアと相関があるんじゃない？",
            "        T = []",
            "        last = [-1] * 26",
            "        for d in range(D):",
            "            ma = -INF",
            "            for i in range(26):",
            "                tmp = S[d][i]",
            "                dd = d - last[i]",
            "                tmp += C[i] * (((dd + n_days + dd) * (n_days) // 2))",
            "                if tmp > ma:",
            "                    t = i",
            "                    ma = tmp",
            "            last[t] = d  # Tを選んだあとで決める",
            "            T.append(t)",
            "        return T",
            "    T = _make_T(2)",
            "    sco = score(D, C, S, T)",
            "    for i in range(3, 16):",
            "        T, sco = maximizer(_make_T(i), T, sco)",
            "    return T, sco",
            "bestT, bestscore = ret_init_T()",
            "def add_noise(T, thre_p, days_near):",
            "    '''確率的にどちらかの操作を行う",
            "    1.日付dとコンテストqをランダムに選びd日目に開催するコンテストのタイプをqに変更する",
            "    2.10日以内の点でコンテストを入れ替える",
            "    thre_pはどちらの行動を行うかを調節、days_nearは近さのパラメータ'''",
            "    ret = T.copy()",
            "    if random() < thre_p:",
            "        d = randint(0, D - 1)",
            "        q = randint(0, 25)",
            "        ret[d] = q",
            "        return ret",
            "    else:",
            "        i = randint(0, D - 2)",
            "        j = randint(i - days_near, i + days_near)",
            "        j = max(j, 0)",
            "        j = min(j, D - 1)",
            "        if i == j:",
            "            j += 1",
            "        ret[i], ret[j] = ret[j], ret[i]",
            "        return ret",
            "while time() - t0 < 1.92:",
            "    bestT, bestscore = maximizer(add_noise(bestT, 0.8, 8), bestT, bestscore)",
            "    bestT, bestscore = maximizer(add_noise(bestT, 0.8, 8), bestT, bestscore)",
            "    bestT, bestscore = maximizer(add_noise(bestT, 0.8, 8), bestT, bestscore)",
            "    bestT, bestscore = maximizer(add_noise(bestT, 0.8, 8), bestT, bestscore)",
            "    bestT, bestscore = maximizer(add_noise(bestT, 0.8, 8), bestT, bestscore)",
            "# print(bestscore)",
            "# print(score(D, C, S, T))",
            "print(*mina(*bestT, sub=-1), sep='\\n')"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "# local search is all you need",
            "# 「日付 d とコンテストタイプ q をランダムに選び、d 日目に開催するコンテストをタイプ q に変更する」を実装する",
            "from time import time",
            "t0 = time()",
            "import sys",
            "sys.setrecursionlimit(1 << 25)",
            "read = sys.stdin.readline",
            "ra = range",
            "enu = enumerate",
            "def exit(*argv, **kwarg):",
            "    print(*argv, **kwarg)",
            "    sys.exit()",
            "def mina(*argv, sub=1): return list(map(lambda x: x - sub, argv))",
            "# 受け渡されたすべての要素からsubだけ引く.リストを*をつけて展開しておくこと",
            "def a_int(): return int(read())",
            "def ints(): return list(map(int, read().split()))",
            "def read_col(H):",
            "    '''H is number of rows",
            "    A列、B列が与えられるようなとき",
            "    ex1)A,B=read_col(H)    ex2) A,=read_col(H) #一列の場合'''",
            "    ret = []",
            "    for _ in range(H):",
            "        ret.append(list(map(int, read().split())))",
            "    return tuple(map(list, zip(*ret)))",
            "def read_tuple(H):",
            "    '''H is number of rows'''",
            "    ret = []",
            "    for _ in range(H):",
            "        ret.append(tuple(map(int, read().split())))",
            "    return ret",
            "MOD = 10**9 + 7",
            "INF = 2**31  # 2147483648 > 10**9",
            "# default import",
            "from itertools import product, permutations, combinations",
            "from bisect import bisect_left, bisect_right  # , insort_left, insort_right",
            "from functools import reduce",
            "from random import randint",
            "def score(D, C, S, T):",
            "    last = [-1] * 26",
            "    # scores = [0]",
            "    score = 0",
            "    for d in range(D):",
            "        # scores.append(scores[-1] + S[d][T[d]])",
            "        score += S[d][T[d]]",
            "        last[T[d]] = d",
            "        for i in range(26):",
            "            # scores[-1] -= C[i] * (d - last[i])",
            "            score -= C[i] * (d - last[i])  # この場で一番罰則が大きいやつを使うとか？",
            "    return score",
            "D = a_int()",
            "C = ints()",
            "S = read_tuple(D)",
            "def maximizer(newT, bestT, bestscore):",
            "    tmpscore = score(D, C, S, newT)",
            "    if tmpscore > bestscore:",
            "        return newT, tmpscore",
            "    else:",
            "        return bestT, bestscore",
            "def ret_init_T():",
            "    '''greedyで作ったTを初期値とする。",
            "    return",
            "    ----------",
            "    T, score ... 初期のTとそのTで得られるscore",
            "    '''",
            "    def _make_T(n_days):",
            "        # editorialよりd日目の改善は、改善せずにd+n_days経過したときの関数にしたほうが",
            "        # 最終的なスコアと相関があるんじゃない？",
            "        T = []",
            "        last = [-1] * 26",
            "        for d in range(D):",
            "            ma = -INF",
            "            for i in range(26):",
            "                tmp = S[d][i]",
            "                for j in range(n_days):",
            "                    tmp += C[i] * (d + j - last[i])",
            "                if tmp > ma:",
            "                    t = i",
            "                    ma = tmp",
            "            last[t] = d  # Tを選んだあとで決める",
            "            T.append(t)",
            "        return T",
            "    T = _make_T(0)",
            "    sco = score(D, C, S, T)",
            "    for i in range(1, 20):",
            "        T, sco = maximizer(_make_T(i), T, sco)",
            "    return T, sco",
            "bestT, bestscore = ret_init_T()",
            "def add_noise(T):",
            "    '''日付dとコンテストqをランダムに選びd日目に開催するコンテストのタイプをqに変更する'''",
            "    ret = T.copy()",
            "    d = randint(0, D - 1)",
            "    q = randint(0, 25)",
            "    ret[d] = q",
            "    return ret",
            "t1 = time()",
            "bestT, bestscore = maximizer(add_noise(bestT), bestT, bestscore)",
            "dt = time() - t1",
            "times = (1.95 - (time() - t0)) // dt",
            "for _ in range(int(times)):",
            "    bestT, bestscore = maximizer(add_noise(bestT), bestT, bestscore)",
            "# while time() - t0 < 1.92:",
            "#     # while time() - t0 < 5:",
            "#     bestT, bestscore = maximizer(add_noise(bestT), bestT, bestscore)",
            "#     print(bestscore)",
            "# print(bestscore)",
            "# print(t0, t1, dt, times, time() - t0)",
            "# print(score(D, C, S, T))",
            "print(*mina(*bestT, sub=-1), sep='\\n')"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "# annealing is all you need",
            "# hyper parameter tune is all you need",
            "from time import time",
            "t0 = time()",
            "import sys",
            "sys.setrecursionlimit(1 << 25)",
            "read = sys.stdin.readline",
            "ra = range",
            "enu = enumerate",
            "def exit(*argv, **kwarg):",
            "    print(*argv, **kwarg)",
            "    sys.exit()",
            "def mina(*argv, sub=1): return list(map(lambda x: x - sub, argv))",
            "# 受け渡されたすべての要素からsubだけ引く.リストを*をつけて展開しておくこと",
            "def a_int(): return int(read())",
            "def ints(): return list(map(int, read().split()))",
            "def read_col(H):",
            "    '''H is number of rows",
            "    A列、B列が与えられるようなとき",
            "    ex1)A,B=read_col(H)    ex2) A,=read_col(H) #一列の場合'''",
            "    ret = []",
            "    for _ in range(H):",
            "        ret.append(list(map(int, read().split())))",
            "    return tuple(map(list, zip(*ret)))",
            "def read_tuple(H):",
            "    '''H is number of rows'''",
            "    ret = []",
            "    for _ in range(H):",
            "        ret.append(tuple(map(int, read().split())))",
            "    return ret",
            "INF = 2**31  # 2147483648 > 10**9",
            "# default import",
            "from bisect import bisect_left, bisect_right, insort_left",
            "from random import randint, random",
            "from math import exp",
            "D = a_int()",
            "C = ints()",
            "S = read_tuple(D)",
            "def annealing(oldscore, newscore, T):",
            "    '''p(newscore-oldscore,T)=min(1,exp((newscore-oldscore)/T)) の確率でnewscoreを採用する",
            "    newが選ばれた時はTrueを返す'''",
            "    if oldscore < newscore:",
            "        return True",
            "    else:",
            "        p = exp((newscore - oldscore) / T)",
            "        return random() < p",
            "def T_to_date_by_contest(T):",
            "    '''Tを日付形式にしつつscoreも計算'''",
            "    date_by_contest = [[-1] for _ in range(26)]",
            "    for d, t in enumerate(T):",
            "        date_by_contest[t].append(d)",
            "    for i in range(26):",
            "        date_by_contest[i].append(D)  # 番兵",
            "    return date_by_contest",
            "def eval(D, C, S, date_by_contest):",
            "    '''2~3*D回のループでスコアを計算する'''",
            "    score = 0",
            "    for c, dates in enu(date_by_contest):",
            "        for d in dates[1:-1]:",
            "            score += S[d][c]",
            "        for i in range(len(dates) - 1):",
            "            dd = (dates[i + 1] - dates[i])",
            "            # for ddd in range(dd):",
            "            #     score -= C[c] * (ddd)",
            "            score -= C[c] * (dd - 1) * dd // 2",
            "    return score",
            "def maximizer(newT, bestT, bestscore):",
            "    '''具体的なTの最大化用'''",
            "    tmpscore = eval(D, C, S, T_to_date_by_contest(newT))",
            "    if tmpscore > bestscore:",
            "        return newT, tmpscore",
            "    else:",
            "        return bestT, bestscore",
            "def ret_init_T():",
            "    '''greedyで作ったTを初期値とする。",
            "    return",
            "    ----------",
            "    T, score ... 初期のTとそのTで得られるscore",
            "    '''",
            "    def _make_T(n_days):",
            "        # editorialよりd日目の改善は、改善せずにd+n_days経過したときの関数にしたほうが",
            "        # 最終的なスコアと相関があるんじゃない？",
            "        T = []",
            "        last = [-1] * 26",
            "        for d in range(D):",
            "            ma = -INF",
            "            for i in range(26):",
            "                tmp = S[d][i]",
            "                dd = d - last[i]",
            "                tmp += C[i] * (((dd + n_days + dd) * (n_days) // 2))",
            "                if tmp > ma:",
            "                    t = i",
            "                    ma = tmp",
            "            last[t] = d  # Tを選んだあとで決める",
            "            T.append(t)",
            "        return T",
            "    T = _make_T(3)",
            "    sco = eval(D, C, S, T_to_date_by_contest(T))",
            "    for i in range(4, 13):",
            "        T, sco = maximizer(_make_T(i), T, sco)",
            "    return T, sco",
            "class Schedule:",
            "    def __init__(self, T: list, date_by_contest, score: int):",
            "        self.T = T",
            "        self.date_by_contest = date_by_contest",
            "        self.score = score",
            "    def try_change_contest(self, d, j):",
            "        '''d日目をjに変更したときのscore'''",
            "        score = self.score",
            "        i = self.T[d]  # コンテストi→jに変化する",
            "        if i == j:",
            "            return score  # 変化しないので",
            "        score += S[d][j] - S[d][i]",
            "        # iの変化についてscoreを計算し直す",
            "        # d_i_idx = bisect_left(self.date_by_contest[i], d)  # iにおけるdのindex",
            "        d_i_idx = self.date_by_contest[i].index(d)  # iにおけるdのindex",
            "        dd = self.date_by_contest[i][d_i_idx + 1] - \\",
            "            self.date_by_contest[i][d_i_idx - 1]",
            "        score -= C[i] * (dd - 1) * dd // 2",
            "        dd = self.date_by_contest[i][d_i_idx + 1] - d",
            "        score += C[i] * (dd - 1) * dd // 2",
            "        dd = d - self.date_by_contest[i][d_i_idx - 1]",
            "        score += C[i] * (dd - 1) * dd // 2",
            "        # jの変化についてscoreを計算し直す",
            "        d_j_idx = bisect_left(self.date_by_contest[j], d)",
            "        dd = self.date_by_contest[j][d_j_idx] - \\",
            "            self.date_by_contest[j][d_j_idx - 1]",
            "        score += C[j] * (dd - 1) * dd // 2",
            "        dd = self.date_by_contest[j][d_j_idx] - d",
            "        score -= C[j] * (dd - 1) * dd // 2",
            "        dd = d - self.date_by_contest[j][d_j_idx - 1]",
            "        score -= C[j] * (dd - 1) * dd // 2",
            "        return score",
            "    def change_contest(self, d, j):",
            "        '''d日目をjに変更する'''",
            "        self.score = self.try_change_contest(d, j)",
            "        i = self.T[d]",
            "        self.T[d] = j",
            "        self.date_by_contest[i].remove(d)",
            "        insort_left(self.date_by_contest[j], d)",
            "def trial(sche, thre_p, days_near, Tt):",
            "    '''確率的にどちらかの操作を行ってよかったらScheduleを更新する",
            "    1.日付dとコンテストqをランダムに選びd日目に開催するコンテストのタイプをqに変更する",
            "    2.10日以内の点でコンテストを入れ替える",
            "    thre_pはどちらの行動を行うかを調節、days_nearは近さのパラメータ'''",
            "    if random() < thre_p:",
            "        # 一点更新",
            "        d = randint(0, D - 1)",
            "        q = randint(0, 25)",
            "        if annealing(sche.score, sche.try_change_contest(d, q), Tt):",
            "            sche.change_contest(d, q)",
            "        return sche  # 参照渡しだから変わらんけどね",
            "    else:",
            "        T = sche.T.copy()",
            "        i = randint(0, D - 2)",
            "        j = randint(i - days_near, i + days_near)",
            "        j = max(j, 0)",
            "        j = min(j, D - 1)",
            "        if i == j:",
            "            j += 1",
            "        T[i], T[j] = T[j], T[i]",
            "        new_score = eval(D, C, S, T_to_date_by_contest(T))",
            "        if annealing(sche.score, new_score, Tt):",
            "            return Schedule(T, T_to_date_by_contest(T), new_score)",
            "        else:",
            "            return sche",
            "bestT, bestscore = ret_init_T()",
            "sche = Schedule(bestT, T_to_date_by_contest(bestT), bestscore)",
            "T0 = 599",
            "T1 = 5",
            "TL = 1.91",
            "# TL = 5",
            "now = time()",
            "while now - t0 < TL:",
            "    Tt = (T0**((now - t0) / TL)) * (T1**(1 - (now - t0) / TL))",
            "    for _ in range(3000):",
            "        sche = trial(sche, 0.762, 15, Tt)",
            "    now = time()",
            "# print(sche.score)",
            "# print(score(D, C, S, T))",
            "print(*mina(*sche.T, sub=-1), sep='\\n')"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "test = False",
            "if test:",
            "    import time",
            "    start = time.time()",
            "import sys",
            "import random",
            "def solve(c_list, days, now):",
            "    r = sum(c_list[i]*(now-days[i]) for i in range(26))",
            "    return r",
            "if test == True:",
            "    #seed = 94",
            "    #random.seed(seed)",
            "    d = 365",
            "    c = [random.randrange(0, 101) for _ in range(26)]",
            "    s = [[random.randrange(0, 20001) for _ in range(26)] for _ in range(d)]",
            "    c_ = ' '.join(map(str, c))",
            "    s_ = '\\n'.join([' '.join(map(str, i)) for i in s])",
            "    with open('./input.txt', 'w') as f:",
            "        f.write('\\n'.join([str(d), c_, s_]))",
            "else:",
            "    d = int(input())",
            "    c = list(map(int, input().split()))",
            "    s = [list(map(int, input().split())) for _i in range(d)]",
            "last_days = [-1 for _i in range(26)]",
            "result = []",
            "score = 0",
            "for today in range(d):",
            "    checker = [c[j]*(today-last_days[j]) for j in range(26)]",
            "    y = sum(checker)",
            "    finder = [s[today][j]-(y-checker[j]) for j in range(26)]",
            "    x = finder.index(max(finder))",
            "    if today < d-1:",
            "        second_checker = [c[j]*(today+1-last_days[j]) for j in range(26)]",
            "        second_finder = [s[today+1][j]-(y-checker[j]) for j in range(26)]",
            "        second_x = second_finder.index(max(second_finder))",
            "        if x == second_finder:",
            "            x = finder.index(sorted(finder)[-2])",
            "    last_days[x] = today",
            "    result.append(x+1)",
            "    score += s[today][x] - solve(c, last_days, today)",
            "if test:",
            "    first = score",
            "    print(score)",
            "def change(problems, days):",
            "    last_days = [-1 for _i in range(26)]",
            "    score = 0",
            "    for i in range(d):",
            "        score += s[i][problems[i]-1]",
            "        last_days[problems[i]-1] = i",
            "        score -= sum([c[j]*(i-last_days[j]) for j in range(26)])",
            "    return score",
            "change_list = result.copy()",
            "for i in range(9200):",
            "    rand = random.randrange(5)",
            "    if rand < 2:",
            "        x, y = random.randrange(0, d), random.randrange(0, d)",
            "        while x == y:",
            "            y = random.randrange(0, d)",
            "        change_list[x], change_list[y] = change_list[y], change_list[x]",
            "        next_score = change(change_list, d)",
            "        if next_score >= score:",
            "            if test:print(i, score, next_score, abs(next_score-score), 'two')",
            "            score = next_score",
            "            result[x], result[y] = result[y], result[x]",
            "        else:",
            "            change_list[x], change_list[y] = change_list[y], change_list[x]",
            "    elif rand < 4:",
            "        x = random.randrange(0, d)",
            "        y = random.randrange(1, 27)",
            "        while change_list[x] == y:",
            "            x = random.randrange(0, d)",
            "            y = random.randrange(1, 27)",
            "        change_list[x], z = y, change_list[x]",
            "        next_score = change(change_list, d)",
            "        if next_score >= score:",
            "            if test:print(i, score, next_score, abs(next_score-score), 'one')",
            "            score = next_score",
            "            result[x] = y",
            "        else:",
            "            change_list[x] = z",
            "    else:",
            "        x, y, z = random.randrange(0, d), random.randrange(0, d), random.randrange(0, d)",
            "        while x==y and y==z:",
            "            y = random.randrange(0, d)",
            "        change_list[x], change_list[y] , change_list[z] = change_list[y], change_list[z], change_list[x]",
            "        next_score = change(change_list, d)",
            "        if next_score >= score:",
            "            if test:print(i, score, next_score, abs(next_score-score), 'three')",
            "            score = next_score",
            "            result[x], result[y], result[z] = result[y], result[z], result[x]",
            "        else:",
            "            change_list[x], change_list[y], change_list[z] = change_list[z], change_list[x] , change_list[y]",
            "if test == True:",
            "    with open('./output.txt', 'w') as f:",
            "        f.write('\\n'.join(map(str, result)))",
            "else:",
            "    for i in result:",
            "        print(i)",
            "if test:",
            "    elapsed_time = time.time() - start",
            "    print(score-first)",
            "    print (\"elapsed_time:{0}\".format(elapsed_time) + \"[sec]\")"
        ],
        "label": [
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            0,
            2,
            1,
            0,
            2,
            2,
            1,
            1,
            1
        ]
    },
    {
        "content": [
            "from sys import stdin",
            "input = stdin.readline",
            "from time import time",
            "from random import randint",
            "from copy import deepcopy",
            "start_time = time()",
            "def calcScore(t, s, c):",
            "    scores = [0]*26",
            "    lasts = [0]*26",
            "    for i in range(1, len(t)):",
            "        scores[t[i]] += s[i][t[i]]",
            "        dif = i - lasts[t[i]]",
            "        scores[t[i]] -= c[t[i]] * dif * (dif-1) // 2",
            "        lasts[t[i]] = i",
            "    for i in range(26):",
            "        dif = len(t) - lasts[i]",
            "        scores[i] -= c[i] * dif * (dif-1) // 2",
            "    return scores",
            "def greedy(c, s):",
            "    day_lim = len(s)",
            "    socres = [0]*26",
            "    t = [0]*day_lim",
            "    lasts = [0]*26",
            "    for i in range(1, day_lim):",
            "        pls = [v for v in socres]",
            "        mns = [v for v in socres]",
            "        for j in range(26):",
            "            pls[j] += s[i][j]",
            "            mns[j] -= c[j] * (i - lasts[j])",
            "        sum_mns = sum(mns)",
            "        pt = sum_mns - mns[0] + pls[0]",
            "        idx = 0",
            "        for j in range(1, 26):",
            "            tmp = sum_mns - mns[j] + pls[j]",
            "            if pt < tmp:",
            "                pt = tmp",
            "                idx = j",
            "        t[i] = idx",
            "        lasts[idx] = i",
            "        for j in range(26):",
            "            if j == idx:",
            "                socres[j] = pls[j]",
            "            else:",
            "                socres[j] = mns[j]",
            "    return socres, t",
            "def subGreedy(c, s, t, day):",
            "    day_lim = len(s)",
            "    socres = [0]*26",
            "    t = [0]*day_lim",
            "    lasts = [0]*26",
            "    for i in range(1, day_lim):",
            "        if day <= i:",
            "            pls = [v for v in socres]",
            "            mns = [v for v in socres]",
            "            for j in range(26):",
            "                pls[j] += s[i][j]",
            "                mns[j] -= c[j] * (i - lasts[j])",
            "            sum_mns = sum(mns)",
            "            pt = sum_mns - mns[0] + pls[0]",
            "            idx = 0",
            "            for j in range(1, 26):",
            "                tmp = sum_mns - mns[j] + pls[j]",
            "                if pt < tmp:",
            "                    pt = tmp",
            "                    idx = j",
            "            t[i] = idx",
            "            lasts[idx] = i",
            "            for j in range(26):",
            "                if j == idx:",
            "                    socres[j] = pls[j]",
            "                else:",
            "                    socres[j] = mns[j]",
            "        else:",
            "            scores[t[i]] += s[i][t[i]]",
            "            lasts[t[i]] = i",
            "            for j in range(26):",
            "                dif = i - lasts[j]",
            "                scores[j] -= c[j] * dif",
            "    return socres, t",
            "D = int(input())",
            "c = list(map(int, input().split()))",
            "s = [[0]*26 for _ in range(D+1)]",
            "for i in range(1, D+1):",
            "    s[i] = list(map(int, input().split()))",
            "scores, t = greedy(c, s)",
            "sum_score = sum(scores)",
            "while time() - start_time < 1.8:",
            "    tmp_t = deepcopy(t)",
            "    typ = randint(1, 100)",
            "    if typ <= 30:",
            "        for _ in range(1):",
            "            tmp_t[randint(1, D)] = randint(0, 25)",
            "        tmp_scores = calcScore(tmp_t, s, c)",
            "        sum_tmp_score = sum(tmp_scores)",
            "        if sum_score < sum_tmp_score:",
            "            sum_score = sum_tmp_score",
            "            t = tmp_t",
            "            scores = tmp_scores",
            "    elif typ <= 80:",
            "        dist = randint(1, 20)",
            "        p = randint(1, D-dist)",
            "        q = p + dist",
            "        tmp_t[p], tmp_t[q] = tmp_t[q], tmp_t[p]",
            "        tmp_scores = calcScore(tmp_t, s, c)",
            "        sum_tmp_score = sum(tmp_scores)",
            "        if sum_score < sum_tmp_score:",
            "            sum_score = sum_tmp_score",
            "            t = tmp_t",
            "            scores = tmp_scores",
            "    elif typ <= 100:",
            "        day = randint(D//4, D)",
            "        tmp_t = deepcopy(t)",
            "        tmp_scores, tmp_t = subGreedy(c, s, tmp_t, day)",
            "        sum_tmp_score = sum(tmp_scores)",
            "        if sum_score < sum_tmp_score:",
            "            sum_score = sum_tmp_score",
            "            t = tmp_t",
            "            scores = tmp_scores",
            "for v in t[1:]:",
            "    print(v+1)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# local search is all you need",
            "# 「日付 d とコンテストタイプ q をランダムに選び、d 日目に開催するコンテストをタイプ q に変更する」",
            "# このデメリット→変化させる量が小さすぎるとすぐに行き止まり (局所最適解) に陥ってしまい、逆に、変化させる量が 大きすぎると闇雲に探す状態に近くなって、改善できる確率が低くなってしまう。",
            "# 今回ならば、開催日が全体的に遠すぎず近すぎない感じのlocal minimumに収束する∵d日目のコンテストをi→jに変更したとする。iの開催期間はすごく伸びると2乗でスコアが下がるため、iの開催期間が比較的近いところのiしか選ばれない",
            "# →じゃ2点スワップを導入して改善してみよう",
            "from time import time",
            "t0 = time()",
            "import sys",
            "sys.setrecursionlimit(1 << 25)",
            "read = sys.stdin.readline",
            "ra = range",
            "enu = enumerate",
            "def exit(*argv, **kwarg):",
            "    print(*argv, **kwarg)",
            "    sys.exit()",
            "def mina(*argv, sub=1): return list(map(lambda x: x - sub, argv))",
            "# 受け渡されたすべての要素からsubだけ引く.リストを*をつけて展開しておくこと",
            "def a_int(): return int(read())",
            "def ints(): return list(map(int, read().split()))",
            "def read_col(H):",
            "    '''H is number of rows",
            "    A列、B列が与えられるようなとき",
            "    ex1)A,B=read_col(H)    ex2) A,=read_col(H) #一列の場合'''",
            "    ret = []",
            "    for _ in range(H):",
            "        ret.append(list(map(int, read().split())))",
            "    return tuple(map(list, zip(*ret)))",
            "def read_tuple(H):",
            "    '''H is number of rows'''",
            "    ret = []",
            "    for _ in range(H):",
            "        ret.append(tuple(map(int, read().split())))",
            "    return ret",
            "MOD = 10**9 + 7",
            "INF = 2**31  # 2147483648 > 10**9",
            "# default import",
            "from itertools import product, permutations, combinations",
            "from bisect import bisect_left, bisect_right  # , insort_left, insort_right",
            "from functools import reduce",
            "from random import randint, random",
            "def score(D, C, S, T):",
            "    last = [-1] * 26",
            "    # scores = [0]",
            "    score = 0",
            "    for d in range(D):",
            "        # scores.append(scores[-1] + S[d][T[d]])",
            "        score += S[d][T[d]]",
            "        last[T[d]] = d",
            "        for i in range(26):",
            "            # scores[-1] -= C[i] * (d - last[i])",
            "            score -= C[i] * (d - last[i])  # この場で一番罰則が大きいやつを使うとか？",
            "    return score",
            "D = a_int()",
            "C = ints()",
            "S = read_tuple(D)",
            "def maximizer(newT, bestT, bestscore):",
            "    tmpscore = score(D, C, S, newT)",
            "    if tmpscore > bestscore:",
            "        return newT, tmpscore",
            "    else:",
            "        return bestT, bestscore",
            "def ret_init_T():",
            "    '''greedyで作ったTを初期値とする。",
            "    return",
            "    ----------",
            "    T, score ... 初期のTとそのTで得られるscore",
            "    '''",
            "    def _make_T(n_days):",
            "        # editorialよりd日目の改善は、改善せずにd+n_days経過したときの関数にしたほうが",
            "        # 最終的なスコアと相関があるんじゃない？",
            "        T = []",
            "        last = [-1] * 26",
            "        for d in range(D):",
            "            ma = -INF",
            "            for i in range(26):",
            "                tmp = S[d][i]",
            "                for j in range(n_days):",
            "                    tmp += C[i] * (d + j - last[i])",
            "                if tmp > ma:",
            "                    t = i",
            "                    ma = tmp",
            "            last[t] = d  # Tを選んだあとで決める",
            "            T.append(t)",
            "        return T",
            "    T = _make_T(0)",
            "    sco = score(D, C, S, T)",
            "    for i in range(1, 20):",
            "        T, sco = maximizer(_make_T(i), T, sco)",
            "    return T, sco",
            "bestT, bestscore = ret_init_T()",
            "def add_noise(T, thre_p, days_near):",
            "    '''確率的にどちらかの操作を行う",
            "    1.日付dとコンテストqをランダムに選びd日目に開催するコンテストのタイプをqに変更する",
            "    2.10日以内の点でコンテストを入れ替える",
            "    thre_pはどちらの行動を行うかを調節、days_nearは近さのパラメータ'''",
            "    ret = T.copy()",
            "    if random() < thre_p:",
            "        d = randint(0, D - 1)",
            "        q = randint(0, 25)",
            "        ret[d] = q",
            "        return ret",
            "    else:",
            "        i = randint(0, D - 2)",
            "        j = randint(i - days_near, i + days_near)",
            "        j = max(j, 0)",
            "        j = min(j, D - 1)",
            "        if i == j:",
            "            j += 1",
            "        ret[i], ret[j] = ret[j], ret[i]",
            "        return ret",
            "while time() - t0 < 1.92:",
            "    # while time() - t0 < 5:",
            "    bestT, bestscore = maximizer(add_noise(bestT, 0.8, 8), bestT, bestscore)",
            "    # print(bestscore)",
            "# print(bestscore)",
            "# print(score(D, C, S, T))",
            "print(*mina(*bestT, sub=-1), sep='\\n')"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "import sys #再帰関数の上限,10**5以上の場合python",
            "import time",
            "t0=time.time()",
            "import random",
            "random.seed(2)",
            "def input():",
            "    x=sys.stdin.readline()",
            "    return x[:-1] if x[-1]==\"\\n\" else x",
            "def printe(*x):print(*x,file=sys.stderr)",
            "def printl(li): _=print(*li, sep=\"\\n\") if li else None",
            "def main():",
            "    mod = 1000000007",
            "    #w.sort(key=itemgetter(1),reversed=True)  #二個目の要素で降順並び替え",
            "    D = int(input())",
            "    #N, K = map(int, input().split())",
            "    cs = tuple(map(int, input().split())) #1行ベクトル",
            "    #L = tuple(int(input()) for i in range(N)) #改行ベクトル",
            "    S = tuple(tuple(map(int, input().split())) for i in range(D)) #改行行列",
            "    lss=[]",
            "    ls=[0]*26",
            "    anss=[-1]*D",
            "    for i in range(D):",
            "        s=S[i]",
            "        if i==0:",
            "            msc=-1000000",
            "            ans=-1",
            "            for j in range(26):",
            "                sc=s[j]+cs[j]",
            "                if msc<sc:",
            "                    ans=j",
            "                    msc=sc",
            "            ls[ans]=1",
            "            #lss.append(ls)",
            "            anss[i]=ans+1",
            "            continue",
            "        msc=0",
            "        ans=-1",
            "        dec=[-cs[j]*(i+1-ls[j]) for j in range(26)]",
            "        msc=-10000000",
            "        ans=-1",
            "        for j in range(26):",
            "            sc=s[j]-dec[j]",
            "            if msc<sc:",
            "                ans=j",
            "                msc=sc",
            "        ls[ans]=i+1",
            "        #lss.append(ls)",
            "        anss[i]=ans+1",
            "    def eval(anss):",
            "        ls=[0]*26",
            "        score=0",
            "        for i in range(D):",
            "            j=anss[i]-1",
            "            ls[j]=i+1",
            "            score+=S[i][j]",
            "            dec=sum([cs[k]*(i+1-ls[k]) for k in range(26)])",
            "            score-=dec",
            "        return score",
            "    def eval2(anss,score,target,val,pval):",
            "        score=score-S[target][pval-1]+S[target][val-1]",
            "        f1=0",
            "        f2=0",
            "        cp=cv=-1",
            "        if target>0:",
            "            for i in range(target-1,-1,-1):",
            "                a=anss[i]",
            "                if a==pval and not f1:",
            "                    cp=i",
            "                    f1=1",
            "                elif a==val and not f2:",
            "                    cv=i",
            "                    f2=1",
            "                if f1 and f2:",
            "                    break",
            "        f1=f2=0",
            "        csv=cs[val-1]",
            "        csp=cs[pval-1]",
            "        tcv=(target-cv)*csv",
            "        tcp=(target-cp)*csp",
            "        score+=tcv-tcp",
            "        for i in range(target+1,D):",
            "            a=anss[i]",
            "            if anss[i]==pval and not f2:",
            "                f2=1",
            "            elif anss[i]==val and not f1:",
            "                f1=1",
            "            if not f1:",
            "                score+=tcv",
            "            if not f2:",
            "                score-=tcp",
            "            if f1 and f2:",
            "                break",
            "        return score",
            "    csc=eval(anss)",
            "    #nans=copy(anss)",
            "    yaki=1000.0",
            "    count=0",
            "    abest=anss.copy()",
            "    tsc=csc",
            "    lc=0",
            "    mc=10000",
            "    while 1:",
            "        count+=1",
            "        target=random.randrange(0,D)",
            "        pval=anss[target]",
            "        target2=target",
            "        pval2=pval",
            "        while pval2==pval:",
            "            target2=random.randrange(0,D)",
            "            pval2=anss[target2]",
            "        val=pval",
            "        val2=pval2",
            "        while val==pval or val==pval2:",
            "            val=random.randrange(0,26)+1",
            "        while val2==pval or val2==pval2 or val2==val:",
            "            val2=random.randrange(0,26)+1",
            "        #val=pval",
            "        #nans[target]=val",
            "        #printe(target,val,pval,target2,val2,pval2)",
            "        nsc=eval2(anss,tsc,target,val,pval)",
            "        nsc=eval2(anss,nsc,target2,val2,pval2)",
            "        if nsc>csc:",
            "            csc=nsc",
            "            tsc=nsc",
            "            anss[target]=val",
            "            anss[target2]=val2",
            "            abest=anss.copy()",
            "            lc=count",
            "        else:",
            "            r=random.random()",
            "            if r<2**(-(csc-nsc)/(yaki+1e-9)):",
            "                anss[target]=val",
            "                anss[target2]=val2",
            "                tsc=nsc",
            "            if count-lc>mc:",
            "                anss=abest.copy()",
            "                tsc=csc",
            "                lc=count",
            "        if time.process_time()>1.95:",
            "            break",
            "    printl(abest)",
            "    return",
            "    #printe(csc,count,lc,abest[0])",
            "    #printe(eval(anss))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "import sys, re",
            "from collections import deque, defaultdict, Counter",
            "from math import exp, ceil, sqrt, hypot, factorial, pi, sin, cos, radians, gcd, e",
            "from itertools import accumulate, permutations, combinations, product, groupby, combinations_with_replacement",
            "from operator import itemgetter, mul",
            "from copy import deepcopy",
            "from string import ascii_lowercase, ascii_uppercase, digits",
            "from bisect import bisect, bisect_left",
            "from heapq import heappush, heappop",
            "from functools import reduce",
            "import random",
            "import time",
            "def input(): return sys.stdin.readline().strip()",
            "def INT(): return int(input())",
            "def MAP(): return map(int, input().split())",
            "def LIST(): return list(map(int, input().split()))",
            "def ZIP(n): return zip(*(MAP() for _ in range(n)))",
            "sys.setrecursionlimit(10 ** 9)",
            "INF = float('inf')",
            "mod = 10 ** 9 + 7",
            "start = time.time()",
            "D = INT()",
            "C = LIST()",
            "s = [LIST() for _ in range(D)]",
            "def compute_score(out):",
            "    score = 0",
            "    last = [0]*26",
            "    for d in range(D):",
            "        last[out[d]] = d+1",
            "        for i in range(26):",
            "            score -= (d+1-last[i])*c[i]",
            "        score += s[d][out[d]]",
            "    return score",
            "def decrease(d, j):  # d:日にち, j:開催するコンテスト",
            "    tmp = 0",
            "    for i in range(26):",
            "        if i == j: continue",
            "        tmp += C[i]*(d-last[i])",
            "    return tmp",
            "def init():  # 貪欲でとった解を1度保存する",
            "    global now",
            "    for i in range(D):  # i+1日目",
            "        ma = -INF",
            "        ma_idx = None",
            "        for j in range(26):  # 開催するコンテスト",
            "            tmp = now",
            "            tmp += s[i][j]",
            "            tmp -= decrease(i+1, j)",
            "            if tmp > ma:",
            "                ma = tmp",
            "                ma_idx = j",
            "        now = ma",
            "        last[ma_idx] = i+1",
            "        score[ma_idx] += s[i][ma_idx]",
            "        for j in range(26):",
            "            score[j] -= C[j]*(i+1-last[j])",
            "        last[ma_idx] = i+1",
            "        ans[i] = ma_idx+1",
            "def update(d, q):  # d日目のところをqに変更する",
            "    d -= 1",
            "    q -= 1",
            "    c = ans[d]-1  # c:更新前",
            "    ans[d] = q+1",
            "    last_c = 0",
            "    last_q = 0",
            "    score_c = 0",
            "    score_q = 0",
            "    for j in range(D):",
            "        if ans[j]-1 == c:",
            "            last_c = j+1",
            "            score_c += s[j][c]",
            "        elif ans[j]-1 == q:",
            "            last_q = j+1",
            "            score_q += s[j][q]",
            "        score_c -= C[c] * (j+1 - last_c)",
            "        score_q -= C[q] * (j+1 - last_q)",
            "    score[c] = score_c",
            "    score[q] = score_q",
            "def swap(d):  # d日目とd+1日目の開催を入れ替える",
            "    update(d, ans[d])",
            "    update(d+1, ans[d-1])",
            "ans = [0]*D",
            "last = [0]*26",
            "score = [0]*26",
            "now = 0",
            "init()",
            "TL = 1.8 - (time.time()-start)",
            "start = time.time()",
            "T0 = 2e3",
            "T1 = 6e2",
            "T = T0",
            "randint = random.randint",
            "rand = random.random",
            "while 1:",
            "    t = (time.time()-start)/TL",
            "    if t >= 1:",
            "        break",
            "    T = pow(T0, 1-t)*pow(T1, t)",
            "    if rand() < 0.5:  # 1点変更",
            "        d = randint(1, D)",
            "        q = randint(1, 26)",
            "        old = ans[d-1]",
            "        old_score = score.copy()",
            "        s_old = sum(score)",
            "        update(d, q)",
            "        s_new = sum(score)",
            "        if s_new <= s_old and exp((s_new-s_old)/T) <= rand():  # 戻す確率",
            "            score = old_score",
            "            ans[d-1] = old",
            "    else:  # 2点入れ替え",
            "        d = randint(1, D-1)",
            "        old = ans[d-1]",
            "        old_score = score.copy()",
            "        s_old = sum(score)",
            "        swap(d)",
            "        s_new = sum(score)",
            "        if s_new <= s_old and exp((s_new-s_old)/T) <= rand():",
            "            score = old_score",
            "            ans[d-1] = old",
            "print(*ans, sep=\"\\n\")"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2
        ]
    },
    {
        "content": [
            "# large n_trials is all you need",
            "# local searchをたくさんするためにcost計算のさらなる高速化を考えてみる",
            "# online judgeの環境ではサチるほど探索されていたみたいで改善されなかった",
            "from time import time",
            "t0 = time()",
            "import sys",
            "sys.setrecursionlimit(1 << 25)",
            "read = sys.stdin.readline",
            "ra = range",
            "enu = enumerate",
            "def exit(*argv, **kwarg):",
            "    print(*argv, **kwarg)",
            "    sys.exit()",
            "def mina(*argv, sub=1): return list(map(lambda x: x - sub, argv))",
            "# 受け渡されたすべての要素からsubだけ引く.リストを*をつけて展開しておくこと",
            "def a_int(): return int(read())",
            "def ints(): return list(map(int, read().split()))",
            "def read_col(H):",
            "    '''H is number of rows",
            "    A列、B列が与えられるようなとき",
            "    ex1)A,B=read_col(H)    ex2) A,=read_col(H) #一列の場合'''",
            "    ret = []",
            "    for _ in range(H):",
            "        ret.append(list(map(int, read().split())))",
            "    return tuple(map(list, zip(*ret)))",
            "def read_tuple(H):",
            "    '''H is number of rows'''",
            "    ret = []",
            "    for _ in range(H):",
            "        ret.append(tuple(map(int, read().split())))",
            "    return ret",
            "MOD = 10**9 + 7",
            "INF = 2**31  # 2147483648 > 10**9",
            "# default import",
            "from itertools import product, permutations, combinations",
            "from bisect import bisect_left, bisect_right, insort_left",
            "from functools import reduce",
            "from random import randint, random",
            "D = a_int()",
            "C = ints()",
            "S = read_tuple(D)",
            "def T_to_date_by_contest(T):",
            "    '''Tを日付形式にしつつscoreも計算'''",
            "    date_by_contest = [[-1] for _ in range(26)]",
            "    for d, t in enumerate(T):",
            "        date_by_contest[t].append(d)",
            "    for i in range(26):",
            "        date_by_contest[i].append(D)  # 番兵",
            "    return date_by_contest",
            "def eval(D, C, S, date_by_contest):",
            "    '''2~3*D回のループでスコアを計算する'''",
            "    score = 0",
            "    for c, dates in enu(date_by_contest):",
            "        for d in dates[1:-1]:",
            "            score += S[d][c]",
            "        for i in range(len(dates) - 1):",
            "            dd = (dates[i + 1] - dates[i])",
            "            # for ddd in range(dd):",
            "            #     score -= C[c] * (ddd)",
            "            score -= C[c] * (dd - 1) * dd // 2",
            "    return score",
            "def maximizer(newT, bestT, bestscore):",
            "    '''具体的なTの最大化用'''",
            "    tmpscore = eval(D, C, S, T_to_date_by_contest(newT))",
            "    if tmpscore > bestscore:",
            "        return newT, tmpscore",
            "    else:",
            "        return bestT, bestscore",
            "def ret_init_T():",
            "    '''greedyで作ったTを初期値とする。",
            "    return",
            "    ----------",
            "    T, score ... 初期のTとそのTで得られるscore",
            "    '''",
            "    def _make_T(n_days):",
            "        # editorialよりd日目の改善は、改善せずにd+n_days経過したときの関数にしたほうが",
            "        # 最終的なスコアと相関があるんじゃない？",
            "        T = []",
            "        last = [-1] * 26",
            "        for d in range(D):",
            "            ma = -INF",
            "            for i in range(26):",
            "                tmp = S[d][i]",
            "                dd = d - last[i]",
            "                tmp += C[i] * (((dd + n_days + dd) * (n_days) // 2))",
            "                if tmp > ma:",
            "                    t = i",
            "                    ma = tmp",
            "            last[t] = d  # Tを選んだあとで決める",
            "            T.append(t)",
            "        return T",
            "    T = _make_T(2)",
            "    sco = eval(D, C, S, T_to_date_by_contest(T))",
            "    for i in range(3, 16):",
            "        T, sco = maximizer(_make_T(i), T, sco)",
            "    return T, sco",
            "class Schedule:",
            "    def __init__(self, T: list, date_by_contest, score: int):",
            "        self.T = T",
            "        self.date_by_contest = date_by_contest",
            "        self.score = score",
            "    def try_change_contest(self, d, j):",
            "        '''d日目をjに変更したときのscore'''",
            "        score = self.score",
            "        i = self.T[d]  # コンテストi→jに変化する",
            "        if i == j:",
            "            return score  # 変化しないので",
            "        score += S[d][j] - S[d][i]",
            "        # iの変化についてscoreを計算し直す",
            "        # d_i_idx = bisect_left(self.date_by_contest[i], d)  # iにおけるdのindex",
            "        d_i_idx = self.date_by_contest[i].index(d)  # iにおけるdのindex",
            "        dd = self.date_by_contest[i][d_i_idx + 1] - \\",
            "            self.date_by_contest[i][d_i_idx - 1]",
            "        score -= C[i] * (dd - 1) * dd // 2",
            "        dd = self.date_by_contest[i][d_i_idx + 1] - d",
            "        score += C[i] * (dd - 1) * dd // 2",
            "        dd = d - self.date_by_contest[i][d_i_idx - 1]",
            "        score += C[i] * (dd - 1) * dd // 2",
            "        # jの変化についてscoreを計算し直す",
            "        d_j_idx = bisect_left(self.date_by_contest[j], d)",
            "        dd = self.date_by_contest[j][d_j_idx] - \\",
            "            self.date_by_contest[j][d_j_idx - 1]",
            "        score += C[j] * (dd - 1) * dd // 2",
            "        dd = self.date_by_contest[j][d_j_idx] - d",
            "        score -= C[j] * (dd - 1) * dd // 2",
            "        dd = d - self.date_by_contest[j][d_j_idx - 1]",
            "        score -= C[j] * (dd - 1) * dd // 2",
            "        return score",
            "    def change_contest(self, d, j):",
            "        '''d日目をjに変更する'''",
            "        self.score = self.try_change_contest(d, j)",
            "        i = self.T[d]",
            "        self.T[d] = j",
            "        self.date_by_contest[i].remove(d)",
            "        insort_left(self.date_by_contest[j], d)",
            "def trial(sche, thre_p, days_near):",
            "    '''確率的にどちらかの操作を行ってよかったらScheduleを更新する",
            "    1.日付dとコンテストqをランダムに選びd日目に開催するコンテストのタイプをqに変更する",
            "    2.10日以内の点でコンテストを入れ替える",
            "    thre_pはどちらの行動を行うかを調節、days_nearは近さのパラメータ'''",
            "    if random() < thre_p:",
            "        # 一点更新",
            "        d = randint(0, D - 1)",
            "        q = randint(0, 25)",
            "        if sche.score < sche.try_change_contest(d, q):",
            "            sche.change_contest(d, q)",
            "        return sche  # 参照渡しだから変わらんけどね",
            "    else:",
            "        T = sche.T.copy()",
            "        i = randint(0, D - 2)",
            "        j = randint(i - days_near, i + days_near)",
            "        j = max(j, 0)",
            "        j = min(j, D - 1)",
            "        if i == j:",
            "            j += 1",
            "        T[i], T[j] = T[j], T[i]",
            "        new_score = eval(D, C, S, T_to_date_by_contest(T))",
            "        if sche.score < new_score:",
            "            return Schedule(T, T_to_date_by_contest(T), new_score)",
            "        else:",
            "            return sche",
            "bestT, bestscore = ret_init_T()",
            "sche = Schedule(bestT, T_to_date_by_contest(bestT), bestscore)",
            "while time() - t0 < 1.92:",
            "    for _ in range(1000):",
            "        sche = trial(sche, 0.9, 20)",
            "# print(sche.score)",
            "# print(score(D, C, S, T))",
            "print(*mina(*sche.T, sub=-1), sep='\\n')"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "# 貪欲法 + 山登り法 + 3点スワップ操作",
            "import time",
            "s__ = time.time()",
            "limit = 1.9",
            "#limit = 10",
            "from numba import njit",
            "import numpy as np",
            "d = int(input())",
            "cs = list(map(int, input().split()))",
            "cs = np.array(cs, dtype=np.int64)",
            "sm = [list(map(int, input().split())) for _ in range(d)]",
            "sm = np.array(sm, dtype=np.int64)",
            "@njit('i8(i8[:], i8)', cache=True)",
            "def total_satisfaction(ts, d):",
            "    ls = np.zeros(26, dtype=np.int64)",
            "    s = 0",
            "    for i in range(d):",
            "        t = ts[i]",
            "        t -= 1",
            "        s += sm[i][t]",
            "        ls[t] = i + 1",
            "        dv = cs * ((i+1) - ls)",
            "        s -= dv.sum()",
            "    return s",
            "@njit('i8[:]()', cache=True)",
            "def greedy():",
            "    ts = np.array([0] * d, dtype=np.int64)",
            "    for i in range(d):",
            "        mx = -1e10",
            "        mxt = None",
            "        for t in range(1, 26+1):",
            "            ts[i] = t",
            "            s = total_satisfaction(ts, i + 1)",
            "            if s > mx:",
            "                mx = s",
            "                mxt = t",
            "        ts[i] = mxt",
            "    return ts",
            "@njit('i8(i8, i8[:])', cache=True)",
            "def loop(mxsc, ts):",
            "    it = 100",
            "    rds = np.random.randint(0, 6, (it,))",
            "    rdd = np.random.randint(1, d, (it,))",
            "    rdq = np.random.randint(1, 26, (it,))",
            "    rdx = np.random.randint(1, 12, (it,))",
            "    rdy = np.random.randint(1, 12, (it,))",
            "    c1 = 0",
            "    c2 = 3",
            "    for i in range(it):",
            "        bk1 = 0",
            "        bk2 = 0",
            "        bk3 = 0",
            "        if rds[0] <= c1:",
            "            # trailing",
            "            di = rdd[i]",
            "            qi = rdq[i]",
            "            bk1 = ts[di]",
            "            ts[di] = qi",
            "        elif rds[0] <= c2:",
            "            # swap",
            "            di = rdd[i]",
            "            xi = rdx[i]",
            "            if di + xi >= d:",
            "                xi = di - xi",
            "            else:",
            "                xi = di + xi",
            "            bk1 = ts[di]",
            "            bk2 = ts[xi]",
            "            ts[di] = bk2",
            "            ts[xi] = bk1",
            "        else:",
            "            # triswap",
            "            di = rdd[i]",
            "            xi = rdx[i]",
            "            if di + xi >= d:",
            "                xi = di - xi",
            "            else:",
            "                xi = di + xi",
            "            yi = rdy[i]",
            "            if xi + yi >= d:",
            "                yi = xi - yi",
            "            else:",
            "                yi = xi + yi",
            "            bk1 = ts[di]",
            "            bk2 = ts[xi]",
            "            bk3 = ts[yi]",
            "            ts[di] = bk2",
            "            ts[xi] = bk3",
            "            ts[yi] = bk1",
            "        sc = total_satisfaction(ts, d)",
            "        if sc > mxsc:",
            "            #print(mxsc, '->', sc)",
            "            mxsc = sc",
            "        else:",
            "            # 最大値を更新しなかったら戻す",
            "            if rds[0] <= c1:",
            "                ts[di] = bk1",
            "            elif rds[0] <= c2:",
            "                ts[di] = bk1",
            "                ts[xi] = bk2",
            "            else:",
            "                ts[di] = bk1",
            "                ts[xi] = bk2",
            "                ts[yi] = bk3",
            "    return mxsc",
            "ts = greedy()",
            "mxsc = total_satisfaction(ts, d)",
            "mxbk = mxsc",
            "s_ = time.time()",
            "mxsc = loop(mxsc, ts)",
            "e_ = time.time()",
            "consume = s_ - s__",
            "elapsed = e_ - s_",
            "#print('consume:', consume)",
            "#print('elapsed:', elapsed)",
            "if consume < limit:",
            "    lp = int((limit - consume) / elapsed)",
            "    #print('loop', lp)",
            "    for _ in range(lp):",
            "        mxsc = loop(mxsc, ts)",
            "for t in ts:    print(t)",
            "#print(mxbk, mxsc)",
            "#print(time.time() - s__)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "from random import randint",
            "import sys",
            "input = sys.stdin.readline",
            "INF = 9223372036854775808",
            "def calc_score(D, C, S, T):",
            "    \"\"\"",
            "    開催日程Tを受け取ってそこまでのスコアを返す",
            "    コンテストi 0-indexed",
            "    d 0-indexed",
            "    \"\"\"",
            "    score = 0",
            "    last = [0]*26  # コンテストiを前回開催した日",
            "    for d, t in enumerate(T):",
            "        last[t] = d + 1",
            "        for i in range(26):",
            "            score -= (d + 1 - last[i]) * C[i]",
            "        score += S[d][t]",
            "    return score",
            "def update_score(D, C, S, T, score, ct, ci):",
            "    \"\"\"",
            "    ct日目のコンテストをコンテストciに変更する",
            "    スコアを差分更新する",
            "    ct: change t 変更日 0-indexed",
            "    ci: change i 変更コンテスト 0-indexed",
            "    \"\"\"",
            "    new_score = score",
            "    last = [0]*26  # コンテストiを前回開催した日",
            "    prei = T[ct]  # 変更前に開催する予定だったコンテストi",
            "    for d, t in enumerate(T, start=1):",
            "        last[t] = d",
            "        new_score += (d - last[prei])*C[prei]",
            "        new_score += (d - last[ci])*C[ci]",
            "    last = [0]*26",
            "    for d, t in enumerate(T, start=1):",
            "        if d-1 == ct:",
            "            last[ci] = d",
            "        else:",
            "            last[t] = d",
            "        new_score -= (d - last[prei])*C[prei]",
            "        new_score -= (d - last[ci])*C[ci]",
            "    new_score -= S[ct][prei]",
            "    new_score += S[ct][ci]",
            "    return new_score",
            "def evaluate(D, C, S, T, k):",
            "    \"\"\"",
            "    d日目終了時点での満足度を計算し，",
            "    d + k日目終了時点での満足度の減少も考慮する",
            "    \"\"\"",
            "    score = 0",
            "    last = [0]*26",
            "    for d, t in enumerate(T):",
            "        last[t] = d + 1",
            "        for i in range(26):",
            "            score -= (d + 1 - last[i]) * C[i]",
            "        score += S[d][t]",
            "    for d in range(len(T), min(len(T) + k, D)):",
            "        for i in range(26):",
            "            score -= (d + 1 - last[i]) * C[i]",
            "    return score",
            "def greedy(D, C, S):",
            "    Ts = []",
            "    for k in range(7, 9):",
            "        T = []  # 0-indexed",
            "        max_score = -INF",
            "        for d in range(D):",
            "            # d+k日目終了時点で満足度が一番高くなるようなコンテストiを開催する",
            "            max_score = -INF",
            "            best_i = 0",
            "            for i in range(26):",
            "                T.append(i)",
            "                score = evaluate(D, C, S, T, k)",
            "                if max_score < score:",
            "                    max_score = score",
            "                    best_i = i",
            "                T.pop()",
            "            T.append(best_i)",
            "        Ts.append((max_score, T))",
            "    return max(Ts, key=lambda pair: pair[0])",
            "def local_search(D, C, S, score, T):",
            "    for k in range(85000):",
            "        sel = randint(1, 2)",
            "        if sel == 1:",
            "            # ct 日目のコンテストをciに変更",
            "            ct = randint(0, D-1)",
            "            ci = randint(0, 25)",
            "            new_score = update_score(D, C, S, T, score, ct, ci)",
            "            if score < new_score:",
            "                T[ct] = ci",
            "                score = new_score",
            "        else:",
            "            # ct1 日目と ct2 日目のコンテストをswap",
            "            ct1 = randint(0, D-1)",
            "            ct2 = randint(0, D-1)",
            "            ci1 = T[ct1]",
            "            ci2 = T[ct2]",
            "            new_score = update_score(D, C, S, T, score, ct1, ci2)",
            "            new_score = update_score(D, C, S, T, new_score, ct2, ci1)",
            "            if score < new_score:",
            "                score = new_score",
            "                T[ct1] = ci2",
            "                T[ct2] = ci1",
            "    return T",
            "if __name__ == '__main__':",
            "    D = int(input())",
            "    C = [int(i) for i in input().split()]",
            "    S = [[int(i) for i in input().split()] for j in range(D)]",
            "    init_score, T = greedy(D, C, S)",
            "    T = local_search(D, C, S, init_score, T)",
            "    for t in T:",
            "        print(t+1)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "content": [
            "test = False",
            "from time import time",
            "start = time()",
            "import sys",
            "import random",
            "def solve(c_list, days, now):",
            "    r = sum(c_list[i]*(now-days[i]) for i in range(26))",
            "    return r",
            "if test == True:",
            "    #seed = 94",
            "    #random.seed(seed)",
            "    d = 365",
            "    c = [random.randrange(0, 101) for _ in range(26)]",
            "    s = [[random.randrange(0, 20001) for _ in range(26)] for _ in range(d)]",
            "    c_ = ' '.join(map(str, c))",
            "    s_ = '\\n'.join([' '.join(map(str, i)) for i in s])",
            "    with open('./input.txt', 'w') as f:",
            "        f.write('\\n'.join([str(d), c_, s_]))",
            "else:",
            "    d = int(input())",
            "    c = list(map(int, input().split()))",
            "    s = [list(map(int, input().split())) for _i in range(d)]",
            "last_days = [-1 for _i in range(26)]",
            "result = []",
            "score = 0",
            "for today in range(d):",
            "    checker = [c[j]*(today-last_days[j]) for j in range(26)]",
            "    y = sum(checker)",
            "    finder = [s[today][j]-(y-checker[j]) for j in range(26)]",
            "    x = finder.index(max(finder))",
            "    if today < d-1:",
            "        second_checker = [c[j]*(today+1-last_days[j]) for j in range(26)]",
            "        second_finder = [s[today+1][j]-(y-checker[j]) for j in range(26)]",
            "        second_x = second_finder.index(max(second_finder))",
            "        if x == second_finder:",
            "            x = finder.index(sorted(finder)[-2])",
            "    last_days[x] = today",
            "    result.append(x+1)",
            "    score += s[today][x] - solve(c, last_days, today)",
            "if test:",
            "    print(score)",
            "def change(problems, days):",
            "    last_days = [-1 for _i in range(26)]",
            "    score = 0",
            "    for i in range(d):",
            "        score += s[i][problems[i]-1]",
            "        last_days[problems[i]-1] = i",
            "        score -= sum([c[j]*(i-last_days[j]) for j in range(26)])",
            "    return score",
            "change_list = result.copy()",
            "while time()-start < 1.9:",
            "    if random.randrange(2)<1:",
            "        x, y = random.randrange(0, d), random.randrange(0, d)",
            "        while x == y:",
            "            y = random.randrange(0, d)",
            "        change_list[x], change_list[y] = change_list[y], change_list[x]",
            "        next_score = change(change_list, d)",
            "        if next_score >= score:",
            "            if test:print(score, next_score, abs(next_score-score), 'two')",
            "            score = next_score",
            "            result[x], result[y] = result[y], result[x]",
            "        else:",
            "            change_list[x], change_list[y] = change_list[y], change_list[x]",
            "    else:",
            "        x = random.randrange(0, d)",
            "        y = random.randrange(1, 27)",
            "        while change_list[x] == y:",
            "            x = random.randrange(0, d)",
            "            y = random.randrange(1, 27)",
            "        change_list[x], z = y, change_list[x]",
            "        next_score = change(change_list, d)",
            "        if next_score >= score:",
            "            if test:print(score, next_score, abs(next_score-score), 'one')",
            "            score = next_score",
            "            result[x] = y",
            "        else:",
            "            change_list[x] = z",
            "if test == True:",
            "    with open('./output.txt', 'w') as f:",
            "        f.write('\\n'.join(map(str, result)))",
            "else:",
            "    for i in result:",
            "        print(i)",
            "if test:",
            "    elapsed_time = time() - start",
            "    print (\"elapsed_time:{0}\".format(elapsed_time) + \"[sec]\")"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            2,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            0,
            2,
            1,
            0,
            2,
            2,
            1,
            1
        ]
    },
    {
        "content": [
            "# strat_annealing",
            "import sys",
            "input = sys.stdin.readline",
            "import numpy as np",
            "from numba import njit",
            "def read():",
            "    D = int(input().strip())",
            "    C = np.fromstring(input().strip(), dtype=np.int32, sep=\" \")",
            "    S = np.empty((D, 26), dtype=np.int32)",
            "    for i in range(D):",
            "        s = np.fromstring(input().strip(), dtype=np.int32, sep=\" \")",
            "        S[i, :] = s[:]",
            "    M = 400000",
            "    RD = np.random.randint(D, size=(M, ), dtype=np.int32)",
            "    RQ = np.random.randint(26, size=(M, ), dtype=np.int32)",
            "    DQ = np.stack([RD, RQ]).T",
            "    COND = np.random.randint(2, size=(M, ), dtype=np.bool)",
            "    SA_COND = np.random.uniform(size=(M, ))",
            "    return D, C, S, M, DQ, COND, SA_COND",
            "@njit",
            "def diff_satisfaction(C, S, d, p, last):",
            "    \"\"\"d日目にコンテストpを開催するときの、満足度の更新量を求める",
            "    \"\"\"",
            "    v = 0",
            "    for i in range(26):",
            "        v -= C[i] * (d - last[i])",
            "    v += C[p] * (d - last[p])",
            "    v += S[d, p]",
            "    return v",
            "@njit",
            "def evaluate(D, C, S, d, p, last, k=13):",
            "    \"\"\"d日目にコンテストpを開催し、その後d+k日目までコンテストが開催されないときの、満足度の更新差分を求める",
            "    \"\"\"",
            "    v = diff_satisfaction(C, S, d, p, last)",
            "    for e in range(d+1, min(d+k, D)):",
            "        for i in range(26):",
            "            v -= C[i] * (e - last[i])",
            "        v += C[p] * (d - last[p])",
            "    return v",
            "@njit",
            "def greedy_fine(D, C, S):",
            "    T = np.zeros(D, dtype=np.int32)",
            "    last = -np.ones(26, dtype=np.int32)",
            "    cumsat = 0",
            "    for d in range(D):",
            "        max_p = 0",
            "        max_e = -999999999",
            "        # select contest greedily",
            "        for p in range(26):",
            "            e = evaluate(D, C, S, d, p, last, k=8)",
            "            if e > max_e:",
            "                max_p = p",
            "                max_e = e",
            "        # update schedule",
            "        cumsat += diff_satisfaction(C, S, d, max_p, last)",
            "        T[d] = max_p",
            "        last[max_p] = d",
            "    return cumsat, T",
            "@njit",
            "def update(D, C, S, T, d, q, cumsat):",
            "    \"\"\"1点更新: d日目のコンテストをqに変更する",
            "    \"\"\"",
            "    p = T[d]",
            "    dp1, dq1 = -1, -1",
            "    dp3, dq3 = D, D",
            "    for i in range(0, d):",
            "        if T[i] == p:",
            "            dp1 = i",
            "        if T[i] == q:",
            "            dq1 = i",
            "    for i in range(D-1, d, -1):",
            "        if T[i] == p:",
            "            dp3 = i",
            "        if T[i] == q:",
            "            dq3 = i",
            "    cumsat = cumsat - S[d, p] + S[d, q] - C[p] * (dp3-d) * (d-dp1) + C[q] * (dq3-d) * (d-dq1)",
            "    return cumsat",
            "@njit",
            "def swap(D, C, S, T, d0, p0, d1, p1, cumsat):",
            "    \"\"\"2点スワップ: d0日目のコンテストp0とd1日目のコンテストp1を交換する",
            "    \"\"\"",
            "    cumsat = update(D, C, S, T, d0, p1, cumsat)",
            "    cumsat = update(D, C, S, T, d1, p0, cumsat)",
            "    return cumsat",
            "@njit",
            "def greedy(D, C, S):",
            "    T = np.zeros(D, dtype=np.int32)",
            "    last = -np.ones(26, dtype=np.int32)",
            "    cumsat = 0",
            "    for d in range(D):",
            "        max_p = 0",
            "        max_diff = -999999999",
            "        # select contest greedily",
            "        for p in range(26):",
            "            diff = diff_satisfaction(C, S, d, p, last)",
            "            if diff > max_diff:",
            "                max_p = p",
            "                max_diff = diff",
            "        # update schedule",
            "        cumsat += max_diff",
            "        T[d] = max_p",
            "        last[max_p] = d",
            "    return cumsat, T",
            "@njit",
            "def sa_proba(delta, t):",
            "    if delta >= 0:",
            "        return 1.0",
            "    else:",
            "        return np.exp(delta / t)",
            "@njit",
            "def solve(D, C, S, M, DQ, COND, SA_COND):",
            "    cumsat, T = greedy(D, C, S)",
            "    # 初期温度",
            "    SA_T0 = 2e3",
            "    # 終了温度",
            "    SA_T1 = 6e2",
            "    # 一定温度を保つステップ数",
            "    SA_STEP = 100",
            "    t = SA_T0",
            "    for i in range(M):",
            "        if i % SA_STEP == 0:",
            "            f = i / M",
            "            t = (SA_T0 ** (1.0 - f)) * (SA_T1 ** f)",
            "        d, q = DQ[i, :]",
            "        if COND[i] >= 1:",
            "            newsat = update(D, C, S, T, d, q, cumsat)",
            "            # if newsat - cumsat > 0:",
            "            if sa_proba(newsat - cumsat, t) > SA_COND[i]:",
            "                cumsat = newsat",
            "                T[d] = q",
            "        else:",
            "            d0, d1 = d, min(d+1+q//2, D-1)",
            "            newsat = swap(D, C, S, T, d0, T[d0], d1, T[d1], cumsat)",
            "            # if newsat - cumsat > 0:",
            "            if sa_proba(newsat - cumsat, t) > SA_COND[i]:",
            "                cumsat = newsat",
            "                T[d1], T[d0] = T[d0], T[d1]",
            "    for a in T:",
            "        print(a+1)",
            "if __name__ == '__main__':",
            "    inputs = read()",
            "    outputs = solve(*inputs)",
            "    if outputs is not None:",
            "        print(\"%s\" % str(outputs))"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            0
        ]
    },
    {
        "content": [
            "#!python3",
            "from time import perf_counter",
            "limit = 1.90",
            "tick = perf_counter()",
            "import sys",
            "iim = lambda: map(int, sys.stdin.readline().rstrip().split())",
            "from random import randrange",
            "from bisect import bisect",
            "def resolve():",
            "    G = 26",
            "    it = map(int, sys.stdin.read().split())",
            "    D = next(it)",
            "    C = [next(it) for i in range(G)]",
            "    S = [[next(it) for i in range(G)] for i in range(D)]",
            "    L = [[-1] for i in range(G)]",
            "    T = [0] * D",
            "    def update(di, qi):",
            "        score = 0",
            "        t0 = T[di]",
            "        score += S[di][qi]-S[di][t0]",
            "        a1 = li = L[t0][:]",
            "        ii = li.index(di)",
            "        la = D if len(li)-1 == ii else li[ii+1]",
            "        score -= C[t0] * (di-li[ii-1])*(la-di)",
            "        li.pop(ii)",
            "        a2 = li = L[qi][:]",
            "        ii = bisect(li, di)",
            "        li.insert(ii, di)",
            "        la = D if len(li)-1 == ii else li[ii+1]",
            "        score += C[qi] * (di-li[ii-1])*(la-di)",
            "        return score, (a1, a2)",
            "    def update2(di, qi):",
            "        score = 0",
            "        t0 = T[di]",
            "        score += S[di][qi]-S[di][t0]",
            "        a1 = li = L[t0][:]",
            "        ii = li.index(di)",
            "        la = D if len(li)-1 == ii else li[ii+1]",
            "        score -= C[t0] * (di-li[ii-1])*(la-di)",
            "        li.pop(ii)",
            "        a2 = li = L[qi][:]",
            "        ii = bisect(li, di)",
            "        li.insert(ii, di)",
            "        la = D if len(li)-1 == ii else li[ii+1]",
            "        score += C[qi] * (di-li[ii-1])*(la-di)",
            "        return score, {t0: a1, qi: a2}",
            "    def sa(diff):",
            "        d0 = dict()",
            "        score = 0",
            "        tt = dict()",
            "        #while score > diff:",
            "        for i in range(randrange(3, 10)):",
            "            di, qi = randrange(0, D), randrange(0, G)",
            "            diff, d1 = update2(di, qi)",
            "            score += diff",
            "            if not di in tt:",
            "                tt[di] = T[di]",
            "            T[di] = qi",
            "            if score > 0:",
            "                for k, v in d1.items():",
            "                    L[k] = v",
            "                return score",
            "            for k, v in d1.items():",
            "                if not k in d0:",
            "                    d0[k] = L[k]",
            "                L[k] = v",
            "        # give up restore",
            "        for k, v in tt.items(): T[k] = v",
            "        for k, v in d0.items(): L[k] = v",
            "        return 0",
            "    U = 7",
            "    def calc(i, j):",
            "        score = S[i][j]",
            "        for k in range(G):",
            "            u = k - L[k][-1]",
            "            score -= C[k] * (u + u + U) * U // 2",
            "        score += C[k] * U * (i-L[j][-1])",
            "        return score",
            "    def dswap(di, dj):",
            "        qi, qj = T[di], T[dj]",
            "        swap0 = (L[qi], L[qj])",
            "        score, swap1 = update(di, qj)",
            "        T[di] = qj",
            "        L[qi], L[qj] = swap1",
            "        diff, swap2 = update(dj, qi)",
            "        score += diff",
            "        if score > 0:",
            "            T[dj] = qi",
            "            L[qj], L[qi] = swap2",
            "        else:",
            "            score = 0",
            "            T[di], T[dj] = qi, qj",
            "            L[qi], L[qj] = swap0",
            "        return score",
            "    def fullscore():",
            "        score = 0",
            "        last = [-1] * 26",
            "        for i, ti in enumerate(T):",
            "            score += S[i][ti]",
            "            last[ti] = i",
            "            for ci, la in zip(C, last):",
            "                score -= ci * (i-la)",
            "        return score",
            "    for di in range(D):",
            "        i, score = 0, calc(di, 0)",
            "        for qi in range(1, G):",
            "            x = calc(di, qi)",
            "            if x > score:",
            "                i, score = qi, x",
            "        T[di] = i",
            "        L[i].append(di)",
            "    t = 0",
            "    #s0 = score = fullscore()",
            "    while t < limit:",
            "        ab = randrange(0, 100)",
            "        if ab > 50:",
            "            score += sa(0)",
            "            #di, qi = randrange(0, D), randrange(0, G)",
            "            #diff, swap = update(di, qi)",
            "            #if diff > 0:",
            "            #    #score += diff",
            "            #    q0, T[di] = T[di], qi",
            "            #    L[q0], L[qi] = swap",
            "        else:",
            "            di = randrange(0, D-1)",
            "            dj = randrange(di+1, D)",
            "            diff = dswap(di, dj)",
            "            if diff > 0: score += diff",
            "        t = perf_counter() - tick",
            "    print(*(i+1 for i in T), sep=\"\\n\")",
            "    #s1 = fullscore(); print(s0, s1, score, score - s1, s1 - s0)",
            "if __name__ == \"__main__\":",
            "    resolve()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "import time",
            "START = time.time()",
            "import random",
            "import sys",
            "input = sys.stdin.readline",
            "Days = int(input())",
            "C = list(map(int, input().split())) # 満足度低下",
            "Ss = [list(map(int, input().split())) for _ in range(Days)]",
            "# Ss[d][i]: d日目にiを開催したときの満足度",
            "INF = 10**18",
            "TIMELIMIT = 1.9",
            "def outputToScore(T):",
            "    last = [0]*26",
            "    satisfied = 0",
            "    for d, t in enumerate(T):",
            "        t -= 1; d += 1",
            "        satisfied += Ss[d-1][t]",
            "        last[t] = d",
            "        for i, c in enumerate(C):",
            "            satisfied -= c*(d-last[i])",
            "        # print(satisfied)",
            "    return satisfied",
            "def outputToScore2(T):",
            "    last = [0]*26",
            "    used = [[] for _ in range(26)]",
            "    satisfied = 0",
            "    for d, t in enumerate(T):",
            "        t -= 1; d += 1",
            "        satisfied += Ss[d-1][t]",
            "        used[t].append(d)",
            "        last[t] = d",
            "        for i, c in enumerate(C):",
            "            satisfied -= c*(d-last[i])",
            "        # print(satisfied)",
            "    return satisfied, used",
            "def greedy():",
            "    last = [0]*26",
            "    T = []",
            "    for d in range(Days):",
            "        satisfied_max = -INF",
            "        selected = -1",
            "        for t in range(26):",
            "            score_t = Ss[d][t]",
            "            for j, c in enumerate(C):",
            "                if t != j:",
            "                    score_t -= c*(d+1-last[j])",
            "            if score_t > satisfied_max:",
            "                satisfied_max = score_t",
            "                selected = t",
            "        T.append(selected+1)",
            "        last[selected] = d+1",
            "    return T",
            "def modifiedScore(d, aft, Used, T):",
            "    bef = T[d-1]-1",
            "    deltaSatis = Ss[d-1][aft] - Ss[d-1][bef]",
            "    # d日目のコンテストをbefからaftに変える",
            "    # bi-1 -> bi -> bi+1 を bi-1 -> bi+1",
            "    befind = Used[bef].index(d)",
            "    befday0 = 0 if befind == 0 else Used[bef][befind-1]",
            "    befday2 = Days+1 if befind == len(Used[bef])-1 else Used[bef][befind+1]",
            "    befd01 = d - befday0",
            "    befd12 = befday2 - d",
            "    befd02 = befday2-befday0",
            "    deltaSatis -= C[bef]*(befd02*(befd02-1)//2) - C[bef]*(befd01*(befd01-1)//2 + befd12*(befd12-1)//2)",
            "    # ai -> ai+1 を ai -> (insert) -> ai+1",
            "    if len(Used[aft]) > 0:",
            "        aftday0 = 0",
            "        aftday2 = Days+1",
            "        for a in Used[aft]:",
            "            if a < d:",
            "                aftday0 = a",
            "            elif aftday2 == Days+1:",
            "                aftday2 = a",
            "        aftd01 = d - aftday0",
            "        aftd12 = aftday2 - d",
            "        aftd02 = aftd01 + aftd12",
            "        deltaSatis += C[aft]*(aftd02*(aftd02-1)//2) - C[aft]*(aftd01*(aftd01-1)//2 + aftd12*(aftd12-1)//2)",
            "    else:",
            "        d01 = d",
            "        d12 = Days+1 - d",
            "        deltaSatis += C[aft] * Days*(Days+1)//2 - C[aft]*(d01*(d01-1)//2 + d12*(d12-1)//2)",
            "    return deltaSatis",
            "def update(Used, T, bef, aft, d):",
            "    Used[bef].remove(d)",
            "    inserted = False",
            "    new = []",
            "    for a in Used[aft]:",
            "        if a > d and not inserted:",
            "            inserted = True",
            "            new.append(d)",
            "        new.append(a)",
            "    if not inserted:",
            "        new.append(d)",
            "    Used[aft] = new",
            "    T[d-1] = aft+1",
            "    return T, Used",
            "def goingup(T, Used):",
            "    d = random.randint(1, Days)",
            "    bef = T[d-1]-1",
            "    aft = random.randint(0, 25)",
            "    if bef == aft:",
            "        return T, Used",
            "    if modifiedScore(d, aft, Used, T) > 0:",
            "        T, Used = update(Used, T, bef, aft, d)",
            "    return T, Used",
            "def main():",
            "    T = greedy()",
            "    Satisfied, Used = outputToScore2(T)",
            "    while time.time() - START < TIMELIMIT:",
            "        T, Used = goingup(T, Used)",
            "    print(*T, sep=\"\\n\")",
            "def test():",
            "    T = [int(input()) for _ in range(Days)] # 開催するコンテスト",
            "    Q = int(input())",
            "    Query = [list(map(int, input().split())) for _ in range(Q)]",
            "    Satisfied, Used = outputToScore2(T)",
            "    for d, aft in Query:",
            "        aft -= 1",
            "        bef = T[d-1]-1",
            "        Satisfied += modifiedScore(d, aft, Used, T)",
            "        T, Used = update(Used, T, T[d-1]-1, aft, d)",
            "        print(Satisfied)",
            "if __name__ == \"__main__\":",
            "    main()",
            "    # test()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1
        ]
    },
    {
        "content": [
            "import sys, re",
            "from collections import deque, defaultdict, Counter",
            "from math import exp, ceil, sqrt, hypot, factorial, pi, sin, cos, radians, gcd, e",
            "from itertools import accumulate, permutations, combinations, product, groupby, combinations_with_replacement",
            "from operator import itemgetter, mul",
            "from copy import deepcopy",
            "from string import ascii_lowercase, ascii_uppercase, digits",
            "from bisect import bisect, bisect_left",
            "from heapq import heappush, heappop",
            "from functools import reduce",
            "import random",
            "import time",
            "def input(): return sys.stdin.readline().strip()",
            "def INT(): return int(input())",
            "def MAP(): return map(int, input().split())",
            "def LIST(): return list(map(int, input().split()))",
            "def ZIP(n): return zip(*(MAP() for _ in range(n)))",
            "sys.setrecursionlimit(10 ** 9)",
            "INF = float('inf')",
            "mod = 10 ** 9 + 7",
            "start = time.time()",
            "D = INT()",
            "C = LIST()",
            "s = [LIST() for _ in range(D)]",
            "def decrease(d, j):  # d:日にち, j:開催するコンテスト",
            "    tmp = 0",
            "    for i in range(26):",
            "        if i == j: continue",
            "        tmp += C[i]*(d-last[i])",
            "    return tmp",
            "def init():  # 貪欲でとった解を1度保存する",
            "    global now",
            "    for i in range(D):  # i+1日目",
            "        ma = -INF",
            "        ma_idx = None",
            "        for j in range(26):  # 開催するコンテスト",
            "            tmp = now",
            "            tmp += s[i][j]",
            "            tmp -= decrease(i+1, j)",
            "            if tmp > ma:",
            "                ma = tmp",
            "                ma_idx = j",
            "        now = ma",
            "        last[ma_idx] = i+1",
            "        score[ma_idx] += s[i][ma_idx]",
            "        for j in range(26):",
            "            score[j] -= C[j]*(i+1-last[j])",
            "        last[ma_idx] = i+1",
            "        ans[i] = ma_idx+1",
            "def update(d, q):  # d日目のところをqに変更する",
            "    d -= 1",
            "    q -= 1",
            "    c = ans[d]-1  # c:更新前",
            "    ans[d] = q+1",
            "    last_c = 0",
            "    last_q = 0",
            "    score_c = 0",
            "    score_q = 0",
            "    for j in range(D):",
            "        if ans[j]-1 == c:",
            "            last_c = j+1",
            "            score_c += s[j][c]",
            "        elif ans[j]-1 == q:",
            "            last_q = j+1",
            "            score_q += s[j][q]",
            "        score_c -= C[c] * (j+1 - last_c)",
            "        score_q -= C[q] * (j+1 - last_q)",
            "    score[c] = score_c",
            "    score[q] = score_q",
            "def swap(d):  # d日目とd+1日目の開催を入れ替える",
            "    update(d, ans[d])",
            "    update(d+1, ans[d-1])",
            "ans = [0]*D",
            "last = [0]*26",
            "score = [0]*26",
            "now = 0",
            "init()",
            "TL = 1.8 - (time.time()-start)",
            "start = time.time()",
            "T0 = 2e3",
            "T1 = 6e2",
            "T = T0",
            "randint = random.randint",
            "rand = random.random",
            "while 1:",
            "    t = (time.time()-start)/TL",
            "    if t >= 1:",
            "        break",
            "    T = pow(T0, 1-t)*pow(T1, t)",
            "    if rand() < 0.5:  # 1点変更",
            "        d = randint(1, D)",
            "        q = randint(1, 26)",
            "        old = ans[d-1]",
            "        old_score = score.copy()",
            "        s_old = sum(score)",
            "        update(d, q)",
            "        s_new = sum(score)",
            "        if s_new <= s_old and exp((s_new-s_old)/T) <= rand():  # 戻す確率",
            "            score = old_score",
            "            ans[d-1] = old",
            "    else:  # 2点入れ替え",
            "        d = randint(1, D-1)",
            "        old = ans[d-1]",
            "        old_score = score.copy()",
            "        s_old = sum(score)",
            "        swap(d)",
            "        s_new = sum(score)",
            "        if s_new <= s_old and exp((s_new-s_old)/T) <= rand():",
            "            score = old_score",
            "            ans[d-1] = old",
            "print(*ans, sep=\"\\n\")"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2
        ]
    },
    {
        "content": [
            "# strat_localsearch_fine",
            "import sys",
            "input = sys.stdin.readline",
            "import numpy as np",
            "from numba import njit",
            "def read():",
            "    D = int(input().strip())",
            "    C = np.fromstring(input().strip(), dtype=np.int32, sep=\" \")",
            "    S = np.empty((D, 26), dtype=np.int32)",
            "    for i in range(D):",
            "        s = np.fromstring(input().strip(), dtype=np.int32, sep=\" \")",
            "        S[i, :] = s[:]",
            "    M = 100000",
            "    RD = np.random.randint(D, size=(M, ), dtype=np.int32)",
            "    RQ = np.random.randint(26, size=(M, ), dtype=np.int32)",
            "    DQ = np.stack([RD, RQ]).T",
            "    COND = np.random.randint(2, size=(M, ), dtype=np.bool)",
            "    return D, C, S, M, DQ, COND",
            "@njit",
            "def diff_satisfaction(C, S, d, p, last):",
            "    \"\"\"d日目にコンテストpを開催するときの、満足度の更新量を求める",
            "    \"\"\"",
            "    v = 0",
            "    for i in range(26):",
            "        v -= C[i] * (d - last[i])",
            "    v += C[p] * (d - last[p])",
            "    v += S[d, p]",
            "    return v",
            "@njit",
            "def evaluate(D, C, S, d, p, last, k=13):",
            "    \"\"\"d日目にコンテストpを開催し、その後d+k日目までコンテストが開催されないときの、満足度の更新差分を求める",
            "    \"\"\"",
            "    v = diff_satisfaction(C, S, d, p, last)",
            "    for e in range(d+1, min(d+k, D)):",
            "        for i in range(26):",
            "            v -= C[i] * (e - last[i])",
            "        v += C[p] * (d - last[p])",
            "    return v",
            "@njit",
            "def greedy_fine(D, C, S):",
            "    T = np.zeros(D, dtype=np.int32)",
            "    last = -np.ones(26, dtype=np.int32)",
            "    cumsat = 0",
            "    for d in range(D):",
            "        max_p = 0",
            "        max_e = -999999999",
            "        # select contest greedily",
            "        for p in range(26):",
            "            e = evaluate(D, C, S, d, p, last, k=8)",
            "            if e > max_e:",
            "                max_p = p",
            "                max_e = e",
            "        # update schedule",
            "        cumsat += diff_satisfaction(C, S, d, max_p, last)",
            "        T[d] = max_p",
            "        last[max_p] = d",
            "    return cumsat, T",
            "@njit",
            "def update(D, C, S, T, d, q, cumsat):",
            "    \"\"\"1点更新: d日目のコンテストをqに変更する",
            "    \"\"\"",
            "    p = T[d]",
            "    dp1, dq1 = -1, -1",
            "    dp3, dq3 = D, D",
            "    for i in range(0, d):",
            "        if T[i] == p:",
            "            dp1 = i",
            "        if T[i] == q:",
            "            dq1 = i",
            "    for i in range(D-1, d, -1):",
            "        if T[i] == p:",
            "            dp3 = i",
            "        if T[i] == q:",
            "            dq3 = i",
            "    cumsat = cumsat - S[d, p] + S[d, q] - C[p] * (dp3-d) * (d-dp1) + C[q] * (dq3-d) * (d-dq1)",
            "    return cumsat",
            "def swap(D, C, S, T, d0, p0, d1, p1, cumsat):",
            "    \"\"\"2点スワップ: d0日目のコンテストp0とd1日目のコンテストp1を交換する",
            "    \"\"\"",
            "    cumsat = update(D, C, S, T, d0, p1, cumsat)",
            "    cumsat = update(D, C, S, T, d1, p0, cumsat)",
            "    return cumsat",
            "@njit",
            "def greedy(D, C, S):",
            "    T = np.zeros(D, dtype=np.int32)",
            "    last = -np.ones(26, dtype=np.int32)",
            "    cumsat = 0",
            "    for d in range(D):",
            "        max_p = 0",
            "        max_diff = -999999999",
            "        # select contest greedily",
            "        for p in range(26):",
            "            diff = diff_satisfaction(C, S, d, p, last)",
            "            if diff > max_diff:",
            "                max_p = p",
            "                max_diff = diff",
            "        # update schedule",
            "        cumsat += max_diff",
            "        T[d] = max_p",
            "        last[max_p] = d",
            "    return cumsat, T",
            "def solve(D, C, S, M, DQ, COND):",
            "    cumsat, T = greedy(D, C, S)",
            "    for i in range(M):",
            "        d, q = DQ[i, :]",
            "        if COND[i]:",
            "            newsat = update(D, C, S, T, d, q, cumsat)",
            "            if newsat > cumsat:",
            "                cumsat = newsat",
            "                T[d] = q",
            "        else:",
            "            d0, d1 = d, min(d+1+q//2, D-1)",
            "            newsat = swap(D, C, S, T, d0, T[d0], d1, T[d1], cumsat)",
            "            if newsat > cumsat:",
            "                cumsat = newsat",
            "                T[d1], T[d0] = T[d0], T[d1]",
            "    for t in T:",
            "        print(t+1)",
            "if __name__ == '__main__':",
            "    inputs = read()",
            "    outputs = solve(*inputs)",
            "    if outputs is not None:",
            "        print(\"%s\" % str(outputs))"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            0
        ]
    },
    {
        "content": [
            "import time",
            "START = time.time()",
            "import math",
            "import random",
            "import sys",
            "input = sys.stdin.readline",
            "Days = int(input())",
            "C = list(map(int, input().split())) # 満足度低下",
            "Ss = [list(map(int, input().split())) for _ in range(Days)]",
            "# Ss[d][i]: d日目にiを開催したときの満足度",
            "# with open(\"input.txt\", \"r\") as f:",
            "#     L = f.readlines()",
            "#     Days = int(L[0].rstrip())",
            "#     C = list(map(int, L[1].rstrip().split()))",
            "#     Ss = [list(map(int, L[2+i].rstrip().split())) for i in range(Days)]",
            "INF = 10**18",
            "TIMELIMIT = 1.9",
            "def outputToScore(T):",
            "    last = [0]*26",
            "    satisfied = 0",
            "    for d, t in enumerate(T):",
            "        t -= 1; d += 1",
            "        satisfied += Ss[d-1][t]",
            "        last[t] = d",
            "        for i, c in enumerate(C):",
            "            satisfied -= c*(d-last[i])",
            "        # print(satisfied)",
            "    return satisfied",
            "def outputToScore2(T):",
            "    last = [0]*26",
            "    used = [[] for _ in range(26)]",
            "    satisfied = 0",
            "    for d, t in enumerate(T):",
            "        t -= 1; d += 1",
            "        satisfied += Ss[d-1][t]",
            "        used[t].append(d)",
            "        last[t] = d",
            "        for i, c in enumerate(C):",
            "            satisfied -= c*(d-last[i])",
            "        # print(satisfied)",
            "    return satisfied, used",
            "def greedy():",
            "    last = [0]*26",
            "    T = []",
            "    for d in range(Days):",
            "        satisfied_max = -INF",
            "        selected = -1",
            "        for t in range(26):",
            "            score_t = Ss[d][t]",
            "            for j, c in enumerate(C):",
            "                if t != j:",
            "                    score_t -= c*(d+1-last[j])",
            "            if score_t > satisfied_max:",
            "                satisfied_max = score_t",
            "                selected = t",
            "        T.append(selected+1)",
            "        last[selected] = d+1",
            "    return T",
            "def modifiedScore(d, aft, Used, T):",
            "    bef = T[d-1]-1",
            "    deltaSatis = Ss[d-1][aft] - Ss[d-1][bef]",
            "    # d日目のコンテストをbefからaftに変える",
            "    # bi-1 -> bi -> bi+1 を bi-1 -> bi+1",
            "    befind = Used[bef].index(d)",
            "    befday0 = 0 if befind == 0 else Used[bef][befind-1]",
            "    befday2 = Days+1 if befind == len(Used[bef])-1 else Used[bef][befind+1]",
            "    befd01 = d - befday0",
            "    befd12 = befday2 - d",
            "    befd02 = befday2-befday0",
            "    deltaSatis -= C[bef]*(befd02*(befd02-1)//2) - C[bef]*(befd01*(befd01-1)//2 + befd12*(befd12-1)//2)",
            "    # ai -> ai+1 を ai -> (insert) -> ai+1",
            "    if len(Used[aft]) > 0:",
            "        aftday0 = 0",
            "        aftday2 = Days+1",
            "        for a in Used[aft]:",
            "            if a < d:",
            "                aftday0 = a",
            "            elif aftday2 == Days+1:",
            "                aftday2 = a",
            "        aftd01 = d - aftday0",
            "        aftd12 = aftday2 - d",
            "        aftd02 = aftd01 + aftd12",
            "        deltaSatis += C[aft]*(aftd02*(aftd02-1)//2) - C[aft]*(aftd01*(aftd01-1)//2 + aftd12*(aftd12-1)//2)",
            "    else:",
            "        d01 = d",
            "        d12 = Days+1 - d",
            "        deltaSatis += C[aft] * Days*(Days+1)//2 - C[aft]*(d01*(d01-1)//2 + d12*(d12-1)//2)",
            "    return deltaSatis",
            "def update(Used, T, bef, aft, d):",
            "    Used[bef].remove(d)",
            "    inserted = False",
            "    new = []",
            "    for a in Used[aft]:",
            "        if a > d and not inserted:",
            "            inserted = True",
            "            new.append(d)",
            "        new.append(a)",
            "    if not inserted:",
            "        new.append(d)",
            "    Used[aft] = new",
            "    T[d-1] = aft+1",
            "    return T, Used",
            "def goingup(T, Used, Temp):",
            "    d = random.randint(1, Days)",
            "    bef = T[d-1]-1",
            "    aft = random.randint(0, 25)",
            "    if bef == aft:",
            "        return T, Used",
            "    delta = modifiedScore(d, aft, Used, T)",
            "    if delta > 0 or math.exp(delta/Temp) > random.random():",
            "        T, Used = update(Used, T, bef, aft, d)",
            "    return T, Used",
            "def main():",
            "    T = greedy()",
            "    Satisfied, Used = outputToScore2(T)",
            "    # 焼き鈍しの初期設定",
            "    TempMax = 10**3",
            "    TempMin = 1",
            "    REMAIN = TIMELIMIT - time.time()",
            "    LOOPBEGIN = TIMELIMIT - REMAIN",
            "    while time.time() - START < TIMELIMIT:",
            "        t = (time.time() - LOOPBEGIN)/REMAIN",
            "        Temp = TempMax**(1-t) * TempMin**t",
            "        T, Used = goingup(T, Used, Temp)",
            "    print(*T, sep=\"\\n\")",
            "    # print(outputToScore2(T)[0])",
            "def test():",
            "    T = [int(input()) for _ in range(Days)] # 開催するコンテスト",
            "    Q = int(input())",
            "    Query = [list(map(int, input().split())) for _ in range(Q)]",
            "    Satisfied, Used = outputToScore2(T)",
            "    for d, aft in Query:",
            "        aft -= 1",
            "        bef = T[d-1]-1",
            "        Satisfied += modifiedScore(d, aft, Used, T)",
            "        T, Used = update(Used, T, T[d-1]-1, aft, d)",
            "        print(Satisfied)",
            "if __name__ == \"__main__\":",
            "    main()",
            "    # test()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1
        ]
    },
    {
        "content": [
            "# 貪欲法 + 山登り法 + 3点スワップ操作 + アニーリング",
            "import time",
            "s__ = time.time()",
            "limit = 1.9",
            "#limit = 10",
            "from numba import njit",
            "import numpy as np",
            "d = int(input())",
            "cs = list(map(int, input().split()))",
            "cs = np.array(cs, dtype=np.int64)",
            "sm = [list(map(int, input().split())) for _ in range(d)]",
            "sm = np.array(sm, dtype=np.int64)",
            "@njit('i8(i8[:], i8)', cache=True)",
            "def total_satisfaction(ts, d):",
            "    ls = np.zeros(26, dtype=np.int64)",
            "    s = 0",
            "    for i in range(d):",
            "        t = ts[i]",
            "        t -= 1",
            "        s += sm[i][t]",
            "        ls[t] = i + 1",
            "        dv = cs * ((i+1) - ls)",
            "        s -= dv.sum()",
            "    return s",
            "@njit('i8(i8, i8[:], f8)', cache=True)",
            "def loop(mxsc, ts, tmpr):",
            "    it = 50",
            "    rds = np.random.randint(0, 5, (it,))",
            "    rdd = np.random.randint(1, d, (it,))",
            "    rdq = np.random.randint(1, 26, (it,))",
            "    rdx = np.random.randint(1, 12, (it,))",
            "    rdy = np.random.randint(1, 6, (it,))",
            "    c1 = 1",
            "    c2 = 4",
            "    for i in range(it):",
            "        bk1 = 0",
            "        bk2 = 0",
            "        bk3 = 0",
            "        if rds[0] <= c1:",
            "            # trailing",
            "            di = rdd[i]",
            "            qi = rdq[i]",
            "            bk1 = ts[di]",
            "            ts[di] = qi",
            "        elif rds[0] <= c2:",
            "            # swap",
            "            di = rdd[i]",
            "            xi = rdx[i]",
            "            if di + xi >= d:",
            "                xi = di - xi",
            "            else:",
            "                xi = di + xi",
            "            bk1 = ts[di]",
            "            bk2 = ts[xi]",
            "            ts[di] = bk2",
            "            ts[xi] = bk1",
            "        else:",
            "            # triswap",
            "            di = rdd[i]",
            "            xi = rdx[i]",
            "            if di + xi >= d:",
            "                xi = di - xi",
            "            else:",
            "                xi = di + xi",
            "            yi = rdy[i]",
            "            if xi + yi >= d:",
            "                yi = xi - yi",
            "            else:",
            "                yi = xi + yi",
            "            bk1 = ts[di]",
            "            bk2 = ts[xi]",
            "            bk3 = ts[yi]",
            "            ts[di] = bk2",
            "            ts[xi] = bk3",
            "            ts[yi] = bk1",
            "        sc = total_satisfaction(ts, d)",
            "        delta = sc - mxsc",
            "        if delta > 0:",
            "            #print('d>0', mxsc, '->', sc)",
            "            #print(mxsc, '->', sc)",
            "            mxsc = sc",
            "        else:",
            "            # Random < e^(Δ/T) の場合も更新",
            "            exp = np.exp(delta / tmpr)",
            "            #if i == 0:print('delta=', delta, 'tmpr=', tmpr, exp)",
            "            r = np.random.random()",
            "            if r <= exp:",
            "                #print('d<0', mxsc, '->', sc, delta, tmpr, exp)",
            "                mxsc = sc",
            "            else:",
            "                # 最大値を更新しなかったら戻す",
            "                if rds[0] <= c1:",
            "                    ts[di] = bk1",
            "                elif rds[0] <= c2:",
            "                    ts[di] = bk1",
            "                    ts[xi] = bk2",
            "                else:",
            "                    ts[di] = bk1",
            "                    ts[xi] = bk2",
            "                    ts[yi] = bk3",
            "    return mxsc",
            "@njit('i8[:]()', cache=True)",
            "def greedy():",
            "    ts = np.array([0] * d, dtype=np.int64)",
            "    for i in range(d):",
            "        mx = -1e10",
            "        mxt = None",
            "        for t in range(1, 26+1):",
            "            ts[i] = t",
            "            s = total_satisfaction(ts, i + 1)",
            "            if s > mx:",
            "                mx = s",
            "                mxt = t",
            "        ts[i] = mxt",
            "    return ts",
            "ts = greedy()",
            "#ts = np.random.randint(1, 26, (d,)).astype(np.int64)",
            "mxsc = total_satisfaction(ts, d)",
            "mxbk = mxsc",
            "# annealing vars",
            "t0 = 2e3",
            "t1 = 6e2",
            "s_ = time.time()",
            "mxsc = loop(mxsc, ts, t0)",
            "e_ = time.time()",
            "consume = s_ - s__",
            "elapsed = e_ - s_",
            "#print('consume:', consume)",
            "#print('elapsed:', elapsed)",
            "if consume < limit:",
            "    lp = int((limit - consume) / elapsed)",
            "    for i in range(lp):",
            "        t = i / lp",
            "        tmpr = np.power(t0, 1 - t) * np.power(t1, t)",
            "        mxsc = loop(mxsc, ts, tmpr)",
            "        #print(mxsc)",
            "for t in ts:    print(t)",
            "#print(mxbk, mxsc)",
            "#print(time.time() - s__)",
            "#print(mxsc)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "# abc171_c.py",
            "# https://atcoder.jp/contests/abc171/tasks/abc171_c",
            "# C - One Quadrillion and One Dalmatians /",
            "# 実行時間制限: 2 sec / メモリ制限: 1024 MB",
            "# 配点 : 300点",
            "# 問題文",
            "# ロジャーは、彼のもとに突如現れた 1000000000000001匹の犬をすべて飼うことを決意しました。",
            "# 犬たちにはもともと 1 から 1000000000000001までの番号がふられていましたが、ロジャーは彼らに以下のルールで名前を授けました。",
            "#     1,2,⋯,26番の番号がついた犬はその順に a,b,...,z と命名されます。",
            "#     27,28,29,⋯,701,702番の番号がついた犬はその順に aa,ab,ac,...,zy,zz と命名されます。",
            "#     703,704,705,⋯,18277,18278番の番号がついた犬はその順に aaa,aab,aac,...,zzy,zzz と命名されます。",
            "#     18279,18280,18281,⋯,475253,475254番の番号がついた犬はその順に aaaa,aaab,aaac,...,zzzy,zzzz と命名されます。",
            "#     475255,475256,⋯    番の番号がついた犬はその順に aaaaa,aaaab,... と命名されます。",
            "#     (以下省略)",
            "# つまり、ロジャーが授けた名前を番号順に並べると:",
            "# a,b,...,z,aa,ab,...,az,ba,bb,...,bz,...,za,zb,...,zz,aaa,aab,...,aaz,aba,abb,...,abz,...,zzz,aaaa,...",
            "# のようになります。",
            "# ロジャーはあなたに問題を出しました。",
            "# 「番号 Nの犬の名前を答えよ。」",
            "# 制約",
            "#     Nは整数",
            "#     1≤N≤1000000000000001",
            "# 入力",
            "# 入力は以下の形式で標準入力から与えられる。",
            "# N",
            "# 出力",
            "# ロジャーの問題に対する答えを、英小文字のみからなる文字列として出力せよ。",
            "# 入力例 1",
            "# 2",
            "# 出力例 1",
            "# b",
            "# 入力例 2",
            "# 27",
            "# 出力例 2",
            "# aa",
            "# 入力例 3",
            "# 123456789",
            "# 出力例 3",
            "# jjddja",
            "global FLAG_LOG",
            "FLAG_LOG = False",
            "def log(value):",
            "    # FLAG_LOG = True",
            "    FLAG_LOG = False",
            "    if FLAG_LOG:",
            "        print(str(value))",
            "def calculation(lines):",
            "    # S = lines[0]",
            "    N = int(lines[0])",
            "    # N, M = list(map(int, lines[0].split()))",
            "    # values = list(map(int, lines[1].split()))",
            "    # values = list(map(int, lines[2].split()))",
            "    # values = list()",
            "    # for i in range(N):",
            "    #     values.append(int(lines[i]))",
            "    # valueses = list()",
            "    # for i in range(N):",
            "    #     valueses.append(list(map(int, lines[i+1].split())))",
            "    alp = 'abcdefghijklmnopqrstuvwxyz'",
            "    # １起点なので一つずらす",
            "    q = N - 1",
            "    result = ''",
            "    # 下１桁ずつ加算",
            "    while True:",
            "        q, mod = divmod(q, 26)",
            "        result = alp[mod] + result",
            "        if q == 0:",
            "            return [result]",
            "        q -= 1",
            "    return ['error']",
            "# 引数を取得",
            "def get_input_lines(lines_count):",
            "    lines = list()",
            "    for _ in range(lines_count):",
            "        lines.append(input())",
            "    return lines",
            "# テストデータ",
            "def get_testdata(pattern):",
            "    if pattern == 1:",
            "        lines_input = ['2']",
            "        lines_export = ['b']",
            "    if pattern == 2:",
            "        lines_input = ['27']",
            "        lines_export = ['aa']",
            "    if pattern == 3:",
            "        lines_input = ['123456789']",
            "        lines_export = ['jjddja']",
            "    return lines_input, lines_export",
            "# 動作モード判別",
            "def get_mode():",
            "    import sys",
            "    args = sys.argv",
            "    global FLAG_LOG",
            "    if len(args) == 1:",
            "        mode = 0",
            "        FLAG_LOG = False",
            "    else:",
            "        mode = int(args[1])",
            "        FLAG_LOG = True",
            "    return mode",
            "# 主処理",
            "def main():",
            "    import time",
            "    started = time.time()",
            "    mode = get_mode()",
            "    if mode == 0:",
            "        lines_input = get_input_lines(1)",
            "    else:",
            "        lines_input, lines_export = get_testdata(mode)",
            "    lines_result = calculation(lines_input)",
            "    for line_result in lines_result:",
            "        print(line_result)",
            "    # if mode > 0:",
            "    #     print(f'lines_input=[{lines_input}]')",
            "    #     print(f'lines_export=[{lines_export}]')",
            "    #     print(f'lines_result=[{lines_result}]')",
            "    #     if lines_result == lines_export:",
            "    #         print('OK')",
            "    #     else:",
            "    #         print('NG')",
            "    # finished = time.time()",
            "    # duration = finished - started",
            "    # print(f'duration=[{duration}]')",
            "# 起動処理",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "def main():",
            "    import sys",
            "    read = sys.stdin.buffer.read",
            "    readline = sys.stdin.buffer.readline",
            "    readlines = sys.stdin.buffer.readlines",
            "    sys.setrecursionlimit(10 ** 7)",
            "    class Combination:",
            "        def __init__(self, n_max, mod=10**9+7):",
            "            # O(n_max + log(mod))",
            "            self.mod = mod",
            "            f = 1",
            "            self.fac = fac = [f]",
            "            for i in range(1, n_max+1):",
            "                f = f * i % mod",
            "                fac.append(f)",
            "            f = pow(f, mod-2, mod)",
            "            self.facinv = facinv = [f]",
            "            for i in range(n_max, 0, -1):",
            "                f = f * i % mod",
            "                facinv.append(f)",
            "            facinv.reverse()",
            "        # \"n 要素\" は区別できる n 要素",
            "        # \"k グループ\" はちょうど k グループ",
            "        def __call__(self, n, r):  # self.C と同じ",
            "            return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod",
            "        def C(self, n, r):",
            "            if not 0 <= r <= n:",
            "                return 0",
            "            return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod",
            "        def P(self, n, r):",
            "            if not 0 <= r <= n:",
            "                return 0",
            "            return self.fac[n] * self.facinv[n-r] % self.mod",
            "        def H(self, n, r):",
            "            if (n == 0 and r > 0) or r < 0:",
            "                return 0",
            "            return self.fac[n+r-1] * self.facinv[r] % self.mod * self.facinv[n-1] % self.mod",
            "        def rising_factorial(self, n, r):  # 上昇階乗冪 n * (n+1) * ... * (n+r-1)",
            "            return self.fac[n+r-1] * self.facinv[n-1] % self.mod",
            "        def stirling_first(self, n, k):  # 第 1 種スターリング数  lru_cache を使うと O(nk)  # n 要素を k 個の巡回列に分割する場合の数",
            "            if n == k:",
            "                return 1",
            "            if k == 0:",
            "                return 0",
            "            return (self.stirling_first(n-1, k-1) + (n-1)*self.stirling_first(n-1, k)) % self.mod",
            "        def stirling_second(self, n, k):  # 第 2 種スターリング数 O(k + log(n))  # n 要素を区別のない k グループに分割する場合の数",
            "            if n == k:",
            "                return 1  # n==k==0 のときのため",
            "            return self.facinv[k] * sum((-1)**(k-m) * self.C(k, m) * pow(m, n, self.mod) for m in range(1, k+1)) % self.mod",
            "        def balls_and_boxes_3(self, n, k):  # n 要素を区別のある k グループに分割する場合の数  O(k + log(n))",
            "            return sum((-1)**(k-m) * self.C(k, m) * pow(m, n, self.mod) for m in range(1, k+1)) % self.mod",
            "        def bernoulli(self, n):  # ベルヌーイ数  lru_cache を使うと O(n**2 * log(mod))",
            "            if n == 0:",
            "                return 1",
            "            if n % 2 and n >= 3:",
            "                return 0  # 高速化",
            "            return (- pow(n+1, self.mod-2, self.mod) * sum(self.C(n+1, k) * self.bernoulli(k) % self.mod for k in range(n))) % self.mod",
            "        def faulhaber(self, k, n):  # べき乗和 0^k + 1^k + ... + (n-1)^k",
            "            # bernoulli に lru_cache を使うと O(k**2 * log(mod))  bernoulli が計算済みなら O(k * log(mod))",
            "            return pow(k+1, self.mod-2, self.mod) * sum(self.C(k+1, j) * self.bernoulli(j) % self.mod * pow(n, k-j+1, self.mod) % self.mod for j in range(k+1)) % self.mod",
            "        def lah(self, n, k):  # n 要素を k 個の空でない順序付き集合に分割する場合の数  O(1)",
            "            return self.C(n-1, k-1) * self.fac[n] % self.mod * self.facinv[k] % self.mod",
            "        def bell(self, n, k):  # n 要素を k グループ以下に分割する場合の数  O(k**2 + k*log(mod))",
            "            return sum(self.stirling_second(n, j) for j in range(1, k+1)) % self.mod",
            "    k = int(readline())",
            "    s = readline().rstrip().decode()",
            "    n = len(s)",
            "    ans = 0",
            "    mod = 10 ** 9 + 7",
            "    comb = Combination(n + k)",
            "    v = 1",
            "    for i in range(k + 1):",
            "        ans += comb(n + k, i) * v",
            "        ans %= mod",
            "        v *= 25",
            "        v %= mod",
            "    print(ans)",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "MOD = 10**9+7",
            "class mint:",
            "    def __init__(self, x):",
            "        self.x = x % MOD if isinstance(x, int) else int(x) % MOD",
            "    def __str__(self):",
            "        return str(self.x)",
            "    __repr__ = __str__",
            "    def __iadd__(self, other):",
            "        self.x += other.x if isinstance(other, mint) else other",
            "        self.x -= MOD if self.x >= MOD else 0",
            "        return self",
            "    def __isub__(self, other):",
            "        self.x += MOD-other.x if isinstance(other, mint) else MOD-other",
            "        self.x -= MOD if self.x >= MOD else 0",
            "        return self",
            "    def __imul__(self, other):",
            "        self.x *= other.x if isinstance(other, mint) else other",
            "        self.x %= MOD",
            "        return self",
            "    def __imod__(self, other):",
            "        self.x %= other.x if isinstance(other, mint) else other",
            "        self.x %= MOD",
            "        return self",
            "    def __add__(self, other):",
            "        return (",
            "            mint(self.x + other.x) if isinstance(other, mint) else",
            "            mint(self.x + other)",
            "        )",
            "    def __sub__(self, other):",
            "        return (",
            "            mint(self.x - other.x) if isinstance(other, mint) else",
            "            mint(self.x - other)",
            "        )",
            "    def __mul__(self, other):",
            "        return (",
            "            mint(self.x * other.x) if isinstance(other, mint) else",
            "            mint(self.x * other)",
            "        )",
            "    def __mod__(self, other):",
            "        return (",
            "            mint(self.x % other.x) if isinstance(other, mint) else",
            "            mint(self.x % other)",
            "        )",
            "    def __truediv__(self, other):",
            "        return (",
            "            mint(",
            "                self.x * pow(other.x, MOD - 2, MOD)",
            "            ) if isinstance(other, mint) else",
            "            mint(self.x * pow(other, MOD - 2, MOD))",
            "        )",
            "    def __pow__(self, other):",
            "        return (",
            "            mint(pow(self.x, other.x, MOD)) if isinstance(other, mint) else",
            "            mint(pow(self.x, other, MOD))",
            "        )",
            "    __radd__ = __add__",
            "    def __rsub__(self, other):",
            "        return (",
            "            mint(other.x - self.x) if isinstance(other, mint) else",
            "            mint(other - self.x)",
            "        )",
            "    __rmul__ = __mul__",
            "    def __rmod__(self, other):",
            "        return (",
            "            mint(other.x % self.x) if isinstance(other, mint) else",
            "            mint(other % self.x)",
            "        )",
            "    def __rtruediv__(self, other):",
            "        return (",
            "            mint(",
            "                other.x * pow(self.x, MOD - 2, MOD)",
            "            ) if isinstance(other, mint) else",
            "            mint(other * pow(self.x, MOD - 2, MOD))",
            "        )",
            "    def __rpow__(self, other):",
            "        return (",
            "            mint(pow(other.x, self.x, MOD)) if isinstance(other, mint) else",
            "            mint(pow(other, self.x, MOD))",
            "        )",
            "class Comb():",
            "    # class <mint> should be imported",
            "    def __init__(self, n):",
            "        self.n = n",
            "        fact = [0]*(n+1) # 1-indexed",
            "        ifact = [0]*(n+1) # 逆元",
            "        fact[0] = mint(1)",
            "        for i in range(1, n+1):",
            "            fact[i] = fact[i-1]*i",
            "        ifact[-1] = pow(fact[-1], MOD-2)",
            "        for i in range(n, 0, -1):",
            "            ifact[i-1] = ifact[i]*i",
            "        self.fact = fact",
            "        self.ifact = ifact",
            "    def calc(self, n, k):",
            "        if k<0 or k>n:",
            "            return 0",
            "        return self.fact[n]*self.ifact[k]*self.ifact[n-k]",
            "cb= Comb(2000005)",
            "k = int(input())",
            "s = input()",
            "n = len(s)",
            "ans = mint(0)",
            "for i in range(n-1,n+k):",
            "    ans += cb.calc(i,n-1)*pow(25,i-n+1,MOD)*pow(26,n+k-i-1,MOD)",
            "print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            2,
            1,
            1,
            1,
            2,
            1,
            1,
            1,
            2,
            1,
            1,
            1,
            2,
            1,
            1,
            1,
            2,
            1,
            0,
            0,
            1,
            2,
            1,
            0,
            0,
            1,
            2,
            1,
            0,
            0,
            1,
            2,
            1,
            0,
            0,
            1,
            2,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            0,
            0,
            1,
            2,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            2,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "# でつoO(YOU PLAY WITH THE CARDS YOU'RE DEALT..)",
            "import sys",
            "MOD = 10**9 + 7",
            "def main(K, S):",
            "    N = len(S)",
            "    fu = FactorialUtils(N + K)",
            "    ans = Mint()",
            "    for i in range(K + 1):",
            "        tmp = Mint(1)",
            "        tmp *= fu.multichoose(N, K - i)",
            "        tmp *= pow(25, K - i, MOD)",
            "        tmp *= pow(26, i, MOD)",
            "        ans += tmp",
            "    print(ans)",
            "class FactorialUtils:",
            "    def __init__(self, n):",
            "        self.fac = [1] * (n + 1)",
            "        self.ifac = [1] * (n + 1)",
            "        for i in range(2, n + 1): self.fac[i] = self.fac[i - 1] * i % MOD",
            "        self.ifac[n] = pow(self.fac[n], MOD - 2, MOD)",
            "        for i in range(n, 1, -1): self.ifac[i - 1] = self.ifac[i] * i % MOD",
            "    def choose(self, n, r):",
            "        if r < 0 or r > n: return 0",
            "        return (self.fac[n] * self.ifac[n - r] % MOD) * self.ifac[r] % MOD",
            "    def multichoose(self, u, k):",
            "        return (self.fac[u + k - 1] * self.ifac[u - 1] % MOD) * self.ifac[k] % MOD",
            "class Mint:",
            "    def __init__(self, value=0):",
            "        self.value = value % MOD",
            "        if self.value < 0: self.value += MOD",
            "    @staticmethod",
            "    def get_value(x): return x.value if isinstance(x, Mint) else x",
            "    def inverse(self):",
            "        a, b = self.value, MOD",
            "        u, v = 1, 0",
            "        while b:",
            "            t = a // b",
            "            b, a = a - t * b, b",
            "            v, u = u - t * v, v",
            "        if u < 0: u += MOD",
            "        return u",
            "    def __repr__(self): return str(self.value)",
            "    def __eq__(self, other): return self.value == other.value",
            "    def __neg__(self): return Mint(-self.value)",
            "    def __hash__(self): return hash(self.value)",
            "    def __bool__(self): return self.value != 0",
            "    def __iadd__(self, other):",
            "        self.value = (self.value + Mint.get_value(other)) % MOD",
            "        return self",
            "    def __add__(self, other):",
            "        new_obj = Mint(self.value)",
            "        new_obj += other",
            "        return new_obj",
            "    __radd__ = __add__",
            "    def __isub__(self, other):",
            "        self.value = (self.value - Mint.get_value(other)) % MOD",
            "        if self.value < 0: self.value += MOD",
            "        return self",
            "    def __sub__(self, other):",
            "        new_obj = Mint(self.value)",
            "        new_obj -= other",
            "        return new_obj",
            "    def __rsub__(self, other):",
            "        new_obj = Mint(Mint.get_value(other))",
            "        new_obj -= self",
            "        return new_obj",
            "    def __imul__(self, other):",
            "        self.value = self.value * Mint.get_value(other) % MOD",
            "        return self",
            "    def __mul__(self, other):",
            "        new_obj = Mint(self.value)",
            "        new_obj *= other",
            "        return new_obj",
            "    __rmul__ = __mul__",
            "    def __ifloordiv__(self, other):",
            "        other = other if isinstance(other, Mint) else Mint(other)",
            "        self *= other.inverse()",
            "        return self",
            "    def __floordiv__(self, other):",
            "        new_obj = Mint(self.value)",
            "        new_obj //= other",
            "        return new_obj",
            "    def __rfloordiv__(self, other):",
            "        new_obj = Mint(Mint.get_value(other))",
            "        new_obj //= self",
            "        return new_obj",
            "if __name__ == '__main__':",
            "    input = sys.stdin.readline",
            "    K = int(input())",
            "    S = input().rstrip()",
            "    main(K, S)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "MOD = 1000000007  # type: int",
            "def solve(K: int, S: str):",
            "    '''",
            "    >>> solve(1, 'a')",
            "    51",
            "    '''",
            "    N = len(S)",
            "    mf = ModFactorial(MOD, N+K+1)",
            "    ans = 0",
            "    for k in range(K+1):",
            "        ans = (ans + mf.combination(k+N-1, k) * pow(25, k, MOD) % MOD * pow(26, K-k, MOD)) % MOD",
            "    return ans",
            "# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools",
            "def main():",
            "    def iterate_tokens():",
            "        for line in sys.stdin:",
            "            for word in line.split():",
            "                yield word",
            "    tokens = iterate_tokens()",
            "    K = int(next(tokens))  # type: int",
            "    S = next(tokens)  # type: str",
            "    print(solve(K, S))",
            "def mod_range(mod, start, stop=None, step=1):",
            "    if stop == None:",
            "        stop = start",
            "        start = 0",
            "    return map(lambda i: i % mod, range(start, stop, step))",
            "def mod_inv(mod, n):",
            "    '''",
            "    >>> mod_inv(3, 2)",
            "    2",
            "    >>> mod_inv(1000000007, 2)",
            "    500000004",
            "    '''",
            "    return pow(n, mod-2, mod)",
            "def mod_permutation(mod, n, r):",
            "    '''",
            "    >>> mod_permutation(1000000007, 10, 2)",
            "    90",
            "    >>> mod_permutation(7, 10, 2)",
            "    6",
            "    '''",
            "    m = 1",
            "    for i in mod_range(mod, n-r+1, n+1):",
            "        m = (m * i) % mod",
            "    return m",
            "def mod_factorial(mod, n):",
            "    '''",
            "    >>> mod_factorial(1000000007, 10)",
            "    3628800",
            "    >>> mod_factorial(7, 6)",
            "    6",
            "    '''",
            "    return mod_permutation(mod, n, n)",
            "def mod_combination(mod, n, r):",
            "    '''",
            "    >>> mod_combination(1000000007, 10, 2)",
            "    45",
            "    >>> mod_combination(7, 10, 2)",
            "    3",
            "    '''",
            "    return mod_permutation(mod, n, r) * mod_inv(mod, mod_factorial(mod, r)) % mod",
            "class ModFactorial:",
            "    def __init__(self, mod, size=1):",
            "        '''",
            "        >>> ModFactorial(7, 7)",
            "        Traceback (most recent call last):",
            "        ...",
            "        AssertionError",
            "        '''",
            "        assert mod > size",
            "        self._mod = mod",
            "        self._init_factorials(size)",
            "    def _mod_range(self, start, stop=None, step=1):",
            "        return mod_range(self._mod, start, stop, step)",
            "    def _mod_inv(self, n):",
            "        return mod_inv(self._mod, n)",
            "    def _init_factorials(self, size):",
            "        '''",
            "        >>> mf1 = ModFactorial(1000000007)",
            "        >>> mf2 = ModFactorial(1000000007, 10)",
            "        >>> mf1.factorial(10) == mf2.factorial(10)",
            "        True",
            "        '''",
            "        self._factorials = [1] * size",
            "        n = 1 # リストの参照は遅いので減らす",
            "        for i, m in enumerate(self._mod_range(1, size), 1):",
            "            n = (n * m) % self._mod",
            "            self._factorials[i] = n",
            "    def _append_factorials(self, n):",
            "        for m in map(lambda i: i % self._mod, range(len(self._factorials), n+1)):",
            "            self._factorials.append((self._factorials[-1] * m) % self._mod)",
            "    def factorial(self, n):",
            "        '''",
            "        >>> ModFactorial(1000000007).factorial(10)",
            "        3628800",
            "        >>> ModFactorial(7).factorial(6)",
            "        6",
            "        >>> ModFactorial(7).factorial(7)",
            "        Traceback (most recent call last):",
            "        ...",
            "        AssertionError",
            "        '''",
            "        assert n < self._mod",
            "        if len(self._factorials) <= n:",
            "            self._append_factorials(n)",
            "        return self._factorials[n]",
            "    def factorial_inv(self, n):",
            "        '''",
            "        >>> MOD = 1000000007",
            "        >>> mf = ModFactorial(MOD)",
            "        >>> mf.factorial_inv(10)",
            "        283194722",
            "        >>> mf.factorial_inv(10) * mf.factorial(10) % MOD",
            "        1",
            "        >>> MOD = 7",
            "        >>> mf = ModFactorial(MOD)",
            "        >>> mf.factorial_inv(6)",
            "        6",
            "        >>> mf.factorial_inv(6) * mf.factorial(6) % MOD",
            "        1",
            "        '''",
            "        return self._mod_inv(self.factorial(n))",
            "    def permutation(self, n, r):",
            "        '''",
            "        >>> ModFactorial(1000000007).permutation(10, 2)",
            "        90",
            "        '''",
            "        return self.factorial(n) * self.factorial_inv(n-r) % self._mod",
            "    def combination(self, n, r):",
            "        '''",
            "        >>> ModFactorial(1000000007).combination(10, 2)",
            "        45",
            "        '''",
            "        return self.permutation(n, r) * self.factorial_inv(r) % self._mod",
            "def test():",
            "    import doctest",
            "    doctest.testmod()",
            "if __name__ == '__main__':",
            "    #test()",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def isp():   return input().split()",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    a, v = mi()",
            "    b, w = mi()",
            "    t = ii()",
            "    if v <= w:",
            "        print('NO')",
            "    else:",
            "        dist = abs(a - b)",
            "        print('YES') if dist <= t * (v - w) else print('NO')",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def isp():   return input().split()",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, k = mi()",
            "    L = lmi()",
            "    for _ in range(k):",
            "        if min(L) == n:",
            "            break",
            "        imos = [0] * n",
            "        for i in range(n):",
            "            num = L[i]",
            "            imos[max(0, i - num)] += 1",
            "            if i + num + 1 <= n - 1:",
            "                imos[i + num + 1] -= 1",
            "        for i in range(1, n):",
            "            imos[i] += imos[i-1]",
            "        L = imos",
            "    print(*L, sep=' ')",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 998244353                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    # def my_update(seq, L):",
            "    #     n = len(seq)",
            "    #     for i in range(n-1):",
            "    #         seq[i+1] += L[i]",
            "    # n, s = mi()",
            "    # L = lmi()",
            "    # dp = [[0] * (n + 1) for j in range(s + 1)]    # chain の長さ、場合のかず",
            "    # # print(dp)",
            "    # for i in range(n):",
            "    #     for j in range(s, -1, -1):",
            "    #         if j == 0 and L[i] <= s:",
            "    #             dp[L[i]][1] += 1",
            "    #         elif j + L[i] <= s and dp[j]:",
            "    #             my_update(dp[j + L[i]], dp[j])    # counter",
            "    #     # print(dp)",
            "    # ans = 0",
            "    # for chain_len, num in enumerate(dp[s]):",
            "    #     ans = (ans + pow(2, n - chain_len, mod) * num) % mod",
            "    # print(ans)",
            "    # write-up solution",
            "    \"\"\"",
            "    Ai それぞれ選ぶ or 選ばないと選択して行った時、足して S にできる組み合わせは何パターンできるか？",
            "    ->",
            "    まさに二項定理の発想",
            "    fi = 1+x^Ai として",
            "    T = {1, 2, 3} に対する答えは [x^S]f1*f2*f3",
            "    T = {1, 2} に対する答えは [x^S]f1*f2",
            "    のように計算していく",
            "    全パターン f1*f2*f3 + f1*f2 + f1*f3 + f2*f3 + f1 + f2 + f3 の [x^S] の値が答え",
            "    ->",
            "    (1+f1)*...*(1+fi)*...*(1+fn) の x^S の係数と一致",
            "    [x^S] Π{i=1...n} (2 + x^Ai)",
            "    を計算せよ、という問である",
            "    \"\"\"",
            "    n, s = mi()",
            "    A = lmi()",
            "    power_memo = [0] * (s + 1)",
            "    power_memo[0] = 2",
            "    if A[0] <= s:",
            "        power_memo[A[0]] = 1",
            "    for i in range(1, n):",
            "        # print(power_memo)",
            "        for j in range(s, -1, -1):",
            "            tmp = (power_memo[j] * 2) % mod",
            "            if j - A[i] >= 0 and power_memo[j - A[i]]:",
            "                tmp += power_memo[j - A[i]]",
            "            power_memo[j] = tmp % mod",
            "    # print(power_memo)",
            "    print(power_memo[s])",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# abc168_c.py",
            "# https://atcoder.jp/contests/abc168/tasks/abc168_c",
            "# C - : (Colon) /",
            "# 実行時間制限: 2 sec / メモリ制限: 1024 MB",
            "# 配点: 300点",
            "# 問題文",
            "# 時針と分針の長さがそれぞれ Aセンチメートル、Bセンチメートルであるアナログ時計を考えます。",
            "# 時針と分針それぞれの片方の端点は同じ定点に固定されており、この点を中心としてそれぞれの針は一定の角速度で時計回りに回転します。",
            "# 時針は 12時間で、分針は 1 時間で 1周します。",
            "# 0時ちょうどに時針と分針は重なっていました。",
            "# ちょうど H 時 M 分になったとき、2本の針の固定されていない方の端点は何センチメートル離れているでしょうか。",
            "# 制約",
            "#     入力はすべて整数",
            "#     1≤A,B≤1000",
            "#     0≤H≤11",
            "#     0≤M≤59",
            "# 入力",
            "# 入力は以下の形式で標準入力から与えられる。",
            "# A B H M",
            "# 出力",
            "# 答えを、単位を除いて出力せよ。正しい値との絶対誤差または相対誤差が 10−9以下であれば正解とみなされる。",
            "# 入力例 1",
            "# 3 4 9 0",
            "# 出力例 1",
            "# 5.00000000000000000000",
            "# 2本の針は図のようになるので、答えは 5センチメートルです。",
            "# 9時0分のアナログ時計",
            "# 入力例 2",
            "# 3 4 10 40",
            "# 出力例 2",
            "# 4.56425719433005567605",
            "# 2本の針は図のようになります。各針は常に一定の角速度で回ることに注意してください。",
            "global FLAG_LOG",
            "FLAG_LOG = False",
            "def log(value):",
            "    # FLAG_LOG = True",
            "    FLAG_LOG = False",
            "    if FLAG_LOG:",
            "        print(str(value))",
            "def calculation(lines):",
            "    # S = lines[0]",
            "    # N = int(lines[0])",
            "    A, B, H, M = list(map(int, lines[0].split()))",
            "    # values = list(map(int, lines[1].split()))",
            "    # values = list(map(int, lines[2].split()))",
            "    # values = list()",
            "    # for i in range(N):",
            "    #     values.append(int(lines[i]))",
            "    # valueses = list()",
            "    # for i in range(N):",
            "    #     valueses.append(list(map(int, lines[i+1].split())))",
            "    h = 360 / 12 * (H+(M/60))",
            "    m = 360 / 60 * M",
            "    a = abs(h-m)",
            "    log(f'h=[{h}], m=[{m}], a=[{a}]')",
            "    # Ｈ軸をＸ扱いで、(3, 0) ※この座標は固定",
            "    # x, y = 3.0, 0",
            "    # M軸の座標を計算",
            "    import math",
            "    x = math.cos(a/180*math.pi) * B",
            "    y = math.sin(a/180*math.pi) * B",
            "    log(f'x=[{x}], y=[{y}]')",
            "    result = ((x-A)**2 + y**2)**0.5",
            "    return [result]",
            "# 引数を取得",
            "def get_input_lines(lines_count):",
            "    lines = list()",
            "    for _ in range(lines_count):",
            "        lines.append(input())",
            "    return lines",
            "# テストデータ",
            "def get_testdata(pattern):",
            "    if pattern == 1:",
            "        lines_input = ['3 4 9 0']",
            "        lines_export = [5.00000000000000000000]",
            "    if pattern == 2:",
            "        lines_input = ['3 4 10 40']",
            "        lines_export = [4.56425719433005567605]",
            "    return lines_input, lines_export",
            "# 動作モード判別",
            "def get_mode():",
            "    import sys",
            "    args = sys.argv",
            "    global FLAG_LOG",
            "    if len(args) == 1:",
            "        mode = 0",
            "        FLAG_LOG = False",
            "    else:",
            "        mode = int(args[1])",
            "        FLAG_LOG = True",
            "    return mode",
            "# 主処理",
            "def main():",
            "    import time",
            "    started = time.time()",
            "    mode = get_mode()",
            "    if mode == 0:",
            "        lines_input = get_input_lines(1)",
            "    else:",
            "        lines_input, lines_export = get_testdata(mode)",
            "    lines_result = calculation(lines_input)",
            "    for line_result in lines_result:",
            "        print(line_result)",
            "    # if mode > 0:",
            "    #     print(f'lines_input=[{lines_input}]')",
            "    #     print(f'lines_export=[{lines_export}]')",
            "    #     print(f'lines_result=[{lines_result}]')",
            "    #     if lines_result == lines_export:",
            "    #         print('OK')",
            "    #     else:",
            "    #         print('NG')",
            "    # finished = time.time()",
            "    # duration = finished - started",
            "    # print(f'duration=[{duration}]')",
            "# 起動処理",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "from collections import defaultdict",
            "sys.setrecursionlimit(500000)",
            "class Fraction:",
            "    def gcd(self, a ,b):",
            "        a,b = max(a,b),min(a,b)",
            "        while a%b!=0:",
            "            a,b = b,a%b",
            "        return b",
            "    def frac(self,a,b):",
            "        if a==0 and b==0:",
            "            return (0,0)",
            "        elif a==0:",
            "            return (0,1)",
            "        elif b==0:",
            "            return (1,0)",
            "        else:",
            "            d = self.gcd(abs(a),abs(b))",
            "            if a<0:",
            "                a = -a",
            "                b = -b",
            "            return (a//d,b//d)",
            "    def __init__(self, a, b):",
            "        self.value = self.frac(a,b)",
            "    def v(self):",
            "        return self.value",
            "    def __lt__(self, other):",
            "        assert self.value!=(0,0) and other.value!=(0,0), 'value (0,0) cannot be compared.'",
            "        a,b = self.value",
            "        c,d = other.value",
            "        return a*d < b*c",
            "    def __le__(self, other):",
            "        assert self.value!=(0,0) and other.value!=(0,0), 'value (0,0) cannot be compared.'",
            "        a,b = self.value",
            "        c,d = other.value",
            "        return a*d <= b*c",
            "    def __eq__(self, other):",
            "        a,b = self.value",
            "        c,d = other.value",
            "        return a==c and b==d",
            "    def __ne__(self, other):",
            "        a,b = self.value",
            "        c,d = other.value",
            "        return not (a==c and b==d)",
            "    def __gt__(self, other):",
            "        assert self.value!=(0,0) and other.value!=(0,0), 'value (0,0) cannot be compared.'",
            "        a,b = self.value",
            "        c,d = other.value",
            "        return a*d > b*c",
            "    def __ge__(self, other):",
            "        assert self.value!=(0,0) and other.value!=(0,0), 'value (0,0) cannot be compared.'",
            "        a,b = self.value",
            "        c,d = other.value",
            "        return a*d >= b*c",
            "    def __add__(self, other):",
            "        a,b = self.value",
            "        c,d = other.value",
            "        return Fraction(a*d + b*c, b*d)",
            "    def __sub__(self, other):",
            "        a,b = self.value",
            "        c,d = other.value",
            "        return Fraction(a*d - b*c, b*d)",
            "    def __mul__(self, other):",
            "        a,b = self.value",
            "        c,d = other.value",
            "        return Fraction(a*c, b*d)",
            "    def __truediv__(self, other):",
            "        a,b = self.value",
            "        c,d = other.value",
            "        return Fraction(a*d, b*c)",
            "    def __neg__(self):",
            "        a,b = self.value",
            "        return Fraction(-a,b)",
            "    def inv(self):",
            "        return Fraction(1,1) / self",
            "def input():",
            "    return sys.stdin.readline()[:-1]",
            "def main():",
            "    N = int(input())",
            "    vec = [list(map(int,input().split())) for i in range(N)]",
            "    arg = defaultdict(int)",
            "    zero = 0",
            "    for v in vec:",
            "        if v[0] == 0 and v[1] == 0:",
            "            zero += 1",
            "        else:",
            "            f = Fraction(v[0],v[1])",
            "            arg[f.v()] += 1",
            "            arg[(-f.inv()).v()] += 0",
            "    pair = []",
            "    fd = lambda : False",
            "    checked_list = defaultdict(fd)",
            "    for key in arg:",
            "        if not checked_list[key]:",
            "            inv = (-Fraction(*key).inv()).v()",
            "            pair.append([arg[key],arg[inv]])",
            "            checked_list[inv] = True",
            "    mod = 1000000007",
            "    ans = 1",
            "    for p1,p2 in pair:",
            "        ans *= pow(2,p1,mod) + pow(2,p2,mod) - 1",
            "        ans %= mod",
            "    ans += zero",
            "    ans %= mod",
            "    print((ans+mod-1)%mod)",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "#",
            "# 　　  ⋀_⋀",
            "#　　  (･ω･)",
            "# .／ Ｕ ∽ Ｕ＼",
            "#  │＊　合　＊│",
            "#  │＊　格　＊│",
            "#  │＊　祈　＊│",
            "#  │＊　願　＊│",
            "#  │＊　　　＊│",
            "#      ￣",
            "#",
            "import sys",
            "sys.setrecursionlimit(10**6)",
            "input=sys.stdin.readline",
            "from math import floor,sqrt,factorial,hypot,log,gcd #log2ないｙｐ",
            "from heapq import heappop, heappush, heappushpop",
            "from collections import Counter,defaultdict,deque",
            "from itertools import accumulate,permutations,combinations,product,combinations_with_replacement",
            "from bisect import bisect_left,bisect_right",
            "from copy import deepcopy",
            "from random import randint",
            "def ceil(a,b): return (a+b-1)//b",
            "inf=float('inf')",
            "mod = 10**9+7",
            "def pprint(*A):",
            "    for a in A:     print(*a,sep='\\n')",
            "def INT_(n): return int(n)-1",
            "def MI(): return map(int,input().split())",
            "def MF(): return map(float, input().split())",
            "def MI_(): return map(INT_,input().split())",
            "def LI(): return list(MI())",
            "def LI_(): return [int(x) - 1 for x in input().split()]",
            "def LF(): return list(MF())",
            "def LIN(n:int): return [I() for _ in range(n)]",
            "def LLIN(n: int): return [LI() for _ in range(n)]",
            "def LLIN_(n: int): return [LI_() for _ in range(n)]",
            "def LLI(): return [list(map(int, l.split() )) for l in input()]",
            "def I(): return int(input())",
            "def F(): return float(input())",
            "def ST(): return input().replace('\\n', '')",
            "#mint",
            "class ModInt:",
            "    def __init__(self, x):",
            "        self.x = x % mod",
            "    def __str__(self):",
            "        return str(self.x)",
            "    __repr__ = __str__",
            "    def __add__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(self.x + other.x)",
            "        else:",
            "            return ModInt(self.x + other)",
            "    __radd__ = __add__",
            "    def __sub__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(self.x - other.x)",
            "        else:",
            "            return ModInt(self.x - other)",
            "    def __rsub__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(other.x - self.x)",
            "        else:",
            "            return ModInt(other - self.x)",
            "    def __mul__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(self.x * other.x)",
            "        else:",
            "            return ModInt(self.x * other)",
            "    __rmul__ = __mul__",
            "    def __truediv__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(self.x * pow(other.x, mod-2,mod))",
            "        else:",
            "            return ModInt(self.x * pow(other, mod - 2, mod))",
            "    def __rtruediv(self, other):",
            "        if isinstance(other, self):",
            "            return ModInt(other * pow(self.x, mod - 2, mod))",
            "        else:",
            "            return ModInt(other.x * pow(self.x, mod - 2, mod))",
            "    def __pow__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(pow(self.x, other.x, mod))",
            "        else:",
            "            return ModInt(pow(self.x, other, mod))",
            "    def __rpow__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(pow(other.x, self.x, mod))",
            "        else:",
            "            return ModInt(pow(other, self.x, mod))",
            "def main():",
            "    N=I()",
            "    A,B=[],[]",
            "    for i in range(N):",
            "        a,b = MI()",
            "        A.append(a)",
            "        B.append(b)",
            "    both_zero_cnt = 0",
            "    num_of_group = defaultdict(int) ##既約分数にしてあげて、(分子,分母)がkeyで、負なら分子が負になる他は正",
            "    for i in range(N):",
            "        a,b = A[i], B[i]",
            "        if(a==b==0):",
            "            both_zero_cnt+=1",
            "            continue",
            "        elif(a==0):",
            "            num_of_group[-inf,inf] += 1",
            "            num_of_group[inf,inf] += 0",
            "        elif(b==0):",
            "            num_of_group[inf,inf] += 1",
            "        else:",
            "            if(a*b<0):",
            "                a,b=abs(a),abs(b)",
            "                g = gcd(a,b)",
            "                a//=g",
            "                b//=g",
            "                num_of_group[(-b,a)] += 1",
            "                num_of_group[(b,a)] += 0",
            "            else:",
            "                a,b=abs(a),abs(b)",
            "                g = gcd(a,b)",
            "                a//=g",
            "                b//=g",
            "                num_of_group[(a,b)] += 1",
            "    # print(num_of_group.items())",
            "    if(both_zero_cnt==N):",
            "        print(N)",
            "        return",
            "    ##solve",
            "    ans = ModInt(1)",
            "    # two_pow = [1]",
            "    # for i in range(N):",
            "    #     two_pow.append((2*two_pow[-1])%mod)",
            "    # print(two_pow,\"#######\")",
            "    for (a,b),cnt1 in num_of_group.items():",
            "        if(a<0):",
            "            continue",
            "        tmp = ModInt(2)**cnt1",
            "        if (-a,b) in num_of_group:",
            "            cnt2 = num_of_group[-a,b]",
            "            tmp += ModInt(2)**cnt2",
            "            tmp-=1",
            "        if(tmp):",
            "            ans *= tmp",
            "    ans -= 1 ##全部選ばない",
            "    ans += both_zero_cnt",
            "    print(ans)",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "sys.setrecursionlimit(10**6) #再帰関数の上限",
            "import math",
            "from copy import copy, deepcopy",
            "from operator import itemgetter",
            "from bisect import bisect_left, bisect, bisect_right#2分探索",
            "#bisect_left(l,x), bisect(l,x)#aはソート済みである必要あり。aの中からx未満の要素数を返す。rightだと以下",
            "from collections import deque",
            "#deque(l), pop(), append(x), popleft(), appendleft(x)",
            "##listでqueの代用をするとO(N)の計算量がかかってしまうので注意",
            "from collections import Counter#文字列を個数カウント辞書に、",
            "#S=Counter(l),S.most_common(x),S.keys(),S.values(),S.items()",
            "from itertools import accumulate#累積和",
            "#list(accumulate(l))",
            "from heapq import heapify,heappop,heappush",
            "#heapify(q),heappush(q,a),heappop(q) #q=heapify(q)としないこと、返り値はNone",
            "#import fractions#古いatcoderコンテストの場合GCDなどはここからimportする",
            "def input(): return sys.stdin.readline()[:-1]",
            "def printl(li): print(*li, sep=\"\\n\")",
            "def argsort(s, return_sorted=False):",
            "    inds=sorted(range(len(s)), key=lambda k: s[k])",
            "    if return_sorted: return inds, [s[i] for i in inds]",
            "    return inds",
            "def alp2num(c,cap=False): return ord(c)-97 if not cap else ord(c)-65",
            "def num2alp(i,cap=False): return chr(i+97) if not cap else chr(i+65)",
            "class modint():#add:和,mul:積,pow:累乗,div:商(modと互いに素であること)",
            "    def __init__(self,x,mod=1000000007): self.x, self.mod=x, mod",
            "    def add(self,a): self.x=(self.x+a%self.mod)%self.mod",
            "    def mul(self,c): self.x=(self.x*(c%self.mod))%self.mod",
            "    def pow(self,p): self.x=pow(self.x,p,self.mod)",
            "    def div(self,d):",
            "        u,v,a,b=1,0,d,self.mod",
            "        while b:",
            "            t=a//b",
            "            a-=t*b",
            "            a,b,u,v=b,a,v,u-t*v",
            "        if a!=1: print(\"not 素\")",
            "        self.x=(self.x*(u%self.mod))%self.mod",
            "def main():",
            "    mod = 1000000007",
            "    #w.sort(key=itemgetter(1),reversed=True)  #二個目の要素で降順並び替え",
            "    N = int(input())",
            "    #N, K = map(int, input().split())",
            "    #A = tuple(map(int, input().split())) #1行ベクトル",
            "    #L = tuple(int(input()) for i in range(N)) #改行ベクトル",
            "    #S = tuple(tuple(map(int, input().split())) for i in range(N)) #改行行列",
            "    d=dict()",
            "    m=10**18+100",
            "    for i in range(N):",
            "        A, B = map(int, input().split())",
            "        if A==0 and B==0:",
            "            d[-m]=d.get(-m,0)+1",
            "        elif B==0:",
            "            d[m]=d.get(m,0)+1",
            "        elif A==0:",
            "            d[0]=d.get(0,0)+1",
            "        else:",
            "            sa=sb=1",
            "            if A<0:",
            "                sa=-1",
            "                A*=-1",
            "            if B<0:",
            "                sb=-1",
            "                B*=-1",
            "            g=math.gcd(A,B)",
            "            A=A//g",
            "            B=B//g",
            "            if sa==-1 and sb==-1:",
            "                t=(A,B)",
            "            elif sb==-1:",
            "                t=(-A,B)",
            "            else:",
            "                t=(sa*A,sb*B)",
            "            d[t]=d.get(t,0)+1",
            "    #print(d)",
            "    ks=set(d.keys())",
            "    alis=[]",
            "    tot=modint(1)",
            "    for i, k in enumerate(ks):",
            "        if d[k]==-1.0:",
            "            continue",
            "        if k==-m:",
            "            continue",
            "        if k==m:",
            "            ik=0",
            "        elif k==0:",
            "            ik=m",
            "        elif k[0]<0:",
            "            ik=(k[1],-k[0])",
            "        else:",
            "            ik=(-k[1],k[0])",
            "        #print(ik)",
            "        if ik in ks:",
            "            d1,d2=d[k],d[ik]",
            "            tot.mul((pow(2,d1,mod)-1)+(pow(2,d2,mod)-1)+1)",
            "            d[ik]=-1",
            "        else:",
            "            tot.mul(pow(2,d[k],mod))",
            "    tot.add(-1)",
            "    tot.add(d.get(-m,0))",
            "    print(tot.x)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "from heapq import heappush, heappop, heapify",
            "from collections import deque, defaultdict, Counter",
            "import itertools",
            "from itertools import permutations, combinations, accumulate, product, combinations_with_replacement",
            "import sys",
            "import bisect",
            "import string",
            "import math",
            "import time",
            "def I(): return int(input())",
            "def S(): return input()",
            "def MI(): return map(int, input().split())",
            "def MS(): return map(str, input().split())",
            "def LI(): return [int(i) for i in input().split()]",
            "def LI_(): return [int(i)-1 for i in input().split()]",
            "def StoI(): return [ord(i)-97 for i in input()]",
            "def ItoS(nn): return chr(nn+97)",
            "def input(): return sys.stdin.readline().rstrip()",
            "def list2d(a, b, c): return [[c] * b for i in range(a)]",
            "def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]",
            "def list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]",
            "def print_matrix(mat):",
            "    for i in range(len(mat)):",
            "        print(*['IINF' if v == IINF else \"{:0=4}\".format(v) for v in mat[i]])",
            "yn = {False: 'No', True: 'Yes'}",
            "YN = {False: 'NO', True: 'YES'}",
            "MOD = 10**9+7",
            "inf = float('inf')",
            "IINF = 10**19",
            "l_alp = string.ascii_lowercase",
            "u_alp = string.ascii_uppercase",
            "ts = time.time()",
            "sys.setrecursionlimit(10**6)",
            "nums = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10']",
            "show_flg = False",
            "# show_flg = True",
            "def gcd(a, b):",
            "    if b == 0:",
            "        return a",
            "    return gcd(b, a % b)",
            "def main():",
            "    N = I()",
            "    zero = 0",
            "    plus_Ai_Bi = defaultdict(int)",
            "    minus_Bj_Aj = defaultdict(int)",
            "    zero_cnt = 0",
            "    used = set()",
            "    for i in range(N):",
            "        a, b = MI()",
            "        if a == 0 and b == 0:",
            "            zero_cnt += 1",
            "            continue",
            "        gcdab = gcd(abs(a), abs(b))",
            "        a = a // gcdab",
            "        b = b // gcdab",
            "        if a > 0 and b > 0:",
            "            # pos",
            "            plus_Ai_Bi[(a, b)] += 1",
            "            # neg",
            "            minus_Bj_Aj[(-b, a)] += 1",
            "        elif a > 0 and b < 0:",
            "            # neg",
            "            plus_Ai_Bi[(-a, -b)] += 1",
            "            # pos",
            "            minus_Bj_Aj[(-b, a)] += 1",
            "        elif a < 0 and b > 0:",
            "            # neg",
            "            plus_Ai_Bi[(a, b)] += 1",
            "            # pos",
            "            minus_Bj_Aj[(b, -a)] += 1",
            "        elif a == 0:",
            "            # neg",
            "            plus_Ai_Bi[(a, abs(b))] += 1",
            "            # pos",
            "            minus_Bj_Aj[(abs(b), a)] += 1",
            "        elif b == 0:",
            "            # neg",
            "            plus_Ai_Bi[(abs(a), b)] += 1",
            "            # pos",
            "            minus_Bj_Aj[(b, abs(a))] += 1",
            "        else:",
            "            # pos",
            "            plus_Ai_Bi[(-a, -b)] += 1",
            "            # neg",
            "            minus_Bj_Aj[(b, -a)] += 1",
            "    # print(plus_Ai_Bi)",
            "    # print(minus_Bj_Aj)",
            "    ans = 1",
            "    for pair, cnt1 in plus_Ai_Bi.items():",
            "        a, b = pair",
            "        if pair in used:",
            "            continue",
            "        if pair in minus_Bj_Aj:",
            "            cnt2 = minus_Bj_Aj[pair]",
            "            group1 = pow(2, cnt1, MOD) - 1",
            "            group2 = pow(2, cnt2, MOD) - 1",
            "            ans *= group1 + group2 + 1",
            "            ans %= MOD",
            "            if a > 0 and b > 0:",
            "                # minus_Bj_Aj[(-b, a)] += 1",
            "                used.add((-b, a))",
            "            elif a > 0 and b < 0:",
            "                # minus_Bj_Aj[(-b, a)] += 1",
            "                used.add((-b, a))",
            "            elif a < 0 and b > 0:",
            "                # minus_Bj_Aj[(b, -a)] += 1",
            "                used.add((b, -a))",
            "            elif a == 0:",
            "                used.add((abs(b), a))",
            "            elif b == 0:",
            "                used.add((b, abs(a)))",
            "            else:",
            "                # minus_Bj_Aj[(b, -a)] += 1",
            "                used.add((b, -a))",
            "            # print(pair, ans)",
            "        else:",
            "            ans *= pow(2, cnt1, MOD)",
            "            ans %= MOD",
            "    print((ans - 1 + zero_cnt) % MOD)",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "from math import gcd",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def standardization(a, b):",
            "        \"\"\"",
            "        (a, b) で表される方向ベクトルをシンプルな整数ペアの方向ベクトルへ変換する",
            "        処理後は第一、第四象限に方向ベクトルが集中する",
            "        \"\"\"",
            "        assert (a != 0 or b != 0)",
            "        if a == 0:",
            "            return (0, 1)",
            "        if b == 0:",
            "            return (1, 0)",
            "        g = gcd(a, b)",
            "        a //= g",
            "        b //= g",
            "        # 第一項は正になるように",
            "        # 原点対照にしてもベクトルの直行性は変わらない",
            "        return (a, b) if a > 0 else (-a, -b)",
            "    n = ii()",
            "    L = [lmi() for _ in range(n)]",
            "    dict_b_pos = defaultdict(int)",
            "    dict_b_neg = defaultdict(int)",
            "    origin = 0",
            "    for a, b in L:",
            "        if a == 0 and b == 0:",
            "            origin += 1",
            "            continue",
            "        a, b = standardization(a, b)",
            "        if b <= 0:",
            "            dict_b_neg[(a, b)] += 1",
            "        else:",
            "            dict_b_pos[(b, -a)] += 1    # 対応するものはこれ",
            "            dict_b_neg[(b, -a)] += 0    # 対応するスロットだけ作っておきループが回るようにする",
            "    # print(dict_b_neg)",
            "    # print(dict_b_pos)",
            "    ans = origin",
            "    tmp = 1",
            "    for key, u in dict_b_neg.items():",
            "        v = dict_b_pos[key]",
            "        tmp = (tmp * (1 + pow(2, u, mod) - 1 + pow(2, v, mod) - 1)) % mod",
            "    ans += tmp",
            "    ans -= 1    # 全部使わないパターンを除く",
            "    print(ans % mod)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "from io import StringIO",
            "import unittest",
            "import os",
            "# 再帰処理上限(dfs作成時に設定するのが面倒なので限度近い値を組み込む)",
            "sys.setrecursionlimit(999999999)",
            "def prepare(n, mod=998244353):",
            "    f = 1",
            "    factorials = [1]",
            "    for m in range(1, n + 1):",
            "        f *= m",
            "        f %= mod",
            "        factorials.append(f)",
            "    inv = pow(f, mod - 2, mod)",
            "    invs = [1] * (n + 1)",
            "    invs[n] = inv",
            "    for m in range(n, 1, -1):",
            "        inv *= m",
            "        inv %= mod",
            "        invs[m - 1] = inv",
            "    return factorials, invs",
            "def cmb(n, r):",
            "    mod = 998244353",
            "    ans = 1",
            "    for i in range(r):",
            "        ans *= n - i",
            "        ans %= mod",
            "    for i in range(1, r + 1):",
            "        ans *= pow(i, mod - 2, mod)",
            "        ans %= mod",
            "    return ans",
            "# 実装を行う関数",
            "def resolve(test_def_name=\"\"):",
            "    n, m, k = map(int, input().split())",
            "    # 全組み合わせ数(重複順列)",
            "    # all_pattern = pow(m, n, 998244353)",
            "    # 使用方法サンプル(10 N 3= 10個の要素から3つを選ぶ場合の組み合わせ数)",
            "    fns, invs = prepare(2000000)",
            "    # さらに6 N 5= 6個の要素から5つを選ぶ場合の組み合わせ数 ->このように、大量のパターンが欲しいときはこっちを使う。",
            "    # aa = (fns[6] * invs[5] * invs[6 - 5]) % 998244353  # ans=120",
            "    # 許容される組み合わせを加算していく",
            "    ans = 0",
            "    for i in range(k + 1):",
            "        # ans += (m * pow(m - 1, m - i - 1, 998244353) * cmb(n - 1, i)) % 998244353",
            "        # ans = (fns[n-1] * invs[k] * invs[n-1 - k]) % 998244353",
            "        ans += m * pow(m - 1, n - i - 1, 998244353) * (fns[n - 1] * invs[i] * invs[n - 1 - i])",
            "        ans = ans % 998244353",
            "    print(ans)",
            "    # ans = (m * pow(m - 1, m - k - 1, 998244353) * cmb(n - 1, k)) % 998244353",
            "    # カウント外の組み合わせ数",
            "    # kpl1 = k + 1",
            "    # ng_pattern = m * pow((m - 1), n - (k + 1), 998244353)",
            "    # ng_pattern = ng_pattern % 998244353",
            "    # ans = all_pattern - ng_pattern",
            "# テストクラス",
            "class TestClass(unittest.TestCase):",
            "    def assertIO(self, assert_input, output):",
            "        stdout, sat_in = sys.stdout, sys.stdin",
            "        sys.stdout, sys.stdin = StringIO(), StringIO(assert_input)",
            "        resolve(sys._getframe().f_back.f_code.co_name)",
            "        sys.stdout.seek(0)",
            "        out = sys.stdout.read()[:-1]",
            "        sys.stdout, sys.stdin = stdout, sat_in",
            "        self.assertEqual(out, output)",
            "    def test_input_1(self):",
            "        test_input = \"\"\"3 2 1\"\"\"",
            "        output = \"\"\"6\"\"\"",
            "        self.assertIO(test_input, output)",
            "    def test_input_2(self):",
            "        test_input = \"\"\"100 100 0\"\"\"",
            "        output = \"\"\"73074801\"\"\"",
            "        self.assertIO(test_input, output)",
            "    def test_input_3(self):",
            "        test_input = \"\"\"60522 114575 7559\"\"\"",
            "        output = \"\"\"479519525\"\"\"",
            "        self.assertIO(test_input, output)",
            "    # 自作テストパターンのひな形(利用時は「tes_t」のアンダーバーを削除すること",
            "    def test_1original_1(self):",
            "        test_input = \"\"\"4 10 0\"\"\"",
            "        output = \"\"\"7290\"\"\"",
            "        self.assertIO(test_input, output)",
            "    def test_1original_2(self):",
            "        test_input = \"\"\"4 10 1\"\"\"",
            "        output = \"\"\"9720\"\"\"",
            "        self.assertIO(test_input, output)",
            "    def test_1original_3(self):",
            "        test_input = \"\"\"4 10 2\"\"\"",
            "        output = \"\"\"9990\"\"\"",
            "        self.assertIO(test_input, output)",
            "    def test_1original_4(self):",
            "        test_input = \"\"\"4 10 3\"\"\"",
            "        output = \"\"\"10000\"\"\"",
            "        self.assertIO(test_input, output)",
            "# 実装orテストの呼び出し",
            "if __name__ == \"__main__\":",
            "    if os.environ.get(\"USERNAME\") is None:",
            "        # AtCoder提出時の場合",
            "        resolve()",
            "    else:",
            "        # 自PCの場合",
            "        unittest.main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "content": [
            "import sys",
            "read = sys.stdin.buffer.read",
            "readline = sys.stdin.buffer.readline",
            "readlines = sys.stdin.buffer.readlines",
            "sys.setrecursionlimit(10 ** 7)",
            "class Combination:",
            "    def __init__(self, n_max, mod=10**9+7):",
            "        # O(n_max + log(mod))",
            "        self.mod = mod",
            "        f = 1",
            "        self.fac = fac = [f]",
            "        for i in range(1, n_max+1):",
            "            f = f * i % mod",
            "            fac.append(f)",
            "        f = pow(f, mod-2, mod)",
            "        self.facinv = facinv = [f]",
            "        for i in range(n_max, 0, -1):",
            "            f = f * i % mod",
            "            facinv.append(f)",
            "        facinv.reverse()",
            "    # \"n 要素\" は区別できる n 要素",
            "    # \"k グループ\" はちょうど k グループ",
            "    def __call__(self, n, r):  # self.C と同じ",
            "        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod",
            "    def C(self, n, r):",
            "        if not 0 <= r <= n:",
            "            return 0",
            "        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod",
            "    def P(self, n, r):",
            "        if not 0 <= r <= n:",
            "            return 0",
            "        return self.fac[n] * self.facinv[n-r] % self.mod",
            "    def H(self, n, r):",
            "        if (n == 0 and r > 0) or r < 0:",
            "            return 0",
            "        return self.fac[n+r-1] * self.facinv[r] % self.mod * self.facinv[n-1] % self.mod",
            "    def rising_factorial(self, n, r):  # 上昇階乗冪 n * (n+1) * ... * (n+r-1)",
            "        return self.fac[n+r-1] * self.facinv[n-1] % self.mod",
            "    def stirling_first(self, n, k):  # 第 1 種スターリング数  lru_cache を使うと O(nk)  # n 要素を k 個の巡回列に分割する場合の数",
            "        if n == k:",
            "            return 1",
            "        if k == 0:",
            "            return 0",
            "        return (self.stirling_first(n-1, k-1) + (n-1)*self.stirling_first(n-1, k)) % self.mod",
            "    def stirling_second(self, n, k):  # 第 2 種スターリング数 O(k + log(n))  # n 要素を区別のない k グループに分割する場合の数",
            "        if n == k:",
            "            return 1  # n==k==0 のときのため",
            "        return self.facinv[k] * sum((-1)**(k-m) * self.C(k, m) * pow(m, n, self.mod) for m in range(1, k+1)) % self.mod",
            "    def balls_and_boxes_3(self, n, k):  # n 要素を区別のある k グループに分割する場合の数  O(k + log(n))",
            "        return sum((-1)**(k-m) * self.C(k, m) * pow(m, n, self.mod) for m in range(1, k+1)) % self.mod",
            "    def bernoulli(self, n):  # ベルヌーイ数  lru_cache を使うと O(n**2 * log(mod))",
            "        if n == 0:",
            "            return 1",
            "        if n % 2 and n >= 3:",
            "            return 0  # 高速化",
            "        return (- pow(n+1, self.mod-2, self.mod) * sum(self.C(n+1, k) * self.bernoulli(k) % self.mod for k in range(n))) % self.mod",
            "    def faulhaber(self, k, n):  # べき乗和 0^k + 1^k + ... + (n-1)^k",
            "        # bernoulli に lru_cache を使うと O(k**2 * log(mod))  bernoulli が計算済みなら O(k * log(mod))",
            "        return pow(k+1, self.mod-2, self.mod) * sum(self.C(k+1, j) * self.bernoulli(j) % self.mod * pow(n, k-j+1, self.mod) % self.mod for j in range(k+1)) % self.mod",
            "    def lah(self, n, k):  # n 要素を k 個の空でない順序付き集合に分割する場合の数  O(1)",
            "        return self.C(n-1, k-1) * self.fac[n] % self.mod * self.facinv[k] % self.mod",
            "    def bell(self, n, k):  # n 要素を k グループ以下に分割する場合の数  O(k**2 + k*log(mod))",
            "        return sum(self.stirling_second(n, j) for j in range(1, k+1)) % self.mod",
            "n, m, k = map(int, read().split())",
            "mod = 998244353",
            "comb = Combination(n, mod)",
            "ans = 0",
            "n -= 1",
            "for i in range(k + 1):",
            "    ans += comb.C(n, n - i) * m * pow(m - 1, n - i, mod) % mod",
            "    ans %= mod",
            "print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2
        ]
    },
    {
        "content": [
            "# -*- coding: utf-8 -*-",
            "import sys",
            "import math",
            "from bisect import bisect_left",
            "from bisect import bisect_right",
            "import collections",
            "import copy",
            "import heapq",
            "from collections import defaultdict",
            "from heapq import heappop, heappush",
            "import itertools",
            "input = sys.stdin.readline",
            "from collections import defaultdict",
            "from heapq import heappop, heappush",
            "from decimal import *",
            "##### リストの 二分木検索 #####",
            "# bisect_left(lists, 3)",
            "# bisect_right(lists, 3)",
            "##### プライオリティキュー #####",
            "# heapq.heapify(a) #リストaのheap化",
            "# heapq.heappush(a,x) #heap化されたリストaに要素xを追加",
            "# heapq.heappop(a) #heap化されたリストaから最小値を削除＆その最小値を出力",
            "# heapq.heappush(a, -x) #最大値を取り出す時は、pushする時にマイナスにして入れよう",
            "# heapq.heappop(a) * (-1) #取り出す時は、-1を掛けて取り出すこと",
            "##### タプルリストのソート #####",
            "# sorted(ans) #(a, b) -> 1st : aの昇順, 2nd : bの昇順",
            "# sorted(SP, key=lambda x:(x[0],-x[1])) #(a, b) -> 1st : aの昇順, 2nd : bの降順",
            "# sorted(SP, key=lambda x:(-x[0],x[1])) #(a, b) -> 1st : aの降順, 2nd : bの昇順",
            "# sorted(SP, key=lambda x:(-x[0],-x[1])) #(a, b) -> 1st : aの降順, 2nd : bの降順",
            "# sorted(SP, key=lambda x:(x[1])) #(a, b) -> 1st : bの昇順",
            "# sorted(SP, key=lambda x:(-x[1])) #(a, b) -> 1st : bの降順",
            "##### 累乗 #####",
            "# pow(x, y, z) -> x**y % z",
            "##### 割り算の切り上げ #####",
            "# tmp = -(-4 // 3)",
            "##### dict の for文 #####",
            "# for k, v in d.items():",
            "#     print(k, v)",
            "##### 進数の変換 #####",
            "# bin_str = bin(i)",
            "# oct_str = oct(i)",
            "# hex_str = hex(i)",
            "def inputInt(): return int(input())",
            "def inputMap(): return map(int, input().split())",
            "def inputList(): return list(map(int, input().split()))",
            "def inputStr(): return input()[:-1]",
            "inf = float('inf')",
            "mod = 1000000007",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "def main():",
            "\tN,M,K = inputMap()",
            "\tcnv = Combination(N, 998244353)",
            "\tans = 0",
            "\tfor i in range(K+1):",
            "\t\tblc = N-i",
            "\t\ttmp = pow(M-1, blc-1, 998244353)",
            "\t\ttmp = (M * tmp) % 998244353",
            "\t\tprn = cnv(N-1, i)",
            "\t\ttmp = (tmp * prn) % 998244353",
            "\t\tans = (ans + tmp) % 998244353",
            "\tprint(ans)",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "# N 個のボールを K グループに分ける場合のパターン数",
            "def sunuke(N, K, mod=10**9+7):",
            "\tif N < K or K-1 < 0:",
            "\t\treturn 0",
            "\telse:",
            "\t\treturn combination(N-1, K-1, mod)",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "# nCr mod m",
            "# rがn/2に近いと非常に重くなる",
            "def combination(n, r, mod=10**9+7):",
            "    r = min(r, n-r)",
            "    res = 1",
            "    for i in range(r):",
            "        res = res * (n - i) * modinv(i+1, mod) % mod",
            "    return res",
            "# mを法とするaの乗法的逆元",
            "def modinv(a, mod=10**9+7):",
            "    return pow(a, mod-2, mod)",
            "def egcd(a, b):",
            "    if a == 0:",
            "        return b, 0, 1",
            "    else:",
            "        g, y, x = egcd(b % a, a)",
            "        return g, x - (b // a) * y, y",
            "# nHr mod m",
            "# 問題によって、combination()を切り替えること",
            "def H(n, r, mod=10**9+7):",
            "\t# comb = Combination(n+r-1, mod)",
            "\t# return comb(n+r-1, r)",
            "    return combination(n+r-1, r, mod)",
            "class Combination:",
            "    \"\"\"",
            "    O(n)の前計算を1回行うことで，O(1)でnCr mod mを求められる",
            "    n_max = 10**6のとき前処理は約950ms (PyPyなら約340ms, 10**7で約1800ms)",
            "    使用例：",
            "    comb = Combination(1000000)",
            "    print(comb(5, 3))  # 10",
            "    \"\"\"",
            "    def __init__(self, n_max, mod=10**9+7):",
            "        self.mod = mod",
            "        self.modinv = self.make_modinv_list(n_max)",
            "        self.fac, self.facinv = self.make_factorial_list(n_max)",
            "    def __call__(self, n, r):",
            "        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod",
            "    def make_factorial_list(self, n):",
            "        # 階乗のリストと階乗のmod逆元のリストを返す O(n)",
            "        # self.make_modinv_list()が先に実行されている必要がある",
            "        fac = [1]",
            "        facinv = [1]",
            "        for i in range(1, n+1):",
            "            fac.append(fac[i-1] * i % self.mod)",
            "            facinv.append(facinv[i-1] * self.modinv[i] % self.mod)",
            "        return fac, facinv",
            "    def make_modinv_list(self, n):",
            "        # 0からnまでのmod逆元のリストを返す O(n)",
            "        modinv = [0] * (n+1)",
            "        modinv[1] = 1",
            "        for i in range(2, n+1):",
            "            modinv[i] = self.mod - self.mod//i * modinv[self.mod%i] % self.mod",
            "        return modinv",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "# dfs のサンプル",
            "def dfs(graph,parent,counter,edge):",
            "    stk = []",
            "    stk.append(edge)",
            "    while len(stk) > 0:",
            "        p = stk.pop()",
            "        for e in graph[p]:",
            "            if parent[p] == e:",
            "                continue",
            "            else:",
            "                parent[e] = p",
            "                counter[e] += counter[p]",
            "                stk.append(e)",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "if __name__ == \"__main__\":",
            "\tmain()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import math",
            "mod = 998244353",
            "import numpy as np",
            "def create_modC(n, mod):",
            "    if n == 0:",
            "        return (lambda r: 1)",
            "    b = int(math.log(mod-2, 2)) + 1",
            "    fac = np.zeros((b, n+1), dtype=np.int64)",
            "    #print(fac.shape)",
            "    inv = np.ones(n+1, dtype=np.int64)",
            "    fac[0, 0], fac[0, 1] = 1, 1",
            "    for i in range(2, n+1):",
            "        fac[0, i] = (fac[0, i-1] * i) % mod",
            "    for i in range(1, b):",
            "        fac[i, :] = (fac[i-1, :] ** 2) % mod",
            "    indice = []",
            "    N = mod - 2",
            "    i = 0",
            "    while N > 0:",
            "        if N % 2 == 1:",
            "            indice.append(i)",
            "        N = N >> 1",
            "        i += 1",
            "    for i in indice:",
            "        inv *= fac[i,:]",
            "        inv %= mod",
            "    fac = fac[0,:]",
            "    def _modC(r):",
            "        if r == 0 or r == n:",
            "            return 1",
            "        result = fac[n] * inv[n-r]",
            "        result %= mod",
            "        result *= inv[r] % mod",
            "        result %= mod",
            "        return result",
            "    return _modC",
            "def mod_factorial(mod):",
            "    cache = [1,1,2]",
            "    def _factorial(n):",
            "        nonlocal cache",
            "        if n == 0:",
            "            return 1",
            "        length = len(cache)",
            "        v = cache[-1]",
            "        while n >= length:",
            "            v *= length",
            "            v %= mod",
            "            cache.append(v)",
            "            length +=1",
            "        return cache[n]",
            "    return _factorial",
            "def mod_pow(x, mod):",
            "    xx = [1, x]",
            "    def _pow(y, x=x):",
            "        nonlocal xx",
            "        if y == 0:",
            "            return 1",
            "        while len(xx) <= math.log(y, 2)+1:",
            "            v = xx[-1] * xx[-1]",
            "            v %= mod",
            "            xx.append(v)",
            "        i = 1",
            "        result = 1",
            "        while y > 0:",
            "            if y % 2 == 1:",
            "                result *= xx[i]",
            "                result %= mod",
            "            y = y >> 1",
            "            i += 1",
            "        return result",
            "    return _pow",
            "def test():",
            "    N, M, K = 3,2,1",
            "    answer = 6",
            "    v = resolve(N, M, K)",
            "    print(f\"N={N} M={M} K={K} {v}={answer}\")",
            "    N, M, K = 100,100,0",
            "    answer = 73074801",
            "    v = resolve(N, M, K)",
            "    print(f\"N={N} M={M} K={K} {v}={answer}\")",
            "    N, M, K = 60522,114575,7559",
            "    answer = 479519525",
            "    v = resolve(N, M, K)",
            "    print(f\"N={N} M={M} K={K} {v}={answer}\")",
            "    N, M, K = 200000,190000,190000",
            "    v = resolve(N, M, K)",
            "    print(f\"N={N} M={M} K={K} {v}\")",
            "    N, M, K = 1,1,0",
            "    print(f\"N={N} M={M} K={K}\")",
            "    v = resolve(N, M, K)",
            "    print(f\"N={N} M={M} K={K} {v}\")",
            "    N, M, K = 200000,200000,190000",
            "    v = resolve(N, M, K)",
            "    print(f\"N={N} M={M} K={K} {v}\")",
            "    for i in range(100):",
            "        N, M = np.random.randint(200000), np.random.randint(200000)",
            "        K = np.random.randint(N-1)",
            "        v = resolve(N, M, K)",
            "        print(f\"N={N} M={M} K={K} {v}\")",
            "def main():",
            "    #test()",
            "    N, M, K = map(int, input().split())",
            "    v = resolve(N, M, K)",
            "    print(v)",
            "def resolve(N, M, K):",
            "    from datetime import datetime",
            "    result = 0",
            "    m1pow = mod_pow(M-1, mod)",
            "    modC = create_modC(N-1, mod)",
            "    for k in range(K+1):",
            "        b = m1pow(N-1-k)",
            "        c = modC(k)",
            "        v = b",
            "        v *= c",
            "        v %= mod",
            "        #if k < 10:",
            "        #    print(f\"b={b} c={c} k={k} {v}\")",
            "        result += v",
            "        result %= mod",
            "    result *= M",
            "    result %= mod",
            "    result = int(result)",
            "    return result",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# -*- coding: utf-8 -*-",
            "import sys",
            "import math",
            "from bisect import bisect_left",
            "from bisect import bisect_right",
            "import collections",
            "import copy",
            "import heapq",
            "from collections import defaultdict",
            "from heapq import heappop, heappush",
            "import itertools",
            "input = sys.stdin.readline",
            "from collections import defaultdict",
            "from heapq import heappop, heappush",
            "from decimal import *",
            "##### リストの 二分木検索 #####",
            "# bisect_left(lists, 3)",
            "# bisect_right(lists, 3)",
            "##### プライオリティキュー #####",
            "# heapq.heapify(a) #リストaのheap化",
            "# heapq.heappush(a,x) #heap化されたリストaに要素xを追加",
            "# heapq.heappop(a) #heap化されたリストaから最小値を削除＆その最小値を出力",
            "# heapq.heappush(a, -x) #最大値を取り出す時は、pushする時にマイナスにして入れよう",
            "# heapq.heappop(a) * (-1) #取り出す時は、-1を掛けて取り出すこと",
            "##### タプルリストのソート #####",
            "# sorted(ans) #(a, b) -> 1st : aの昇順, 2nd : bの昇順",
            "# sorted(SP, key=lambda x:(x[0],-x[1])) #(a, b) -> 1st : aの昇順, 2nd : bの降順",
            "# sorted(SP, key=lambda x:(-x[0],x[1])) #(a, b) -> 1st : aの降順, 2nd : bの昇順",
            "# sorted(SP, key=lambda x:(-x[0],-x[1])) #(a, b) -> 1st : aの降順, 2nd : bの降順",
            "# sorted(SP, key=lambda x:(x[1])) #(a, b) -> 1st : bの昇順",
            "# sorted(SP, key=lambda x:(-x[1])) #(a, b) -> 1st : bの降順",
            "##### 累乗 #####",
            "# pow(x, y, z) -> x**y % z",
            "##### 割り算の切り上げ #####",
            "# tmp = -(-4 // 3)",
            "##### dict の for文 #####",
            "# for k, v in d.items():",
            "#     print(k, v)",
            "def inputInt(): return int(input())",
            "def inputMap(): return map(int, input().split())",
            "def inputList(): return list(map(int, input().split()))",
            "def inputStr(): return input()[:-1]",
            "inf = float('inf')",
            "mod = 1000000007",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "def main():",
            "\tN = inputInt()",
            "\tpazuru_nobori = []",
            "\tpazuru_kudari = []",
            "\tfor i in range(N):",
            "\t\tS = inputStr()",
            "\t\ttmp = 0",
            "\t\tmin_tmp = 0",
            "\t\tfor s in S:",
            "\t\t\tif s == \"(\":",
            "\t\t\t\ttmp += 1",
            "\t\t\telse:",
            "\t\t\t\ttmp -= 1",
            "\t\t\tif min_tmp > tmp:",
            "\t\t\t\tmin_tmp = tmp",
            "\t\tif tmp >= 0:",
            "\t\t\tpazuru_nobori.append((min_tmp,tmp))",
            "\t\telse:",
            "\t\t\tpazuru_kudari.append((min_tmp,tmp))",
            "\tpazuru_nobori.sort()",
            "\tpazuru_nobori = pazuru_nobori[::-1]",
            "\tscore = 0",
            "\tfor i,val in enumerate(pazuru_nobori):",
            "\t\tmin_tmp,tmp = val",
            "\t\tif score + min_tmp < 0:",
            "\t\t\tprint(\"No\")",
            "\t\t\tsys.exit()",
            "\t\tscore += tmp",
            "\tpazuru_kudari_non = []",
            "\tfor i,val in enumerate(pazuru_kudari):",
            "\t\tmin_tmp,tmp = val",
            "\t\tmin_tmp_2 = min_tmp - tmp",
            "\t\ttmp_2 = -1 * tmp",
            "\t\tpazuru_kudari_non.append((min_tmp_2,tmp_2))",
            "\tpazuru_kudari_non.sort()",
            "\tpazuru_kudari_non = pazuru_kudari_non[::-1]",
            "\tscore2 = 0",
            "\tfor i,val in enumerate(pazuru_kudari_non):",
            "\t\tmin_tmp,tmp = val",
            "\t\tif score2 + min_tmp < 0:",
            "\t\t\tprint(\"No\")",
            "\t\t\tsys.exit()",
            "\t\tscore2 += tmp",
            "\tif score2 == score:",
            "\t\tprint(\"Yes\")",
            "\telse:",
            "\t\tprint(\"No\")",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "# N 個のボールを K グループに分ける場合のパターン数",
            "def sunuke(N, K, mod=10**9+7):",
            "\tif N < K or K-1 < 0:",
            "\t\treturn 0",
            "\telse:",
            "\t\treturn combination(N-1, K-1, mod)",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "# nCr mod m",
            "# rがn/2に近いと非常に重くなる",
            "def combination(n, r, mod=10**9+7):",
            "    r = min(r, n-r)",
            "    res = 1",
            "    for i in range(r):",
            "        res = res * (n - i) * modinv(i+1, mod) % mod",
            "    return res",
            "# mを法とするaの乗法的逆元",
            "def modinv(a, mod=10**9+7):",
            "    return pow(a, mod-2, mod)",
            "def egcd(a, b):",
            "    if a == 0:",
            "        return b, 0, 1",
            "    else:",
            "        g, y, x = egcd(b % a, a)",
            "        return g, x - (b // a) * y, y",
            "# nHr mod m",
            "# 問題によって、combination()を切り替えること",
            "def H(n, r, mod=10**9+7):",
            "\t# comb = Combination(n+r-1, mod)",
            "\t# return comb(n+r-1, r)",
            "    return combination(n+r-1, r, mod)",
            "class Combination:",
            "    \"\"\"",
            "    O(n)の前計算を1回行うことで，O(1)でnCr mod mを求められる",
            "    n_max = 10**6のとき前処理は約950ms (PyPyなら約340ms, 10**7で約1800ms)",
            "    使用例：",
            "    comb = Combination(1000000)",
            "    print(comb(5, 3))  # 10",
            "    \"\"\"",
            "    def __init__(self, n_max, mod=10**9+7):",
            "        self.mod = mod",
            "        self.modinv = self.make_modinv_list(n_max)",
            "        self.fac, self.facinv = self.make_factorial_list(n_max)",
            "    def __call__(self, n, r):",
            "        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod",
            "    def make_factorial_list(self, n):",
            "        # 階乗のリストと階乗のmod逆元のリストを返す O(n)",
            "        # self.make_modinv_list()が先に実行されている必要がある",
            "        fac = [1]",
            "        facinv = [1]",
            "        for i in range(1, n+1):",
            "            fac.append(fac[i-1] * i % self.mod)",
            "            facinv.append(facinv[i-1] * self.modinv[i] % self.mod)",
            "        return fac, facinv",
            "    def make_modinv_list(self, n):",
            "        # 0からnまでのmod逆元のリストを返す O(n)",
            "        modinv = [0] * (n+1)",
            "        modinv[1] = 1",
            "        for i in range(2, n+1):",
            "            modinv[i] = self.mod - self.mod//i * modinv[self.mod%i] % self.mod",
            "        return modinv",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "# dfs のサンプル",
            "def dfs(graph,parent,counter,edge):",
            "    stk = []",
            "    stk.append(edge)",
            "    while len(stk) > 0:",
            "        p = stk.pop()",
            "        for e in graph[p]:",
            "            if parent[p] == e:",
            "                continue",
            "            else:",
            "                parent[e] = p",
            "                counter[e] += counter[p]",
            "                stk.append(e)",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "if __name__ == \"__main__\":",
            "\tmain()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n = ii()",
            "    l_p_only = []",
            "    r_p_only = []",
            "    r_p_l_p = []",
            "    for _ in range(n):",
            "        s = input()",
            "        left_cnt = 0",
            "        right_cnt = 0",
            "        for char in s:",
            "            if char == ')':",
            "                if left_cnt > 0:",
            "                    left_cnt -= 1",
            "                else:",
            "                    right_cnt += 1",
            "            else:",
            "                left_cnt += 1",
            "        if left_cnt == 0 and right_cnt == 0:",
            "            pass",
            "        elif right_cnt == 0:",
            "            l_p_only.append(left_cnt)",
            "        elif left_cnt == 0:",
            "            r_p_only.append(- right_cnt)",
            "        else:",
            "            r_p_l_p.append([- right_cnt, left_cnt])",
            "    # print(l_p_only)",
            "    # print(r_p_l_p)",
            "    # print(r_p_only)",
            "    current_left = sum(l_p_only)",
            "    pos = []",
            "    neg = []",
            "    for elm in r_p_l_p:",
            "        if elm[0] + elm[1] >= 0:",
            "            pos.append(elm)",
            "        else:",
            "            neg.append(elm)",
            "    pos.sort(key=lambda x: x[0], reverse=True)    # 負の値が大きい順、0 に近い順",
            "    for elm in pos:",
            "        current_left += elm[0]",
            "        if current_left >= 0:",
            "            current_left += elm[1]",
            "        else:",
            "            print('No')",
            "            exit()",
            "    neg.sort(key=lambda x: x[0])    # 負の値が小さい順、- に大きい順に最初のうちにやっておく",
            "    for elm in neg:",
            "        current_left += elm[0]",
            "        if current_left >= 0:",
            "            current_left += elm[1]",
            "        else:",
            "            print('No')",
            "            exit()",
            "    if current_left >= 0 and current_left == - sum(r_p_only):",
            "        print('Yes')",
            "    else:",
            "        print('No')",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import math",
            "import fractions",
            "#import sys",
            "#input = sys.stdin.readline",
            "def make_divisors(n):",
            "    divisors = []",
            "    for i in range(1, int(n**0.5)+1):",
            "        if n % i == 0:",
            "            divisors.append(i)",
            "            if i != n // i:",
            "                divisors.append(n//i)",
            "    # divisors.sort()",
            "    return divisors",
            "def ValueToBits(x,digit):",
            "    res = [0 for i in range(digit)]",
            "    now = x",
            "    for i in range(digit):",
            "        res[i]=now%2",
            "        now = now >> 1",
            "    return res",
            "def BitsToValue(arr):",
            "    n = len(arr)",
            "    ans = 0",
            "    for i in range(n):",
            "        ans+= arr[i] * 2**i",
            "    return ans",
            "def ZipArray(a):",
            "    aa = [[a[i],i]for i in range(n)]",
            "    aa.sort(key = lambda x : x[0])",
            "    for i in range(n):",
            "        aa[i][0]=i+1",
            "    aa.sort(key = lambda x : x[1])",
            "    b=[aa[i][0] for i in range(len(a))]",
            "    return b",
            "def ValueToArray10(x, digit):",
            "    ans = [0 for i in range(digit)]",
            "    now = x",
            "    for i in range(digit):",
            "        ans[digit-i-1] = now%10",
            "        now = now //10",
            "    return ans",
            "def Zeros(a,b):",
            "    if(b<=-1):",
            "        return [0 for i in range(a)]",
            "    else:",
            "        return [[0 for i in range(b)] for i in range(a)]",
            "class Bit:",
            "    def __init__(self, n):",
            "        self.size = n",
            "        self.tree = [0] * (n + 1)",
            "    def sum(self, i):",
            "        s = 0",
            "        while i > 0:",
            "            s += self.tree[i]",
            "            i -= i & -i",
            "        return s",
            "    def add(self, i, x):",
            "        while i <= self.size:",
            "            self.tree[i] += x",
            "            i += i & -i",
            "'''",
            "def cmb(n, r, p):",
            "    if (r < 0) or (n < r):",
            "        return 0",
            "    r = min(r, n - r)",
            "    return fact[n] * factinv[r] * factinv[n-r] % p",
            "p = 2",
            "N = 10 ** 6 + 2",
            "fact = [1, 1]  # fact[n] = (n! mod p)",
            "factinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)",
            "inv = [0, 1]  # factinv 計算用",
            "for i in range(2, N + 1):",
            "    fact.append((fact[-1] * i) % p)",
            "    inv.append((-inv[p % i] * (p // i)) % p)",
            "    factinv.append((factinv[-1] * inv[-1]) % p)",
            "'''",
            "#a = list(map(int, input().split()))",
            "#################################################",
            "#################################################",
            "#################################################",
            "#################################################",
            "n = int(input())",
            "lr = []",
            "for i in range(n):",
            "    s = input()",
            "    m = len(s)",
            "    #exam left",
            "    count = 0",
            "    left = 0",
            "    for j in range(m):",
            "        if(s[j]=='('):",
            "            count += 1",
            "        else:",
            "            if(count == 0):",
            "                left+=1",
            "            else:",
            "                count -=1",
            "    #exam right",
            "    count = 0",
            "    right = 0",
            "    for j in range(m):",
            "        if(s[m-j-1]==')'):",
            "            count += 1",
            "        else:",
            "            if(count == 0):",
            "                right+=1",
            "            else:",
            "                count -=1",
            "    #print(left,right)",
            "    lr.append([left,right])",
            "existL = 0",
            "existR = 0",
            "sumL = 0",
            "sumR = 0",
            "for i in range(n):",
            "    sumL += lr[i][0]",
            "    sumR += lr[i][1]",
            "    if(lr[i][0]==0 and lr[i][1]!=0):",
            "        existL=1",
            "        #print(lr[i])",
            "    if(lr[i][1]==0 and lr[i][0]!=0):",
            "        existR=1",
            "        #print(lr[i])",
            "lr2 = []",
            "for i in range(n):",
            "    if(lr[i][0]==0): lr2.append(lr[i])",
            "lr3 = []",
            "for i in range(n):",
            "    if(lr[i][0]*lr[i][1]!=0): lr3.append(lr[i])",
            "lr3.sort(key = lambda x : x[0]-x[1])",
            "for i in lr3:",
            "    lr2.append(i)",
            "for i in range(n):",
            "    if(lr[i][1]==0): lr2.append(lr[i])",
            "#print(lr2)",
            "ok = 1",
            "now = 0",
            "for i in range(n):",
            "    now -= lr2[i][0]",
            "    if(now<0):",
            "        ok = 0",
            "        #print('a',lr2[i])",
            "    now += lr2[i][1]",
            "if(existL*existR == 1 and sumL == sumR and ok==1):",
            "    print(\"Yes\")",
            "else:",
            "    if(sumL==0 and sumR==0):",
            "        print(\"Yes\")",
            "    else:",
            "        print(\"No\")"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            0,
            1,
            0,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            2,
            1,
            0,
            1,
            0
        ]
    },
    {
        "content": [
            "# -*- coding: utf-8 -*-",
            "import sys",
            "from bisect import bisect_left,bisect_right",
            "from collections import defaultdict",
            "sys.setrecursionlimit(10**9)",
            "INF=10**18",
            "MOD=10**9+7",
            "input=lambda: sys.stdin.readline().rstrip()",
            "YesNo=lambda b: bool([print('Yes')] if b else print('No'))",
            "YESNO=lambda b: bool([print('YES')] if b else print('NO'))",
            "int1=lambda x:int(x)-1",
            "def main():",
            "    class SegmentTree:",
            "        def __init__(self,n,segfunc,ide_ele):",
            "            self.segfunc=segfunc",
            "            self.ide_ele=ide_ele",
            "            self.num=2**(n-1).bit_length()",
            "            self.dat=[ide_ele]*2*self.num",
            "        def init(self,iter):",
            "            for i in range(len(iter)):",
            "                self.dat[i+self.num]=iter[i]",
            "            for i in range(self.num-1,0,-1):",
            "                self.dat[i]=self.segfunc(self.dat[i*2],self.dat[i*2+1])",
            "        def update(self,k,x):",
            "            k+=self.num",
            "            self.dat[k]=x",
            "            while k:",
            "                k//=2",
            "                self.dat[k]=self.segfunc(self.dat[k*2],self.dat[k*2+1])",
            "        def query(self,p,q):",
            "            if q<=p:",
            "                return self.ide_ele",
            "            p+=self.num",
            "            q+=self.num-1",
            "            res=self.ide_ele",
            "            while q-p>1:",
            "                if p&1==1:",
            "                    res=self.segfunc(res,self.dat[p])",
            "                if q&1==0:",
            "                    res=self.segfunc(res,self.dat[q])",
            "                    q-=1",
            "                p=(p+1)//2",
            "                q=q//2",
            "            if p==q:",
            "                res=self.segfunc(res,self.dat[p])",
            "            else:",
            "                res=self.segfunc(self.segfunc(res,self.dat[p]),self.dat[q])",
            "            return res",
            "    N=int(input())",
            "    S=[input() for i in range(N)]",
            "    P=0",
            "    M=0",
            "    c=0",
            "    Seg=SegmentTree(10**6+1,lambda a,b:max(a,b),-INF)",
            "    l_PM=defaultdict(list)",
            "    stack=defaultdict(list)",
            "    minus=set()",
            "    for i,s in enumerate(S):",
            "        p=0",
            "        m=0",
            "        for x in s:",
            "            if x=='(':",
            "                p+=1",
            "            else:",
            "                if p>0:",
            "                    p-=1",
            "                else:",
            "                    m+=1",
            "        if m==0 and p>0:",
            "            P+=p",
            "        elif p==0 and m>0:",
            "            M+=m",
            "        elif p>0 and m>0:",
            "            c+=1",
            "            minus.add(m)",
            "            stack[m].append(p-m)",
            "    minus=list(minus)",
            "    minus.sort()",
            "    for x in minus:",
            "        stack[x].sort()",
            "        if x<=P:",
            "            while stack[x]:",
            "                y=stack[x].pop()",
            "                if y>=0:",
            "                    c-=1",
            "                    P+=y",
            "                else:",
            "                    Seg.update(x,y)",
            "                    l_PM[y].append(x)",
            "                    break",
            "        else:",
            "            y=stack[x].pop()",
            "            Seg.update(x,y)",
            "            l_PM[y].append(x)",
            "    for _ in range(c):",
            "        x=Seg.query(0,P+1)",
            "        if x==-INF or P+x<0:",
            "            print('No')",
            "            exit()",
            "        l_PM[x].sort()",
            "        res=bisect_right(l_PM[x],P)-1",
            "        index=l_PM[x][res]",
            "        del l_PM[x][res]",
            "        if stack[index]:",
            "            y=stack[index].pop()",
            "            Seg.update(index,y)",
            "            l_PM[y].append(index)",
            "        else:",
            "            Seg.update(index,-INF)",
            "        P+=x",
            "    P-=M",
            "    YesNo(P==0)",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "# input()",
            "# int(input())",
            "# map(int, input().split())",
            "# list(map(int, input().split()))",
            "# list(map(int, list(input()))) # スペースがない数字リストを読み込み",
            "import math",
            "import fractions",
            "import sys",
            "import bisect",
            "import heapq  # 優先度付きキュー(最小値取り出し)",
            "import collections",
            "from collections import Counter",
            "from collections import deque",
            "import pprint",
            "import itertools",
            "sr = lambda: input()",
            "ir = lambda: int(sr())",
            "lr = lambda: list(map(int, sr().split()))",
            "\"\"\"nを素因数分解\"\"\"",
            "\"\"\"2以上の整数n => [[素因数, 指数], ...]の2次元リスト\"\"\"",
            "def factorization(n):",
            "    arr = []",
            "    temp = n",
            "    if n == 1:",
            "        return arr",
            "    for i in range(2, int(-(-n ** 0.5 // 1)) + 1):",
            "        if temp % i == 0:",
            "            cnt = 0",
            "            while temp % i == 0:",
            "                cnt += 1",
            "                temp //= i",
            "            arr.append([i, cnt])",
            "    if temp != 1:",
            "        arr.append([temp, 1])",
            "    if arr == []:",
            "        arr.append([n, 1])",
            "    return arr",
            "# a^n",
            "def power(a, n, mod):",
            "    x = 1",
            "    while n:",
            "        if n & 1:",
            "            x *= a % mod",
            "        n >>= 1",
            "        a *= a % mod",
            "    return x % mod",
            "# n*(n-1)*...*(l+1)*l",
            "def kaijo(n, l, mod):",
            "    if n == 0:",
            "        return 1",
            "    a = n",
            "    tmp = n - 1",
            "    while (tmp >= l):",
            "        a = a * tmp % mod",
            "        tmp -= 1",
            "    return a",
            "# Union Find",
            "class UnionFind():",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parents = [-1] * n",
            "    def find(self, x):",
            "        if self.parents[x] < 0:",
            "            return x",
            "        else:",
            "            self.parents[x] = self.find(self.parents[x])",
            "            return self.parents[x]",
            "    def union(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "        if x == y:",
            "            return",
            "        if self.parents[x] > self.parents[y]:",
            "            x, y = y, x",
            "        self.parents[x] += self.parents[y]",
            "        self.parents[y] = x",
            "    def size(self, x):",
            "        return -self.parents[self.find(x)]",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "    def members(self, x):",
            "        root = self.find(x)",
            "        return [i for i in range(self.n) if self.find(i) == root]",
            "    def roots(self):",
            "        return [i for i, x in enumerate(self.parents) if x < 0]",
            "    def group_count(self):",
            "        return len(self.roots())",
            "    def all_group_members(self):",
            "        return {r: self.members(r) for r in self.roots()}",
            "    def __str__(self):",
            "        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())",
            "# 約数生成",
            "def make_divisors(n):",
            "    divisors = []",
            "    for i in range(1, int(n**0.5)+1):",
            "        if n % i == 0:",
            "            divisors.append(i)",
            "            if i != n // i:",
            "                divisors.append(n//i)",
            "    divisors.sort()",
            "    return divisors",
            "inf = 10 ** 18",
            "mod = 10 ** 9 + 7",
            "n,m,q = lr()",
            "abcd = [lr() for i in range(q)]",
            "def getAns(s, num, l):",
            "    if l == n:",
            "        ret = 0",
            "        for a,b,c,d in abcd:",
            "            a-=1",
            "            b-=1",
            "            if s[b]-s[a] == c:",
            "                ret+=d",
            "        return ret",
            "    else:",
            "        ret = 0",
            "        for i in range(num, m+1):",
            "            tmp = s.copy()",
            "            tmp.append(i)",
            "            ret = max(ret, getAns(tmp, i, l+1))",
            "        return ret",
            "print(getAns([], 1, 0))"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "# vim: set fileencoding=utf-8",
            "# pylint: disable=unused-import, invalid-name, missing-docstring, bad-continuation",
            "\"\"\"Module docstring",
            "\"\"\"",
            "import functools",
            "import heapq",
            "import itertools",
            "import logging",
            "import math",
            "import random",
            "import string",
            "import sys",
            "from argparse import ArgumentParser",
            "from collections import defaultdict, deque",
            "from copy import deepcopy",
            "from typing import Dict, List, Optional, Set, Tuple",
            "def solve(values: List[int], nb: int) -> int:",
            "    s_values = sorted(((v, i) for i, v in enumerate(values)), reverse=True)",
            "    dp = [[0 for _ in range(nb + 1)] for _ in range(nb + 1)]",
            "    for i, (v, p) in enumerate(s_values, start=1):",
            "        for x in range(i + 1):",
            "            y = i - x",
            "            if y == 0:",
            "                dp[x][y] = dp[x - 1][0] + abs(p - x + 1) * v",
            "                continue",
            "            if x == 0:",
            "                dp[x][y] = dp[x][y - 1] + abs(nb - y - p) * v",
            "                continue",
            "            dp[x][y] = max(",
            "                dp[x - 1][y] + abs(p - x + 1) * v, dp[x][y - 1] + abs(nb - y - p) * v",
            "            )",
            "    return max(dp[i][nb - i] for i in range(nb + 1))",
            "def do_job():",
            "    \"Do the work\"",
            "    LOG.debug(\"Start working\")",
            "    # first line is number of test cases",
            "    N = int(input())",
            "    values = list(map(int, input().split()))",
            "    # values = []",
            "    # for _ in range(N):",
            "    #     values.append(input().split())",
            "    result = solve(values, N)",
            "    print(result)",
            "def print_output(testcase: int, result) -> None:",
            "    \"Formats and print result\"",
            "    if result is None:",
            "        result = \"IMPOSSIBLE\"",
            "    print(\"Case #{}: {}\".format(testcase + 1, result))",
            "    # 6 digits float precision {:.6f} (6 is the default value)",
            "    # print(\"Case #{}: {:f}\".format(testcase + 1, result))",
            "def configure_log(log_file: Optional[str] = None) -> None:",
            "    \"Configure the log output\"",
            "    log_formatter = logging.Formatter(",
            "        \"%(asctime)s - %(filename)s:%(lineno)d - \" \"%(levelname)s - %(message)s\"",
            "    )",
            "    if log_file:",
            "        handler = logging.FileHandler(filename=log_file)",
            "    else:",
            "        handler = logging.StreamHandler(sys.stdout)",
            "    handler.setFormatter(log_formatter)",
            "    LOG.addHandler(handler)",
            "LOG = None",
            "# for interactive call: do not add multiple times the handler",
            "if not LOG:",
            "    LOG = logging.getLogger(\"template\")",
            "    configure_log()",
            "def main(argv=None):",
            "    \"Program wrapper.\"",
            "    if argv is None:",
            "        argv = sys.argv[1:]",
            "    parser = ArgumentParser()",
            "    parser.add_argument(",
            "        \"-v\",",
            "        \"--verbose\",",
            "        dest=\"verbose\",",
            "        action=\"store_true\",",
            "        default=False,",
            "        help=\"run as verbose mode\",",
            "    )",
            "    args = parser.parse_args(argv)",
            "    if args.verbose:",
            "        LOG.setLevel(logging.DEBUG)",
            "    do_job()",
            "    return 0",
            "if __name__ == \"__main__\":",
            "    import doctest",
            "    doctest.testmod()",
            "    sys.exit(main())",
            "class memoized:",
            "    \"\"\"Decorator that caches a function's return value each time it is called.",
            "    If called later with the same arguments, the cached value is returned, and",
            "    not re-evaluated.",
            "    \"\"\"",
            "    def __init__(self, func):",
            "        self.func = func",
            "        self.cache = {}",
            "    def __call__(self, *args):",
            "        try:",
            "            return self.cache[args]",
            "        except KeyError:",
            "            value = self.func(*args)",
            "            self.cache[args] = value",
            "            return value",
            "        except TypeError:",
            "            # uncachable -- for instance, passing a list as an argument.",
            "            # Better to not cache than to blow up entirely.",
            "            return self.func(*args)",
            "    def __repr__(self):",
            "        \"\"\"Return the function's docstring.\"\"\"",
            "        return self.func.__doc__",
            "    def __get__(self, obj, objtype):",
            "        \"\"\"Support instance methods.\"\"\"",
            "        return functools.partial(self.__call__, obj)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "content": [
            "import sys",
            "sys.setrecursionlimit(10 ** 9)",
            "# input = sys.stdin.readline    ####",
            "def int1(x): return int(x) - 1",
            "def II(): return int(input())",
            "def MI(): return map(int, input().split())",
            "def MI1(): return map(int1, input().split())",
            "def LI(): return list(map(int, input().split()))",
            "def LI1(): return list(map(int1, input().split()))",
            "def LLI(rows_number): return [LI() for _ in range(rows_number)]",
            "def MS(): return input().split()",
            "def LS(): return list(input())",
            "def LLS(rows_number): return [LS() for _ in range(rows_number)]",
            "def printlist(lst, k=' '): print(k.join(list(map(str, lst))))",
            "INF = float('inf')",
            "# from math import ceil, floor, log2",
            "# from collections import deque",
            "# from itertools import combinations as comb, combinations_with_replacement as comb_w, accumulate, product, permutations",
            "# from heapq import heapify, heappop, heappush",
            "# import numpy as np    # cumsum",
            "# from bisect import bisect_left, bisect_right",
            "def solve():",
            "    N = II()",
            "    S = LS()",
            "    R = []",
            "    G = []",
            "    B = []",
            "    for i, s in enumerate(S):",
            "        if s == 'R':",
            "            R.append(i)",
            "        elif s == 'G':",
            "            G.append(i)",
            "        else:",
            "            B.append(i)",
            "    len_r = len(R)",
            "    len_g = len(G)",
            "    len_b = len(B)",
            "    def g(lst, r,  j):",
            "        l = -1",
            "        while r - l > 1:",
            "            m = (l + r) // 2",
            "            if lst[m] <= j:",
            "                l = m",
            "            else:",
            "                r = m",
            "        return r",
            "    def f(lst, r, out):",
            "        l = -1",
            "        while r - l > 1:",
            "            m = (r + l) // 2",
            "            if out < lst[m]:",
            "                r = m",
            "            elif out > lst[m]:",
            "                l = m",
            "            else:",
            "                return True",
            "        return False",
            "    ans = 0",
            "    for i in range(N):",
            "        si = S[i]",
            "        for j in range(i+1, N):",
            "            sj = S[j]",
            "            if si == sj: continue",
            "            out = j + j - i",
            "            # print(i, j, si, sj, out)",
            "            if si == 'R':",
            "                if sj == 'G':",
            "                    # B",
            "                    k = g(B, len_b, j)",
            "                    # print(k)",
            "                    ans += len_b - k",
            "                    if f(B, len_b, out):",
            "                        ans -= 1",
            "                elif sj == 'B':",
            "                    # G",
            "                    k = g(G, len_g, j)",
            "                    ans += len_g - k",
            "                    if f(G, len_g, out):",
            "                        ans -= 1",
            "            elif si == 'G':",
            "                if sj == 'R':",
            "                    # B",
            "                    k = g(B, len_b, j)",
            "                    ans += len_b - k",
            "                    if f(B, len_b, out):",
            "                        ans -= 1",
            "                elif sj == 'B':",
            "                    # R",
            "                    k = g(R, len_r, j)",
            "                    ans += len_r - k",
            "                    if f(R, len_r, out):",
            "                        ans -= 1",
            "            elif si == 'B':",
            "                if sj == 'R':",
            "                    # G",
            "                    k = g(G, len_g, j)",
            "                    ans += len_g - k",
            "                    if f(G, len_g, out):",
            "                        ans -= 1",
            "                elif sj == 'G':",
            "                    # R",
            "                    k = g(R, len_r, j)",
            "                    ans += len_r - k",
            "                    if f(R, len_r, out):",
            "                        ans -= 1",
            "    print(ans)",
            "if __name__ == '__main__':",
            "    solve()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import math",
            "import sys",
            "import itertools",
            "sys.setrecursionlimit(10**7)",
            "MOD = 1000000007  # type: int",
            "class Factorial:",
            "    def __init__(self, MOD):",
            "        self.MOD = MOD",
            "        self.factorials = [1, 1]  # 階乗を求めるためのキャッシュ",
            "        self.invModulos = [0, 1]  # n^-1のキャッシュ",
            "        self.invFactorial_ = [1, 1]  # (n^-1)!のキャッシュ",
            "    def calc(self, n):",
            "        if n <= -1:",
            "            print(\"Invalid argument to calculate n!\")",
            "            print(\"n must be non-negative value. But the argument was \" + str(n))",
            "            exit()",
            "        if n < len(self.factorials):",
            "            return self.factorials[n]",
            "        nextArr = [0] * (n + 1 - len(self.factorials))",
            "        initialI = len(self.factorials)",
            "        prev = self.factorials[-1]",
            "        m = self.MOD",
            "        for i in range(initialI, n + 1):",
            "            prev = nextArr[i - initialI] = prev * i % m",
            "        self.factorials += nextArr",
            "        return self.factorials[n]",
            "    def inv(self, n):",
            "        if n <= -1:",
            "            print(\"Invalid argument to calculate n^(-1)\")",
            "            print(\"n must be non-negative value. But the argument was \" + str(n))",
            "            exit()",
            "        p = self.MOD",
            "        pi = n % p",
            "        if pi < len(self.invModulos):",
            "            return self.invModulos[pi]",
            "        initialI = len(self.invModulos)",
            "        for i in range(initialI, min(p, n + 1)):",
            "            next = -self.invModulos[p % i] * (p // i) % p",
            "            self.invModulos.append(next)",
            "        return self.invModulos[pi]",
            "    def invFactorial(self, n):",
            "        if n <= -1:",
            "            print(\"Invalid argument to calculate (n^(-1))!\")",
            "            print(\"n must be non-negative value. But the argument was \" + str(n))",
            "            exit()",
            "        if n < len(self.invFactorial_):",
            "            return self.invFactorial_[n]",
            "        self.inv(n)  # To make sure already calculated n^-1",
            "        nextArr = [0] * (n + 1 - len(self.invFactorial_))",
            "        initialI = len(self.invFactorial_)",
            "        prev = self.invFactorial_[-1]",
            "        p = self.MOD",
            "        for i in range(initialI, n + 1):",
            "            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p",
            "        self.invFactorial_ += nextArr",
            "        return self.invFactorial_[n]",
            "class Combination:",
            "    def __init__(self, MOD):",
            "        self.MOD = MOD",
            "        self.factorial = Factorial(MOD)",
            "    def choose_k_from_n(self, n, k):",
            "        if k < 0 or n < k:",
            "            return 0",
            "        k = min(k, n - k)",
            "        f = self.factorial",
            "        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD",
            "def pow(a,n,m):",
            "    if n == 1:",
            "        return a",
            "    elif n == 0 or a == 1:",
            "        return 1",
            "    else:",
            "        if n%2 == 0:",
            "            r = pow(a,n//2,m)",
            "            return r*r%m",
            "        else:",
            "            r = pow(a,n-1,m)",
            "            return a*r%m",
            "def solve(N: int, K: int):",
            "    powDict = {}",
            "    def powd(a):",
            "        if a in powDict:",
            "            return powDict[a]",
            "        else:",
            "            powDict[a] = pow(a,N,MOD)",
            "            return powDict[a]",
            "    cDict = {}",
            "    sum = 0",
            "    for p in range(K,0,-1):",
            "        c = powd(K//p)",
            "        for i in range(2*p,K+1,p):",
            "            c = (c-cDict[i])%MOD",
            "        cDict[p]=c",
            "        sum = (sum + c*p)%MOD",
            "    print(sum)",
            "# Generated by 1.1.6 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)",
            "def main():",
            "    def iterate_tokens():",
            "        for line in sys.stdin:",
            "            for word in line.split():",
            "                yield word",
            "    tokens = iterate_tokens()",
            "    N = int(next(tokens))  # type: int",
            "    K = int(next(tokens))  # type: int",
            "    solve(N, K)",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def isp():   return input().split()",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def solve(n, k):",
            "        ans = 0",
            "        num_of_total_gcd = [0] * (k + 1)",
            "        for m in range(k, 0, -1):",
            "            cnt = pow(k//m, n, mod)",
            "            for i in range(2, k+1):",
            "                if m * i <= k:",
            "                    cnt -= num_of_total_gcd[m * i]",
            "                else:",
            "                    break",
            "            num_of_total_gcd[m] = cnt % mod",
            "            ans = (ans + m * cnt) % mod",
            "        return ans",
            "    n, k = mi()",
            "    print(solve(n, k))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import pprint",
            "N=int(input())",
            "A=list(map(int,input().split()))",
            "if N%2==0:#偶数なら1回まで2こ飛ばしで無茶できる",
            "    dp=[[-float(\"inf\") for _ in range(2)] for _ in range(N+10)]#dpはj=0の時は無茶をしていない系列j=1の時は1回無茶をした系列である",
            "    if N==2:#2の時は個別",
            "        print(max(A[0],A[1]))",
            "    else:#それ以外の時は",
            "        for i in range(N):",
            "            if i==0:            #i=0をとる時の任意の系列は無茶を確実にしていないのでdp[i][0]のみA[0]",
            "                dp[0][0]=A[0]",
            "            elif i==1:          #i=1をとる時の任意の系列は一回無茶をして取っているはずである、よってdp[i][1]のみA[1]",
            "                dp[1][1]=A[1]",
            "            elif i==2:          #i=2をとる時の任意の系列は一回も無茶せずに先頭からとっているのでdp[i][0]=A[0]+A[2]",
            "                dp[2][0]=A[0]+A[2]",
            "            else:                   #そのほかは再帰的に考える",
            "                for j in range(2):",
            "                    if j==0:                                                    #無茶しない系列を生成する時",
            "                        dp[i][0]=max(dp[i][0],dp[i-2][0]+A[i])                  #そこまでの無茶しなかった系列に自らを足していけば良い",
            "                    elif j==1:                                                  #一回無茶する系列を生成する時",
            "                        dp[i][1]=max(dp[i][1],dp[i-2][1]+A[i],dp[i-3][0]+A[i])  #すでにある無茶した時の値(いらない？)と、前までの系列で無茶していて今回は無茶できないパターン、今回で無茶をするパターンのうち最大を用いて系列生成すれば良い",
            "        print(max(dp[N-1][1],dp[N-2][0]))                                       #1回も飛ばさない時は後ろから二番目のdp値が相当することに注意",
            "else:#奇数なら計2回まで無茶できる(2飛ばし×2、3飛ばし×1まで許容)",
            "    #print(A[0],A[1])",
            "    dp=[[-float(\"inf\") for _ in range(3)] for _ in range(N+10)]#dpはj=0の時は無茶をしない系列j=1は1回無茶をした系列、j=2は2回無茶をしている系列",
            "    if N==3:#N=3の時は個別",
            "        print(max(A[0],A[1],A[2]))",
            "    else:#それ以外の時は",
            "        for i in range(N):",
            "            if i<4:",
            "                if i==0:                                        #i=0をとる任意の系列は無茶を確実にしていないのでdp[i][0]のみA[0]",
            "                    dp[0][0]=A[0]",
            "                if i==1:                                        #i=1をとる任意の系列は確実に1回無茶をしているのでdp[i][1]のみA[1]",
            "                    dp[1][1]=A[1]",
            "                if i==2:                                        #i=2をとる時は2回分の無茶をしてA[2]を得る時(dp[i][2]=A[2])および1かいも無茶せずに撮っている時(dp[i][0]=A[2]+A[0])",
            "                    dp[2][2]=A[2]",
            "                    dp[2][0]=A[0]+A[2]",
            "                if i==3:                                        #i=3をとる時は1回目で無茶をしてそのあと無茶していないパターン(dp[1][1]+A[3])といきなり1回無茶をしたパターン(dp[0][0]+A[3])があるのでその最大を",
            "                    dp[3][1]=max(dp[1][1]+A[3],dp[0][0]+A[3])",
            "            else:                                                                               #そのほかは再帰的に",
            "                for j in range(3):",
            "                    if j==0:                                                                    #無茶してない系列を生成する時、",
            "                        dp[i][0]=max(dp[i][0],dp[i-2][0]+A[i])                                  #そこまでの無茶しなかった系列に自らを足していけば良い",
            "                    elif j==1:                                                                  #1回だけ無茶した系列を生成する時",
            "                        dp[i][1]=max(dp[i][1],dp[i-2][1]+A[i],dp[i-3][0]+A[i])                  #すでにある1回無茶した時の値(いらない？)と、前までの系列で1回無茶していて今回は無茶しないパターン、今回で初めて無茶をするパターンのうち最大を用いて系列生成すれば良い",
            "                    else:                                                                       #2回無茶した系列を生成する時",
            "                        dp[i][2]=max(dp[i][2],dp[i-2][2]+A[i],dp[i-3][1]+A[i],dp[i-4][0]+A[i])  #すでにある2回無茶した時の値(いらない？)と、もう二回無茶していて無茶できないパターン、前までの系列で1回無茶していて今回も1回無茶するしないパターン、今回でいきなり2回無茶をするパターンのうち最大を用いて系列生成すれば良い",
            "        print(max(dp[N-1][2],dp[N-2][1],dp[N-3][0]))                                            #1回も飛ばさない時は後ろから3番目が、1回だけ飛ばした時は後ろから2番目のdp値が相当することに注意"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": [
            "import sys,collections as cl,bisect as bs",
            "sys.setrecursionlimit(100000)",
            "input = sys.stdin.readline",
            "mod = 10**9+7",
            "Max = sys.maxsize",
            "def l(): #intのlist",
            "    return list(map(int,input().split()))",
            "def m(): #複数文字",
            "    return map(int,input().split())",
            "def onem(): #Nとかの取得",
            "    return int(input())",
            "def s(x): #圧縮",
            "    a = []",
            "    if len(x) == 0:",
            "        return []",
            "    aa = x[0]",
            "    su = 1",
            "    for i in range(len(x)-1):",
            "        if aa != x[i+1]:",
            "            a.append([aa,su])",
            "            aa = x[i+1]",
            "            su = 1",
            "        else:",
            "            su += 1",
            "    a.append([aa,su])",
            "    return a",
            "def jo(x): #listをスペースごとに分ける",
            "    return \" \".join(map(str,x))",
            "def max2(x): #他のときもどうように作成可能",
            "    return max(map(max,x))",
            "def In(x,a): #aがリスト(sorted)",
            "    k = bs.bisect_left(a,x)",
            "    if k != len(a) and a[k] ==  x:",
            "        return True",
            "    else:",
            "        return False",
            "def pow_k(x, n):",
            "    ans = 1",
            "    while n:",
            "        if n % 2:",
            "            ans *= x",
            "        x *= x",
            "        n >>= 1",
            "    return ans",
            "\"\"\"",
            "def nibu(x,n,r):",
            "    ll = 0",
            "    rr = r",
            "    while True:",
            "        mid = (ll+rr)//2",
            "    if rr == mid:",
            "        return ll",
            "    if (ここに評価入れる):",
            "        rr = mid",
            "    else:",
            "        ll = mid+1",
            "\"\"\"",
            "n = onem()",
            "a = l()",
            "if n % 2 == 0:",
            "    po = [a[i] for i in range(n)]",
            "    for i in range(n-3,-1,-1):",
            "        po[i] += po[i+2]",
            "    ans = sum(a[0::2])",
            "    ans = max(ans,sum(a[1::2]))",
            "    co = 0",
            "    for i in range(0,n,2):",
            "        if i+1 <= n-1:",
            "            ans = max(ans,co+po[i+1])",
            "        else:",
            "            ans = max(ans,co)",
            "        co += a[i]",
            "    print(ans)",
            "else:",
            "    po = [a[i] for i in range(n)]",
            "    mi = [-Max for i in range(n)]",
            "    for i in range(n-3,-1,-1):",
            "        po[i] += po[i+2]",
            "    ans = sum(a[1::2])",
            "    ans = max(ans,sum(a[0::2]) - a[-1])",
            "    #print(ans)",
            "    l1 = [-Max for i in range(n)]",
            "    for i in range(n):",
            "        if i != n-1:",
            "            l1[i] = po[i+1]",
            "    \"\"\"",
            "    co = 0",
            "    for i in range(0,n,2):",
            "        if i != n-1:",
            "            l1[i] = co + po[i+1]",
            "        else:",
            "            l1[i] = co",
            "        co += a[i]",
            "    co = 0",
            "    for i in range(1,n,2):",
            "        if i != n-1:",
            "            l1[i] = co + po[i+1]",
            "        else:",
            "            l1[i] = co",
            "        co += a[i]",
            "    \"\"\"",
            "    for i in range(n-1,-1,-1):",
            "        if i == n-1:",
            "            continue",
            "        elif i == n-2:",
            "            mi[i] = l1[i]",
            "        else:",
            "            mi[i] = max(mi[i+2]+a[i],l1[i])",
            "    l1 = mi",
            "    \"\"\"",
            "    for i in range(n-1,-1,-1):",
            "        if i <= n-3:",
            "            mi[i] = min(mi[i+2],a[i])",
            "        else:",
            "            mi[i] = a[i]",
            "    print(mi)",
            "    \"\"\"",
            "    l2 = [-Max for i in range(n)]",
            "    for i in range(n-1,-1,-1):",
            "        l2[i] = po[i]",
            "    #print(l1)",
            "    #print(l2)",
            "    co = 0",
            "    for i in range(0,n,2):",
            "        if i + 2 <= n-1:",
            "            #print(ans,co+l1[i+1],co+l2[i+2])",
            "            ans = max(ans,co+l1[i+1],co+l2[i+2])",
            "        elif i+1 <= n-1:",
            "            ans = max(ans,co+l1[i+1])",
            "        else:",
            "            ans = max(ans,co)",
            "        co += a[i]",
            "    co = 0",
            "    #print(ans)",
            "    for i in range(1,n,2):",
            "        #print(ans,co+l1[i+1])",
            "        ans = max(ans,co+po[i+1])",
            "        #ans = max(ans,co+l1[i+1])",
            "        co += a[i]",
            "    #print(\"po:\"+str(mi[1]))",
            "    print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "content": [
            "def main():",
            "    K = int(input())",
            "    lunlun = [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]",
            "    start1 = [\"1\"]",
            "    start2 = [\"2\"]",
            "    start3 = [\"3\"]",
            "    start4 = [\"4\"]",
            "    start5 = [\"5\"]",
            "    start6 = [\"6\"]",
            "    start7 = [\"7\"]",
            "    start8 = [\"8\"]",
            "    start9 = [\"9\"]",
            "    while len(lunlun) < 10 ** 5:",
            "        next_starts = []",
            "        for i in range(1, 10):",
            "            news = []",
            "            if i == 1:",
            "                for n in start1:",
            "                    if len(n) == 1:",
            "                        new_n = n + \"0\"",
            "                    else:",
            "                        if abs(int(n[0])) > 1 or abs(int(n[1])) > 1:",
            "                            break",
            "                        new_n = n[0] + \"0\" + n[1:]",
            "                    lunlun.append(new_n)",
            "                    news.append(new_n)",
            "                for n in start1:",
            "                    new_n = str(i) + n",
            "                    lunlun.append(new_n)",
            "                    news.append(new_n)",
            "                for n in start2:",
            "                    new_n = str(i) + n",
            "                    lunlun.append(new_n)",
            "                    news.append(new_n)",
            "                next_starts.append(news)",
            "            elif i == 2:",
            "                for n in start1:",
            "                    new_n = str(i) + n",
            "                    lunlun.append(new_n)",
            "                    news.append(new_n)",
            "                for n in start2:",
            "                    new_n = str(i) + n",
            "                    lunlun.append(new_n)",
            "                    news.append(new_n)",
            "                for n in start3:",
            "                    new_n = str(i) + n",
            "                    lunlun.append(new_n)",
            "                    news.append(new_n)",
            "                next_starts.append(news)",
            "            elif i == 3:",
            "                for n in start2:",
            "                    new_n = str(i) + n",
            "                    lunlun.append(new_n)",
            "                    news.append(new_n)",
            "                for n in start3:",
            "                    new_n = str(i) + n",
            "                    lunlun.append(new_n)",
            "                    news.append(new_n)",
            "                for n in start4:",
            "                    new_n = str(i) + n",
            "                    lunlun.append(new_n)",
            "                    news.append(new_n)",
            "                next_starts.append(news)",
            "            elif i == 4:",
            "                for n in start3:",
            "                    new_n = str(i) + n",
            "                    lunlun.append(new_n)",
            "                    news.append(new_n)",
            "                for n in start4:",
            "                    new_n = str(i) + n",
            "                    lunlun.append(new_n)",
            "                    news.append(new_n)",
            "                for n in start5:",
            "                    new_n = str(i) + n",
            "                    lunlun.append(new_n)",
            "                    news.append(new_n)",
            "                next_starts.append(news)",
            "            elif i == 5:",
            "                for n in start4:",
            "                    new_n = str(i) + n",
            "                    lunlun.append(new_n)",
            "                    news.append(new_n)",
            "                for n in start5:",
            "                    new_n = str(i) + n",
            "                    lunlun.append(new_n)",
            "                    news.append(new_n)",
            "                for n in start6:",
            "                    new_n = str(i) + n",
            "                    lunlun.append(new_n)",
            "                    news.append(new_n)",
            "                next_starts.append(news)",
            "            elif i == 6:",
            "                for n in start5:",
            "                    new_n = str(i) + n",
            "                    lunlun.append(new_n)",
            "                    news.append(new_n)",
            "                for n in start6:",
            "                    new_n = str(i) + n",
            "                    lunlun.append(new_n)",
            "                    news.append(new_n)",
            "                for n in start7:",
            "                    new_n = str(i) + n",
            "                    lunlun.append(new_n)",
            "                    news.append(new_n)",
            "                next_starts.append(news)",
            "            elif i == 7:",
            "                for n in start6:",
            "                    new_n = str(i) + n",
            "                    lunlun.append(new_n)",
            "                    news.append(new_n)",
            "                for n in start7:",
            "                    new_n = str(i) + n",
            "                    lunlun.append(new_n)",
            "                    news.append(new_n)",
            "                for n in start8:",
            "                    new_n = str(i) + n",
            "                    lunlun.append(new_n)",
            "                    news.append(new_n)",
            "                next_starts.append(news)",
            "            elif i == 8:",
            "                for n in start7:",
            "                    new_n = str(i) + n",
            "                    lunlun.append(new_n)",
            "                    news.append(new_n)",
            "                for n in start8:",
            "                    new_n = str(i) + n",
            "                    lunlun.append(new_n)",
            "                    news.append(new_n)",
            "                for n in start9:",
            "                    new_n = str(i) + n",
            "                    lunlun.append(new_n)",
            "                    news.append(new_n)",
            "                next_starts.append(news)",
            "            elif i == 9:",
            "                for n in start8:",
            "                    new_n = str(i) + n",
            "                    lunlun.append(new_n)",
            "                    news.append(new_n)",
            "                for n in start9:",
            "                    new_n = str(i) + n",
            "                    lunlun.append(new_n)",
            "                    news.append(new_n)",
            "                next_starts.append(news)",
            "        start1 = next_starts[0]",
            "        start2 = next_starts[1]",
            "        start3 = next_starts[2]",
            "        start4 = next_starts[3]",
            "        start5 = next_starts[4]",
            "        start6 = next_starts[5]",
            "        start7 = next_starts[6]",
            "        start8 = next_starts[7]",
            "        start9 = next_starts[8]",
            "    print(lunlun[K-1])",
            "main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "import sys",
            "import heapq",
            "import re",
            "from heapq import heapify, heappop, heappush",
            "from itertools import permutations",
            "from bisect import bisect_left, bisect_right",
            "from collections import Counter, deque",
            "from fractions import gcd",
            "from math import factorial, sqrt, ceil",
            "from functools import lru_cache, reduce",
            "INF = 1 << 60",
            "MOD = 1000000007",
            "sys.setrecursionlimit(10 ** 7)",
            "# UnionFind",
            "class UnionFind():",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parents = [-1] * n",
            "    def find(self, x):",
            "        if self.parents[x] < 0:",
            "            return x",
            "        else:",
            "            self.parents[x] = self.find(self.parents[x])",
            "            return self.parents[x]",
            "    def union(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "        if x == y:",
            "            return",
            "        if self.parents[x] > self.parents[y]:",
            "            x, y = y, x",
            "        self.parents[x] += self.parents[y]",
            "        self.parents[y] = x",
            "    def size(self, x):",
            "        return -self.parents[self.find(x)]",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "    def members(self, x):",
            "        root = self.find(x)",
            "        return [i for i in range(self.n) if self.find(i) == root]",
            "    def roots(self):",
            "        return [i for i, x in enumerate(self.parents) if x < 0]",
            "    def group_count(self):",
            "        return len(self.roots())",
            "    def all_group_members(self):",
            "        return {r: self.members(r) for r in self.roots()}",
            "    def __str__(self):",
            "        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())",
            "# ダイクストラ",
            "def dijkstra_heap(s, edge, n):",
            "    #始点sから各頂点への最短距離",
            "    d = [10**20] * n",
            "    used = [True] * n #True:未確定",
            "    d[s] = 0",
            "    used[s] = False",
            "    edgelist = []",
            "    for a,b in edge[s]:",
            "        heapq.heappush(edgelist,a*(10**6)+b)",
            "    while len(edgelist):",
            "        minedge = heapq.heappop(edgelist)",
            "        #まだ使われてない頂点の中から最小の距離のものを探す",
            "        if not used[minedge%(10**6)]:",
            "            continue",
            "        v = minedge%(10**6)",
            "        d[v] = minedge//(10**6)",
            "        used[v] = False",
            "        for e in edge[v]:",
            "            if used[e[1]]:",
            "                heapq.heappush(edgelist,(e[0]+d[v])*(10**6)+e[1])",
            "    return d",
            "# 素因数分解",
            "def factorization(n):",
            "    arr = []",
            "    temp = n",
            "    for i in range(2, int(-(-n**0.5//1))+1):",
            "        if temp%i==0:",
            "            cnt=0",
            "            while temp%i==0:",
            "                cnt+=1",
            "                temp //= i",
            "            arr.append([i, cnt])",
            "    if temp!=1:",
            "        arr.append([temp, 1])",
            "    if arr==[]:",
            "        arr.append([n, 1])",
            "    return arr",
            "# 2数の最小公倍数",
            "def lcm(x, y):",
            "    return (x * y) // gcd(x, y)",
            "# リストの要素の最小公倍数",
            "def lcm_list(numbers):",
            "    return reduce(lcm, numbers, 1)",
            "# リストの要素の最大公約数",
            "def gcd_list(numbers):",
            "    return reduce(gcd, numbers)",
            "# 素数判定",
            "def is_prime(n):",
            "    if n <= 1:",
            "        return False",
            "    p = 2",
            "    while True:",
            "        if p ** 2 > n:",
            "            break",
            "        if n % p == 0:",
            "            return False",
            "        p += 1",
            "    return True",
            "# limit以下の素数を列挙",
            "def eratosthenes(limit):",
            "    A = [i for i in range(2, limit+1)]",
            "    P = []",
            "    while True:",
            "        prime = min(A)",
            "        if prime > sqrt(limit):",
            "            break",
            "        P.append(prime)",
            "        i = 0",
            "        while i < len(A):",
            "            if A[i] % prime == 0:",
            "                A.pop(i)",
            "                continue",
            "            i += 1",
            "    for a in A:",
            "        P.append(a)",
            "    return P",
            "# 同じものを含む順列",
            "def permutation_with_duplicates(L):",
            "    if L == []:",
            "        return [[]]",
            "    else:",
            "        ret = []",
            "        # set（集合）型で重複を削除、ソート",
            "        S = sorted(set(L))",
            "        for i in S:",
            "            data = L[:]",
            "            data.remove(i)",
            "            for j in permutation_with_duplicates(data):",
            "                ret.append([i] + j)",
            "        return ret",
            "# ここから書き始める",
            "k = int(input())",
            "queue = deque([str(i) for i in range(1, 10)])",
            "ans = \"\"",
            "for i in range(k):",
            "    ans = queue.popleft()",
            "    if ans[-1] != \"0\":",
            "        queue.append(ans + str(int(ans[-1]) - 1))",
            "    queue.append(ans + ans[-1])",
            "    if ans[-1] != \"9\":",
            "        queue.append(ans + str(int(ans[-1]) + 1))",
            "print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            0,
            2
        ]
    },
    {
        "content": [
            "# -*- coding: utf-8 -*-",
            "import sys",
            "import math",
            "import os",
            "import itertools",
            "import string",
            "import heapq",
            "import _collections",
            "from collections import Counter",
            "from collections import defaultdict",
            "from collections import deque",
            "from functools import lru_cache",
            "import bisect",
            "import re",
            "import queue",
            "import decimal",
            "class Scanner():",
            "    @staticmethod",
            "    def int():",
            "        return int(sys.stdin.readline().rstrip())",
            "    @staticmethod",
            "    def string():",
            "        return sys.stdin.readline().rstrip()",
            "    @staticmethod",
            "    def map_int():",
            "        return [int(x) for x in Scanner.string().split()]",
            "    @staticmethod",
            "    def string_list(n):",
            "        return [Scanner.string() for i in range(n)]",
            "    @staticmethod",
            "    def int_list_list(n):",
            "        return [Scanner.map_int() for i in range(n)]",
            "    @staticmethod",
            "    def int_cols_list(n):",
            "        return [Scanner.int() for i in range(n)]",
            "class Math():",
            "    @staticmethod",
            "    def gcd(a, b):",
            "        if b == 0:",
            "            return a",
            "        return Math.gcd(b, a % b)",
            "    @staticmethod",
            "    def lcm(a, b):",
            "        return (a * b) // Math.gcd(a, b)",
            "    @staticmethod",
            "    def divisor(n):",
            "        res = []",
            "        i = 1",
            "        for i in range(1, int(n ** 0.5) + 1):",
            "            if n % i == 0:",
            "                res.append(i)",
            "                if i != n // i:",
            "                    res.append(n // i)",
            "        return res",
            "    @staticmethod",
            "    def round_up(a, b):",
            "        return -(-a // b)",
            "    @staticmethod",
            "    def is_prime(n):",
            "        if n < 2:",
            "            return False",
            "        if n == 2:",
            "            return True",
            "        if n % 2 == 0:",
            "            return False",
            "        d = int(n ** 0.5) + 1",
            "        for i in range(3, d + 1, 2):",
            "            if n % i == 0:",
            "                return False",
            "        return True",
            "    @staticmethod",
            "    def fact(N):",
            "        res = {}",
            "        tmp = N",
            "        for i in range(2, int(N ** 0.5 + 1) + 1):",
            "            cnt = 0",
            "            while tmp % i == 0:",
            "                cnt += 1",
            "                tmp //= i",
            "            if cnt > 0:",
            "                res[i] = cnt",
            "        if tmp != 1:",
            "            res[tmp] = 1",
            "        if res == {}:",
            "            res[N] = 1",
            "        return res",
            "def pop_count(x):",
            "    x = x - ((x >> 1) & 0x5555555555555555)",
            "    x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)",
            "    x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f",
            "    x = x + (x >> 8)",
            "    x = x + (x >> 16)",
            "    x = x + (x >> 32)",
            "    return x & 0x0000007f",
            "MOD = int(1e09) + 7",
            "INF = int(1e15)",
            "def solve():",
            "    K = Scanner.int()",
            "    d = deque()",
            "    for i in range(1, 10):",
            "        d.append(i)",
            "    MAX = 10 ** 5 + 100",
            "    for i in range(MAX):",
            "        n = d[i]",
            "        a = int(str(n)[-1])",
            "        if a != 0:",
            "            d.append(n * 10 + (a - 1))",
            "        d.append(n * 10 + a)",
            "        if a != 9:",
            "            d.append(n * 10 + (a + 1))",
            "        if len(d) >= K:",
            "            print(d[K - 1])",
            "            return",
            "def main():",
            "    # sys.stdin = open(\"sample.txt\")",
            "    # T = Scanner.int()",
            "    # for _ in range(T):",
            "    #     solve()",
            "    # print('YNeos'[not solve()::2])",
            "    solve()",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/python3",
            "# import bisect",
            "# from collections import Counter, deque, OrderedDict, defaultdict",
            "from copy import copy, deepcopy # pythonのみ．copyは1次元，deepcopyは多次元．",
            "# from decimal import Decimal, ROUND_HALF_UP, ROUND_HALF_EVEN",
            "# from functools import reduce",
            "# from heapq import heapify, heappop, heappush",
            "# from itertools import accumulate, permutations, combinations, combinations_with_replacement, groupby, product",
            "# import math",
            "# import numpy as np  # Pythonのみ！",
            "# from operator import xor",
            "# import re",
            "# from scipy.sparse.csgraph import connected_components  # Pythonのみ！",
            "# ↑cf.  https://note.nkmk.me/python-scipy-connected-components/",
            "# from scipy.sparse import csr_matrix",
            "# import statistics # Pythonのみ",
            "# import string",
            "import unittest",
            "from io import StringIO",
            "import sys",
            "sys.setrecursionlimit(10 ** 5 + 10)",
            "def input(): return sys.stdin.readline().strip()",
            "def resolve():",
            "    n = int(input())",
            "    import math",
            "    # cf. https://qiita.com/suecharo/items/14137fb74c26e2388f1f",
            "    def make_prime_list_2(num):",
            "        if num < 2:",
            "            return []",
            "        # 0のものは素数じゃないとする",
            "        prime_list = [i for i in range(num + 1)]",
            "        prime_list[1] = 0  # 1は素数ではない",
            "        num_sqrt = math.sqrt(num)",
            "        for prime in prime_list:",
            "            if prime == 0:",
            "                continue",
            "            if prime > num_sqrt:",
            "                break",
            "            for non_prime in range(2 * prime, num, prime):",
            "                prime_list[non_prime] = 0",
            "        return [prime for prime in prime_list if prime != 0]",
            "    def prime_factorization_2(num):",
            "        \"\"\"numの素因数分解",
            "        素因数をkeyに乗数をvalueに格納した辞書型dict_counterを返す\"\"\"",
            "        if num <= 1:",
            "            return False",
            "        else:",
            "            num_sqrt = math.floor(math.sqrt(num))",
            "            prime_list = make_prime_list_2(num_sqrt)",
            "            dict_counter = {}  # 何度もこの関数を呼び出して辞書を更新したい時はこれを引数にして",
            "            # cf. https://atcoder.jp/contests/arc034/submissions/12251452",
            "            for prime in prime_list:",
            "                while num % prime == 0:",
            "                    if prime in dict_counter:",
            "                        dict_counter[prime] += 1",
            "                    else:",
            "                        dict_counter[prime] = 1",
            "                    num //= prime",
            "            if num != 1:",
            "                if num in dict_counter:",
            "                    dict_counter[num] += 1",
            "                else:",
            "                    dict_counter[num] = 1",
            "            return dict_counter",
            "    def divisor_count(num):",
            "        \"\"\"numの約数の個数を求める\"\"\"",
            "        if num < 0:",
            "            return None",
            "        elif num == 1:",
            "            return 1",
            "        else:",
            "            divisor_num = 1",
            "            dict_fact = prime_factorization_2(num)",
            "            for value in dict_fact.values():",
            "                divisor_num *= (value + 1)",
            "            return divisor_num",
            "    ans = divisor_count(n-1)",
            "    def make_divisors(n):",
            "        divisors = []",
            "        for i in range(1, int(n**0.5)+1):",
            "            if n % i == 0:",
            "                divisors.append(i)",
            "                if i != n // i:  # 平方数の場合n**0.5を1つだけにしてる",
            "                    divisors.append(n//i)",
            "        # divisors.sort() # ソートしたけりゃして",
            "        return divisors",
            "    l = make_divisors(n)",
            "    def main():",
            "        cnt = 0",
            "        for i in l:",
            "            if i==1: continue",
            "            v = copy(n)",
            "            while v % i == 0:",
            "                v /= i",
            "            v%=i",
            "            if v==1: cnt += 1",
            "        return cnt",
            "    print(ans+main()-1)",
            "resolve()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n = ii()",
            "    # naive, O(nlgn)",
            "    # cnt = 0",
            "    # for k in range(2, n + 1):",
            "    #     tmp = n",
            "    #     if tmp % k == 1:",
            "    #         cnt += 1",
            "    #     elif tmp % k == 0:",
            "    #         while tmp >= k and tmp % k == 0:",
            "    #             tmp //= k",
            "    #         if tmp % k == 1:",
            "    #             cnt += 1",
            "    # print(cnt)",
            "    class Eratos:",
            "        def __init__(self, num):",
            "            assert(num >= 1)",
            "            self.table_max = num",
            "            # self.table[i] は i が素数かどうかを示す (bool)",
            "            self.table = [False if i == 0 or i == 1 else True for i in range(num+1)]",
            "            for i in range(2, int(math.sqrt(num)) + 1):",
            "                if self.table[i]:",
            "                    for j in range(i ** 2, num + 1, i):    # i**2 からスタートすることで定数倍高速化できる",
            "                        self.table[j] = False",
            "            # self.table_max 以下の素数を列挙したリスト",
            "            self.prime_numbers = [2] if self.table_max >= 2 else []",
            "            for i in range(3, self.table_max + 1, 2):",
            "                if self.table[i]:",
            "                    self.prime_numbers.append(i)",
            "        def is_prime(self, num):",
            "            \"\"\"",
            "            >>> e = Eratos(100)",
            "            >>> [i for i in range(1, 101) if e.is_prime(i)]",
            "            [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]",
            "            \"\"\"",
            "            assert(num >= 1)",
            "            if num > self.table_max:",
            "                raise ValueError('Eratos.is_prime(): exceed table_max({}). got {}'.format(self.table_max, num))",
            "            return self.table[num]",
            "        def prime_factorize(self, num):",
            "            \"\"\"",
            "            >>> e = Eratos(10000)",
            "            >>> e.prime_factorize(6552)",
            "            {2: 3, 3: 2, 7: 1, 13: 1}",
            "            \"\"\"",
            "            assert(num >= 1)",
            "            if int(math.sqrt(num)) > self.table_max:",
            "                raise ValueError('Eratos.prime_factorize(): exceed prime table size. got {}'.format(num))",
            "            factorized_dict = dict()    # 素因数分解の結果を記録する辞書",
            "            candidate_prime_numbers = [i for i in range(2, int(math.sqrt(num)) + 1) if self.is_prime(i)]",
            "            # n について、√n 以下の素数で割り続けると最後には 1 or 素数となる",
            "            # 背理法を考えれば自明 (残された数が √n より上の素数の積であると仮定。これは自明に n を超えるため矛盾)",
            "            for p in candidate_prime_numbers:",
            "                # これ以上調査は無意味",
            "                if num == 1:",
            "                    break",
            "                while num % p == 0:",
            "                    num //= p",
            "                    try:",
            "                        factorized_dict[p]",
            "                    except KeyError:",
            "                        factorized_dict[p] = 0",
            "                    finally:",
            "                        factorized_dict[p] += 1",
            "            if num != 1:",
            "                factorized_dict[num] = 1",
            "            return factorized_dict",
            "    eratos = Eratos(int(math.sqrt(n)))",
            "    d_1 = eratos.prime_factorize(n - 1)",
            "    # n = k + 1, 2k + 1, 3k + 1, ...",
            "    cnt = 0",
            "    tmp = 1",
            "    for _, v in d_1.items():",
            "        tmp *= (v + 1)",
            "    tmp -= 1",
            "    cnt += tmp",
            "    d_2 = eratos.prime_factorize(n)",
            "    # 全約数 x (除: 1) について (n // x) ≡ 1 (mod x) なら cnt += 1とすればいいのでは",
            "    # 約数の個数は高々 2√n 個なので間に合いそう？",
            "    L = [range(v + 1) for _, v in d_2.items()]",
            "    power_list = list(product(*L))",
            "    prime_list = list(d_2.keys())",
            "    for elm in power_list:",
            "        # elm は具体的な各素数の指数を指定したリストである",
            "        div = 1",
            "        for i in range(len(prime_list)):",
            "            div *= pow(prime_list[i], elm[i])",
            "        # print(f\"div: {div}\")",
            "        if div != 1:",
            "            assert(n % div == 0)",
            "            copy_n = n",
            "            while copy_n % div == 0:",
            "                copy_n //= div",
            "            if copy_n % div == 1:",
            "                cnt += 1",
            "    print(cnt)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# -*- coding: utf-8 -*-",
            "import sys",
            "import math",
            "import os",
            "import itertools",
            "import string",
            "import heapq",
            "import _collections",
            "from collections import Counter",
            "from collections import defaultdict",
            "from collections import deque",
            "from functools import lru_cache",
            "import bisect",
            "import re",
            "import queue",
            "import decimal",
            "class Scanner():",
            "    @staticmethod",
            "    def int():",
            "        return int(sys.stdin.readline().rstrip())",
            "    @staticmethod",
            "    def string():",
            "        return sys.stdin.readline().rstrip()",
            "    @staticmethod",
            "    def map_int():",
            "        return [int(x) for x in Scanner.string().split()]",
            "    @staticmethod",
            "    def string_list(n):",
            "        return [Scanner.string() for i in range(n)]",
            "    @staticmethod",
            "    def int_list_list(n):",
            "        return [Scanner.map_int() for i in range(n)]",
            "    @staticmethod",
            "    def int_cols_list(n):",
            "        return [Scanner.int() for i in range(n)]",
            "class Math():",
            "    @staticmethod",
            "    def gcd(a, b):",
            "        if b == 0:",
            "            return a",
            "        return Math.gcd(b, a % b)",
            "    @staticmethod",
            "    def lcm(a, b):",
            "        return (a * b) // Math.gcd(a, b)",
            "    @staticmethod",
            "    def divisor(n):",
            "        res = []",
            "        i = 1",
            "        for i in range(1, int(n ** 0.5) + 1):",
            "            if n % i == 0:",
            "                res.append(i)",
            "                if i != n // i:",
            "                    res.append(n // i)",
            "        return res",
            "    @staticmethod",
            "    def round_up(a, b):",
            "        return -(-a // b)",
            "    @staticmethod",
            "    def is_prime(n):",
            "        if n < 2:",
            "            return False",
            "        if n == 2:",
            "            return True",
            "        if n % 2 == 0:",
            "            return False",
            "        d = int(n ** 0.5) + 1",
            "        for i in range(3, d + 1, 2):",
            "            if n % i == 0:",
            "                return False",
            "        return True",
            "    @staticmethod",
            "    def fact(N):",
            "        res = {}",
            "        tmp = N",
            "        for i in range(2, int(N ** 0.5 + 1) + 1):",
            "            cnt = 0",
            "            while tmp % i == 0:",
            "                cnt += 1",
            "                tmp //= i",
            "            if cnt > 0:",
            "                res[i] = cnt",
            "        if tmp != 1:",
            "            res[tmp] = 1",
            "        if res == {}:",
            "            res[N] = 1",
            "        return res",
            "def pop_count(x):",
            "    x = x - ((x >> 1) & 0x5555555555555555)",
            "    x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)",
            "    x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f",
            "    x = x + (x >> 8)",
            "    x = x + (x >> 16)",
            "    x = x + (x >> 32)",
            "    return x & 0x0000007f",
            "MOD = int(1e09) + 7",
            "INF = int(1e15)",
            "def dist(i, j, X, Y):",
            "    if j <= X:",
            "        return j - i",
            "    if i >= Y:",
            "        return j - i",
            "    if i <= X < Y <= j:",
            "        return X - i + 1 + j - Y",
            "    if X <= i < j <= Y:",
            "        d1 = j - i",
            "        d2 = i - X + 1 + Y - j",
            "        return min(d1, d2)",
            "    if i <= X <= j <= Y:",
            "        d1 = j - i",
            "        d2 = X - i + 1 + Y - j",
            "        return min(d1, d2)",
            "    else:",
            "        d1 = j - i",
            "        d2 = i - X + 1 + j - Y",
            "        return min(d1, d2)",
            "def solve():",
            "    N, X, Y = Scanner.map_int()",
            "    ans = [0 for _ in range(1, N + 1)]",
            "    for i in range(1, N + 1):",
            "        for j in range(i + 1, N + 1):",
            "            d = dist(i, j, X, Y)",
            "            ans[d] += 1",
            "    print(*ans[1:], sep='\\n')",
            "def main():",
            "    # sys.stdin = open(\"sample.txt\")",
            "    # T = Scanner.int()",
            "    # for _ in range(T):",
            "    #     solve()",
            "    # print('YNeos'[not solve()::2])",
            "    solve()",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# abc159_b.py",
            "# https://atcoder.jp/contests/abc159/tasks/abc159_b",
            "# B - String Palindrome /",
            "# 実行時間制限: 2 sec / メモリ制限: 1024 MB",
            "# 配点 : 200点",
            "# 問題文",
            "# 長さが奇数である文字列 Sが以下の条件をすべて満たすとき、Sは「強い回文」であるといいます。",
            "#     Sは回文である。",
            "#     Nを S の長さとするとき、S の 1 文字目から (N−1)/2文字目まで(両端含む)からなる文字列は回文である。",
            "#     Sの (N+3)/2 文字目から N文字目まで(両端含む)からなる文字列は回文である。",
            "# Sが強い回文かどうかを判定してください。",
            "# 制約",
            "#     Sは英小文字のみからなる",
            "#     Sの長さは 3 以上 99以下の奇数",
            "# 入力",
            "# 入力は以下の形式で標準入力から与えられる。",
            "# S",
            "# 出力",
            "# S",
            "# が強い回文ならば Yes 、 強い回文でないならば No と出力せよ。",
            "# 入力例 1",
            "# akasaka",
            "# 出力例 1",
            "# Yes",
            "# Sは akasaka",
            "# Sの 1 文字目から 3文字目までからなる文字列は aka",
            "# Sの 5 文字目から 7文字目までからなる文字列は aka",
            "# これらはすべて回文であるため、Sは強い回文です。",
            "# 入力例 2",
            "# level",
            "# 出力例 2",
            "# No",
            "# 入力例 3",
            "# atcoder",
            "# 出力例 3",
            "# No",
            "global FLAG_LOG",
            "FLAG_LOG = False",
            "def log(value):",
            "    # FLAG_LOG = True",
            "    # FLAG_LOG = False",
            "    if FLAG_LOG:",
            "        print(str(value))",
            "def calculation(lines):",
            "    S = lines[0]",
            "    # N = int(lines[0])",
            "    # N, M = list(map(int, lines[0].split()))",
            "    # values = list(map(int, lines[1].split()))",
            "    # values = list(map(int, lines[2].split()))",
            "    # values = list()",
            "    # for i in range(N):",
            "    #     values.append(int(lines[i]))",
            "    # valueses = list()",
            "    # for i in range(N):",
            "    #     valueses.append(list(map(int, lines[i+1].split())))",
            "    n = int((len(S)-1)/2)",
            "    if is_kaibun(S) is not True:",
            "        return ['No']",
            "    if is_kaibun(S[:n]) is not True:",
            "        return ['No']",
            "    if is_kaibun(S[-n:]) is not True:",
            "        return ['No']",
            "    return ['Yes']",
            "def is_kaibun(s):",
            "    t = ''.join(list(reversed(s)))",
            "    if s == t:",
            "        return True",
            "    else:",
            "        return False",
            "# 引数を取得",
            "def get_input_lines(lines_count):",
            "    lines = list()",
            "    for _ in range(lines_count):",
            "        lines.append(input())",
            "    return lines",
            "# テストデータ",
            "def get_testdata(pattern):",
            "    if pattern == 1:",
            "        lines_input = ['akasaka']",
            "        lines_export = ['Yes']",
            "    if pattern == 2:",
            "        lines_input = ['level']",
            "        lines_export = ['No']",
            "    if pattern == 3:",
            "        lines_input = ['atcoder']",
            "        lines_export = ['No']",
            "    return lines_input, lines_export",
            "# 動作モード判別",
            "def get_mode():",
            "    import sys",
            "    args = sys.argv",
            "    global FLAG_LOG",
            "    if len(args) == 1:",
            "        mode = 0",
            "        FLAG_LOG = False",
            "    else:",
            "        mode = int(args[1])",
            "        FLAG_LOG = True",
            "    return mode",
            "# 主処理",
            "def main():",
            "    import time",
            "    started = time.time()",
            "    mode = get_mode()",
            "    if mode == 0:",
            "        lines_input = get_input_lines(1)",
            "    else:",
            "        lines_input, lines_export = get_testdata(mode)",
            "    lines_result = calculation(lines_input)",
            "    for line_result in lines_result:",
            "        print(line_result)",
            "    # if mode > 0:",
            "    #     print(f'lines_input=[{lines_input}]')",
            "    #     print(f'lines_export=[{lines_export}]')",
            "    #     print(f'lines_result=[{lines_result}]')",
            "    #     if lines_result == lines_export:",
            "    #         print('OK')",
            "    #     else:",
            "    #         print('NG')",
            "    # finished = time.time()",
            "    # duration = finished - started",
            "    # print(f'duration=[{duration}]')",
            "# 起動処理",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product                # product(iter, repeat=n)",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4",
            "def main():",
            "    mod = 1000000007                  # 10^9+7",
            "    inf = float('inf')",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():  return int(input())",
            "    def mi():  return map(int, input().split())",
            "    def mi_0(): return map(lambda x: int(x)-1, input().split())",
            "    def lmi(): return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():  return list(input())",
            "    h, w, k = mi()",
            "    L = []",
            "    for _ in range(h):",
            "        L.append(list(map(int, li())))",
            "    L_trans = [[None] * h for _ in range(w)]",
            "    for i in range(h):",
            "        for j in range(w):",
            "            L_trans[j][i] = L[i][j]",
            "    d = 2 ** (h-1)",
            "    cost = [float('inf')] * d",
            "    for state in range(d):",
            "        bit_count = bin(state)[2:].count('1')",
            "        separated = [[0] * (bit_count + 1) for _ in range(w)]",
            "        for i in range(w):",
            "            current = 0",
            "            for j in range(h):",
            "                if j >= 1 and 1 << (j-1) & state:",
            "                    current += 1",
            "                if L_trans[i][j]:",
            "                    separated[i][current] += 1",
            "        previous = [0] * (bit_count + 1)",
            "        cnt = 0",
            "        # print(separated)",
            "        for i in range(w):",
            "            if any(map(lambda x: x > k, separated[i])):",
            "                break",
            "            if all(map(lambda x: x <= k, [elm + previous[ind] for ind, elm in enumerate(separated[i])])):",
            "                # print(f\"just add: {previous} {separated[i]}\")",
            "                for ind, elm in enumerate(separated[i]):",
            "                    previous[ind] += elm    # 追加",
            "            else:",
            "                cnt += 1",
            "                # print(f\"count up: {previous} {separated[i]}\")",
            "                for ind, elm in enumerate(separated[i]):",
            "                    previous[ind] = elm    # 上書き",
            "        else:",
            "            cost[state] = bit_count + cnt",
            "    # print(cost)",
            "    print(min(cost))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "def main():",
            "    H,W,K=map(int,input().split())",
            "    S=[]",
            "    for i in range(H):",
            "        col=list(map(int,list(input())))",
            "        S.append(col)",
            "    CumulativeS=[[S[i][0]] for i in range(H)]",
            "    for i in range(len(S)):",
            "        for j in range(1,len(S[i])):",
            "            CumulativeS[i].append(CumulativeS[i][j-1]+S[i][j])",
            "    for i in range(1,len(S)):",
            "        for j in range(len(S[i])):",
            "            CumulativeS[i][j]+=CumulativeS[i-1][j]",
            "    all_bit=1<<H-1",
            "    res=10000",
            "    for bit in range(all_bit):",
            "        wide_bound=[]",
            "        for i in range(H-1):",
            "            if (bit & (1<<i))!=0:",
            "                wide_bound.append(i)",
            "        res_=len(wide_bound)",
            "        high_bound=[]",
            "        high_flag=0",
            "        for i in range(W):",
            "            if len(high_bound)==0:",
            "                for b in range(len(wide_bound)):",
            "                    if b==0:",
            "                        white_chocolate=CumulativeS[wide_bound[b]][i]",
            "                    else:",
            "                        white_chocolate=CumulativeS[wide_bound[b]][i]-CumulativeS[wide_bound[b-1]][i]",
            "                    if white_chocolate>K:",
            "                        if i-1<0:",
            "                            high_flag=1",
            "                            break",
            "                        high_bound.append(i-1)",
            "                        break",
            "                    if b==len(wide_bound)-1:",
            "                        white_chocolate=CumulativeS[H-1][i]-CumulativeS[wide_bound[b]][i]",
            "                        if white_chocolate > K:",
            "                            if i-1<0:",
            "                                high_flag=1",
            "                                break",
            "                            high_bound.append(i - 1)",
            "                if high_flag==1:",
            "                    break",
            "                if len(wide_bound)==0:",
            "                    white_chocolate = CumulativeS[H - 1][i]",
            "                    if white_chocolate>K:",
            "                        if i-1<0:",
            "                            high_flag=1",
            "                            break",
            "                        high_bound.append(i-1)",
            "            else:",
            "                for b in range(len(wide_bound)):",
            "                    if b == 0:",
            "                        white_chocolate = CumulativeS[wide_bound[b]][i]-CumulativeS[wide_bound[b]][high_bound[len(high_bound)-1]]",
            "                    else:",
            "                        white_chocolate = CumulativeS[wide_bound[b]][i] - CumulativeS[wide_bound[b - 1]][i]-CumulativeS[wide_bound[b]][high_bound[len(high_bound)-1]]+CumulativeS[wide_bound[b-1]][high_bound[len(high_bound)-1]]",
            "                    if white_chocolate>K:",
            "                        if i-1<0:",
            "                            high_flag=1",
            "                            break",
            "                        high_bound.append(i-1)",
            "                        break",
            "                    if b == len(wide_bound) - 1:",
            "                        white_chocolate = CumulativeS[H - 1][i] - CumulativeS[wide_bound[b]][i]-CumulativeS[H-1][high_bound[len(high_bound)-1]]+CumulativeS[wide_bound[b]][high_bound[len(high_bound)-1]]",
            "                        if white_chocolate>K:",
            "                            if i-1<0:",
            "                                high_flag=1",
            "                                break",
            "                            high_bound.append(i-1)",
            "                if high_flag==1:",
            "                    break",
            "                if len(wide_bound)==0:",
            "                    white_chocolate = CumulativeS[H - 1][W - 1]-CumulativeS[H-1][high_bound[len(high_bound)-1]]",
            "                    if white_chocolate>K:",
            "                        if i-1<0:",
            "                            high_flag=1",
            "                            break",
            "                        high_bound.append(i-1)",
            "        res_+=len(high_bound)",
            "        if res_<res and high_flag==0:",
            "            res=res_",
            "    print(res)",
            "if __name__==\"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "import sys",
            "import math",
            "import copy",
            "import heapq",
            "from functools import cmp_to_key",
            "from bisect import bisect_left, bisect_right",
            "from collections import defaultdict, deque, Counter",
            "sys.setrecursionlimit(1000000)",
            "# input aliases",
            "input = sys.stdin.readline",
            "getS = lambda: input().strip()",
            "getN = lambda: int(input())",
            "getList = lambda: list(map(int, input().split()))",
            "getZList = lambda: [int(x) - 1 for x in input().split()]",
            "INF = float(\"inf\")",
            "MOD = 10**9 + 7",
            "divide = lambda x: pow(x, MOD-2, MOD)",
            "def nck(n, k, kaijyo):",
            "    return (npk(n, k, kaijyo) * divide(kaijyo[k])) % MOD",
            "def npk(n, k, kaijyo):",
            "    if k == 0 or k == n:",
            "        return n % MOD",
            "    return (kaijyo[n] * divide(kaijyo[n-k])) % MOD",
            "def fact_and_inv(SIZE):",
            "    inv = [0] * SIZE  # inv[j] = j^{-1} mod MOD",
            "    fac = [0] * SIZE  # fac[j] = j! mod MOD",
            "    finv = [0] * SIZE  # finv[j] = (j!)^{-1} mod MOD",
            "    inv[1] = 1",
            "    fac[0] = fac[1] = 1",
            "    finv[0] = finv[1] = 1",
            "    for i in range(2, SIZE):",
            "        inv[i] = MOD - (MOD // i) * inv[MOD % i] % MOD",
            "        fac[i] = fac[i - 1] * i % MOD",
            "        finv[i] = finv[i - 1] * inv[i] % MOD",
            "    return fac, finv",
            "def renritsu(A, Y):",
            "    # example 2x + y = 3, x + 3y = 4",
            "    # A = [[2,1], [1,3]])",
            "    # Y = [[3],[4]] または [3,4]",
            "    A = np.matrix(A)",
            "    Y = np.matrix(Y)",
            "    Y = np.reshape(Y, (-1, 1))",
            "    X = np.linalg.solve(A, Y)",
            "    # [1.0, 1.0]",
            "    return X.flatten().tolist()[0]",
            "class TwoDimGrid:",
            "    # 2次元座標 -> 1次元",
            "    def __init__(self, h, w, wall=\"o\"):",
            "        self.h = h",
            "        self.w = w",
            "        self.size = (h+2) * (w+2)",
            "        self.wall = wall",
            "        self.get_grid()",
            "        self.init_cost()",
            "    def get_grid(self):",
            "        grid = [self.wall * (self.w + 2)]",
            "        for i in range(self.h):",
            "            grid.append(self.wall + getS() + self.wall)",
            "        grid.append(self.wall * (self.w + 2))",
            "        self.grid = grid",
            "    def init_cost(self):",
            "        self.cost = [INF] * self.size",
            "    def pos(self, x, y):",
            "        # 壁も含めて0-indexed 元々の座標だけ考えると1-indexed",
            "        return y * (self.w + 2) + x",
            "    def getgrid(self, x, y):",
            "        return self.grid[y][x]",
            "    def get(self, x, y):",
            "        return self.cost[self.pos(x, y)]",
            "    def set(self, x, y, v):",
            "        self.cost[self.pos(x, y)] = v",
            "        return",
            "    def show(self):",
            "        for i in range(self.h+2):",
            "            print(self.cost[(self.w + 2) * i:(self.w + 2) * (i+1)])",
            "    def showsome(self, tgt):",
            "        for t in tgt:",
            "            print(t)",
            "        return",
            "    def showsomejoin(self, tgt):",
            "        for t in tgt:",
            "            print(\"\".join(t))",
            "        return",
            "    def search(self):",
            "        grid = self.grid",
            "        move = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
            "        move_eight = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]",
            "        d = deque()",
            "        d.append((1,1))",
            "        self.set(1,1,0)",
            "        while(d):",
            "            cx, cy = d.popleft()",
            "            cc = self.get(cx, cy)",
            "            if self.getgrid(cx, cy) == self.wall:",
            "                continue",
            "            for dx, dy in [(1, 0), (0, 1)]:",
            "                nx, ny = cx + dx, cy + dy",
            "                if self.getgrid(cx, cy) == self.getgrid(nx, ny):",
            "                    if self.get(nx, ny) > cc:",
            "                        d.append((nx, ny))",
            "                        self.set(nx, ny, cc)",
            "                else:",
            "                    if self.get(nx, ny) > cc + 1:",
            "                        d.append((nx, ny))",
            "                        self.set(nx, ny, cc + 1)",
            "        # self.show()",
            "        ans = (self.get(self.w, self.h))",
            "        if self.getgrid(1,1) == \"#\":",
            "            ans += 1",
            "        print((ans + 1) // 2)",
            "def soinsu(n):",
            "    ret = defaultdict(int)",
            "    for i in range(2, int(math.sqrt(n) + 2)):",
            "        if n % i == 0:",
            "            while True:",
            "                if n % i == 0:",
            "                    ret[i] += 1",
            "                    n //= i",
            "                else:",
            "                    break",
            "    if not ret:",
            "        return {n: 1}",
            "    return ret",
            "def solve():",
            "    h, w = getList()",
            "    G = TwoDimGrid(h, w)",
            "    G.search()",
            "def main():",
            "    n = getN()",
            "    for _ in range(n):",
            "        solve()",
            "    return",
            "if __name__ == \"__main__\":",
            "    # main()",
            "    solve()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            2,
            1,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def isp():   return input().split()",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    h, w = mi()",
            "    if h == 1 or w == 1:",
            "        print(1)",
            "    else:",
            "        if h % 2 == 0 or w % 2 == 0:",
            "            print(h * w // 2)",
            "        else:",
            "            print(h * (w - 1) // 2 + (h + 1) // 2)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def isp():   return input().split()",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    a, b, c = mi()",
            "    if c - (a + b) <= 0:",
            "        print('No')",
            "    else:",
            "        print('Yes') if 4 * a * b < (c - (a + b)) ** 2 else print('No')",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def isp():   return input().split()",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n = ii()",
            "    def create_string(digit, buf):",
            "        if digit == n:",
            "            print(''.join(map(lambda x: chr(x + ord('a')), buf)))",
            "            return",
            "        for num in range(max(buf) + 2):",
            "            create_string(digit+1, buf+[num])",
            "    create_string(1, [0])",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# abc157_b.py",
            "# https://atcoder.jp/contests/abc157/tasks/abc157_b",
            "# B - Bingo /",
            "# 実行時間制限: 2 sec / メモリ制限: 1024 MB",
            "# 配点 : 200点",
            "# 問題文",
            "# 3×3のサイズのビンゴカードがあります。上から i 行目、左から j 列目の数は Ai,jです。",
            "# 続けて、 N個の数 b1,b2,⋯,bNが選ばれます。",
            "# 選ばれた数がビンゴカードの中にあった場合、ビンゴカードのその数に印を付けます。",
            "# N個の数字が選ばれた時点でビンゴが達成されているか、則ち、縦・横・斜めのいずれか 1 列に並んだ 3つの数の組であって、",
            "# 全てに印の付いているものが存在するかどうかを判定してください。",
            "# 制約",
            "#     入力は全て整数",
            "#     1≤Ai,j≤100",
            "#     Ai1,j1≠Ai2,j2((i1,j1)≠(i2,j2))",
            "#     1≤N≤10",
            "#     1≤bi≤100",
            "#     bi≠bj(i≠j)",
            "# 入力",
            "# 入力は以下の形式で標準入力から与えられる。",
            "# A1,1 A1,2 A1,3",
            "# A2,1 A2,2 A2,3",
            "# A3,1 A3,2 A3,3",
            "# N",
            "# b1",
            "# ⋮",
            "# bN",
            "# 出力",
            "# ビンゴが達成されているならば Yes と、そうでないならば No と出力せよ。",
            "# 入力例 1",
            "# 84 97 66",
            "# 79 89 11",
            "# 61 59 7",
            "# 7",
            "# 89",
            "# 7",
            "# 87",
            "# 79",
            "# 24",
            "# 84",
            "# 30",
            "# 出力例 1",
            "# Yes",
            "# A1,1,A2,1,A2,2,A3,3に印が付けられます。このとき、左上から右下にかけて斜めに 3個の印が並び、ビンゴが成立しています。",
            "# 入力例 2",
            "# 41 7 46",
            "# 26 89 2",
            "# 78 92 8",
            "# 5",
            "# 6",
            "# 45",
            "# 16",
            "# 57",
            "# 17",
            "# 出力例 2",
            "# No",
            "# 印は 1つも付いていません。",
            "# 入力例 3",
            "# 60 88 34",
            "# 92 41 43",
            "# 65 73 48",
            "# 10",
            "# 60",
            "# 43",
            "# 88",
            "# 11",
            "# 48",
            "# 73",
            "# 65",
            "# 41",
            "# 92",
            "# 34",
            "# 出力例 3",
            "# Yes",
            "# 全てのマスに印が付いています。",
            "global FLAG_LOG",
            "FLAG_LOG = False",
            "def log(value):",
            "    # FLAG_LOG = True",
            "    # FLAG_LOG = False",
            "    if FLAG_LOG:",
            "        print(str(value))",
            "def calculation(lines):",
            "    # S = lines[0]",
            "    N = int(lines[3])",
            "    # N, M = list(map(int, lines[0].split()))",
            "    values_a1 = list(map(int, lines[0].split()))",
            "    values_a2 = list(map(int, lines[1].split()))",
            "    values_a3 = list(map(int, lines[2].split()))",
            "    values = list()",
            "    for i in range(N):",
            "        values.append(int(lines[i+4]))",
            "    # valueses = list()",
            "    # for i in range(N):",
            "    #     valueses.append(list(map(int, lines[i+1].split())))",
            "    # ビンゴしているかどうかのフラグs",
            "    flags = [0] * 9",
            "    for n in range(N):",
            "        if values[n] == values_a1[0]:",
            "            flags[0] = 1",
            "        if values[n] == values_a1[1]:",
            "            flags[1] = 1",
            "        if values[n] == values_a1[2]:",
            "            flags[2] = 1",
            "        if values[n] == values_a2[0]:",
            "            flags[3] = 1",
            "        if values[n] == values_a2[1]:",
            "            flags[4] = 1",
            "        if values[n] == values_a2[2]:",
            "            flags[5] = 1",
            "        if values[n] == values_a3[0]:",
            "            flags[6] = 1",
            "        if values[n] == values_a3[1]:",
            "            flags[7] = 1",
            "        if values[n] == values_a3[2]:",
            "            flags[8] = 1",
            "    result = 'No'",
            "    # 横",
            "    if flags[0] * flags[1] * flags[2] == 1:",
            "        result = 'Yes'",
            "    if flags[3] * flags[4] * flags[5] == 1:",
            "        result = 'Yes'",
            "    if flags[6] * flags[7] * flags[8] == 1:",
            "        result = 'Yes'",
            "    # 縦",
            "    if flags[0] * flags[3] * flags[6] == 1:",
            "        result = 'Yes'",
            "    if flags[1] * flags[4] * flags[7] == 1:",
            "        result = 'Yes'",
            "    if flags[2] * flags[5] * flags[8] == 1:",
            "        result = 'Yes'",
            "    # 斜め",
            "    if flags[0] * flags[4] * flags[8] == 1:",
            "        result = 'Yes'",
            "    if flags[2] * flags[4] * flags[6] == 1:",
            "        result = 'Yes'",
            "    return [result]",
            "# 引数を取得",
            "def get_input_lines():",
            "    lines = list()",
            "    for _ in range(3):",
            "        lines.append(input())",
            "    line = input()",
            "    N = int(line)",
            "    lines.append(line)",
            "    for _ in range(N):",
            "        lines.append(input())",
            "    return lines",
            "# テストデータ",
            "def get_testdata(pattern):",
            "    if pattern == 1:",
            "        lines_input = ['84 97 66', '79 89 11', '61 59 7', '7', '89', '7', '87', '79', '24', '84', '30']",
            "        lines_export = ['Yes']",
            "    if pattern == 2:",
            "        lines_input = ['41 7 46', '26 89 2', '78 92 8', '5', '6', '45', '16', '57', '17']",
            "        lines_export = ['No']",
            "    if pattern == 3:",
            "        lines_input = ['60 88 34', '92 41 43', '65 73 48', '10', '60', '43', '88', '11', '48', '73', '65', '41', '92', '34']",
            "        lines_export = ['Yes']",
            "    return lines_input, lines_export",
            "# 動作モード判別",
            "def get_mode():",
            "    import sys",
            "    args = sys.argv",
            "    global FLAG_LOG",
            "    if len(args) == 1:",
            "        mode = 0",
            "        FLAG_LOG = False",
            "    else:",
            "        mode = int(args[1])",
            "        FLAG_LOG = True",
            "    return mode",
            "# 主処理",
            "def main():",
            "    import time",
            "    started = time.time()",
            "    mode = get_mode()",
            "    if mode == 0:",
            "        lines_input = get_input_lines()",
            "    else:",
            "        lines_input, lines_export = get_testdata(mode)",
            "    lines_result = calculation(lines_input)",
            "    for line_result in lines_result:",
            "        print(line_result)",
            "    # if mode > 0:",
            "    #     print(f'lines_input=[{lines_input}]')",
            "    #     print(f'lines_export=[{lines_export}]')",
            "    #     print(f'lines_result=[{lines_result}]')",
            "    #     if lines_result == lines_export:",
            "    #         print('OK')",
            "    #     else:",
            "    #         print('NG')",
            "    # finished = time.time()",
            "    # duration = finished - started",
            "    # print(f'duration=[{duration}]')",
            "# 起動処理",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "from sys import exit",
            "from collections import deque",
            "from copy import deepcopy",
            "from bisect import bisect_left, bisect_right, insort_left, insort_right",
            "from heapq import heapify, heappop, heappush",
            "from itertools import product, permutations, combinations, combinations_with_replacement",
            "from functools import reduce",
            "from math import gcd, sin, cos, tan, asin, acos, atan, degrees, radians",
            "sys.setrecursionlimit(10**6)",
            "INF = 10**20",
            "eps = 1.0e-20",
            "MOD = 10**9+7",
            "def lcm(x,y):",
            "    return x*y//gcd(x,y)",
            "def lgcd(l):",
            "    return reduce(gcd,l)",
            "def llcm(l):",
            "    return reduce(lcm,l)",
            "def powmod(n,i,mod=MOD):",
            "    return pow(n,mod-1+i,mod) if i<0 else pow(n,i,mod)",
            "def div2(x):",
            "    return x.bit_length()",
            "def div10(x):",
            "    return len(str(x))-(x==0)",
            "def intput():",
            "    return int(input())",
            "def mint():",
            "    return map(int,input().split())",
            "def lint():",
            "    return list(map(int,input().split()))",
            "def ilint():",
            "    return int(input()), list(map(int,input().split()))",
            "def judge(x, l=['Yes', 'No']):",
            "    print(l[0] if x else l[1])",
            "def lprint(l, sep='\\n'):",
            "    for x in l:",
            "        print(x, end=sep)",
            "def ston(c, c0='a'):",
            "    return ord(c)-ord(c0)",
            "def ntos(x, c0='a'):",
            "    return chr(x+ord(c0))",
            "class counter(dict):",
            "    def __init__(self, *args):",
            "        super().__init__(args)",
            "    def add(self,x,d=1):",
            "        self.setdefault(x,0)",
            "        self[x] += d",
            "    def list(self):",
            "        l = []",
            "        for k in self:",
            "            l.extend([k]*self[k])",
            "        return l",
            "class comb():",
            "    def __init__(self, n, mod=None):",
            "        self.l = [1]",
            "        self.n = n",
            "        self.mod = mod",
            "    def get(self,k):",
            "        l,n,mod = self.l, self.n, self.mod",
            "        k = n-k if k>n//2 else k",
            "        while len(l)<=k:",
            "            i = len(l)",
            "            l.append(l[i-1]*(n+1-i)//i if mod==None else (l[i-1]*(n+1-i)*powmod(i,-1,mod))%mod)",
            "        return l[k]",
            "def pf(x,mode='counter'):",
            "    C = counter()",
            "    p = 2",
            "    while x>1:",
            "        k = 0",
            "        while x%p==0:",
            "            x //= p",
            "            k += 1",
            "        if k>0:",
            "            C.add(p,k)",
            "        p = p+2-(p==2) if p*p<x else x",
            "    if mode=='counter':",
            "        return C",
            "    S = set([1])",
            "    for k in C:",
            "        T = deepcopy(S)",
            "        for x in T:",
            "            for i in range(1,C[k]+1):",
            "                S.add(x*(k**i))",
            "    if mode=='set':",
            "        return S",
            "    if mode=='list':",
            "        return sorted(list(S))",
            "class UnionFind():",
            "    # インデックスは0-start",
            "    # 初期化",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parents = [-1]*n",
            "        self.group = n",
            "    # private function",
            "    def root(self, x):",
            "        if self.parents[x]<0:",
            "            return x",
            "        else:",
            "            self.parents[x] = self.root(self.parents[x])",
            "            return self.parents[x]",
            "    # x,yが属するグループの結合",
            "    def union(self, x, y):",
            "        x = self.root(x)",
            "        y = self.root(y)",
            "        if x==y:",
            "            return",
            "        if self.parents[x]>self.parents[y]:",
            "            x,y = y,x",
            "        self.parents[x] += self.parents[y]",
            "        self.parents[y] = x",
            "        self.group -= 1",
            "    # x,yが同グループか判定",
            "    def same(self, x, y):",
            "        return self.root(x)==self.root(y)",
            "    # xと同じグループの要素数を取得",
            "    def size(self, x):",
            "        return -self.parents[self.root(x)]",
            "######################################################",
            "N,M,K=mint()",
            "T=UnionFind(N)",
            "block=[0]*N",
            "for _ in range(M):",
            "    a,b=mint()",
            "    T.union(a-1,b-1)",
            "    block[a-1]+=1",
            "    block[b-1]+=1",
            "for _ in range(K):",
            "    c,d=mint()",
            "    if T.same(c-1,d-1):",
            "        block[c-1]+=1",
            "        block[d-1]+=1",
            "ans=[T.size(i)-block[i]-1 for i in range(N)]",
            "lprint(ans,' ')"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            0,
            2,
            1,
            2,
            1,
            2,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            2,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            1,
            1,
            0,
            0,
            2,
            2
        ]
    },
    {
        "content": [
            "\"\"\"/////////////////////////////////////////////////////////////////////////////////////////////////////////////////",
            "Union-Find！Union-Find！Union-Find！Union-Findぅぅうううわぁああああああああああああああああああああああん！！！",
            "あぁああああ…ああ…あっあっー！あぁああああああ！！！Union-FindUnion-FindUnion-Findぅううぁわぁああああ！！！",
            "あぁクンカクンカ！クンカクンカ！スーハースーハー！スーハースーハー！いい匂いだなぁ…くんくん",
            "んはぁっ！Union-Findたんの桃色ブロンドの髪をクンカクンカしたいお！クンカクンカ！あぁあ！！",
            "間違えた！モフモフしたいお！モフモフ！モフモフ！髪髪モフモフ！カリカリモフモフ…きゅんきゅんきゅい！！",
            "小説12巻のUnion-Findたんかわいかったよぅ！！あぁぁああ…あああ…あっあぁああああ！！ふぁぁあああんんっ！！",
            "アニメ2期放送されて良かったねUnion-Findたん！あぁあああああ！かわいい！Union-Findたん！かわいい！あっああぁああ！",
            "コミック2巻も発売されて嬉し…いやぁああああああ！！！にゃああああああああん！！ぎゃああああああああ！！",
            "ぐあああああああああああ！！！コミックなんて現実じゃない！！！！あ…小説もアニメもよく考えたら…",
            "U n i o n - F i n d ち ゃ ん は 現 実 じ ゃ な い？にゃあああああああああああああん！！うぁああああああああああ！！",
            "そんなぁああああああ！！いやぁぁぁあああああああああ！！はぁああああああん！！う　し　た　ぷ　に　き　あ　王　国　笑ぁああああ！！",
            "この！ちきしょー！やめてやる！！現実なんかやめ…て…え！？見…てる？表紙絵のUnion-Findちゃんが僕を見てる？",
            "表紙絵のUnion-Findちゃんが僕を見てるぞ！Union-Findちゃんが僕を見てるぞ！挿絵のUnion-Findちゃんが僕を見てるぞ！！",
            "アニメのUnion-Findちゃんが僕に話しかけてるぞ！！！よかった…世の中まだまだ捨てたモンじゃないんだねっ！",
            "いやっほぉおおおおおおお！！！僕にはUnion-Findちゃんがいる！！やったよdefault dict！！ひとりでできるもん！！！",
            "あ、コミックのUnion-Findちゃああああああああああああああん！！いやぁあああああああああああああああ！！！！",
            "あっあんああっああんあset様ぁあ！！さ、最小全域木ー！！Dijkstraぁああああああ！！！セグ木ぃいいい！！",
            "ううっうぅうう！！俺の想いよUnion-Findへ届け！！う　し　た　ぷ　に　き　あ　王　国　笑のUnion-Findへ届け！",
            "/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\"\"\"",
            "class UnionFind():",
            "    def __init__(self, n):",
            "        self.parents = list(range(n))",
            "        self.size = [1] * n",
            "    def find(self, x):",
            "        if self.parents[x] == x:",
            "            return x",
            "        else:",
            "            self.parents[x] = self.find(self.parents[x])",
            "            return self.parents[x]",
            "    def union(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "        if x == y:",
            "            return",
            "        if self.size[x] < self.size[y]:",
            "            self.size[y] += self.size[x]",
            "            self.parents[x] = y",
            "        else:",
            "            self.size[x] += self.size[y]",
            "            self.parents[y] = x",
            "    def size(self, x):",
            "        return -self.parents[self.find(x)]",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "    def members(self, x):",
            "        root = self.find(x)",
            "        return [i for i in range(self.n) if self.find(i) == root]",
            "    def roots(self):",
            "        return [i for i, x in enumerate(self.parents) if x < 0]",
            "    def group_count(self):",
            "        return len(self.roots())",
            "    def all_group_members(self):",
            "        return {r: self.members(r) for r in self.roots()}",
            "    def __str__(self):",
            "        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())",
            "n,m,k=map(int,input().split())",
            "uf=UnionFind(n)",
            "friends=[0]*n",
            "for i in range(m):",
            "    a,b=map(int,input().split())",
            "    uf.union(a-1,b-1)",
            "    friends[a-1]+=1",
            "    friends[b-1]+=1",
            "block=[[] for _ in range(n)]",
            "for i in range(k):",
            "    c,d=map(int,input().split())",
            "    block[c-1].append(d)",
            "    block[d-1].append(c)",
            "ans=[0]*n",
            "cnt=[0]*n",
            "for i in range(n):",
            "    cnt[i]=uf.find(i)",
            "for i in range(n):",
            "    num1=uf.size[uf.find(i)]-friends[i]-1",
            "    num2=cnt[i]",
            "    for j in range(len(block[i])):",
            "        if num2==cnt[block[i][j]-1]:",
            "            num1-=1",
            "    ans[i]=num1",
            "print(*ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            2
        ]
    },
    {
        "content": [
            "# -*- coding: utf-8 -*-",
            "import sys",
            "import math",
            "import os",
            "import itertools",
            "import string",
            "import heapq",
            "import _collections",
            "from collections import Counter",
            "from collections import defaultdict",
            "from collections import deque",
            "from functools import lru_cache",
            "import bisect",
            "import re",
            "import queue",
            "import decimal",
            "class Scanner():",
            "    @staticmethod",
            "    def int():",
            "        return int(sys.stdin.readline().rstrip())",
            "    @staticmethod",
            "    def string():",
            "        return sys.stdin.readline().rstrip()",
            "    @staticmethod",
            "    def map_int():",
            "        return [int(x) for x in Scanner.string().split()]",
            "    @staticmethod",
            "    def string_list(n):",
            "        return [Scanner.string() for i in range(n)]",
            "    @staticmethod",
            "    def int_list_list(n):",
            "        return [Scanner.map_int() for i in range(n)]",
            "    @staticmethod",
            "    def int_cols_list(n):",
            "        return [Scanner.int() for i in range(n)]",
            "class Math():",
            "    @staticmethod",
            "    def gcd(a, b):",
            "        if b == 0:",
            "            return a",
            "        return Math.gcd(b, a % b)",
            "    @staticmethod",
            "    def lcm(a, b):",
            "        return (a * b) // Math.gcd(a, b)",
            "    @staticmethod",
            "    def divisor(n):",
            "        res = []",
            "        i = 1",
            "        for i in range(1, int(n ** 0.5) + 1):",
            "            if n % i == 0:",
            "                res.append(i)",
            "                if i != n // i:",
            "                    res.append(n // i)",
            "        return res",
            "    @staticmethod",
            "    def round_up(a, b):",
            "        return -(-a // b)",
            "    @staticmethod",
            "    def is_prime(n):",
            "        if n < 2:",
            "            return False",
            "        if n == 2:",
            "            return True",
            "        if n % 2 == 0:",
            "            return False",
            "        d = int(n ** 0.5) + 1",
            "        for i in range(3, d + 1, 2):",
            "            if n % i == 0:",
            "                return False",
            "        return True",
            "    @staticmethod",
            "    def fact(N):",
            "        res = {}",
            "        tmp = N",
            "        for i in range(2, int(N ** 0.5 + 1) + 1):",
            "            cnt = 0",
            "            while tmp % i == 0:",
            "                cnt += 1",
            "                tmp //= i",
            "            if cnt > 0:",
            "                res[i] = cnt",
            "        if tmp != 1:",
            "            res[tmp] = 1",
            "        if res == {}:",
            "            res[N] = 1",
            "        return res",
            "def pop_count(x):",
            "    x = x - ((x >> 1) & 0x5555555555555555)",
            "    x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)",
            "    x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f",
            "    x = x + (x >> 8)",
            "    x = x + (x >> 16)",
            "    x = x + (x >> 32)",
            "    return x & 0x0000007f",
            "MOD = int(1e09) + 7",
            "INF = int(1e15)",
            "class UnionFind:",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parents = [-1] * n",
            "    def root(self, x):",
            "        if self.parents[x] < 0:",
            "            return x",
            "        else:",
            "            self.parents[x] = self.root(self.parents[x])",
            "            return self.parents[x]",
            "    def unite(self, x, y):",
            "        x = self.root(x)",
            "        y = self.root(y)",
            "        if x == y:",
            "            return",
            "        if self.parents[x] > self.parents[y]:",
            "            x, y = y, x",
            "        self.parents[x] += self.parents[y]",
            "        self.parents[y] = x",
            "    def size(self, x):",
            "        return -self.parents[self.root(x)]",
            "    def is_same(self, x, y):",
            "        return self.root(x) == self.root(y)",
            "def solve():",
            "    N, M, K = Scanner.map_int()",
            "    uni = UnionFind(N)",
            "    friends = [set() for _ in range(N)]",
            "    for _ in range(M):",
            "        a, b = Scanner.map_int()",
            "        a -= 1",
            "        b -= 1",
            "        uni.unite(a, b)",
            "        friends[a].add(b)",
            "        friends[b].add(a)",
            "    block = [set() for _ in range(N)]",
            "    for _ in range(K):",
            "        a, b = Scanner.map_int()",
            "        a -= 1",
            "        b -= 1",
            "        block[a].add(b)",
            "        block[b].add(a)",
            "    ans = [0 for _ in range(N)]",
            "    for i in range(N):",
            "        size = uni.size(i)",
            "        f = len(friends[i])",
            "        bn = 0",
            "        for b in block[i]:",
            "            if uni.is_same(i, b):",
            "                bn += 1",
            "        ans[i] = size - 1 - f - bn",
            "    print(*ans)",
            "def main():",
            "    # sys.stdin = open(\"sample.txt\")",
            "    # T = Scanner.int()",
            "    # for _ in range(T):",
            "    #     solve()",
            "    # print('YNeos'[not solve()::2])",
            "    solve()",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "class BalancingTree:",
            "    \"\"\"平衡二分木のクラス",
            "    Pivotを使った実装.",
            "    0以上2^n - 2以下の整数を扱う",
            "    \"\"\"",
            "    def __init__(self, n):",
            "        \"\"\"",
            "        2の指数nで初期化",
            "        \"\"\"",
            "        self.N = n",
            "        self.root = self.node(1<<n, 1<<n)",
            "    def debug(self):",
            "        \"\"\"デバッグ用の関数\"\"\"",
            "        def debug_info(nd_):",
            "            return (nd_.value - 1, nd_.pivot - 1, nd_.left.value - 1 if nd_.left else -1, nd_.right.value - 1 if nd_.right else -1)",
            "        def debug_node(nd):",
            "            re = []",
            "            if nd.left:",
            "                re += debug_node(nd.left)",
            "            if nd.value: re.append(debug_info(nd))",
            "            if nd.right:",
            "                re += debug_node(nd.right)",
            "            return re",
            "        print(\"Debug - root =\", self.root.value - 1, debug_node(self.root)[:50])",
            "    def append(self, v):",
            "        \"\"\"",
            "        v を追加（その時点で v はない前提）",
            "        \"\"\"",
            "        v += 1",
            "        nd = self.root",
            "        while True:",
            "            if v == nd.value:",
            "                # v がすでに存在する場合に何か処理が必要ならここに書く",
            "                return 0",
            "            else:",
            "                mi, ma = min(v, nd.value), max(v, nd.value)",
            "                if mi < nd.pivot:",
            "                    nd.value = ma",
            "                    if nd.left:",
            "                        nd = nd.left",
            "                        v = mi",
            "                    else:",
            "                        p = nd.pivot",
            "                        nd.left = self.node(mi, p - (p&-p)//2)",
            "                        break",
            "                else:",
            "                    nd.value = mi",
            "                    if nd.right:",
            "                        nd = nd.right",
            "                        v = ma",
            "                    else:",
            "                        p = nd.pivot",
            "                        nd.right = self.node(ma, p + (p&-p)//2)",
            "                        break",
            "    def leftmost(self, nd):",
            "        if nd.left: return self.leftmost(nd.left)",
            "        return nd",
            "    def rightmost(self, nd):",
            "        if nd.right: return self.rightmost(nd.right)",
            "        return nd",
            "    def find_l(self, v):",
            "        \"\"\"",
            "        vより真に小さいやつの中での最大値（なければ-1）",
            "        \"\"\"",
            "        v += 1",
            "        nd = self.root",
            "        prev = 0",
            "        if nd.value < v: prev = nd.value",
            "        while True:",
            "            if v <= nd.value:",
            "                if nd.left:",
            "                    nd = nd.left",
            "                else:",
            "                    return prev - 1",
            "            else:",
            "                prev = nd.value",
            "                if nd.right:",
            "                    nd = nd.right",
            "                else:",
            "                    return prev - 1",
            "    def find_r(self, v):",
            "        \"\"\"",
            "        vより真に大きいやつの中での最小値（なければRoot）",
            "        \"\"\"",
            "        v += 1",
            "        nd = self.root",
            "        prev = 0",
            "        if nd.value > v: prev = nd.value",
            "        while True:",
            "            if v < nd.value:",
            "                prev = nd.value",
            "                if nd.left:",
            "                    nd = nd.left",
            "                else:",
            "                    return prev - 1",
            "            else:",
            "                if nd.right:",
            "                    nd = nd.right",
            "                else:",
            "                    return prev - 1",
            "    @property",
            "    def max(self):",
            "        \"\"\"最大値の属性\"\"\"",
            "        return self.find_l((1<<self.N)-1)",
            "    @property",
            "    def min(self):",
            "        \"\"\"最小値の属性\"\"\"",
            "        return self.find_r(-1)",
            "    def delete(self, v, nd = None, prev = None):",
            "        \"\"\"",
            "        値がvのノードがあれば削除（なければ何もしない）",
            "        \"\"\"",
            "        v += 1",
            "        if not nd: nd = self.root",
            "        if not prev: prev = nd",
            "        while v != nd.value:",
            "            prev = nd",
            "            if v <= nd.value:",
            "                if nd.left:",
            "                    nd = nd.left",
            "                else:",
            "                    return",
            "            else:",
            "                if nd.right:",
            "                    nd = nd.right",
            "                else:",
            "                    return",
            "        if (not nd.left) and (not nd.right):",
            "            if nd.value < prev.value:",
            "                prev.left = None",
            "            else:",
            "                prev.right = None",
            "        elif not nd.left:",
            "            if nd.value < prev.value:",
            "                prev.left = nd.right",
            "            else:",
            "                prev.right = nd.right",
            "        elif not nd.right:",
            "            if nd.value < prev.value:",
            "                prev.left = nd.left",
            "            else:",
            "                prev.right = nd.left",
            "        else:",
            "            nd.value = self.leftmost(nd.right).value",
            "            self.delete(nd.value - 1, nd.right, nd)",
            "    def __contains__(self, v: int) -> bool:",
            "        return self.find_r(v - 1) == v",
            "    class node:",
            "        \"\"\"ノードをあらわすクラス",
            "        v: 値",
            "        p: ピボット値",
            "        で初期化",
            "        \"\"\"",
            "        def __init__(self, v, p):",
            "            self.value = v",
            "            self.pivot = p",
            "            self.left = None",
            "            self.right = None",
            "Trees = [BalancingTree(50) for _ in range(26)]",
            "N = int(input())",
            "S = input()",
            "Q = int(input())",
            "alphabets = list(\"abcdefghijklmnopqrstuvwxyz\")",
            "c2n = {c: i for i, c in enumerate(alphabets)}",
            "for i in range(N):",
            "    Trees[c2n[S[i]]].append(i+1)",
            "S = list(S)",
            "for _ in range(Q):",
            "    tmp = list(input().split())",
            "    if tmp[0] == \"1\":",
            "        _, i, c = tmp",
            "        i = int(i)",
            "        bef = S[i-1]",
            "        if bef == c:",
            "            continue",
            "        Trees[c2n[bef]].delete(i)",
            "        Trees[c2n[c]].append(i)",
            "        S[i-1] = c",
            "    else:",
            "        _, l, r = tmp",
            "        l = int(l)",
            "        r = int(r)",
            "        ans = 0",
            "        for char in range(26):",
            "            res = Trees[char].find_r(l-1)",
            "            if l <= res <= r:",
            "                ans += 1",
            "        print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            2,
            2,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": [
            "#!usr/bin/env python3",
            "from collections import defaultdict, deque, Counter, OrderedDict",
            "from bisect import bisect_left, bisect_right",
            "from functools import reduce, lru_cache",
            "from heapq import heappush, heappop, heapify",
            "import itertools, bisect",
            "import math, fractions",
            "import sys, copy",
            "def L(): return sys.stdin.readline().split()",
            "def I(): return int(sys.stdin.readline().rstrip())",
            "def S(): return list(sys.stdin.readline().rstrip())",
            "def LI(): return [int(x) for x in sys.stdin.readline().split()]",
            "def LI1(): return [int(x) - 1 for x in sys.stdin.readline().split()]",
            "def LS(): return [list(x) for x in sys.stdin.readline().split()]",
            "def IR(n): return [I() for _ in range(n)]",
            "def LIR(n): return [LI() for _ in range(n)]",
            "def LIR1(n): return [LI1() for _ in range(n)]",
            "def SR(n): return [S() for _ in range(n)]",
            "def LSR(n): return [LS() for _ in range(n)]",
            "def LR(n): return [L() for _ in range(n)]",
            "alphabets = \"abcdefghijklmnopqrstuvwxyz\"",
            "sys.setrecursionlimit(1000000)",
            "dire = [[1, 0], [0, 1], [-1, 0], [0, -1]]",
            "dire8 = [[1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]]",
            "MOD = 1000000007",
            "# nodeをリストに変換したらクソ遅かった",
            "import pprint",
            "class BalancingTree:",
            "    def __init__(self, n):",
            "        self.N = n",
            "        self.root = self.node(1<<n, 1<<n)",
            "    def __str__(self):",
            "        def debug_info(nd):",
            "            return (nd.value - 1, nd.left.value - 1 if nd.left else None, nd.right.value - 1 if nd.right else None)",
            "        def debug_node(nd):",
            "            v = debug_info(nd) if nd.value else ()",
            "            left = debug_node(nd.left) if nd.left else []",
            "            right = debug_node(nd.right) if nd.right else []",
            "            return [v, left, right]",
            "        return pprint.PrettyPrinter(indent=4).pformat(debug_node(self.root))",
            "    __repr__ = __str__",
            "    def append(self, v):# v を追加（その時点で v はない前提）",
            "        v += 1",
            "        nd = self.root",
            "        while True:",
            "            # v がすでに存在する場合に何か処理が必要ならここに書く",
            "            if v == nd.value:",
            "                return 0",
            "            else:",
            "                mi, ma = min(v, nd.value), max(v, nd.value)",
            "                if mi < nd.pivot:",
            "                    nd.value = ma",
            "                    if nd.left:",
            "                        nd = nd.left",
            "                        v = mi",
            "                    else:",
            "                        p = nd.pivot",
            "                        nd.left = self.node(mi, p - (p&-p)//2)",
            "                        break",
            "                else:",
            "                    nd.value = mi",
            "                    if nd.right:",
            "                        nd = nd.right",
            "                        v = ma",
            "                    else:",
            "                        p = nd.pivot",
            "                        nd.right = self.node(ma, p + (p&-p)//2)",
            "                        break",
            "    def leftmost(self, nd):",
            "        return self.leftmost(nd.left) if nd.left else nd",
            "    def rightmost(self, nd):",
            "        return self.rightmost(nd.right) if nd.right else nd",
            "    def find_l(self, v): # vより真に小さいやつの中での最大値（なければ-1）",
            "        v += 1",
            "        nd = self.root",
            "        prev = nd.value if nd.value < v else 0",
            "        while True:",
            "            if v <= nd.value:",
            "                if nd.left:",
            "                    nd = nd.left",
            "                else:",
            "                    return prev - 1",
            "            else:",
            "                prev = nd.value",
            "                if nd.right:",
            "                    nd = nd.right",
            "                else:",
            "                    return prev - 1",
            "    def find_r(self, v): # vより真に大きいやつの中での最小値（なければRoot）",
            "        v += 1",
            "        nd = self.root",
            "        prev = nd.value if nd.value > v else 0",
            "        while True:",
            "            if v < nd.value:",
            "                prev = nd.value",
            "                if nd.left:",
            "                    nd = nd.left",
            "                else:",
            "                    return prev - 1",
            "            else:",
            "                if nd.right:",
            "                    nd = nd.right",
            "                else:",
            "                    return prev - 1",
            "    def max(self):",
            "        return self.find_l((1<<self.N)-1)",
            "    def min(self):",
            "        return self.find_r(-1)",
            "    def delete(self, v, nd = None, prev = None): # 値がvのノードがあれば削除（なければ何もしない）",
            "        v += 1",
            "        if not nd:",
            "            nd = self.root",
            "        if not prev:",
            "            prev = nd",
            "        while v != nd.value:",
            "            prev = nd",
            "            if v <= nd.value:",
            "                if nd.left:",
            "                    nd = nd.left",
            "                else:",
            "                    return",
            "            else:",
            "                if nd.right:",
            "                    nd = nd.right",
            "                else:",
            "                    return",
            "        if (not nd.left) and (not nd.right):",
            "            if nd.value < prev.value:",
            "                prev.left = None",
            "            else:",
            "                prev.right = None",
            "        elif not nd.left:",
            "            if nd.value < prev.value:",
            "                prev.left = nd.right",
            "            else:",
            "                prev.right = nd.right",
            "        elif not nd.right:",
            "            if nd.value < prev.value:",
            "                prev.left = nd.left",
            "            else:",
            "                prev.right = nd.left",
            "        else:",
            "            nd.value = self.leftmost(nd.right).value",
            "            self.delete(nd.value - 1, nd.right, nd)",
            "    # v以下のものの中での最大値",
            "    def upper_bound(self, v):",
            "        upper = self.find_r(v)",
            "        return self.find_l(upper)",
            "    def lower_bound(self, v):",
            "        lower = self.find_l(v)",
            "        return self.find_r(lower)",
            "    def __contains__(self, v: int) -> bool:",
            "        return self.find_r(v - 1) == v",
            "    class node:",
            "        def __init__(self, v, p):",
            "            self.value = v",
            "            self.pivot = p",
            "            self.left = None",
            "            self.right = None",
            "def main():",
            "    N = I()",
            "    s = S()",
            "    Q = I()",
            "    query = LR(Q)",
            "    trees = {ch: BalancingTree(25) for ch in alphabets}",
            "    for i, ch in enumerate(s):",
            "        trees[ch].append(i)",
            "    for q in query:",
            "        if q[0] == \"1\":",
            "            _, i, c = q",
            "            i = int(i) - 1",
            "            prev = s[i]",
            "            trees[prev].delete(i)",
            "            s[i] = c",
            "            trees[c].append(i)",
            "        else:",
            "            _, l, r = q",
            "            l, r = int(l) - 1, int(r) - 1",
            "            count = 0",
            "            for _, tree in trees.items():",
            "                first = tree.lower_bound(l)",
            "                if first != tree.root.value - 1 and first <= r:",
            "                    count += 1",
            "            print(count)",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "from collections import deque",
            "class SegmentTree():",
            "    def __init__(self,n,ide_ele,merge_func,init_val):",
            "        self.n=n",
            "        self.ide_ele=ide_ele",
            "        self.merge_func=merge_func",
            "        self.val=[0 for i in range(1<<n)]",
            "        self.merge=[0 for i in range(1<<n)]",
            "        self.parent=[-1 for i in range(1<<n)]",
            "        deq=deque([1<<(n-1)])",
            "        res=[]",
            "        while deq:",
            "            v=deq.popleft()",
            "            res.append(v)",
            "            if not v&1:",
            "                gap=(v&-v)//2",
            "                self.parent[v-gap]=v",
            "                deq.append(v-gap)",
            "                self.parent[v+gap]=v",
            "                deq.append(v+gap)",
            "        for v in res[::-1]:",
            "            if v-1<len(init_val):",
            "                self.val[v-1]=init_val[v-1]",
            "            self.merge[v-1]=self.val[v-1]",
            "            if not v&1:",
            "                gap=(v&-v)//2",
            "                self.merge[v-1]=self.merge_func(self.merge[v-1],self.merge[v-gap-1],self.merge[v+gap-1])",
            "    def update(self,id,x):",
            "        self.val[id]=x",
            "        pos=id+1",
            "        while pos!=-1:",
            "            if pos&1:",
            "                self.merge[pos-1]=self.val[pos-1]",
            "            else:",
            "                gap=(pos&-pos)//2",
            "                self.merge[pos-1]=self.merge_func(self.val[pos-1],self.merge[pos+gap-1],self.merge[pos-gap-1])",
            "            pos=self.parent[pos]",
            "    def cnt(self,k):",
            "        lsb=(k)&(-k)",
            "        return (lsb<<1)-1",
            "    def lower_kth_merge(self,nd,k):",
            "        res=self.ide_ele",
            "        id=nd",
            "        if k==-1:",
            "            return res",
            "        while True:",
            "            if not id%2:",
            "                gap=((id)&(-id))//2",
            "                l=id-gap",
            "                r=id+gap",
            "                cnt=self.cnt(l)",
            "                if cnt<k:",
            "                    k-=cnt+1",
            "                    res=self.merge_func(res,self.val[id-1],self.merge[l-1])",
            "                    id=r",
            "                elif cnt==k:",
            "                    res=self.merge_func(res,self.val[id-1],self.merge[l-1])",
            "                    return res",
            "                else:",
            "                    id=l",
            "            else:",
            "                res=self.merge_func(res,self.val[id-1])",
            "                return res",
            "    def upper_kth_merge(self,nd,k):",
            "        res=self.ide_ele",
            "        id=nd",
            "        if k==-1:",
            "            return res",
            "        while True:",
            "            if not id%2:",
            "                gap=((id)&(-id))//2",
            "                l=id-gap",
            "                r=id+gap",
            "                cnt=self.cnt(r)",
            "                if cnt<k:",
            "                    k-=cnt+1",
            "                    res=self.merge_func(res,self.val[id-1],self.merge[r-1])",
            "                    id=l",
            "                elif cnt==k:",
            "                    res=self.merge_func(res,self.val[id-1],self.merge[r-1])",
            "                    return res",
            "                else:",
            "                    id=r",
            "            else:",
            "                res=self.merge_func(res,self.val[id-1])",
            "                return res",
            "    def query(self,l,r):",
            "        id=1<<(self.n-1)",
            "        while True:",
            "            if id-1<l:",
            "                id+=((id)&(-id))//2",
            "            elif id-1>r:",
            "                id-=((id)&(-id))//2",
            "            else:",
            "                res=self.val[id-1]",
            "                if id%2:",
            "                    return res",
            "                gap=((id)&(-id))//2",
            "                L,R=id-gap,id+gap",
            "                #print(l,r,id,L,R)",
            "                left=self.upper_kth_merge(L,id-1-l-1)",
            "                right=self.lower_kth_merge(R,r-id)",
            "                return self.merge_func(res,left,right)",
            "ide_ele=0",
            "def seg_func(*args):",
            "    res=ide_ele",
            "    for val in args:",
            "        res|=val",
            "    return res",
            "def popcount(x):",
            "    x = x - ((x >> 1) & 0x55555555)",
            "    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)",
            "    x = (x + (x >> 4)) & 0x0f0f0f0f",
            "    x = x + (x >> 8)",
            "    x = x + (x >> 16)",
            "    return x & 0x0000007f",
            "import sys",
            "input=sys.stdin.readline",
            "N=int(input())",
            "S=input().rstrip()",
            "init_val=[1<<(ord(S[i])-97) for i in range(N)]",
            "test=SegmentTree(19,ide_ele,seg_func,init_val)",
            "for _ in range(int(input())):",
            "    t,l,r=input().split()",
            "    t,l=int(t),int(l)",
            "    if t==1:",
            "        val=ord(r)-97",
            "        test.update(l-1,1<<val)",
            "    else:",
            "        r=int(r)",
            "        res=test.query(l-1,r-1)",
            "        print(popcount(res))"
        ],
        "label": [
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            1,
            1,
            1
        ]
    },
    {
        "content": [
            "class SegTree():",
            "    def segFunc(self, x, y):",
            "        return x+y",
            "    def searchIndexFunc(self, val):",
            "        return True",
            "    def __init__(self, ide, init_val):",
            "        n = len(init_val)",
            "        self.ide_ele = ide",
            "        self.num = 2**(n-1).bit_length()",
            "        self.seg = [self.ide_ele] * 2 * self.num",
            "        for i in range(n):",
            "            self.seg[i+self.num-1] = init_val[i]",
            "        for i in range(self.num-2,-1,-1):",
            "            self.seg[i] = self.segFunc(self.seg[2*i+1],self.seg[2*i+2])",
            "    def update(self, idx, val):",
            "        idx += self.num-1",
            "        self.seg[idx] = val",
            "        while idx:",
            "            idx = (idx-1)//2",
            "            self.seg[idx] = self.segFunc(self.seg[idx*2+1], self.seg[idx*2+2])",
            "    def addition(self, idx, val):",
            "        idx += self.num-1",
            "        self.seg[idx] += val",
            "        while idx:",
            "            idx = (idx-1)//2",
            "            self.seg[idx] = self.segFunc(self.seg[idx*2+1], self.seg[idx*2+2])",
            "    def multiplication(self, idx, val):",
            "        idx += self.num-1",
            "        self.seg[idx] *= val",
            "        while idx:",
            "            idx = (idx-1)//2",
            "            self.seg[idx] = self.segFunc(self.seg[idx*2+1], self.seg[idx*2+2])",
            "    def query(self, begin, end):",
            "        if end <= begin:",
            "            return self.ide_ele",
            "        begin += self.num-1",
            "        end += self.num-2",
            "        res = self.ide_ele",
            "        while begin + 1 < end:",
            "            if begin&1 == 0:",
            "                res = self.segFunc(res, self.seg[begin])",
            "            if end&1 == 1:",
            "                res = self.segFunc(res, self.seg[end])",
            "                end -= 1",
            "            begin = begin//2",
            "            end = (end-1)//2",
            "        if begin == end:",
            "            res = self.segFunc(res, self.seg[begin])",
            "        else:",
            "            res = self.segFunc(self.segFunc(res, self.seg[begin]), self.seg[end])",
            "        return res",
            "    def getLargestIndex(self, begin, end):",
            "        L, R = begin, end",
            "        if not self.searchIndexFunc(self.query(begin, end)):",
            "            return None",
            "        while L+1 < R:",
            "            P = (L+R)//2",
            "            if self.searchIndexFunc(self.query(P, R)):",
            "                L = P",
            "            else:",
            "                R = P",
            "        return L",
            "    def getSmallestIndex(self, begin, end):",
            "        L, R = begin, end",
            "        if not self.searchIndexFunc(self.query(begin, end)):",
            "            return None",
            "        while L+1 < R:",
            "            P = (L+R+1)//2",
            "            if self.searchIndexFunc(self.query(L, P)):",
            "                R = P",
            "            else:",
            "                L = P",
            "        return L",
            "def main():",
            "    n = int(input())",
            "    s = input()",
            "    alp = [[0]*n for _ in range(26)]",
            "    for i, c in enumerate(s):",
            "        alp[ord(c) - ord(\"a\")][i] = 1",
            "    seg = [SegTree(0, alp[i]) for i in range(26)]",
            "    q = int(input())",
            "    ans = []",
            "    for _ in range(q):",
            "        a, b, c = map(str, input().split())",
            "        if a == \"1\":",
            "            b = int(b) - 1",
            "            for i in range(26):",
            "                if alp[i][b] == 1:",
            "                    alp[i][b] = 0",
            "                    seg[i].update(b, 0)",
            "            alp[ord(c) - ord(\"a\")][b] = 1",
            "            seg[ord(c) - ord(\"a\")].update(b, 1)",
            "        else:",
            "            b, c = int(b)-1, int(c)",
            "            cnt = 0",
            "            for i in range(26):",
            "                if seg[i].query(b, c) > 0:",
            "                    cnt += 1",
            "            ans.append(cnt)",
            "    for v in ans:",
            "        print(v)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            1,
            2,
            1,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            2,
            1,
            1,
            1,
            0,
            0,
            2,
            1,
            1,
            1,
            0,
            0,
            2,
            1,
            1,
            1,
            0,
            0,
            2,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            2,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            1,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "class SegmentTree():",
            "    \"\"\"A segment Tree.",
            "    This is a segment tree without recursions.",
            "    This can support queries as follows:",
            "     - update a single value in O(logN).",
            "     - get the folded value of values in a segment [l, r) in O(logN)",
            "    N is the length of the given iterable value.",
            "    Parameters",
            "    ----------",
            "    iterable : Iterable[_T]",
            "        An iterable value which will be converted into a segment tree",
            "    func : Callable[[_T, _T], _T]",
            "        A binary function which returns the same type as given two.",
            "        This has to satisfy the associative law:",
            "            func(a, func(b, c)) = func(func(a, b), c)",
            "    e : _T",
            "        The identity element of the given func.",
            "        In other words, this satisfies:",
            "            func(x, e) = func(e, x) = x",
            "    \"\"\"",
            "    def __init__(self, iterable, func, e):",
            "        self.func = func",
            "        self.e = e",
            "        ls = list(iterable)",
            "        self.n = 1 << len(ls).bit_length()",
            "        ls.extend( [self.e] * (self.n - len(ls)) )",
            "        self.data = [self.e] * self.n + ls",
            "        for i in range(self.n-1, 0, -1):",
            "            self.data[i] = self.func(self.data[2*i], self.data[2*i+1])",
            "    def replace(self, index, value):",
            "        \"\"\"replace the old value of the given index with the given new value.",
            "        This replaces the old value of the given index with the given new value in O(logN).",
            "        This is like \"list[index] = value\".",
            "        Parameters",
            "        ----------",
            "        index : int",
            "            The index of the value which will be replaced.",
            "        value : _T",
            "            The new value with which the old value will be replaced.",
            "        \"\"\"",
            "        index += self.n",
            "        self.data[index] = value",
            "        index //= 2",
            "        while index > 0:",
            "            self.data[index] = self.func(self.data[2*index], self.data[2*index+1])",
            "            index //= 2",
            "    def folded(self, l, r):",
            "        \"\"\"get the folded value of values in a segment [l, r).",
            "        This get the folded value of values in a segment [l, r) in O(logN).",
            "        If func is add, it returns the sum of values in [l, r).",
            "        In other words, this is eqivalent to \"sum(list[l:r])\".",
            "        If func is other functions, then this is equivalent to \"accumulate(list[l:r], func)\".",
            "        Parameters",
            "        ----------",
            "        l : int",
            "            The left edge.",
            "        r : int",
            "            The right edge.",
            "        Returns",
            "        -------",
            "        _T(the same type as the type of the element of the given iterable)",
            "            This is equivalent to func(list[l], func(list[l+1], ... ) ).",
            "            If func is represented as '*', then it's:",
            "            list[l] * list[l+1] * ... * list[r-1]",
            "        \"\"\"",
            "        left_folded = self.e",
            "        right_folded = self.e",
            "        l += self.n",
            "        r += self.n",
            "        while l < r:",
            "            if l % 2:",
            "                left_folded = self.func(left_folded, self.data[l])",
            "                l += 1",
            "            if r % 2:",
            "                r -= 1",
            "                right_folded = self.func(self.data[r], right_folded)",
            "            l //= 2",
            "            r //= 2",
            "        return self.func(left_folded, right_folded)",
            "from operator import or_",
            "N = int(input())",
            "S = input()",
            "ls = [1 << (ord(c) - ord('a')) for c in S]",
            "segtree = SegmentTree(ls, or_, 0)",
            "Q = int(input())",
            "for _ in range(Q):",
            "    s = input()",
            "    if s[0] == '1':",
            "        i, c = s[2:].split()",
            "        segtree.replace(int(i)-1, 1 << (ord(c) - ord('a')))",
            "    else:",
            "        l, r = map(int, s[2:].split())",
            "        value = segtree.folded(l-1, r)",
            "        print(format(value, 'b').count('1'))"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            1,
            0,
            2,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            1,
            1,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "def input(): return sys.stdin.readline().rstrip()",
            "# ライブラリ参照https://atcoder.jp/contests/practice2/submissions/16580070",
            "class SegmentTree:",
            "    __slots__ = [\"func\", \"e\", \"original_size\", \"n\", \"data\"]",
            "    def __init__(self, length_or_list, func, e):",
            "        self.func = func",
            "        self.e = e",
            "        if isinstance(length_or_list, int):",
            "            self.original_size = length_or_list",
            "            self.n = 1 << ((length_or_list - 1).bit_length())",
            "            self.data = [self.e] * self.n",
            "        else:",
            "            self.original_size = len(length_or_list)",
            "            self.n = 1 << ((self.original_size - 1).bit_length())",
            "            self.data = [self.e] * self.n + length_or_list + \\",
            "                [self.e] * (self.n - self.original_size)",
            "            for i in range(self.n-1, 0, -1):",
            "                self.data[i] = self.func(self.data[2*i], self.data[2*i+1])",
            "    def replace(self, index, value):",
            "        index += self.n",
            "        self.data[index] = value",
            "        index //= 2",
            "        while index > 0:",
            "            self.data[index] = self.func(",
            "                self.data[2*index], self.data[2*index+1])",
            "            index //= 2",
            "    def folded(self, l, r):",
            "        left_folded = self.e",
            "        right_folded = self.e",
            "        l += self.n",
            "        r += self.n",
            "        while l < r:",
            "            if l % 2:",
            "                left_folded = self.func(left_folded, self.data[l])",
            "                l += 1",
            "            if r % 2:",
            "                r -= 1",
            "                right_folded = self.func(self.data[r], right_folded)",
            "            l //= 2",
            "            r //= 2",
            "        return self.func(left_folded, right_folded)",
            "    def all_folded(self):",
            "        return self.data[1]",
            "    def __getitem__(self, index):",
            "        return self.data[self.n + index]",
            "    def max_right(self, l, f):",
            "        # assert f(self.e)",
            "        if l >= self.original_size:",
            "            return self.original_size",
            "        l += self.n",
            "        left_folded = self.e",
            "        while True:",
            "            # l //= l & -l",
            "            while l % 2 == 0:",
            "                l //= 2",
            "            if not f(self.func(left_folded, self.data[l])):",
            "                while l < self.n:",
            "                    l *= 2",
            "                    if f(self.func(left_folded, self.data[l])):",
            "                        left_folded = self.func(left_folded, self.data[l])",
            "                        l += 1",
            "                return l - self.n",
            "            left_folded = self.func(left_folded, self.data[l])",
            "            l += 1",
            "            if l == l & -l:",
            "                break",
            "        return self.original_size",
            "    # 未verify",
            "    def min_left(self, r, f):",
            "        # assert f(self.e)",
            "        if r == 0:",
            "            return 0",
            "        r += self.n",
            "        right_folded = self.e",
            "        while True:",
            "            r //= r & -r",
            "            if not f(self.func(self.data[r], right_folded)):",
            "                while r < self.n:",
            "                    r = 2 * r + 1",
            "                    if f(self.func(self.data[r], right_folded)):",
            "                        right_folded = self.func(self.data[r], right_folded)",
            "                        r -= 1",
            "                return r + 1 - self.n",
            "            if r == r & -r:",
            "                break",
            "        return 0",
            "def orr(x, y):",
            "    return x | y",
            "def main():",
            "    N = int(input())",
            "    S = input()",
            "    S = list(map(lambda c: 2**(ord(c) - ord('a')), list(S)))",
            "    Q = int(input())",
            "    seg = SegmentTree(S, orr, 0)",
            "    for _ in range(Q):",
            "        num, x, y = input().split()",
            "        if num == '1':",
            "            seg.replace(int(x)-1, 2**(ord(y) - ord('a')))",
            "        else:",
            "            bits = seg.folded(int(x)-1, int(y))",
            "            print(sum(map(int, list(bin(bits))[2:])))",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "class BalancingTree:",
            "    def __init__(self, n):",
            "        self.N = n",
            "        self.root = self.node(1<<n, 1<<n)",
            "    def append(self, v):# v を追加（その時点で v はない前提）",
            "        v += 1",
            "        nd = self.root",
            "        while True:",
            "            if v == nd.value:",
            "                # v がすでに存在する場合に何か処理が必要ならここに書く",
            "                return 0",
            "            else:",
            "                mi, ma = min(v, nd.value), max(v, nd.value)",
            "                if mi < nd.pivot:",
            "                    nd.value = ma",
            "                    if nd.left:",
            "                        nd = nd.left",
            "                        v = mi",
            "                    else:",
            "                        p = nd.pivot",
            "                        nd.left = self.node(mi, p - (p&-p)//2)",
            "                        break",
            "                else:",
            "                    nd.value = mi",
            "                    if nd.right:",
            "                        nd = nd.right",
            "                        v = ma",
            "                    else:",
            "                        p = nd.pivot",
            "                        nd.right = self.node(ma, p + (p&-p)//2)",
            "                        break",
            "    def leftmost(self, nd):",
            "        if nd.left: return self.leftmost(nd.left)",
            "        return nd",
            "    def rightmost(self, nd):",
            "        if nd.right: return self.rightmost(nd.right)",
            "        return nd",
            "    def find_l(self, v): # vより真に小さいやつの中での最大値（なければ-1）",
            "        v += 1",
            "        nd = self.root",
            "        prev = 0",
            "        if nd.value < v: v = nd.value",
            "        while True:",
            "            if v <= nd.value:",
            "                if nd.left:",
            "                    nd = nd.left",
            "                else:",
            "                    return prev - 1",
            "            else:",
            "                prev = nd.value",
            "                if nd.right:",
            "                    nd = nd.right",
            "                else:",
            "                    return prev - 1",
            "    def find_r(self, v): # vより真に大きいやつの中での最小値（なければRoot）",
            "        v += 1",
            "        nd = self.root",
            "        prev = 0",
            "        while True:",
            "            if v < nd.value:",
            "                prev = nd.value",
            "                if nd.left:",
            "                    nd = nd.left",
            "                else:",
            "                    return prev - 1",
            "            else:",
            "                if nd.right:",
            "                    nd = nd.right",
            "                else:",
            "                    return prev - 1",
            "    @property",
            "    def max(self):",
            "        return self.find_l((1<<self.N)-1)",
            "    @property",
            "    def min(self):",
            "        return self.find_r(-1)",
            "    def delete(self, v, nd = None, prev = None): # 値がvのノードがあれば削除（なければ何もしない）",
            "        v += 1",
            "        if not nd: nd = self.root",
            "        if not prev: prev = nd",
            "        while v != nd.value:",
            "            prev = nd",
            "            if v <= nd.value:",
            "                if nd.left:",
            "                    nd = nd.left",
            "                else:",
            "                    return",
            "            else:",
            "                if nd.right:",
            "                    nd = nd.right",
            "                else:",
            "                    return",
            "        if (not nd.left) and (not nd.right):",
            "            if nd.value < prev.value:",
            "                prev.left = None",
            "            else:",
            "                prev.right = None",
            "        elif not nd.left:",
            "            if nd.value < prev.value:",
            "                prev.left = nd.right",
            "            else:",
            "                prev.right = nd.right",
            "        elif not nd.right:",
            "            if nd.value < prev.value:",
            "                prev.left = nd.left",
            "            else:",
            "                prev.right = nd.left",
            "        else:",
            "            nd.value = self.leftmost(nd.right).value",
            "            self.delete(nd.value - 1, nd.right, nd)",
            "    def __contains__(self, v: int) -> bool:",
            "        return self.find_r(v - 1) == v",
            "    class node:",
            "        def __init__(self, v, p):",
            "            self.value = v",
            "            self.pivot = p",
            "            self.left = None",
            "            self.right = None",
            "k = (500000+1).bit_length()",
            "dic = {}",
            "for i in range(97, 123):",
            "    dic[chr(i)] = BalancingTree(k)",
            "n = int(input())",
            "s = input()",
            "lst = []",
            "for i in range(n):",
            "    lst.append(s[i])",
            "    dic[s[i]].append(i)",
            "ans = []",
            "q = int(input())",
            "for _ in range(q):",
            "    que = input()",
            "    if que[0] == '1':",
            "        kind, i, c = que.split()",
            "        i = int(i) - 1",
            "        dic[lst[i]].delete(i)",
            "        dic[c].append(i)",
            "        lst[i] = c",
            "    else:",
            "        kind, l, r = map(int, que.split())",
            "        l -= 2; r -= 1",
            "        temp = 0",
            "        for key in dic.keys():",
            "            if dic[key].find_r(l) <= r:",
            "                temp += 1",
            "        ans.append(temp)",
            "for i in ans:",
            "    print(i)"
        ],
        "label": [
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            2,
            2,
            1,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "class SegmentTree():",
            "    def __init__(self,n,ide_ele,merge_func):",
            "        self.n=n",
            "        self.ide_ele=ide_ele",
            "        self.merge_func=merge_func",
            "        self.val=[0 for i in range(1<<n)]",
            "        self.merge=[0 for i in range(1<<n)]",
            "    def update(self,id,x):",
            "        stack=[]",
            "        pos=1<<(self.n-1)",
            "        while pos-1!=id:",
            "            stack.append(pos)",
            "            if pos-1>id:",
            "                pos-=((pos)&(-pos))//2",
            "            else:",
            "                pos+=((pos)&(-pos))//2",
            "        stack.append(pos)",
            "        self.val[pos-1]=x",
            "        for pos in stack[::-1]:",
            "            if pos%2:",
            "                self.merge[pos-1]=self.val[pos-1]",
            "            else:",
            "                gap=((pos)&(-pos))//2",
            "                r=pos+gap",
            "                l=pos-gap",
            "                self.merge[pos-1]=self.merge_func(self.val[pos-1],self.merge[r-1],self.merge[l-1])",
            "    def cnt(self,k):",
            "        lsb=(k)&(-k)",
            "        return (lsb<<1)-1",
            "    def lower_kth_merge(self,nd,k):",
            "        res=self.ide_ele",
            "        id=nd",
            "        if k==-1:",
            "            return res",
            "        while True:",
            "            if not id%2:",
            "                gap=((id)&(-id))//2",
            "                l=id-gap",
            "                r=id+gap",
            "                cnt=self.cnt(l)",
            "                if cnt<k:",
            "                    k-=cnt+1",
            "                    res=self.merge_func(res,self.val[id-1],self.merge[l-1])",
            "                    id=r",
            "                elif cnt==k:",
            "                    res=self.merge_func(res,self.val[id-1],self.merge[l-1])",
            "                    return res",
            "                else:",
            "                    id=l",
            "            else:",
            "                res=self.merge_func(res,self.val[id-1])",
            "                return res",
            "    def upper_kth_merge(self,nd,k):",
            "        res=self.ide_ele",
            "        id=nd",
            "        if k==-1:",
            "            return res",
            "        while True:",
            "            if not id%2:",
            "                gap=((id)&(-id))//2",
            "                l=id-gap",
            "                r=id+gap",
            "                cnt=self.cnt(r)",
            "                if cnt<k:",
            "                    k-=cnt+1",
            "                    res=self.merge_func(res,self.val[id-1],self.merge[r-1])",
            "                    id=l",
            "                elif cnt==k:",
            "                    res=self.merge_func(res,self.val[id-1],self.merge[r-1])",
            "                    return res",
            "                else:",
            "                    id=r",
            "            else:",
            "                res=self.merge_func(res,self.val[id-1])",
            "                return res",
            "    def query(self,l,r):",
            "        id=1<<(self.n-1)",
            "        while True:",
            "            if id-1<l:",
            "                id+=((id)&(-id))//2",
            "            elif id-1>r:",
            "                id-=((id)&(-id))//2",
            "            else:",
            "                res=self.val[id-1]",
            "                if id%2:",
            "                    return res",
            "                gap=((id)&(-id))//2",
            "                L,R=id-gap,id+gap",
            "                #print(l,r,id,L,R)",
            "                left=self.upper_kth_merge(L,id-1-l-1)",
            "                right=self.lower_kth_merge(R,r-id)",
            "                return self.merge_func(res,left,right)",
            "ide_ele=0",
            "def seg_func(*args):",
            "    res=ide_ele",
            "    for val in args:",
            "        res|=val",
            "    return res",
            "def popcount(x):",
            "    x = x - ((x >> 1) & 0x55555555)",
            "    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)",
            "    x = (x + (x >> 4)) & 0x0f0f0f0f",
            "    x = x + (x >> 8)",
            "    x = x + (x >> 16)",
            "    return x & 0x0000007f",
            "import sys",
            "input=sys.stdin.readline",
            "N=int(input())",
            "S=input().rstrip()",
            "test=SegmentTree(19,ide_ele,seg_func)",
            "for i in range(N):",
            "    val=ord(S[i])-97",
            "    test.update(i,1<<val)",
            "for _ in range(int(input())):",
            "    t,l,r=input().split()",
            "    t,l=int(t),int(l)",
            "    if t==1:",
            "        val=ord(r)-97",
            "        test.update(l-1,1<<val)",
            "    else:",
            "        r=int(r)",
            "        res=test.query(l-1,r-1)",
            "        print(popcount(res))"
        ],
        "label": [
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            1,
            1,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "input = sys.stdin.readline",
            "def I(): return int(input())",
            "def MI(): return map(int, input().split())",
            "def LI(): return list(map(int, input().split()))",
            "def main():",
            "    class Segtree:",
            "        def __init__(self, A, ide_ele, initialize = True, segf = max):",
            "            self.N = len(A)",
            "            self.N0 = 2**(self.N-1).bit_length()",
            "            self.ide_ele = ide_ele",
            "            self.segf = segf",
            "            if initialize:",
            "                self.data = [ide_ele]*self.N0 + A + [ide_ele]*(self.N0 - self.N)",
            "                for i in range(self.N0-1, 0, -1):",
            "                    self.data[i] = self.segf(self.data[2*i], self.data[2*i+1])",
            "            else:",
            "                self.data = [ide_ele]*(2*self.N0)",
            "        def update(self, k, x):",
            "            k += self.N0",
            "            self.data[k] = x",
            "            while k > 0 :",
            "                k = k >> 1",
            "                self.data[k] = self.segf(self.data[2*k], self.data[2*k+1])",
            "        def query(self, l, r):",
            "            L, R = l+self.N0, r+self.N0",
            "            s = self.ide_ele",
            "            t = self.ide_ele",
            "            while L < R:",
            "                if R & 1:",
            "                    R -= 1",
            "                    t = self.segf(self.data[R],t)",
            "                if L & 1:",
            "                    s = self.segf(s,self.data[L])",
            "                    L += 1",
            "                L >>= 1",
            "                R >>= 1",
            "            return self.segf(s,t)",
            "        # セグ木上で二分探索，[l,r)の範囲でcheck関数を満たす最小の値をとるところのindexを返す．",
            "        # reverse=Trueなら最大値かな",
            "        # ない時の返り値がNoneなことに注意",
            "        def binsearch(self, l, r, check, reverse = False):",
            "            L, R = l+self.N0, r+self.N0",
            "            SL, SR = [], []",
            "            while L < R:",
            "                if R & 1:",
            "                    R -= 1",
            "                    SR.append(R)",
            "                if L & 1:",
            "                    SL.append(L)",
            "                    L += 1",
            "                L >>= 1",
            "                R >>= 1",
            "            if reverse:",
            "                pre = self.ide_ele",
            "                for idx in (SR + SL[::-1]):",
            "                    if check(self.segf(self.data[idx], pre)):",
            "                        break",
            "                    else:",
            "                        pre = self.segf(self.data[idx], pre)",
            "                else:",
            "                    return None",
            "                while idx < self.N0:",
            "                    if check(self.segf(self.data[2*idx+1], pre)):",
            "                        idx = 2*idx + 1",
            "                    else:",
            "                        pre = self.segf(self.data[2*idx+1], pre)",
            "                        idx = 2*idx",
            "                return idx - self.N0",
            "            else:",
            "                pre = self.ide_ele",
            "                for idx in (SL + SR[::-1]):",
            "                    if not check(self.segf(pre, self.data[idx])):",
            "                        pre = self.segf(pre, self.data[idx])",
            "                    else:",
            "                        break",
            "                else:",
            "                    return None",
            "                while idx < self.N0:",
            "                    if check(self.segf(pre, self.data[2*idx])):",
            "                        idx = 2*idx",
            "                    else:",
            "                        pre = self.segf(pre, self.data[2*idx])",
            "                        idx = 2*idx + 1",
            "                return idx - self.N0",
            "    N=I()",
            "    S=input()",
            "    Q=I()",
            "    A=[]",
            "    for i in range(N):",
            "        ii=ord(S[i])",
            "        aaa=set([ii])",
            "        A.append(aaa)",
            "    seg=Segtree(A,set([]),segf=lambda a,b:a|b)",
            "    for _ in range(Q):",
            "        q=input().split()",
            "        if q[0]==\"1\":",
            "            i=int(q[1])-1",
            "            c=q[2]",
            "            seg.update(i,set([ord(c)]))",
            "        else:",
            "            l=int(q[1])",
            "            r=int(q[2])",
            "            ans=seg.query(l-1,r)",
            "            print(len(ans))",
            "main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "mod = 10 ** 9 + 7",
            "mod2 = 2**61+1",
            "from collections import deque",
            "import heapq",
            "from bisect import bisect_left, insort_left",
            "def iip(listed):",
            "    ret = [int(i) for i in input().split()]",
            "    if len(ret) == 1 and not listed:",
            "        return ret[0]",
            "    return ret",
            "def main():",
            "    r = solve()",
            "    #print(r)",
            "def solve():",
            "    K = iip(False)",
            "    S = input()",
            "    S = [ord(i) for i in S]",
            "    Q = iip(False)",
            "    posit = {}",
            "    for i in range(ord(\"a\"), ord(\"z\")+1):",
            "        posit[i] = []",
            "    query = []",
            "    for i in range(Q):",
            "        query.append(input().split())",
            "    for i, j in enumerate(S, 1):",
            "        posit[j].append(i)",
            "    result = []",
            "    for d in range(ord(\"a\"), ord(\"z\")+1):",
            "        #print(chr(d), posit[d])",
            "        pass",
            "    for q in query:",
            "        if q[0] == \"1\":",
            "            p = int(q[1])",
            "            before = S[p-1]",
            "            after = ord(q[2])",
            "            if before == after:",
            "                continue",
            "            S[p-1] = after",
            "            idx = bisect_left(posit[before], p)",
            "            posit[before].pop(idx)",
            "            insort_left(posit[after], p)",
            "        else:",
            "            l = int(q[1])",
            "            r = int(q[2])",
            "            ret = 0",
            "            for i in range(ord(\"a\"), ord(\"z\")+1):",
            "                ll = bisect_left(posit[i], l)",
            "                if not posit[i]:  # 文字が存在しなければcontinue",
            "                    #print(\"e2\")",
            "                    continue",
            "                if l > posit[i][-1]:  # lより小さい文字しかなければcontinue",
            "                    continue",
            "                if posit[i][ll] > r:  # l以上のpositionで一番小さいものがrより大きければcontinue",
            "                    #print(\"e3\")",
            "                    continue",
            "                    #print(chr(i))",
            "                ret += 1  # いずれのcontinue条件にも引っかからなければスコアを１増やす",
            "            result.append(ret)",
            "    #print(S)",
            "    #print(posit)",
            "    split_print_space(result)",
            "    return",
            "#####################################################ライブラリ集ここから",
            "def split_print_space(s):",
            "    print(\" \".join([str(i) for i in s]))",
            "def split_print_enter(s):",
            "    print(\"\\n\".join([str(i) for i in s]))",
            "def koenai_saidai_x_index(sorted_list, n):",
            "    l = 0",
            "    r = len(sorted_list)",
            "    if len(sorted_list) == 0:",
            "        return False",
            "    if sorted_list[0] > n:",
            "        return False",
            "    while r - l > 1:",
            "        x = (l + r) // 2",
            "        if sorted_list[x] == n:",
            "            return x",
            "        elif sorted_list[x] > n:",
            "            r = x",
            "        else:",
            "            l = x",
            "    return l",
            "def searchsorted(sorted_list, n, side):",
            "    if side not in [\"right\", \"left\"]:",
            "        raise Exception(\"sideはrightかleftで指定してください\")",
            "    l = 0",
            "    r = len(sorted_list)",
            "    if n > sorted_list[-1]:",
            "        # print(sorted_list)",
            "        return len(sorted_list)",
            "    if n < sorted_list[0]:",
            "        return 0",
            "    while r - l > 1:",
            "        x = (l + r) // 2",
            "        if sorted_list[x] > n:",
            "            r = x",
            "        elif sorted_list[x] < n:",
            "            l = x",
            "        else:",
            "            if side == \"left\":",
            "                r = x",
            "            elif side == \"right\":",
            "                l = x",
            "    if side == \"left\":",
            "        if sorted_list[l] == n:",
            "            return r - 1",
            "        else:",
            "            return r",
            "    if side == \"right\":",
            "        if sorted_list[l] == n:",
            "            return l + 1",
            "        else:",
            "            return l",
            "def soinsuu_bunkai(n):",
            "    ret = []",
            "    for i in range(2, int(n ** 0.5) + 1):",
            "        while n % i == 0:",
            "            n //= i",
            "            ret.append(i)",
            "        if i > n:",
            "            break",
            "    if n != 1:",
            "        ret.append(n)",
            "    return ret",
            "def conbination(n, r, mod, test=False):",
            "    if n <= 0:",
            "        return 0",
            "    if r == 0:",
            "        return 1",
            "    if r < 0:",
            "        return 0",
            "    if r == 1:",
            "        return n",
            "    ret = 1",
            "    for i in range(n - r + 1, n + 1):",
            "        ret *= i",
            "        ret = ret % mod",
            "    bunbo = 1",
            "    for i in range(1, r + 1):",
            "        bunbo *= i",
            "        bunbo = bunbo % mod",
            "    ret = (ret * inv(bunbo, mod)) % mod",
            "    if test:",
            "        # print(f\"{n}C{r} = {ret}\")",
            "        pass",
            "    return ret",
            "def inv(n, mod):",
            "    return power(n, mod - 2)",
            "def power(n, p, mod_= mod):",
            "    if p == 0:",
            "        return 1",
            "    if p % 2 == 0:",
            "        return (power(n, p // 2, mod_) ** 2) % mod_",
            "    if p % 2 == 1:",
            "        return (n * power(n, p - 1, mod_)) % mod_",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "from collections import deque",
            "class SegmentTree():",
            "    def __init__(self,n,ide_ele,merge_func,init_val):",
            "        self.n=n",
            "        self.ide_ele=ide_ele",
            "        self.merge_func=merge_func",
            "        self.val=[0 for i in range(1<<n)]",
            "        self.merge=[0 for i in range(1<<n)]",
            "        self.parent=[-1 for i in range(1<<n)]",
            "        deq=deque([1<<(n-1)])",
            "        res=[]",
            "        while deq:",
            "            v=deq.popleft()",
            "            res.append(v)",
            "            if not v&1:",
            "                gap=(v&-v)//2",
            "                self.parent[v-gap]=v",
            "                deq.append(v-gap)",
            "                self.parent[v+gap]=v",
            "                deq.append(v+gap)",
            "        for v in res[::-1]:",
            "            if v-1<len(init_val):",
            "                self.val[v-1]=init_val[v-1]",
            "            self.merge[v-1]=self.val[v-1]",
            "            if not v&1:",
            "                gap=(v&-v)//2",
            "                self.merge[v-1]=self.merge_func(self.merge[v-1],self.merge[v-gap-1],self.merge[v+gap-1])",
            "    def update(self,id,x):",
            "        self.val[id]=x",
            "        pos=id+1",
            "        while pos!=-1:",
            "            if pos&1:",
            "                self.merge[pos-1]=self.val[pos-1]",
            "            else:",
            "                gap=(pos&-pos)//2",
            "                self.merge[pos-1]=self.merge_func(self.val[pos-1],self.merge[pos+gap-1],self.merge[pos-gap-1])",
            "            pos=self.parent[pos]",
            "    def lower_kth_merge(self,nd,k):",
            "        if k==-1:",
            "            return self.ide_ele",
            "        mini=nd-(nd&-nd)+1+k",
            "        id=nd",
            "        stack=[]",
            "        while True:",
            "            gap=(id&-id)//2",
            "            if id>mini:",
            "                id-=gap",
            "            elif id==mini:",
            "                stack.append(self.val[id-1])",
            "                stack.append(self.merge[id-gap-1])",
            "                return self.merge_func(*stack)",
            "            else:",
            "                stack.append(self.val[id-1])",
            "                stack.append(self.merge[id-gap-1])",
            "                id+=gap",
            "    def upper_kth_merge(self,nd,k):",
            "        if k==-1:",
            "            return self.ide_ele",
            "        maxi=nd+(nd&-nd)-1-k",
            "        id=nd",
            "        stack=[]",
            "        while True:",
            "            gap=(id&-id)//2",
            "            if id>maxi:",
            "                stack.append(self.val[id-1])",
            "                stack.append(self.merge[id+gap-1])",
            "                id-=gap",
            "            elif id==maxi:",
            "                stack.append(self.val[id-1])",
            "                stack.append(self.merge[id+gap-1])",
            "                return self.merge_func(*stack)",
            "            else:",
            "                id+=gap",
            "    def query(self,l,r):",
            "        id=1<<(self.n-1)",
            "        while True:",
            "            if id-1<l:",
            "                id+=((id)&(-id))//2",
            "            elif id-1>r:",
            "                id-=((id)&(-id))//2",
            "            else:",
            "                res=self.val[id-1]",
            "                if id%2:",
            "                    return res",
            "                gap=((id)&(-id))//2",
            "                L,R=id-gap,id+gap",
            "                #print(l,r,id,L,R)",
            "                left=self.upper_kth_merge(L,id-1-l-1)",
            "                right=self.lower_kth_merge(R,r-id)",
            "                return self.merge_func(res,left,right)",
            "ide_ele=0",
            "def seg_func(*args):",
            "    res=ide_ele",
            "    for val in args:",
            "        res|=val",
            "    return res",
            "def popcount(x):",
            "    x = x - ((x >> 1) & 0x55555555)",
            "    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)",
            "    x = (x + (x >> 4)) & 0x0f0f0f0f",
            "    x = x + (x >> 8)",
            "    x = x + (x >> 16)",
            "    return x & 0x0000007f",
            "import sys",
            "input=sys.stdin.readline",
            "N=int(input())",
            "S=input().rstrip()",
            "init_val=[1<<(ord(S[i])-97) for i in range(N)]",
            "test=SegmentTree(N.bit_length(),ide_ele,seg_func,init_val)",
            "for _ in range(int(input())):",
            "    t,l,r=input().split()",
            "    t,l=int(t),int(l)",
            "    if t==1:",
            "        val=ord(r)-97",
            "        test.update(l-1,1<<val)",
            "    else:",
            "        r=int(r)",
            "        res=test.query(l-1,r-1)",
            "        print(popcount(res))"
        ],
        "label": [
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            1,
            1,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product                # product(iter, repeat=n)",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4",
            "def main():",
            "    mod = 1000000007                  # 10^9+7",
            "    inf = float('inf')",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():  return int(input())",
            "    def mi():  return map(int, input().split())",
            "    def mi_0(): return map(lambda x: int(x)-1, input().split())",
            "    def lmi(): return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():  return list(input())",
            "    # 各クエリでの O(|alphabet|) が重いため TLE",
            "    # a...z までの出現フラグを bit field で管理することを考える。そうすればある区間での出現文字を管理する数字たちを合わせる際には OR をとるだけて O(1) で高速に処理できる",
            "    class SegTree:",
            "        def __init__(self, size):",
            "            self.size = size",
            "            self.n0 = 2 ** (size - 1).bit_length()",
            "            self.table = [0 for _ in range(2 * self.n0)]",
            "        def update(self, k, new_char):",
            "            'update char in a_k to new_char'",
            "            table_k = k + self.n0 - 1",
            "            new_num = 1 << (ord(new_char) - ord('a'))",
            "            if self.table[table_k] != new_num:",
            "                self.table[table_k] = new_num",
            "                while table_k // 2 > 0:",
            "                    table_k //= 2",
            "                    self.table[table_k] = self.table[2 * table_k] | self.table[2 * table_k + 1]",
            "        def range_set(self, l, r):",
            "            'return integer that represents character set appeared in a_l to a_r'",
            "            bit_field = 0",
            "            table_l = l + self.n0 - 1",
            "            table_r = r + self.n0 - 1",
            "            if table_l > table_r:",
            "                raise RuntimeError(\"l should be less than or equals to r. got l:{} and r:{}\".format(l, r))",
            "            while table_l < table_r:",
            "                if table_l & 0b1 == 1:",
            "                    bit_field |= self.table[table_l]",
            "                if table_r & 0b1 == 0:",
            "                    bit_field |= self.table[table_r]",
            "                table_l = (table_l + 1)  // 2",
            "                table_r = (table_r - 1) // 2",
            "            if table_l == table_r:",
            "                bit_field |= self.table[table_l]",
            "            return bit_field",
            "    def execute_query(seg_tree, L, buf):",
            "        id = int(L[0])",
            "        if id == 1:",
            "            i = int(L[1])",
            "            char = L[2]",
            "            seg_tree.update(i, char)",
            "        else:",
            "            i, j = map(int, L[1:])",
            "            bit_field = seg_tree.range_set(i, j)",
            "            buf.append(bin(bit_field)[2:].count('1'))",
            "    n = ii()",
            "    s = input()",
            "    q = ii()",
            "    commands = []",
            "    for _ in range(q):",
            "        commands.append(input().split())",
            "    st = SegTree(n)",
            "    for i, char in enumerate(s):",
            "        st.update(i+1, char)",
            "    buf = []",
            "    for query in commands:",
            "        execute_query(st, query, buf)",
            "    for elm in buf:",
            "        print(elm)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "sys.setrecursionlimit(10**6) #再帰関数の上限",
            "import math",
            "from copy import copy, deepcopy",
            "from operator import itemgetter",
            "from bisect import bisect_left, bisect, bisect_right#2分探索",
            "#bisect_left(l,x), bisect(l,x)#aはソート済みである必要あり。aの中からx未満の要素数を返す。rightだと以下",
            "from collections import deque",
            "#deque(l), pop(), append(x), popleft(), appendleft(x)",
            "##listでqueの代用をするとO(N)の計算量がかかってしまうので注意",
            "from collections import Counter#文字列を個数カウント辞書に、",
            "#S=Counter(l),S.most_common(x),S.keys(),S.values(),S.items()",
            "from itertools import accumulate#累積和",
            "#list(accumulate(l))",
            "from heapq import heapify,heappop,heappush",
            "#heapify(q),heappush(q,a),heappop(q) #q=heapify(q)としないこと、返り値はNone",
            "#import fractions#古いatcoderコンテストの場合GCDなどはここからimportする",
            "def input(): return sys.stdin.readline()[:-1]",
            "def printl(li): print(*li, sep=\"\\n\")",
            "def argsort(s, return_sorted=False):",
            "    inds=sorted(range(len(s)), key=lambda k: s[k])",
            "    if return_sorted: return inds, [s[i] for i in inds]",
            "    return inds",
            "class segtree():#seg=segtree(A),単位元とsegfuncを指定すること",
            "    def __init__(self,A,ide=0):#単位元とsegfuncを指定すること",
            "        n=len(A)",
            "        num=2**(n-1).bit_length()#n以上の最小の2のべき乗",
            "        seg=[ide]*(2*num-1)",
            "        segfunc=self.segfunc",
            "        self.ide,self.n,self.num,self.seg = ide, n, num, seg",
            "        for i in range(n): seg[i+num-1]=A[i]#setvalue",
            "        for i in range(num-2,-1,-1):seg[i]=segfunc(seg[2*i+1],seg[2*i+2])#build",
            "    def segfunc(self,x,y):return x|y #seg木の基本関数",
            "    def update(self,k,x):#Aのk番目の要素をxに置き換える,計算量log(N)",
            "        k += self.num-1",
            "        seg,segfunc=self.seg,self.segfunc",
            "        seg[k] = x",
            "        while k:",
            "            k = (k-1)//2",
            "            seg[k] = segfunc(seg[k*2+1],seg[k*2+2])",
            "    def query(self,p,q):#区間[p,q)の累積segfuncを求める,計算量log(N)",
            "        if q<=p: return self.ide",
            "        num,segfunc,seg=self.num,self.segfunc,self.seg",
            "        p += num-1; q += num-2",
            "        res=self.ide",
            "        while q-p>1:",
            "            if p&1 == 0: res = segfunc(res,seg[p])",
            "            if q&1 == 1:",
            "                res = segfunc(res,seg[q])",
            "                q -= 1",
            "            p,q = p//2, (q-1)//2",
            "        if p == q: res = segfunc(res,seg[p])",
            "        else: res = segfunc(segfunc(res,seg[p]),seg[q])",
            "        return res",
            "def main():",
            "    mod = 10**9+7",
            "    alpha2num = lambda c: 2**(ord(c) - ord('a'))",
            "    #w.sort(key=itemgetter(1),reversed=True)  #二個目の要素で降順並び替え",
            "    N = int(input())",
            "    S=input()",
            "    #N, K = map(int, input().split())",
            "    #A = tuple(map(int, input().split())) #1行ベクトル",
            "    #L = tuple(int(input()) for i in range(N)) #改行ベクトル",
            "    #S = tuple(tuple(map(int, input().split())) for i in range(N)) #改行行列",
            "    A=list(map(alpha2num, list(S)))",
            "    #print(A)",
            "    #exit()",
            "    seg=segtree(A)",
            "    #print(A)",
            "    Q=int(input())",
            "    for i in range(Q):",
            "        t, a,b =input().split()",
            "        if t=='1':",
            "            a=int(a)",
            "            seg.update(a-1,alpha2num(b))",
            "        else:",
            "            a,b=int(a),int(b)",
            "            x=seg.query(a-1,b)",
            "            count=0",
            "            for i in range(26):",
            "                count+= (x>>i & 1)",
            "            print(count)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# -*- coding: utf-8 -*-",
            "import sys",
            "import math",
            "import os",
            "import itertools",
            "import string",
            "import heapq",
            "import _collections",
            "from collections import Counter",
            "from collections import defaultdict",
            "from collections import deque",
            "from functools import lru_cache",
            "import bisect",
            "import re",
            "import queue",
            "import decimal",
            "class Scanner():",
            "    @staticmethod",
            "    def int():",
            "        return int(sys.stdin.readline().rstrip())",
            "    @staticmethod",
            "    def string():",
            "        return sys.stdin.readline().rstrip()",
            "    @staticmethod",
            "    def map_int():",
            "        return [int(x) for x in Scanner.string().split()]",
            "    @staticmethod",
            "    def string_list(n):",
            "        return [Scanner.string() for i in range(n)]",
            "    @staticmethod",
            "    def int_list_list(n):",
            "        return [Scanner.map_int() for i in range(n)]",
            "    @staticmethod",
            "    def int_cols_list(n):",
            "        return [Scanner.int() for i in range(n)]",
            "class Math():",
            "    @staticmethod",
            "    def gcd(a, b):",
            "        if b == 0:",
            "            return a",
            "        return Math.gcd(b, a % b)",
            "    @staticmethod",
            "    def lcm(a, b):",
            "        return (a * b) // Math.gcd(a, b)",
            "    @staticmethod",
            "    def divisor(n):",
            "        res = []",
            "        i = 1",
            "        for i in range(1, int(n ** 0.5) + 1):",
            "            if n % i == 0:",
            "                res.append(i)",
            "                if i != n // i:",
            "                    res.append(n // i)",
            "        return res",
            "    @staticmethod",
            "    def round_up(a, b):",
            "        return -(-a // b)",
            "    @staticmethod",
            "    def is_prime(n):",
            "        if n < 2:",
            "            return False",
            "        if n == 2:",
            "            return True",
            "        if n % 2 == 0:",
            "            return False",
            "        d = int(n ** 0.5) + 1",
            "        for i in range(3, d + 1, 2):",
            "            if n % i == 0:",
            "                return False",
            "        return True",
            "    @staticmethod",
            "    def fact(N):",
            "        res = {}",
            "        tmp = N",
            "        for i in range(2, int(N ** 0.5 + 1) + 1):",
            "            cnt = 0",
            "            while tmp % i == 0:",
            "                cnt += 1",
            "                tmp //= i",
            "            if cnt > 0:",
            "                res[i] = cnt",
            "        if tmp != 1:",
            "            res[tmp] = 1",
            "        if res == {}:",
            "            res[N] = 1",
            "        return res",
            "def pop_count(x):",
            "    x = x - ((x >> 1) & 0x5555555555555555)",
            "    x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)",
            "    x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f",
            "    x = x + (x >> 8)",
            "    x = x + (x >> 16)",
            "    x = x + (x >> 32)",
            "    return x & 0x0000007f",
            "MOD = int(1e09) + 7",
            "INF = int(1e15)",
            "def modinv(a):",
            "    b = MOD",
            "    u = 1",
            "    v = 0",
            "    while b:",
            "        t = a // b",
            "        a -= t * b",
            "        a, b = b, a",
            "        u -= t * v",
            "        u, v = v, u",
            "    u %= MOD",
            "    if u < 0:",
            "        u += MOD",
            "    return u",
            "def modpow(a, n):",
            "    res = 1",
            "    while n > 0:",
            "        if n & 1:",
            "            res = res * a % MOD",
            "        a = a * a % MOD",
            "        n >>= 1",
            "    return res",
            "def solve():",
            "    N, A, B = Scanner.map_int()",
            "    ans = modpow(2, N) - 1",
            "    c = 1",
            "    for i in range(1, A + 1):",
            "        c *= N - i + 1",
            "        c %= MOD",
            "        c *= modinv(i) % MOD",
            "    ans -= c",
            "    c = 1",
            "    for i in range(1, B + 1):",
            "        c *= N - i + 1",
            "        c %= MOD",
            "        c *= modinv(i) % MOD",
            "    ans -= c",
            "    ans += MOD",
            "    ans %= MOD",
            "    print(ans)",
            "def main():",
            "    # sys.stdin = open(\"sample.txt\")",
            "    # T = Scanner.int()",
            "    # for _ in range(T):",
            "    #     solve()",
            "    # print('YNeos'[not solve()::2])",
            "    solve()",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "from functools import reduce",
            "from operator import mul",
            "from typing import Callable, ClassVar, Sequence, Type, TypeVar",
            "T = TypeVar('T', bound='ModIntBase')",
            "class ModIntBase:",
            "    value: int",
            "    mod: ClassVar[int]",
            "    fac: ClassVar[Sequence[int]] = ()",
            "    inv: ClassVar[Sequence[int]] = ()",
            "    finv: ClassVar[Sequence[int]] = ()",
            "    def __init__(self, value: int) -> None:",
            "        self.value = value % self.mod",
            "    def __hash__(self) -> int:",
            "        return hash((self.value, self.mod))",
            "    def __eq__(self, other) -> bool:",
            "        if isinstance(other, self.__class__):",
            "            return self.value == other.value",
            "        else:",
            "            return NotImplemented",
            "    def __ne__(self, other) -> bool:",
            "        if isinstance(other, self.__class__):",
            "            return self.value != other.value",
            "        else:",
            "            return NotImplemented",
            "    # TODO: Add type hints",
            "    def __add__(self, other):",
            "        if isinstance(other, self.__class__):",
            "            return self.__class__((self.value + other.value) % self.mod)",
            "        else:",
            "            return NotImplemented",
            "    def __sub__(self, other):",
            "        if isinstance(other, self.__class__):",
            "            return self.__class__((self.value - other.value) % self.mod)",
            "        else:",
            "            return NotImplemented",
            "    def __mul__(self, other):",
            "        if isinstance(other, self.__class__):",
            "            return self.__class__(self.value * other.value % self.mod)",
            "        else:",
            "            return NotImplemented",
            "    def __truediv__(self, other):",
            "        if isinstance(other, self.__class__):",
            "            a = other.value",
            "            b = self.mod",
            "            u = 1",
            "            v = 0",
            "            while b:",
            "                t = a // b",
            "                a, b = b, a - t * b",
            "                u, v = v, u - t * v",
            "            return self.__class__(self.value * u % self.mod)",
            "        else:",
            "            return NotImplemented",
            "    def __pow__(self, other):",
            "        if isinstance(other, self.__class__):",
            "            v = 1",
            "            a = self.value",
            "            b = other.value",
            "            mod = self.mod",
            "            while b > 0:",
            "                if b & 1:",
            "                    v = v * a % mod",
            "                a = a * a % mod",
            "                b >>= 1",
            "            return self.__class__(v)",
            "        else:",
            "            return NotImplemented",
            "    @classmethod",
            "    def comb(cls, n: int, k: int):",
            "        if n < k:",
            "            return cls(0)",
            "        if n < 0 or k < 0:",
            "            return cls(0)",
            "        if n < len(cls.fac):",
            "            return cls(cls.fac[n] * (cls.finv[k] * cls.finv[n - k] % cls.mod) % cls.mod)",
            "        else:",
            "            k = min(k, n - k)",
            "            a = reduce(mul, map(cls, range(n - k + 1, n + 1)), cls(1))",
            "            b = reduce(mul, map(cls, range(1, k + 1)), cls(1))",
            "            return a / b",
            "    def __repr__(self) -> str:",
            "        return f'{self.__class__.__name__}({self.value!r})'",
            "    def __str__(self) -> str:",
            "        return str(self.value)",
            "class ModInt(ModIntBase):",
            "    mod = 1000000007  # 10 ** 9 + 7",
            "def resolve(in_):",
            "    N, A, B = map(int, in_.readline().split())",
            "    c = ModInt(2) ** ModInt(N) - ModInt(1)",
            "    a = ModInt.comb(N, A)",
            "    b = ModInt.comb(N, B)",
            "    return c - a - b",
            "def main():",
            "    answer = resolve(sys.stdin.buffer)",
            "    print(answer)",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "MOD = 1000000007  # type: int",
            "class Factorial:",
            "    def __init__(self,MOD):",
            "        self.MOD = MOD",
            "        self.factorials = [1,1] # 階乗を求めるためのキャッシュ",
            "        self.invModulos = [0,1] # n^-1のキャッシュ",
            "        self.invFactorial_ = [1,1] # (n^-1)!のキャッシュ",
            "    def calc(self,n):",
            "        if n <= -1:",
            "            print(\"Invalid argument to calculate n!\")",
            "            print(\"n must be non-negative value. But the argument was \" + str(n))",
            "            exit()",
            "        if n < len(self.factorials):",
            "            return self.factorials[n]",
            "        nextArr = [0]*(n+1-len(self.factorials))",
            "        initialI = len(self.factorials)",
            "        prev = self.factorials[-1]",
            "        m = self.MOD",
            "        for i in range(initialI,n+1):",
            "            prev = nextArr[i-initialI] = prev * i%m",
            "        self.factorials += nextArr",
            "        return self.factorials[n]",
            "    def inv(self,n):",
            "        if n <= -1:",
            "            print(\"Invalid argument to calculate n^(-1)\")",
            "            print(\"n must be non-negative value. But the argument was \" + str(n))",
            "            exit()",
            "        p = self.MOD",
            "        pi = n%p",
            "        if pi < len(self.invModulos):",
            "            return self.invModulos[pi]",
            "        nextArr = [0]*(n+1-len(self.invModulos))",
            "        initialI = len(self.invModulos)",
            "        for i in range(initialI,min(p,n+1)):",
            "            next = -self.invModulos[p%i]*(p//i)%p",
            "            self.invModulos.append(next)",
            "        return self.invModulos[pi]",
            "    def invFactorial(self,n):",
            "        if n <= -1:",
            "            print(\"Invalid argument to calculate (n^(-1))!\")",
            "            print(\"n must be non-negative value. But the argument was \" + str(n))",
            "            exit()",
            "        if n < len(self.invFactorial_):",
            "            return self.invFactorial_[n]",
            "        self.inv(n) # To make sure already calculated n^-1",
            "        nextArr = [0]*(n+1-len(self.invFactorial_))",
            "        initialI = len(self.invFactorial_)",
            "        prev = self.invFactorial_[-1]",
            "        p = self.MOD",
            "        for i in range(initialI,n+1):",
            "            prev = nextArr[i-initialI] = (prev * self.invModulos[i%p])%p",
            "        self.invFactorial_ += nextArr",
            "        return self.invFactorial_[n]",
            "class Combination:",
            "    def __init__(self,MOD):",
            "        self.MOD = MOD",
            "        self.factorial = Factorial(MOD)",
            "    def choose_k_from_n(self,n,k):",
            "        if k < 0 or n < k:",
            "            return 0",
            "        k = min(k,n-k)",
            "        f = self.factorial",
            "        return f.calc(n)*f.invFactorial(max(n-k,k))*f.invFactorial(min(k,n-k))%self.MOD",
            "def solve(n: int, k: int):",
            "    c = Combination(MOD)",
            "    sum = 0",
            "    for i in range(min(n,k+1)-1,-1,-1):",
            "        c1 = c.choose_k_from_n(n,i)",
            "        c2 = c.choose_k_from_n(n-1,i)",
            "        sum = (sum + c1*c2)%MOD",
            "    print(sum)",
            "    return",
            "# Generated by 1.1.6 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)",
            "def main():",
            "    def iterate_tokens():",
            "        for line in sys.stdin:",
            "            for word in line.split():",
            "                yield word",
            "    tokens = iterate_tokens()",
            "    n = int(next(tokens))  # type: int",
            "    k = int(next(tokens))  # type: int",
            "    solve(n, k)",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "class Combination:",
            "    def __init__(self, n_max, mod=10**9+7):",
            "        # O(n_max + log(mod))",
            "        self.mod = mod",
            "        f = 1",
            "        self.fac = fac = [f]",
            "        for i in range(1, n_max+1):",
            "            f = f * i % mod",
            "            fac.append(f)",
            "        f = pow(f, mod-2, mod)",
            "        self.facinv = facinv = [f]",
            "        for i in range(n_max, 0, -1):",
            "            f = f * i % mod",
            "            facinv.append(f)",
            "        facinv.reverse()",
            "    # \"n 要素\" は区別できる n 要素",
            "    # \"k グループ\" はちょうど k グループ",
            "    def __call__(self, n, r):  # self.C と同じ",
            "        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod",
            "    def C(self, n, r):",
            "        if not 0 <= r <= n: return 0",
            "        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod",
            "    def P(self, n, r):",
            "        if not 0 <= r <= n: return 0",
            "        return self.fac[n] * self.facinv[n-r] % self.mod",
            "    def H(self, n, r):",
            "        if (n == 0 and r > 0) or r < 0: return 0",
            "        return self.fac[n+r-1] * self.facinv[r] % self.mod * self.facinv[n-1] % self.mod",
            "    def rising_factorial(self, n, r):  # 上昇階乗冪 n * (n+1) * ... * (n+r-1)",
            "        return self.fac[n+r-1] * self.facinv[n-1] % self.mod",
            "    def stirling_first(self, n, k):  # 第 1 種スターリング数  lru_cache を使うと O(nk)  # n 要素を k 個の巡回列に分割する場合の数",
            "        if n == k: return 1",
            "        if k == 0: return 0",
            "        return (self.stirling_first(n-1, k-1) + (n-1)*self.stirling_first(n-1, k)) % self.mod",
            "    def stirling_second(self, n, k):  # 第 2 種スターリング数 O(k + log(n))  # n 要素を区別のない k グループに分割する場合の数",
            "        if n == k: return 1  # n==k==0 のときのため",
            "        return self.facinv[k] * sum((-1)**(k-m) * self.C(k, m) * pow(m, n, self.mod) for m in range(1, k+1)) % self.mod",
            "    def balls_and_boxes_3(self, n, k):  # n 要素を区別のある k グループに分割する場合の数  O(k + log(n))",
            "        return sum((-1)**(k-m) * self.C(k, m) * pow(m, n, self.mod) for m in range(1, k+1)) % self.mod",
            "    def bernoulli(self, n):  # ベルヌーイ数  lru_cache を使うと O(n**2 * log(mod))",
            "        if n == 0: return 1",
            "        if n % 2 and n >= 3: return 0  # 高速化",
            "        return (- pow(n+1, self.mod-2, self.mod) * sum(self.C(n+1, k) * self.bernoulli(k) % self.mod for k in range(n))) % self.mod",
            "    def faulhaber(self, k, n):  # べき乗和 0^k + 1^k + ... + (n-1)^k",
            "        # bernoulli に lru_cache を使うと O(k**2 * log(mod))  bernoulli が計算済みなら O(k * log(mod))",
            "        return pow(k+1, self.mod-2, self.mod) * sum(self.C(k+1, j) * self.bernoulli(j) % self.mod * pow(n, k-j+1, self.mod) % self.mod for j in range(k+1)) % self.mod",
            "    def lah(self, n, k):  # n 要素を k 個の空でない順序付き集合に分割する場合の数  O(1)",
            "        return self.C(n-1, k-1) * self.fac[n] % self.mod * self.facinv[k] % self.mod",
            "    def bell(self, n, k):  # n 要素を k グループ以下に分割する場合の数  O(k**2 + k*log(mod))",
            "        return sum(self.stirling_second(n, j) for j in range(1, k+1)) % self.mod",
            "def main():",
            "    N, K = map(int, input().split())",
            "    mod = 10**9+7",
            "    sign = 1",
            "    L = []",
            "    comb = Combination(202020)",
            "    ans = 0",
            "    for n_zeroes in range(min(K+1, N)):",
            "        a = comb.C(N, n_zeroes) * comb.H(N-n_zeroes, n_zeroes) % mod",
            "        ans += a",
            "    print(ans % mod)",
            "main()"
        ],
        "label": [
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, k = mi()",
            "    factorial = [1] * (n + 1)",
            "    for i in range(1, n + 1):",
            "        factorial[i] = (factorial[i - 1] * i) % mod",
            "    # print(factorial)",
            "    def combination(n, r, mod):",
            "        # a^(p-1) = 1",
            "        # a^(p-2) = 1/a",
            "        numerator = factorial[n]",
            "        denominator = (factorial[r] * factorial[n - r]) % mod",
            "        return (numerator * pow(denominator, mod - 2, mod)) % mod",
            "    ans = 0",
            "    for empty_room_num in range(min(n - 1, k) + 1):",
            "        ans = (ans + combination(n, empty_room_num, mod) * combination(n - 1, empty_room_num, mod)) % mod",
            "        # print(f\"{empty_room_num} {ans}\")",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# abc155_c.py",
            "# https://atcoder.jp/contests/abc155/tasks/abc155_c",
            "# C - Poll /",
            "# 実行時間制限: 2 sec / メモリ制限: 1024 MB",
            "# 配点: 300点",
            "# 問題文",
            "# N枚の投票用紙があり、i (1≤i≤N) 枚目には文字列 Siが書かれています。",
            "# 書かれた回数が最も多い文字列を全て、辞書順で小さい順に出力してください。",
            "# 制約",
            "#     1≤N≤2×105",
            "#     Siは英小文字のみからなる文字列 (1≤i≤N)",
            "#     Siの長さは 1 以上 10 以下 (1≤i≤N)",
            "# 入力",
            "# 入力は以下の形式で標準入力から与えられる。",
            "# N",
            "# S1",
            "# :",
            "# SN",
            "# 出力",
            "# あてはまる文字列を全て辞書順で小さい順に、改行区切りで出力せよ。",
            "# 入力例 1",
            "# 7",
            "# beat",
            "# vet",
            "# beet",
            "# bed",
            "# vet",
            "# bet",
            "# beet",
            "# 出力例 1",
            "# beet",
            "# vet",
            "# 書かれた回数は beet と vet が 2回、beat と bed と bet が 1 回です。したがって、2回書かれた beet と vet を出力します。",
            "# 入力例 2",
            "# 8",
            "# buffalo",
            "# buffalo",
            "# buffalo",
            "# buffalo",
            "# buffalo",
            "# buffalo",
            "# buffalo",
            "# buffalo",
            "# 出力例 2",
            "# buffalo",
            "# 入力例 3",
            "# 7",
            "# bass",
            "# bass",
            "# kick",
            "# kick",
            "# bass",
            "# kick",
            "# kick",
            "# 出力例 3",
            "# kick",
            "# 入力例 4",
            "# 4",
            "# ushi",
            "# tapu",
            "# nichia",
            "# kun",
            "# 出力例 4",
            "# kun",
            "# nichia",
            "# tapu",
            "# ushi",
            "global FLAG_LOG",
            "FLAG_LOG = False",
            "def log(value):",
            "    # FLAG_LOG = True",
            "    # FLAG_LOG = False",
            "    if FLAG_LOG:",
            "        print(str(value))",
            "def calculation(lines):",
            "    # S = lines[0]",
            "    N = int(lines[0])",
            "    # N, M = list(map(int, lines[0].split()))",
            "    # values = list(map(int, lines[1].split()))",
            "    # values = list(map(int, lines[2].split()))",
            "    values = list()",
            "    for i in range(N):",
            "        values.append(lines[i+1])",
            "    # valueses = list()",
            "    # for i in range(N):",
            "    #     valueses.append(list(map(int, lines[i+1].split())))",
            "    dic = dict()",
            "    for value in values:",
            "        if value in dic:",
            "            dic[value] += 1",
            "        else:",
            "            dic[value] = 1",
            "    tmp = list()",
            "    for key in dic:",
            "        tmp.append(dic[key])",
            "    ma = max(tmp)",
            "    results = list()",
            "    for key in dic:",
            "        if dic[key] == ma:",
            "            results.append(key)",
            "    results.sort()",
            "    return results",
            "# 引数を取得",
            "def get_input_lines():",
            "    line = input()",
            "    N = int(line)",
            "    lines = list()",
            "    lines.append(line)",
            "    for _ in range(N):",
            "        lines.append(input())",
            "    return lines",
            "# テストデータ",
            "def get_testdata(pattern):",
            "    if pattern == 1:",
            "        lines_input = ['7', 'beat', 'vet', 'beet', 'bed', 'vet', 'bet', 'beet']",
            "        lines_export = ['beet', 'vet']",
            "    if pattern == 2:",
            "        lines_input = ['8', 'buffalo', 'buffalo', 'buffalo', 'buffalo', 'buffalo', 'buffalo', 'buffalo', 'buffalo']",
            "        lines_export = ['buffalo']",
            "    if pattern == 3:",
            "        lines_input = ['7', 'bass', 'bass', 'kick', 'kick', 'bass', 'kick', 'kick']",
            "        lines_export = ['kick']",
            "    if pattern == 4:",
            "        lines_input = ['4', 'ushi', 'tapu', 'nichia', 'kun']",
            "        lines_export = ['kun', 'nichia', 'tapu', 'ushi']",
            "    return lines_input, lines_export",
            "# 動作モード判別",
            "def get_mode():",
            "    import sys",
            "    args = sys.argv",
            "    global FLAG_LOG",
            "    if len(args) == 1:",
            "        mode = 0",
            "        FLAG_LOG = False",
            "    else:",
            "        mode = int(args[1])",
            "        FLAG_LOG = True",
            "    return mode",
            "# 主処理",
            "def main():",
            "    import time",
            "    started = time.time()",
            "    mode = get_mode()",
            "    if mode == 0:",
            "        lines_input = get_input_lines()",
            "    else:",
            "        lines_input, lines_export = get_testdata(mode)",
            "    lines_result = calculation(lines_input)",
            "    for line_result in lines_result:",
            "        print(line_result)",
            "    # if mode > 0:",
            "    #     print(f'lines_input=[{lines_input}]')",
            "    #     print(f'lines_export=[{lines_export}]')",
            "    #     print(f'lines_result=[{lines_result}]')",
            "    #     if lines_result == lines_export:",
            "    #         print('OK')",
            "    #     else:",
            "    #         print('NG')",
            "    # finished = time.time()",
            "    # duration = finished - started",
            "    # print(f'duration=[{duration}]')",
            "# 起動処理",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def isp():   return input().split()",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    L = list(map(int, reversed(li())))",
            "    n = len(L)",
            "    payment = L[:]",
            "    payment.append(0)",
            "    ans = 0",
            "    carry = False",
            "    for i in range(n):",
            "        if 5 < payment[i] or (5 == payment[i] and 5 <= payment[i+1]):",
            "            ans += 9 - L[i] if carry else 10 - L[i]",
            "            payment[i] = 0",
            "            payment[i+1] += 1",
            "            carry = True",
            "        else:",
            "            carry = False",
            "    # print(L)",
            "    # print(list(reversed(payment)))",
            "    ans += sum(payment)",
            "    # ans = 0",
            "    # ans += sum(payment)",
            "    # a = int(''.join(list(map(str, reversed(L)))))",
            "    # b = int(''.join(list(map(str, reversed(payment)))))",
            "    # # print(f\"required {a}, paid: {b}\")",
            "    # ans += sum(map(int, list(str(b - a))))",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "mod = 10**9 + 7",
            "from collections import deque",
            "def main():",
            "    N = iip(False)",
            "    K = iip(False)",
            "    ret = solve(N, K)",
            "    print(ret)",
            "def solve(N, K):",
            "    strn = str(N)",
            "    A = []",
            "    B = []",
            "    for i in range(len(strn), 0, -1):",
            "        if strn[len(strn)-i] != \"0\":",
            "            A.append(int(strn[len(strn)-i]))",
            "            B.append(i)",
            "    if K == 1:",
            "        return 9*(B[0]-1) + A[0]",
            "    if K == 2:",
            "        if len(strn) < 2:",
            "            return 0",
            "        ret = 0",
            "        ret += (B[0]-1) * (B[0]-2) // 2 * (9**2) #桁数がmaxじゃない場合",
            "        ret += (A[0]-1) * 9 * (B[0]-1) #桁数がmaxで先頭桁がmax以外の場合",
            "        if len(B) >= 2 and len(A) >= 2:",
            "            ret += (B[1]-1) * 9 + A[1] #先頭桁がmaxの場合",
            "        return ret",
            "    ret = 0",
            "    ret += (B[0] - 1) * (B[0] - 2) * (B[0] - 3) // 6 * 9**3 #桁数がmaxじゃない場合",
            "    ret += (A[0] - 1) * (B[0] - 1) * (B[0] - 2) // 2 * 9**2 #桁数がmaxで先頭桁がmaxじゃない場合",
            "    #以下、桁数はmaxで先頭桁はmaxとする",
            "    if len(strn) < 3:",
            "        return 0",
            "    if len(B) >= 2:",
            "        ret += (B[1]-1) * (B[1]-2) // 2 * 9**2 #有効2桁目の桁数がmaxじゃない場合",
            "    if len(B) >= 2 and len(A) >= 2:",
            "        ret += (A[1] - 1) * (B[1]-1) * 9 #有効2桁目の桁数がmaxで数字がmaxじゃない場合",
            "    if len(B) >= 3 and len(A) >= 3:",
            "        ret += (B[2] - 1) * 9 + A[2] #有効2桁目,3桁目がmaxの場合",
            "    return ret",
            "#####################################################ライブラリ集ここから",
            "def split_print_space(s):",
            "    print(\" \".join([str(i) for i in s]))",
            "def split_print_enter(s):",
            "    print(\"\\n\".join([str(i) for i in s]))",
            "def searchsorted(sorted_list, n, side):",
            "    if side not in [\"right\", \"left\"]:",
            "        raise Exception(\"sideはrightかleftで指定してください\")",
            "    l = 0",
            "    r = len(sorted_list)",
            "    if n > sorted_list[-1]:",
            "        #print(sorted_list)",
            "        return len(sorted_list)",
            "    if n < sorted_list[0]:",
            "        return 0",
            "    while r-l > 1:",
            "        x = (l+r)//2",
            "        if sorted_list[x] > n:",
            "            r = x",
            "        elif sorted_list[x] < n:",
            "            l = x",
            "        else:",
            "            if side == \"left\":",
            "                r = x",
            "            elif side == \"right\":",
            "                l = x",
            "    if side == \"left\":",
            "        if sorted_list[l] == n:",
            "            return r - 1",
            "        else:",
            "            return r",
            "    if side == \"right\":",
            "        if sorted_list[l] == n:",
            "            return l + 1",
            "        else:",
            "            return l",
            "def iip(listed):",
            "    ret = [int(i) for i in input().split()]",
            "    if len(ret) == 1 and not listed:",
            "        return ret[0]",
            "    return ret",
            "def soinsuu_bunkai(n):",
            "    ret = []",
            "    for i in range(2, int(n**0.5)+1):",
            "        while n % i == 0:",
            "            n //= i",
            "            ret.append(i)",
            "        if i > n:",
            "            break",
            "    if n != 1:",
            "        ret.append(n)",
            "    return ret",
            "def conbination(n, r, mod, test=False):",
            "    if n <=0:",
            "        return 0",
            "    if r == 0:",
            "        return 1",
            "    if r < 0:",
            "        return 0",
            "    if r == 1:",
            "        return n",
            "    ret = 1",
            "    for i in range(n-r+1, n+1):",
            "        ret *= i",
            "        ret = ret % mod",
            "    bunbo = 1",
            "    for i in range(1, r+1):",
            "        bunbo *= i",
            "        bunbo = bunbo % mod",
            "    ret = (ret * inv(bunbo, mod)) % mod",
            "    if test:",
            "        #print(f\"{n}C{r} = {ret}\")",
            "        pass",
            "    return ret",
            "def inv(n, mod):",
            "    return power(n, mod-2)",
            "def power(n, p):",
            "    if p == 0:",
            "        return 1",
            "    if p % 2 == 0:",
            "        return (power(n, p//2) ** 2) % mod",
            "    if p % 2 == 1:",
            "        return (n * power(n, p-1)) % mod",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# 約分してから計算するアルゴリズム",
            "def combination(n, r):",
            "    # n >= 0, r >= 0, r <= n を仮定",
            "    if n < 0 or r < 0 or n < r:",
            "        return 0",
            "    # r <= n - r を仮定",
            "    if n - r < r:",
            "        r = n - r",
            "    # r < 2 の場合",
            "    if r == 0:",
            "        return 1",
            "    if r == 1:",
            "        return n",
            "    # nCr の分子",
            "    # [n - r + 1, n - r + 2, ... , n - 1, n]",
            "    numerator = [n - r + 1 + i for i in range(r)]",
            "    # nCr の分母",
            "    # [1, 2, ... , r - 1, r]",
            "    denominator = [i + 1 for i in range(r)]",
            "    # nCr を約分する",
            "    for i in range(r):",
            "        # i番目の分母で約分する",
            "        # 0番目は1なので省略",
            "        # 元の（今までの約分を行う前の）i番目の分母の値",
            "        original_denominator = i + 1",
            "        # 今までの約分を行った後の、i番目の分母の値",
            "        # 今回の約分で割る数",
            "        divisor = denominator[i]",
            "        # divisorが1（全て約分済み）の場合は無視する",
            "        if divisor == 1:",
            "            continue",
            "        # 約分する相手の分子を決める",
            "        # 0～i番目の分子（約分前）の中で、",
            "        # original_denominatorで割り切れる数",
            "        # （一つしかない）を選ぶ",
            "        # remainder = i番目の分子 % original_denominator",
            "        # とするとき、",
            "        # (i - remainder)番目の分子 = i番目の分子 - remainder",
            "        # (i - remainder)番目の分子 % original_denominator",
            "        #  = (i番目の分子 - remainder) % original_denominator",
            "        #  = 0",
            "        # なので、(i - remainder)番目の分子を選べばよい。",
            "        # remainder = i番目の分子 % original_denominator",
            "        #           = (n - r + i + 1) % (i + 1)",
            "        #           = (n - r) % (i + 1)",
            "        remainder = (n - r) % original_denominator",
            "        # divisor で約分できるペアをすべて約分する",
            "        for j in range(i, r, original_denominator):",
            "            numerator[j - remainder] = numerator[j - remainder] // divisor",
            "            denominator[j] = denominator[j] // divisor",
            "    ans = 1",
            "    for i in numerator:",
            "        ans *= i",
            "    return ans",
            "N_string = input()",
            "N = int(N_string)",
            "K = int(input())",
            "if N < 10:",
            "    if K == 1:",
            "        print(N)",
            "    else:",
            "        print(0)",
            "# elif N < 100:",
            "#     if K == 1:",
            "#         print(9 + N // 10)",
            "#     elif K == 2:",
            "#         print(9 * (N // 10 - 1) + (N - (N // 10) * 10))",
            "#     else:",
            "#         print(0)",
            "else:",
            "    # 10 ** n <= N < 10 ** (n + 1) なる n",
            "    # すなわち、N が n + 1 桁であるような n",
            "    n = len(N_string) - 1",
            "    # 10 ** n 未満で条件を満たす整数の数",
            "    ans = combination(n, K) * (9 ** K)",
            "    # Nの先頭の数字",
            "    a = int(N_string[0])",
            "    if K == 1:",
            "        ans += a",
            "    else:",
            "        # a以外に0でない数字が出現するかどうか",
            "        if N_string[1:] == \"0\" * n:",
            "            # 出現しないとき",
            "            ans += (a - 1) * combination(n, K - 1) * (9 ** (K - 1))",
            "        else:",
            "            # 出現するとき",
            "            # Nの2番目の0以外の数字とその表れる桁数を計算",
            "            m = n - 1",
            "            while True:",
            "                if N_string[n - m] != \"0\":",
            "                    b = int(N_string[n - m])",
            "                    break",
            "                m -= 1",
            "            if K == 2:",
            "                # n + 1 桁かつ、先頭の数字が1以上a未満であるような、",
            "                # 問題の条件を満たす整数の個数",
            "                ans += (a - 1) * combination(n, K - 1) * 9",
            "                # n + 1 桁かつ、先頭の数字が　a　であるような、",
            "                # 問題の条件を満たす整数でN以下のもののの個数",
            "                ans += combination(m, 1) * 9 + b",
            "            else:",
            "                # K == 3",
            "                # a, b以外に0でない数字が出現するかどうか",
            "                if N_string[n - m + 1:] == \"0\" * m:",
            "                    # 出現しないとき",
            "                    # n + 1 桁かつ、先頭の数字が1以上a未満であるような、",
            "                    # 問題の条件を満たす整数の個数",
            "                    ans += (a - 1) * combination(n, 2) * 9 * 9",
            "                    # n + 1 桁で先頭の数字が　a　かつ、 m + 1 桁目が0であるような、",
            "                    # 問題の条件を満たす整数でN以下のもののの個数",
            "                    ans += combination(m, 2) * 9 * 9",
            "                    # n + 1 桁で先頭の数字が a かつ、",
            "                    # m + 1 桁目の数字が1以上b未満であるような、",
            "                    # 問題の条件を満たす整数の個数",
            "                    ans += (b - 1) * combination(m, 1) * 9",
            "                else:",
            "                    # Nの3番目の0以外の数字とその表れる桁数を計算",
            "                    l = m - 1",
            "                    while True:",
            "                        if N_string[n - l] != \"0\":",
            "                            c = int(N_string[n - l])",
            "                            break",
            "                        l -= 1",
            "                    # n + 1 桁かつ、先頭の数字が1以上a未満であるような、",
            "                    # 問題の条件を満たす整数の個数",
            "                    ans += (a - 1) * combination(n, K - 1) * 9 * 9",
            "                    # n + 1 桁で先頭の数字が　a　かつ、 m + 1 桁目が0であるような、",
            "                    # 問題の条件を満たす整数でN以下のもののの個数",
            "                    ans += combination(m, K - 1) * 9 * 9",
            "                    # n + 1 桁で先頭の数字が a かつ、",
            "                    # m + 1 桁目の数字が1以上b未満であるような、",
            "                    # 問題の条件を満たす整数の個数",
            "                    ans += (b - 1) * combination(m, K - 2) * 9",
            "                    # n + 1 桁で先頭の数字が a かつ、",
            "                    # m + 1 桁目の数字が　b　であるような、",
            "                    # 問題の条件を満たす整数でN以下のもののの個数",
            "                    ans += combination(l, 1) * 9 + c",
            "    print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2
        ]
    },
    {
        "content": [
            "# https://atcoder.jp/contests/abc153/tasks/abc153_f",
            "# 筋肉でなぐる",
            "def _gidx(l, r, treesize):",
            "    '''",
            "    lazy propagation用idx生成器 木の下から生成される。1based-indexなので注意.(使うときは-1するとか)",
            "    もとの配列において[l,r)を指定したときに更新すべきidxをyieldする",
            "    treesizeは多くの場合self.num",
            "    '''",
            "    L, R = l + treesize, r + treesize",
            "    lm = (L // (L & -L)) >> 1  # これで成り立つの天才か？",
            "    rm = (R // (R & -R)) >> 1",
            "    while L < R:",
            "        if R <= rm:",
            "            yield R",
            "        if L <= lm:",
            "            yield L",
            "        L >>= 1",
            "        R >>= 1",
            "    while L:  # Rでもいいけどね",
            "        yield L",
            "        L >>= 1",
            "import operator",
            "class LazySegmentTree:  # 区間合計(ホントは何でも良い)クエリ と 区間加算クエリを扱うことにする",
            "    def __init__(self, ls: list, segfunc=operator.add, identity_element=0, lazy_ide=0):",
            "        '''",
            "        セグ木",
            "        一次元のリストlsを受け取り初期化する。O(len(ls))",
            "        区間のルールはsegfuncによって定義される",
            "        identity elementは単位元。e.g., 最小値を求めたい→inf, 和→0, 積→1, gcd→0",
            "        [単位元](https://ja.wikipedia.org/wiki/%E5%8D%98%E4%BD%8D%E5%85%83)",
            "        '''",
            "        self.ide = identity_element",
            "        self.lide = lazy_ide  # lazy用単位元",
            "        self.func = segfunc",
            "        n = len(ls)",
            "        self.num = 2 ** (n - 1).bit_length()  # n以上の最小の2のべき乗",
            "        self.tree = [self.ide] * (2 * self.num)  # 関係ない値を-1においてアクセスを許すと都合が良い",
            "        self.lazy = [self.lide] * (2 * self.num)  # 遅延配列",
            "        for i, l in enumerate(ls):  # 木の葉に代入",
            "            self.tree[i + self.num - 1] = l",
            "        for i in range(self.num - 2, -1, -1):  # 子を束ねて親を更新",
            "            self.tree[i] = segfunc(self.tree[2 * i + 1], self.tree[2 * i + 2])",
            "    def _lazyprop(self, *ids):",
            "        '''",
            "        遅延評価用の関数",
            "        - self.tree[i] に self.lazy[i]の値を伝播させて遅延更新する",
            "        - 子ノードにself.lazyの値を伝播させる **ここは問題ごとに書き換える必要がある**",
            "        - self.lazy[i]をリセットする",
            "        '''",
            "        for i in reversed(ids):",
            "            i -= 1  # to 0basedindex",
            "            v = self.lazy[i]",
            "            if v == self.lide:",
            "                continue",
            "            #########################################################",
            "            # この4つの配列をどう更新するかは問題によって異なる",
            "            self.tree[2 * i + 1] += v >> 1  # 区間加算クエリなので",
            "            self.tree[2 * i + 2] += v >> 1",
            "            self.lazy[2 * i + 1] += v >> 1",
            "            self.lazy[2 * i + 2] += v >> 1",
            "            #########################################################",
            "            self.lazy[i] = self.lide  # 遅延配列を空に戻す",
            "    def update(self, l, r, x):",
            "        '''",
            "        [l,r)番目の要素をxを適応するクエリを行う O(logN)",
            "        '''",
            "        # 1, 根から区間内においてlazyの値を伝播しておく(self.treeの値が有効になる)",
            "        ids = tuple(_gidx(l, r, self.num))",
            "        #########################################################",
            "        # 区間加算queryのような操作の順序が入れ替え可能な場合これをする必要なないが多くの場合でしたほうがバグが少なく(若干遅くなる)",
            "        # self._lazyprop(*ids)",
            "        #########################################################",
            "        # 2, 区間に対してtree,lazyの値を更新 (treeは根方向に更新するため、lazyはpropで葉方向に更新するため)",
            "        if r <= l:",
            "            return ValueError('invalid index (l,rがありえないよ)')",
            "        l += self.num",
            "        r += self.num",
            "        while l < r:",
            "            #########################################################",
            "            # ** 問題によって値のセットの仕方も変えるべし**",
            "            if r & 1:",
            "                r -= 1",
            "                self.tree[r - 1] += x",
            "                self.lazy[r - 1] += x",
            "            if l & 1:",
            "                self.tree[l - 1] += x",
            "                self.lazy[l - 1] += x",
            "                l += 1",
            "            #########################################################",
            "            x <<= 1  # 区間加算クエリでは上段では倍倍になるはずだよね",
            "            l >>= 1",
            "            r >>= 1",
            "        # 3, 伝播させた区間について下からdataの値を伝播する",
            "        for i in ids:",
            "            i -= 1  # to 0based",
            "            #########################################################",
            "            # 関数の先頭でlazy propを省略した場合は、現在のノードにlazyが反映されていないことがある",
            "            # lazyを省略するならここを慎重に書き換えなければならない",
            "            self.tree[i] = self.func(",
            "                self.tree[2 * i + 1], self.tree[2 * i + 2]) + self.lazy[i]",
            "            #########################################################",
            "    def query(self, l, r):",
            "        '''",
            "        区間[l,r)に対するクエリをO(logN)で処理する。例えばその区間の最小値、最大値、gcdなど",
            "        '''",
            "        if r <= l:",
            "            return ValueError('invalid index (l,rがありえないよ)')",
            "        # 1, 根からにlazyの値を伝播させる",
            "        self._lazyprop(*_gidx(l, r, self.num))",
            "        # 2, 区間[l,r)の最小値を求める",
            "        l += self.num",
            "        r += self.num",
            "        res = self.ide",
            "        while l < r:  # 右から寄りながら結果を結合していくイメージ",
            "            if r & 1:",
            "                r -= 1",
            "                res = self.func(res, self.tree[r - 1])",
            "            if l & 1:",
            "                res = self.func(res, self.tree[l - 1])",
            "                l += 1",
            "            l >>= 1",
            "            r >>= 1",
            "        return res",
            "import sys",
            "read = sys.stdin.readline",
            "def read_ints():",
            "    return list(map(int, read().split()))",
            "def read_tuple(H):",
            "    '''",
            "    H is number of rows",
            "    '''",
            "    ret = []",
            "    for _ in range(H):",
            "        ret.append(tuple(map(int, read().split())))",
            "    return ret",
            "def read_col(H, n_cols):",
            "    '''",
            "    H is number of rows",
            "    n_cols is number of cols",
            "    A列、B列が与えられるようなとき",
            "    '''",
            "    ret = [[] for _ in range(n_cols)]",
            "    for _ in range(H):",
            "        tmp = list(map(int, read().split()))",
            "        for col in range(n_cols):",
            "            ret[col].append(tmp[col])",
            "    return ret",
            "# default import",
            "from bisect import bisect_left, bisect_right",
            "N, D, A = read_ints()",
            "XH = read_tuple(N)",
            "XH.sort()",
            "# なにはともあれ攻撃回数に変更",
            "X = []",
            "H_cnt = []",
            "for x, h in XH:",
            "    H_cnt.append((h - 1) // A + 1)",
            "    X.append(x)",
            "seg = LazySegmentTree(H_cnt)",
            "# 前から順に攻撃をシミュレーション",
            "ans = 0",
            "for i in range(N):",
            "    atk = seg.query(i, i + 1)  # 残りの体力を取得(攻撃回数)",
            "    if atk <= 0:",
            "        continue",
            "    ans += atk",
            "    # 巻き添えを後ろの方々に",
            "    seg.update(i+1, bisect_left(X, X[i] + 2 * D + 1, lo=i), -atk)",
            "print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            1,
            2,
            2
        ]
    },
    {
        "content": [
            "import sys",
            "sys.setrecursionlimit(2147483647)",
            "INF = 1 << 60",
            "MOD = 10**9 + 7 # 998244353",
            "input = lambda:sys.stdin.readline().rstrip()",
            "class LazySegmentTree(object):",
            "    def __init__(self, A, dot, unit, compose, identity, act):",
            "        # A : array of monoid (M, dot, unit)",
            "        # (S, compose, identity) : sub monoid of End(M)",
            "        # compose : (f, g) -> fg (f, g in S)",
            "        # act : (f, x) -> f(x) (f in S, x in M)",
            "        logn = (len(A) - 1).bit_length()",
            "        n = 1 << logn",
            "        tree = [unit] * (2 * n)",
            "        for i, v in enumerate(A):",
            "            tree[i + n] = v",
            "        for i in range(n - 1, 0, -1):",
            "            tree[i] = dot(tree[i << 1], tree[i << 1 | 1])",
            "        self._n, self._logn, self._tree, self._lazy = n, logn, tree, [identity] * (2 * n)",
            "        self._dot, self._unit, self._compose, self._identity, self._act = dot, unit, compose, identity, act",
            "    def _ascend(self, i):",
            "        tree, lazy, dot, act = self._tree, self._lazy, self._dot, self._act",
            "        while i > 1:",
            "            i >>= 1",
            "            tree[i] = act(lazy[i], dot(tree[i << 1], tree[i << 1 | 1]))",
            "    def _descend(self, i):",
            "        tree, lazy, identity, compose, act = self._tree, self._lazy, self._identity, self._compose, self._act",
            "        for k in range(self._logn, 0, -1):",
            "            p = i >> k",
            "            f = lazy[p]",
            "            tree[p << 1], lazy[p << 1] = act(f, tree[p << 1]), compose(f, lazy[p << 1])",
            "            tree[p << 1 | 1], lazy[p << 1 | 1] = act(f, tree[p << 1 | 1]), compose(f, lazy[p << 1 | 1])",
            "            lazy[p] = identity",
            "    # A[i] <- f(A[i]) for all i in [l, r)",
            "    def range_act(self, l, r, f):",
            "        l += self._n",
            "        r += self._n",
            "        # propagation isn't necessary if S is commutative",
            "        # self._descend(l)",
            "        # self._descend(r - 1)",
            "        l0, r0 = l, r",
            "        tree, lazy, act, compose = self._tree, self._lazy, self._act, self._compose",
            "        while l < r:",
            "            if l & 1:",
            "                tree[l], lazy[l] = act(f, tree[l]), compose(f, lazy[l])",
            "                l += 1",
            "            if r & 1:",
            "                r -= 1",
            "                tree[r], lazy[r] = act(f, tree[r]), compose(f, lazy[r])",
            "            l >>= 1",
            "            r >>= 1",
            "        self._ascend(l0)",
            "        self._ascend(r0 - 1)",
            "    # calculate product of A[l:r]",
            "    def sum(self, l, r):",
            "        l += self._n",
            "        r += self._n",
            "        self._descend(l)",
            "        self._descend(r - 1)",
            "        l_val = r_val = self._unit",
            "        tree, dot = self._tree, self._dot",
            "        while l < r:",
            "            if l & 1:",
            "                l_val = dot(l_val, tree[l])",
            "                l += 1",
            "            if r & 1:",
            "                r -= 1",
            "                r_val = dot(tree[r], r_val)",
            "            l >>= 1",
            "            r >>= 1",
            "        return dot(l_val, r_val)",
            "from operator import add",
            "def resolve():",
            "    n, d, a = map(int, input().split())",
            "    XH = [None] * n",
            "    coordinates = set() # for coordinates compression",
            "    for i in range(n):",
            "        x, h = map(int, input().split())",
            "        XH[i] = [x, (h - 1) // a + 1] # 初めから何回減らすかだけ持てばよい",
            "        coordinates.add(x)",
            "        coordinates.add(x + 2 * d + 1) # [x, x + 2d + 1) に減らす",
            "    XH.sort()",
            "    compress = {v : i for i, v in enumerate(sorted(coordinates))}",
            "    n = len(compress)",
            "    A = [0] * n",
            "    for i in range(len(XH)):",
            "        A[compress[XH[i][0]]] = XH[i][1]",
            "    res = 0",
            "    tree = LazySegmentTree(A, max, 0, add, 0, add) # 区間 add, 1点取得ができればよいので、区間拡張しなくてよい max にしておく",
            "    for x, h in XH:",
            "        # もし x が生き残っていたら、[x, x + 2d + 1) から hp を引く",
            "        hp = tree.sum(compress[x], compress[x] + 1)",
            "        if hp <= 0:",
            "            continue",
            "        res += hp",
            "        tree.range_act(compress[x], compress[x + 2 * d + 1], -hp)",
            "    print(res)",
            "resolve()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            0,
            0,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "import math",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product                # product(iter, repeat=n)",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict",
            "from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4",
            "def main():",
            "    mod = 1000000007                  # 10^9+7",
            "    inf = float('inf')",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():  return int(input())",
            "    def mi():  return map(int, input().split())",
            "    def mi_0(): return map(lambda x: int(x)-1, input().split())",
            "    def lmi(): return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():  return list(input())",
            "    n, d, a = mi()",
            "    monsters = sorted([lmi() for _ in range(n)])",
            "    monster_points = []",
            "    monster_hps= []",
            "    for pair in monsters:",
            "        monster_points.append(pair[0])",
            "        monster_hps.append(pair[1])",
            "    # どの monster_points[ind] での ind の表すモンスターまで巻き込めるか (右端)",
            "    right_end_monster_ind = [0] * (n)",
            "    for i in range(n):",
            "        right_end_monster_ind[i] = bisect_right(monster_points, monster_points[i]+2*d) - 1",
            "    # print(right_end_monster_ind)",
            "    imos_list = [0] * (n+1)",
            "    damage = 0",
            "    ans = 0",
            "    for i in range(n):",
            "        damage += imos_list[i]",
            "        rest_hp = max(0, monster_hps[i] - damage)",
            "        # print(\"rest {}\".format(rest_hp))",
            "        cnt = math.ceil(rest_hp / a)",
            "        ans += cnt",
            "        imos_list[i+1] += (a * cnt)",
            "        imos_list[right_end_monster_ind[i]+1] -= (a * cnt)",
            "        # print(imos_list)",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "input = sys.stdin.readline",
            "def I(): return int(input())",
            "def MI(): return map(int, input().split())",
            "def LI(): return list(map(int, input().split()))",
            "\"\"\"",
            "左から見る，モンスターが生きているならそいつが左端ギリギリになる位置に爆弾投下",
            "区間減算，座圧",
            "\"\"\"",
            "def main():",
            "    ####################",
            "    import sys",
            "    class Lazysegtree():",
            "        #必ず単位元に注意すること！queryで1点の値のみを抽出するような場合でも，単位元とsegfuncがあってないとダメ！！",
            "        \"\"\"RAQ",
            "        外から使うのは，query，add,updateくらいか",
            "        \"\"\"",
            "        def __init__(self, A, intv, initialize = True, segf = min):",
            "            \"\"\"",
            "            Aが初期配列，intvが単位元,segfが評価関数",
            "            \"\"\"",
            "            #区間は 1-indexed で管理",
            "            self.N = len(A)",
            "            self.N0 = 2**(self.N-1).bit_length()",
            "            self.intv = intv",
            "            self.segf = segf",
            "            self.lazy = [0]*(2*self.N0)",
            "            if initialize:",
            "                self.data = [intv]*self.N0 + A + [intv]*(self.N0 - self.N)",
            "                for i in range(self.N0-1, 0, -1):",
            "                    self.data[i] = self.segf(self.data[2*i], self.data[2*i+1])",
            "            else:",
            "                self.data = [intv]*(2*self.N0)",
            "        def _ascend(self, k):",
            "            k = k >> 1",
            "            c = k.bit_length()",
            "            for j in range(c):",
            "                idx = k >> j",
            "                self.data[idx] = self.segf(self.data[2*idx], self.data[2*idx+1]) \\",
            "                + self.lazy[idx]",
            "        def _descend(self, k):",
            "            k = k >> 1",
            "            idx = 1",
            "            c = k.bit_length()",
            "            for j in range(1, c+1):",
            "                idx = k >> (c - j)",
            "                ax = self.lazy[idx]",
            "                if not ax:",
            "                    continue",
            "                self.lazy[idx] = 0",
            "                self.data[2*idx] += ax",
            "                self.data[2*idx+1] += ax",
            "                self.lazy[2*idx] += ax",
            "                self.lazy[2*idx+1] += ax",
            "        def update(self, k, x):",
            "            #1点のデータの変更",
            "            k = k + self.N0",
            "            self.data[k] = x",
            "            self._ascend(k)",
            "        def query(self, l, r):",
            "            #クエリ，[l,r)かな",
            "            L = l+self.N0",
            "            R = r+self.N0",
            "            Li = L//(L & -L)",
            "            Ri = R//(R & -R)",
            "            self._descend(Li)",
            "            self._descend(Ri - 1)",
            "            s = self.intv",
            "            t = self.intv",
            "            while L < R:",
            "                if R & 1:",
            "                    R -= 1",
            "                    t = self.segf(self.data[R],t)",
            "                if L & 1:",
            "                    s = self.segf(s, self.data[L])",
            "                    L += 1",
            "                L >>= 1",
            "                R >>= 1",
            "            return self.segf(s,t)",
            "        def add(self, l, r, x):",
            "            #区間加算，[l,r)かな",
            "            L = l+self.N0",
            "            R = r+self.N0",
            "            Li = L//(L & -L)",
            "            Ri = R//(R & -R)",
            "            while L < R :",
            "                if R & 1:",
            "                    R -= 1",
            "                    self.data[R] += x",
            "                    self.lazy[R] += x",
            "                if L & 1:",
            "                    self.data[L] += x",
            "                    self.lazy[L] += x",
            "                    L += 1",
            "                L >>= 1",
            "                R >>= 1",
            "            self._ascend(Li)",
            "            self._ascend(Ri-1)",
            "        #必ず単位元に注意すること！queryで1点の値のみを抽出するような場合でも，単位元とsegfuncがあってないとダメ！！",
            "    ##########",
            "    import bisect",
            "    N,D,A=MI()",
            "    X=[0]*N",
            "    H=[0]*N",
            "    for i in range(N):",
            "        X[i],H[i]=MI()",
            "    X,H=zip(*sorted(zip(X,H)))",
            "    from collections import defaultdict",
            "    dd = defaultdict(int)",
            "    for i in range(N):",
            "        dd[X[i]]=i",
            "    ans=0",
            "    inf=10**10",
            "    seg=Lazysegtree(list(H),inf,segf=min)",
            "    for i in range(N):",
            "        h=seg.query(i,i+1)",
            "        if h>0:",
            "            cnt=(h+A-1)//A",
            "            ans+=cnt",
            "            l=i",
            "            t=X[l]+2*D",
            "            r=bisect.bisect_right(X,t)",
            "            seg.add(l,r,-1*cnt*A)",
            "    print(ans)",
            "main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "# https://atcoder.jp/contests/abc153/tasks/abc153_f",
            "# 筋肉でなぐる",
            "def _gidx(l, r, treesize):",
            "    '''",
            "    lazy propagation用idx生成器 木の下から生成される。1based-indexなので注意.(使うときは-1するとか)",
            "    もとの配列において[l,r)を指定したときに更新すべきidxをyieldする",
            "    treesizeは多くの場合self.num",
            "    '''",
            "    L, R = l + treesize, r + treesize",
            "    lm = (L // (L & -L)) >> 1  # これで成り立つの天才か？",
            "    rm = (R // (R & -R)) >> 1",
            "    while L < R:",
            "        if R <= rm:",
            "            yield R",
            "        if L <= lm:",
            "            yield L",
            "        L >>= 1",
            "        R >>= 1",
            "    while L:  # Rでもいいけどね",
            "        yield L",
            "        L >>= 1",
            "import operator",
            "class LazySegmentTree:  # 区間合計(ホントは何でも良い)クエリ と 区間加算クエリを扱うことにする",
            "    def __init__(self, ls: list, segfunc=operator.add, identity_element=0, lazy_ide=0):",
            "        '''",
            "        セグ木",
            "        一次元のリストlsを受け取り初期化する。O(len(ls))",
            "        区間のルールはsegfuncによって定義される",
            "        identity elementは単位元。e.g., 最小値を求めたい→inf, 和→0, 積→1, gcd→0",
            "        [単位元](https://ja.wikipedia.org/wiki/%E5%8D%98%E4%BD%8D%E5%85%83)",
            "        '''",
            "        self.ide = identity_element",
            "        self.lide = lazy_ide  # lazy用単位元",
            "        self.func = segfunc",
            "        n = len(ls)",
            "        self.num = 2 ** (n - 1).bit_length()  # n以上の最小の2のべき乗",
            "        self.tree = [self.ide] * (2 * self.num)  # 関係ない値を-1においてアクセスを許すと都合が良い",
            "        self.lazy = [self.lide] * (2 * self.num)  # 遅延配列",
            "        for i, l in enumerate(ls):  # 木の葉に代入",
            "            self.tree[i + self.num - 1] = l",
            "        for i in range(self.num - 2, -1, -1):  # 子を束ねて親を更新",
            "            self.tree[i] = segfunc(self.tree[2 * i + 1], self.tree[2 * i + 2])",
            "    def _lazyprop(self, *ids):",
            "        '''",
            "        遅延評価用の関数",
            "        - self.tree[i] に self.lazy[i]の値を伝播させて遅延更新する",
            "        - 子ノードにself.lazyの値を伝播させる **ここは問題ごとに書き換える必要がある**",
            "        - self.lazy[i]をリセットする",
            "        '''",
            "        for i in reversed(ids):",
            "            i -= 1  # to 0basedindex",
            "            v = self.lazy[i]",
            "            if v == self.lide:",
            "                continue",
            "            #########################################################",
            "            # この4つの配列をどう更新するかは問題によって異なる",
            "            self.tree[2 * i + 1] += v  # 区間加算クエリなので",
            "            self.tree[2 * i + 2] += v",
            "            self.lazy[2 * i + 1] += v",
            "            self.lazy[2 * i + 2] += v",
            "            #########################################################",
            "            self.lazy[i] = self.lide  # 遅延配列を空に戻す",
            "    def update(self, l, r, x):",
            "        '''",
            "        [l,r)番目の要素をxを適応するクエリを行う O(logN)",
            "        '''",
            "        # 1, 根から区間内においてlazyの値を伝播しておく(self.treeの値が有効になる)",
            "        ids = tuple(_gidx(l, r, self.num))",
            "        #########################################################",
            "        # 区間加算queryのような操作の順序が入れ替え可能な場合これをする必要なないが多くの場合でしたほうがバグが少なく(若干遅くなる)",
            "        self._lazyprop(*ids)",
            "        #########################################################",
            "        # 2, 区間に対してtree,lazyの値を更新 (treeは根方向に更新するため、lazyはpropで葉方向に更新するため)",
            "        if r <= l:",
            "            return ValueError('invalid index (l,rがありえないよ)')",
            "        l += self.num",
            "        r += self.num",
            "        while l < r:",
            "            #########################################################",
            "            # ** 問題によって値のセットの仕方も変えるべし**",
            "            if r & 1:",
            "                r -= 1",
            "                self.tree[r - 1] += x",
            "                self.lazy[r - 1] += x",
            "            if l & 1:",
            "                self.tree[l - 1] += x",
            "                self.lazy[l - 1] += x",
            "                l += 1",
            "            #########################################################",
            "            l >>= 1",
            "            r >>= 1",
            "        # 3, 伝播させた区間について下からdataの値を伝播する",
            "        for i in ids:",
            "            i -= 1  # to 0based",
            "            #########################################################",
            "            # 関数の先頭でlazy propを省略した場合は、現在のノードにlazyが反映されていないことがある",
            "            # lazyを省略するならここを慎重に書き換えなければならない",
            "            self.tree[i] = self.func(",
            "                self.tree[2 * i + 1], self.tree[2 * i + 2])",
            "            #########################################################",
            "    def query(self, l, r):",
            "        '''",
            "        区間[l,r)に対するクエリをO(logN)で処理する。例えばその区間の最小値、最大値、gcdなど",
            "        '''",
            "        if r <= l:",
            "            return ValueError('invalid index (l,rがありえないよ)')",
            "        # 1, 根からにlazyの値を伝播させる",
            "        self._lazyprop(*_gidx(l, r, self.num))",
            "        # 2, 区間[l,r)の最小値を求める",
            "        l += self.num",
            "        r += self.num",
            "        res = self.ide",
            "        while l < r:  # 右から寄りながら結果を結合していくイメージ",
            "            if r & 1:",
            "                r -= 1",
            "                res = self.func(res, self.tree[r - 1])",
            "            if l & 1:",
            "                res = self.func(res, self.tree[l - 1])",
            "                l += 1",
            "            l >>= 1",
            "            r >>= 1",
            "        return res",
            "import sys",
            "read = sys.stdin.readline",
            "def read_ints():",
            "    return list(map(int, read().split()))",
            "def read_tuple(H):",
            "    '''",
            "    H is number of rows",
            "    '''",
            "    ret = []",
            "    for _ in range(H):",
            "        ret.append(tuple(map(int, read().split())))",
            "    return ret",
            "def read_col(H, n_cols):",
            "    '''",
            "    H is number of rows",
            "    n_cols is number of cols",
            "    A列、B列が与えられるようなとき",
            "    '''",
            "    ret = [[] for _ in range(n_cols)]",
            "    for _ in range(H):",
            "        tmp = list(map(int, read().split()))",
            "        for col in range(n_cols):",
            "            ret[col].append(tmp[col])",
            "    return ret",
            "# default import",
            "from collections import defaultdict, Counter, deque",
            "from operator import itemgetter",
            "from itertools import product, permutations, combinations",
            "from fractions import gcd",
            "from bisect import bisect_left, bisect_right, insort_left, insort_right",
            "N, D, A = read_ints()",
            "XH = read_tuple(N)",
            "XH.sort()",
            "# なにはともあれ攻撃回数に変更",
            "X = []",
            "H_cnt = []",
            "for x, h in XH:",
            "    H_cnt.append((h - 1) // A + 1)",
            "    X.append(x)",
            "seg = LazySegmentTree(H_cnt)",
            "# 前から順に攻撃をシミュレーション",
            "ans = 0",
            "for i in range(N):",
            "    atk = seg.query(i, i + 1)  # 残りの体力を取得(攻撃回数)",
            "    if atk <= 0:",
            "        continue",
            "    ans += atk",
            "    # 巻き添えを後ろの方々に",
            "    seg.update(i, bisect_left(X, X[i] + 2 * D + 1, lo=i), -atk)",
            "print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            1,
            2,
            2
        ]
    },
    {
        "content": [
            "def examA():",
            "    N = I()",
            "    L = LI()",
            "    L.sort()",
            "    if sum(L)<=L[-1]*2:",
            "        print(\"No\")",
            "    else:",
            "        print(\"Yes\")",
            "    return",
            "def examB():",
            "    N, M = LI()",
            "    A = [LI()for _ in range(N)]",
            "    A.sort(key=lambda x:x[0])",
            "    ans = 0",
            "    for a,b in A:",
            "        if M<=b:",
            "            ans += a*M",
            "            break",
            "        ans += a*b",
            "        M -= b",
            "    print(ans)",
            "    return",
            "def examC():",
            "    N = I()",
            "    S = [SI()for _ in range(N)]",
            "    D = defaultdict(int)",
            "    for s in S:",
            "        cur = []",
            "        for i,j in Counter(s).items():",
            "            cur.append((i,j))",
            "        #print(cur)",
            "        cur.sort()",
            "        cur = tuple(cur)",
            "        D[cur] += 1",
            "    ans = 0",
            "    for d in D.values():",
            "        ans += (d-1)*d//2",
            "    print(ans)",
            "    return",
            "def examD():",
            "    N, K = LI()",
            "    A = LI()",
            "    S = [0]*(N+1)",
            "    for i in range(N):",
            "        S[i+1] = S[i]+A[i]",
            "    ans = 0",
            "    for i in range(N):",
            "        l = i-1; r = N",
            "        if S[-1]-S[i]<K:",
            "            break",
            "        while(r-l>1):",
            "            now = (l+r)//2",
            "            if S[now]-S[i]<K:",
            "                l = now",
            "            else:",
            "                r = now",
            "        #print(i,r)",
            "        ans += (N-r+1)",
            "    print(ans)",
            "    return",
            "def examE():",
            "    # 区間加算、上書き、一点取得",
            "    class SegmentTree:",
            "        def __init__(self, n, ele, segfun):",
            "            #####単位元######要設定0or1orinf",
            "            self.ide_ele = ele",
            "            self.segfun = segfun",
            "            ####################",
            "            self.n = n",
            "            self.N0 = 1 << n.bit_length()",
            "            self.data = [self.ide_ele] * (self.N0 * 2)",
            "        def update_add(self, l, r, val):",
            "            l += self.N0",
            "            r += self.N0",
            "            while l < r:",
            "                if l & 1:",
            "                    self.data[l] += val",
            "                    l += 1",
            "                if r & 1:",
            "                    self.data[r - 1] += val",
            "                    r -= 1",
            "                l //= 2",
            "                r //= 2",
            "        def update(self, l, r, val):",
            "            l += self.N0",
            "            r += self.N0",
            "            while l < r:",
            "                if l & 1:",
            "                    self.data[l] = self.segfun(self.data[l], val)",
            "                    l += 1",
            "                if r & 1:",
            "                    self.data[r - 1] = self.segfun(self.data[r - 1], val)",
            "                    r -= 1",
            "                l //= 2",
            "                r //= 2",
            "        def query(self, i):",
            "            i += len(self.data) // 2",
            "            ret = self.data[i]",
            "            while i > 0:",
            "                i //= 2",
            "                ret = self.segfun(ret, self.data[i])",
            "            return ret",
            "    N, D, A = LI()",
            "    X = [LI()for _ in range(N)]",
            "    X.sort()",
            "    L = [0]*N",
            "    for i in range(N):",
            "        L[i] = X[i][0]",
            "    S = SegmentTree(N,0,lambda a, b: a+b)",
            "    ans = 0",
            "    for i,[x,h] in enumerate(X):",
            "        H = h - S.query(i)",
            "        if H<=0:",
            "            continue",
            "        ne = bisect.bisect_right(L,x+2*D)",
            "        #print(ne)",
            "        need = (H-1)//A + 1",
            "        S.update(i,ne,need*A)",
            "        ans += need",
            "    print(ans)",
            "    return",
            "def examF():",
            "    ans = 0",
            "    print(ans)",
            "    return",
            "import sys,bisect,itertools,heapq,math,random",
            "from copy import deepcopy",
            "from heapq import heappop,heappush,heapify",
            "from collections import Counter,defaultdict,deque",
            "read = sys.stdin.buffer.read",
            "readline = sys.stdin.buffer.readline",
            "readlines = sys.stdin.buffer.readlines",
            "def I(): return int(readline())",
            "def LI(): return list(map(int,readline().split()))",
            "def LSI(): return list(map(str,sys.stdin.readline().split()))",
            "def LS(): return sys.stdin.readline().split()",
            "def SI(): return sys.stdin.readline().strip()",
            "global mod,mod2,inf,alphabet,_ep",
            "mod = 10**9 + 7",
            "mod2 = 998244353",
            "inf = 10**18",
            "_ep = 10**(-12)",
            "alphabet = [chr(ord('a') + i) for i in range(26)]",
            "sys.setrecursionlimit(10**7)",
            "if __name__ == '__main__':",
            "    examE()",
            "\"\"\"",
            "142",
            "12 9 1445 0 1",
            "asd dfg hj o o",
            "aidn",
            "\"\"\""
        ],
        "label": [
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "mod = int(1e9+7)",
            "def add(a, b):",
            "    c = a + b",
            "    if c >= mod:",
            "        c -= mod",
            "    return c",
            "def mul(a, b):",
            "    return (a * b) % mod",
            "def my_pow(a, b):",
            "    if b == 0:",
            "        return 1",
            "    elif b % 2 == 1:",
            "        return mul(a, my_pow(a, b-1))",
            "    else:",
            "        temp = my_pow(a, b/2)",
            "        return mul(temp, temp)",
            "def my_inv(a):",
            "    return my_pow(a, mod-2)",
            "def modInverse(a, m) :",
            "    m0 = m",
            "    y = 0",
            "    x = 1",
            "    if (m == 1) :",
            "        return 0",
            "    while (a > 1) :",
            "        # q is quotient",
            "        q = a // m",
            "        t = m",
            "        # m is remainder now, process",
            "        # same as Euclid's algo",
            "        m = a % m",
            "        a = t",
            "        t = y",
            "        # Update x and y",
            "        y = x - q * y",
            "        x = t",
            "    # Make x positive",
            "    if (x < 0) :",
            "        x = x + m0",
            "    return x",
            "def main():",
            "    n = int(raw_input())",
            "    arr = [int(x) for x in raw_input().split()]",
            "    answer = {}",
            "    for i in range(n):",
            "        cnt = {}",
            "        x = arr[i]",
            "        i = 2",
            "        while i * i <= x:",
            "            while x % i == 0:",
            "                x /= i",
            "                cnt[i] = cnt.get(i, 0) + 1",
            "            i += 1",
            "        if x != 1:",
            "            cnt[x] = cnt.get(x, 0) + 1",
            "        for key in cnt:",
            "            answer[key] = max(answer.get(key, 0), cnt[key])",
            "    lcm = 1",
            "    for prime in answer:",
            "        for _ in range(answer[prime]):",
            "            lcm = mul(lcm, prime)",
            "    #print(lcm)",
            "    ans = 0",
            "    #print(my_pow(22, 3))",
            "    for x in arr:",
            "        #print(my_inv(x))",
            "        ans = add(ans, mul(lcm, my_inv(x)))",
            "    ans = int(ans)",
            "    print(ans)",
            "main()",
            "\"\"\"",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "using ll = long long;",
            "const int MOD = 1e9+7;",
            "ll add(ll a, ll b) {",
            "    return (a + b) % MOD;",
            "}",
            "ll divi(ll a, ll b) {",
            "    return (a / b) % MOD;",
            "}",
            "ll mul(ll a, ll b) {",
            "    return (a * b) % MOD;",
            "}",
            "// Return a ^ b",
            "int my_pow(int a, int b) {",
            "    if (b == 0) {",
            "        return 1;",
            "    }",
            "    else if (b % 2 == 1) {",
            "        return mul(a, my_pow(a, b-1));",
            "    }",
            "    else {",
            "        int temp = my_pow(a, b/2);",
            "        return mul(temp, temp);",
            "    }",
            "}",
            "int my_inv(int a) {",
            "    return my_pow(a, MOD-2);",
            "}",
            "int main() {",
            "    int n;",
            "    scanf(\"%d\", &n);",
            "    vector<int> arr(n);",
            "    map<int, int> answer;",
            "    //cout << \"test\" << endl;",
            "    for (int i = 0; i < n; i++) {",
            "        map<int, int> cnt;",
            "        scanf(\"%d\", &arr[i]);",
            "        int x = arr[i];",
            "        //cout << x << endl;",
            "        for (int i = 2; i * i <= x; i++) {",
            "            while (x % i == 0) {",
            "                cnt[i] += 1;",
            "                x /= i;",
            "            }",
            "        }",
            "        if (x != 1) {",
            "            cnt[x] += 1;",
            "        }",
            "        //cout << \"test_x\" << endl;",
            "        for (pair<int, int> p : cnt) {",
            "            answer[p.first] = max(answer[p.first], p.second);",
            "        }",
            "    }",
            "    //cout << \"test2\" << endl;",
            "    ll lcm = 1;",
            "    for (pair<int, int> p : answer) {",
            "        int prime = p.first;",
            "        int k = p.second;",
            "        for (int i = 0; i < k; i++) {",
            "            lcm = mul(lcm, prime);",
            "        }",
            "    }",
            "    ll ans = 0;",
            "    //cout << \"test1\" << endl;",
            "    for (int i = 0; i < n; i++) {",
            "        ans = add(ans, mul(lcm, my_inv(arr[i])));",
            "    }",
            "    //cout << \"test2\" << endl;",
            "    printf(\"%lld\", ans);",
            "\treturn 0;",
            "}",
            "\"\"\""
        ],
        "label": [
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            1,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            2,
            2,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2
        ]
    },
    {
        "content": [
            "import sys",
            "import heapq",
            "import re",
            "from itertools import permutations",
            "from bisect import bisect_left, bisect_right",
            "from collections import Counter, deque",
            "from math import factorial, sqrt, ceil, gcd",
            "from functools import lru_cache, reduce",
            "from decimal import Decimal",
            "INF = 1 << 60",
            "MOD = 1000000007",
            "sys.setrecursionlimit(10 ** 7)",
            "# UnionFind",
            "class UnionFind():",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parents = [-1] * n",
            "    def find(self, x):",
            "        if self.parents[x] < 0:",
            "            return x",
            "        else:",
            "            self.parents[x] = self.find(self.parents[x])",
            "            return self.parents[x]",
            "    def union(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "        if x == y:",
            "            return",
            "        if self.parents[x] > self.parents[y]:",
            "            x, y = y, x",
            "        self.parents[x] += self.parents[y]",
            "        self.parents[y] = x",
            "    def size(self, x):",
            "        return -self.parents[self.find(x)]",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "    def members(self, x):",
            "        root = self.find(x)",
            "        return [i for i in range(self.n) if self.find(i) == root]",
            "    def roots(self):",
            "        return [i for i, x in enumerate(self.parents) if x < 0]",
            "    def group_count(self):",
            "        return len(self.roots())",
            "    def all_group_members(self):",
            "        return {r: self.members(r) for r in self.roots()}",
            "    def __str__(self):",
            "        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())",
            "# ダイクストラ",
            "def dijkstra_heap(s, edge, n):",
            "    #始点sから各頂点への最短距離",
            "    d = [10**20] * n",
            "    used = [True] * n #True:未確定",
            "    d[s] = 0",
            "    used[s] = False",
            "    edgelist = []",
            "    for a,b in edge[s]:",
            "        heapq.heappush(edgelist,a*(10**6)+b)",
            "    while len(edgelist):",
            "        minedge = heapq.heappop(edgelist)",
            "        #まだ使われてない頂点の中から最小の距離のものを探す",
            "        if not used[minedge%(10**6)]:",
            "            continue",
            "        v = minedge%(10**6)",
            "        d[v] = minedge//(10**6)",
            "        used[v] = False",
            "        for e in edge[v]:",
            "            if used[e[1]]:",
            "                heapq.heappush(edgelist,(e[0]+d[v])*(10**6)+e[1])",
            "    return d",
            "# 素因数分解",
            "def factorization(n):",
            "    arr = []",
            "    temp = n",
            "    for i in range(2, int(-(-n**0.5//1))+1):",
            "        if temp%i==0:",
            "            cnt=0",
            "            while temp%i==0:",
            "                cnt+=1",
            "                temp //= i",
            "            arr.append([i, cnt])",
            "    if temp!=1:",
            "        arr.append([temp, 1])",
            "    if arr==[]:",
            "        arr.append([n, 1])",
            "    return arr",
            "# 2数の最小公倍数",
            "def lcm(x, y):",
            "    return (x * y) // gcd(x, y)",
            "# リストの要素の最小公倍数",
            "def lcm_list(numbers):",
            "    return reduce(lcm, numbers, 1)",
            "# リストの要素の最大公約数",
            "def gcd_list(numbers):",
            "    return reduce(gcd, numbers)",
            "# 素数判定",
            "def is_prime(n):",
            "    if n <= 1:",
            "        return False",
            "    p = 2",
            "    while True:",
            "        if p ** 2 > n:",
            "            break",
            "        if n % p == 0:",
            "            return False",
            "        p += 1",
            "    return True",
            "# limit以下の素数を列挙",
            "def eratosthenes(limit):",
            "    A = [i for i in range(2, limit+1)]",
            "    P = []",
            "    while True:",
            "        prime = min(A)",
            "        if prime > sqrt(limit):",
            "            break",
            "        P.append(prime)",
            "        i = 0",
            "        while i < len(A):",
            "            if A[i] % prime == 0:",
            "                A.pop(i)",
            "                continue",
            "            i += 1",
            "    for a in A:",
            "        P.append(a)",
            "    return P",
            "# 同じものを含む順列",
            "def permutation_with_duplicates(L):",
            "    if L == []:",
            "        return [[]]",
            "    else:",
            "        ret = []",
            "        # set（集合）型で重複を削除、ソート",
            "        S = sorted(set(L))",
            "        for i in S:",
            "            data = L[:]",
            "            data.remove(i)",
            "            for j in permutation_with_duplicates(data):",
            "                ret.append([i] + j)",
            "        return ret",
            "def make_divisors(n):",
            "    lower_divisors , upper_divisors = [], []",
            "    i = 1",
            "    while i*i <= n:",
            "        if n % i == 0:",
            "            lower_divisors.append(i)",
            "            if i != n // i:",
            "                upper_divisors.append(n//i)",
            "        i += 1",
            "    return lower_divisors + upper_divisors[::-1]",
            "# ここから書き始める",
            "h, w = map(int, input().split())",
            "s = [[j for j in input()] for i in range(h)]",
            "ans = 0",
            "for i in range(h):",
            "    for j in range(w):",
            "        queue = deque([[i, j, 0]])",
            "        visited = [[0 for _ in range(w)] for _ in range(h)]",
            "        while queue:",
            "            y, x, cnt = queue.popleft()",
            "            if not (0 <= y < h and 0 <= x < w) or visited[y][x] == 1 or s[y][x] == \"#\":",
            "                continue",
            "            ans = max(ans, cnt)",
            "            visited[y][x] = 1",
            "            for p in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
            "                y2 = y + p[0]",
            "                x2 = x + p[1]",
            "                queue.append([y2, x2, cnt + 1])",
            "# print(s)",
            "print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2
        ]
    },
    {
        "content": [
            "def I(): return int(input())",
            "def MI(): return map(int, input().split())",
            "def LI(): return list(map(int, input().split()))",
            "def main():",
            "    ##########################################",
            "    import heapq",
            "    class Dijkstra():",
            "        \"\"\"",
            "        ・有向 / 無向は問わない(無向の場合は，逆向きの辺もたす)",
            "        ・負のコストがない場合のみ",
            "        ・計算量はO(E log|V|)",
            "        ・heapを使うことで頂点を走査する必要がなくなる（代わりに，距離更新したものは確定でなくともqueに入れておく）",
            "        ・復元なし",
            "        \"\"\"",
            "        #最短のpathをたす",
            "        class Edge():",
            "            #重み付き有向辺",
            "            def __init__(self, _to, _cost):",
            "                self.to =_to",
            "                self.cost = _cost",
            "        def __init__(self, V):",
            "            #引数Vは頂点数",
            "            self.inf=10**20",
            "            self.G = [[] for _ in range(V)] #隣接リストG[u][i]が頂点uのi番目の辺",
            "            self. _E = 0 #辺の数",
            "            self._V = V #頂点数",
            "        #proparty - 辺の数",
            "        def E(self):",
            "            return self._E",
            "        #proparty - 頂点数",
            "        def V(self):",
            "            return self._V",
            "        def add(self, _from, _to, _cost):",
            "            #2頂点と辺のコストを追加",
            "            self.G[_from].append(self.Edge(_to,_cost))",
            "            self._E +=1",
            "        def add2(self, _from, _to, _cost):",
            "            #2頂点と辺のコスト（無向）を追加",
            "            self.G[_from].append(self.Edge(_to, _cost))",
            "            self.G[_to].append(self.Edge(_from, _cost))",
            "            self._E +=2",
            "        def shortest_path(self,s):#,g):",
            "            #始点sから頂点iまでの最短経路長のリストを返す",
            "            que = [] #priority queue",
            "            d = [self.inf] * self.V()",
            "            #prev = [None]*self.V() #prev[j]は，sからjへ最短経路で行くときのjの一つ前の場所",
            "            #復元で使う",
            "            d[s] = 0",
            "            heapq.heappush(que,(0,s)) #始点の距離と頂点番号をヒープに追加",
            "            while len(que)!=0:",
            "                #キューに格納されてある中で一番コストが小さい頂点を取り出す",
            "                cost,v = heapq.heappop(que)",
            "                #キューに格納された最短経路長候補がdの距離よりも大きい場合に処理をスキップ",
            "                if d[v] < cost:",
            "                    continue",
            "                #頂点vに隣接する各頂点iに対して，vを経由した場合の距離を計算して，これがd[i]よりも小さい場合に更新",
            "                for i in range(len(self.G[v])):",
            "                    e = self.G[v][i] #vのi個目の隣接辺",
            "                    if d[e.to] > d[v] + e.cost:",
            "                        d[e.to] = d[v] + e.cost #更新",
            "                        #prev[e.to] = v",
            "                        #復元で使う",
            "                        heapq.heappush(que,(d[e.to],e.to)) #queに新たな最短経路長候補を追加",
            "            \"\"\"#sからgまでの最短経路",
            "            path = []",
            "            pos = g #今いる場所，ゴールで初期化",
            "            for _ in range(self.V()+1):",
            "                path.append(pos)",
            "                if pos == s:",
            "                    break",
            "                #print(\"pos:\",format(pos))",
            "                pos = prev[pos]",
            "            path.reverse()",
            "            #print(path)\"\"\"",
            "            return d#,path",
            "    ########################",
            "    mod=10**9+7",
            "    H,W=MI()",
            "    S=[]",
            "    S.append(\"#\"*(W+2))",
            "    for i in range(H):",
            "        s=\"#\"+input()+\"#\"",
            "        S.append(s)",
            "    S.append(\"#\"*(W+2))",
            "    djk=Dijkstra((H+2)*(W+2))",
            "    dx=[0,0,1,-1]",
            "    dy=[1,-1,0,0]",
            "    for i in range(1,H+1):",
            "        for j in range(1,W+1):",
            "            if S[i][j]==\".\":",
            "                for k in range(4):",
            "                    ii=i+dx[k]",
            "                    jj=j+dy[k]",
            "                    if S[ii][jj]==\".\":",
            "                        v= (W+2)*i + j",
            "                        nv=(W+2)*ii+jj",
            "                        djk.add2(v,nv,1)",
            "    ans=0",
            "    for i in range((H+2)*(W+2)):",
            "        d=djk.shortest_path(i)",
            "        for di in d:",
            "            if di<=10**10:",
            "                ans=max(ans,di)",
            "    print(ans)",
            "main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "class Graph:",
            "    #入力定義",
            "    def __init__(self,vertex=[]):",
            "        self.vertex=list(vertex)",
            "        self.edge_number=0",
            "        self.adjacent={v:set() for v in vertex}",
            "    #頂点の追加",
            "    def add_vertex(self,*adder):",
            "        k=len(self.vertex)",
            "        m=0",
            "        for u in adder:",
            "            if u not in self.adjacent:",
            "                self.adjacent[u]=set()",
            "                self.vertex.append(u)",
            "    #辺の追加",
            "    def add_edge(self,From,To):",
            "        for w in [From,To]:",
            "            if w not in self.adjacent:",
            "                self.add_vertex(w)",
            "        if To not in self.adjacent[From]:",
            "            self.adjacent[From].add(To)",
            "            self.adjacent[To].add(From)",
            "            self.edge_number+=1",
            "    #辺を除く",
            "    def remove_edge(self,u,v):",
            "        for w in [u,v]:",
            "            if w not in self.adjacent:",
            "                self.add_vertex(w)",
            "        if u in self.adjacent[v]:",
            "            self.adjacent[u].remove(v)",
            "            self.adjacent[v].remove(u)",
            "            self.edge_number-=1",
            "    #頂点を除く",
            "    def remove_vertex(self,*v):",
            "        for w in v:",
            "            if w in self.adjacent:",
            "                self.edge_number-=len(self.adjacent[w])",
            "                for u in self.adjacent[w]:",
            "                    self.adjacent[u].remove(w)",
            "                del self.adjacent[w]",
            "    #Walkの追加",
            "    def add_walk(self,*walk):",
            "        n=len(walk)",
            "        for i in range(n-1):",
            "            self.add_edge(walk[i],walk[i+1])",
            "    #Cycleの追加",
            "    def add_cycle(self,*cycle):",
            "        self.add_walk(*cycle)",
            "        self.add_edge(cycle[-1],cycle[0])",
            "    #頂点の交換",
            "    def __vertex_swap(self,p,q):",
            "        self.vertex.sort()",
            "    #グラフに頂点が存在するか否か",
            "    def vertex_exist(self,v):",
            "        return v in self.adjacent",
            "    #グラフに辺が存在するか否か",
            "    def edge_exist(self,u,v):",
            "        if not(self.vertex_exist(u) and self.vertex_exist(v)):",
            "            return False",
            "        return u in self.adjacent[v]",
            "    #近傍",
            "    def neighbohood(self,v):",
            "        if not self.vertex_exist(v):",
            "            return []",
            "        return list(self.adjacent[v])",
            "    #次数",
            "    def degree(self,v):",
            "        if not self.vertex_exist(v):",
            "            return 0",
            "        return len(self.adjacent[v])",
            "    #頂点数",
            "    def vertex_count(self):",
            "        return len(self.vertex)",
            "    #辺数",
            "    def edge_count(self):",
            "        return self.edge_number",
            "    #頂点vを含む連結成分",
            "    def connected_component(self,v):",
            "        if v not in self.adjacent:",
            "            return []",
            "        from collections import deque",
            "        T={u:False for u in self.adjacent}",
            "        T[v]=True",
            "        S=deque([v])",
            "        while S:",
            "            u=S.popleft()",
            "            for w in self.adjacent[u]:",
            "                if not T[w]:",
            "                    T[w]=True",
            "                    S.append(w)",
            "        return [x for x in self.adjacent if T[x]]",
            "    #距離",
            "    def distance(self,u,v):",
            "        from collections import deque",
            "        inf=float(\"inf\")",
            "        T={v:inf  for v in self.adjacent}",
            "        if u==v:",
            "            return 0",
            "        Q=deque([u])",
            "        T[u]=0",
            "        while Q:",
            "            w=Q.popleft()",
            "            for x in self.adjacent[w]:",
            "                if T[x]==inf:",
            "                    T[x]=T[w]+1",
            "                    Q.append(x)",
            "                    if x==v:",
            "                        return T[x]",
            "        return inf",
            "    #ある1点からの距離",
            "    def distance_all(self,u):",
            "        from collections import deque",
            "        inf=float(\"inf\")",
            "        T={v:inf  for v in self.adjacent}",
            "        Q=deque([u])",
            "        T[u]=0",
            "        while Q:",
            "            w=Q.popleft()",
            "            for x in self.adjacent[w]:",
            "                if T[x]==inf:",
            "                    T[x]=T[w]+1",
            "                    Q.append(x)",
            "        return T",
            "    #最短路",
            "    def shortest_path(self,u,v):",
            "        from collections import deque",
            "        inf=float(\"inf\")",
            "        T={v:[] for v in self.vertex}",
            "        if u==v:",
            "            return 0",
            "        Q=deque([u])",
            "        T[u]=[u]",
            "        while Q:",
            "            w=Q.popleft()",
            "            for x in self.adjacent[w]:",
            "                if not T[x]:",
            "                    T[x]=T[w]+[x]",
            "                    Q.append(x)",
            "                    if x==v:",
            "                        return T[x]",
            "        return None",
            "    #グラフの直径",
            "    def diameter(self):",
            "        from collections import deque",
            "        inf=float(\"inf\")",
            "        u=self.vertex[0]",
            "        T={u:inf  for u in self.vertex}",
            "        Q=deque([u])",
            "        T[u]=0",
            "        while Q:",
            "            w=Q.popleft()",
            "            for x in self.adjacent[w]:",
            "                if T[x]==inf:",
            "                    T[x]=T[w]+1",
            "                    Q.append(x)",
            "        w=max(T,key=lambda x:T[x])",
            "        T={u:inf  for u in self.vertex}",
            "        Q=deque([w])",
            "        T[w]=0",
            "        while Q:",
            "            w=Q.popleft()",
            "            for x in self.adjacent[w]:",
            "                if T[x]==inf:",
            "                    T[x]=T[w]+1",
            "                    Q.append(x)",
            "        w=max(T,key=lambda x:T[x])",
            "        return T[w]",
            "def Grid_Graph(m,n):",
            "    E=[]",
            "    for x in range(1,m+1):",
            "        E+=[(x,y) for y in range(1,n+1)]",
            "    G=Graph(E)",
            "    H=[(1,0),(0,1)]",
            "    for y in range(1,n+1):",
            "        for x in range(1,m+1):",
            "            for a,b in H:",
            "                p=x+a",
            "                q=y+b",
            "                if 1<=p<=m and 1<=q<=n:",
            "                    G.add_edge((x,y),(p,q))",
            "    return G",
            "#====================================================",
            "H,W=map(int,input().split())",
            "G=Grid_Graph(W,H)",
            "for y in range(H):",
            "    S=input()",
            "    for x in range(W):",
            "        if S[x]==\"#\":",
            "            G.remove_vertex((x+1,y+1))",
            "M=-1",
            "for a in G.adjacent:",
            "    U=G.distance_all(a)",
            "    M=max(M,max(U.values()))",
            "print(M)"
        ],
        "label": [
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "import sys",
            "sys.setrecursionlimit(10**7) #再帰関数の上限,10**5以上の場合python",
            "import math",
            "from copy import copy, deepcopy",
            "from copy import deepcopy as dcp",
            "from operator import itemgetter",
            "from bisect import bisect_left, bisect, bisect_right#2分探索",
            "#bisect_left(l,x), bisect(l,x)#aはソート済みである必要あり。aの中からx未満の要素数を返す。rightだと以下",
            "from collections import deque, defaultdict",
            "#deque(l), pop(), append(x), popleft(), appendleft(x)",
            "#q.rotate(n)で → にn回ローテート",
            "from collections import Counter#文字列を個数カウント辞書に、",
            "#S=Counter(l),S.most_common(x),S.keys(),S.values(),S.items()",
            "from itertools import accumulate,combinations,permutations,product#累積和",
            "#list(accumulate(l))",
            "from heapq import heapify,heappop,heappush",
            "#heapify(q),heappush(q,a),heappop(q) #q=heapify(q)としないこと、返り値はNone",
            "from functools import reduce,lru_cache#pypyでもうごく",
            "#@lru_cache(maxsize = None)#maxsizeは保存するデータ数の最大値、2**nが最も高効率",
            "from decimal import Decimal",
            "def input():",
            "    x=sys.stdin.readline()",
            "    return x[:-1] if x[-1]==\"\\n\" else x",
            "def printe(*x):print(\"## \",*x,file=sys.stderr)",
            "def printl(li): _=print(*li, sep=\"\\n\") if li else None",
            "def argsort(s, return_sorted=False):",
            "    inds=sorted(range(len(s)), key=lambda k: s[k])",
            "    if return_sorted: return inds, [s[i] for i in inds]",
            "    return inds",
            "def alp2num(c,cap=False): return ord(c)-97 if not cap else ord(c)-65",
            "def num2alp(i,cap=False): return chr(i+97) if not cap else chr(i+65)",
            "def matmat(A,B):",
            "    K,N,M=len(B),len(A),len(B[0])",
            "    return [[sum([(A[i][k]*B[k][j]) for k in range(K)]) for j in range(M)] for i in range(N)]",
            "def matvec(M,v):",
            "    N,size=len(v),len(M)",
            "    return [sum([M[i][j]*v[j] for j in range(N)]) for i in range(size)]",
            "def T(M):",
            "    n,m=len(M),len(M[0])",
            "    return [[M[j][i] for j in range(n)] for i in range(m)]",
            "def binr(x): return bin(x)[2:]",
            "def bitcount(x): #xは64bit整数",
            "    x= x - ((x >> 1) & 0x5555555555555555)",
            "    x= (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)",
            "    x= (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f",
            "    x+= (x >> 8); x+= (x >> 16); x+= (x >> 32)",
            "    return x & 0x7f",
            "def main():",
            "    mod = 1000000007",
            "    #w.sort(key=itemgetter(1),reverse=True)  #二個目の要素で降順並び替え",
            "    #N = int(input())",
            "    H,W = map(int, input().split())",
            "    #A = tuple(map(int, input().split())) #1行ベクトル",
            "    S = tuple(input() for i in range(H)) #改行ベクトル",
            "    #S = tuple(tuple(map(int, input().split())) for i in range(N)) #改行行列",
            "    n=H*W",
            "    inf=10000000",
            "    def warshall_floyd():#n^3, 処理が軽いので多少ギリギリでも通る",
            "        #d[i][j]: iからjへの最短距離",
            "        #初期化",
            "        d = [[inf]*n for i in range(n)]",
            "        for i in range(H):",
            "            for j in range(W):",
            "                if S[i][j]!=\".\":",
            "                    continue",
            "                for ni,nj in ((i+1,j),(i-1,j),(i,j+1),(i,j-1)):",
            "                    if 0<=ni<H and 0<=nj<W and S[ni][nj]==\".\":",
            "                        d[i*W+j][ni*W+nj]=1",
            "        for i in range(n):",
            "            d[i][i] = 0 #自身のところに行くコストは０",
            "        for k in range(n):",
            "            for i in range(n):",
            "                for j in range(i+1,n):#無向グラフ,有向グラフの場合はrange(0,n)",
            "                    x = min(d[i][j],d[i][k] + d[k][j])",
            "                    d[i][j]=x",
            "                    d[j][i]=x#無向グラフの場合",
            "                # if i==j and d[i][i]<0: #負閉路がある場合",
            "                #     return -1",
            "        return d",
            "    d=warshall_floyd()",
            "    ans=0",
            "    for i in range(H):",
            "        for j in range(W):",
            "            if S[i][j]!=\".\":",
            "                continue",
            "            for ni in range(H):",
            "                for nj in range(W):",
            "                    if d[i*W+j][ni*W+nj]<inf:",
            "                        ans=max(ans,d[i*W+j][ni*W+nj])",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "from collections import defaultdict, deque, Counter",
            "import math",
            "# import copy",
            "from bisect import bisect_left, bisect_right",
            "import heapq",
            "sys.setrecursionlimit(1000000)",
            "# input aliases",
            "input = sys.stdin.readline",
            "getS = lambda: input().strip()",
            "getN = lambda: int(input())",
            "getList = lambda: list(map(int, input().split()))",
            "getZList = lambda: [int(x) - 1 for x in input().split()]",
            "INF = 10 ** 20",
            "MOD = 10**9 + 7",
            "divide = lambda x: pow(x, MOD-2, MOD)",
            "def nck(n, k, kaijyo):",
            "    return (npk(n, k, kaijyo) * divide(kaijyo[k])) % MOD",
            "def npk(n, k, kaijyo):",
            "    if k == 0 or k == n:",
            "        return n % MOD",
            "    return (kaijyo[n] * divide(kaijyo[n-k])) % MOD",
            "def fact_and_inv(SIZE):",
            "    inv = [0] * SIZE  # inv[j] = j^{-1} mod MOD",
            "    fac = [0] * SIZE  # fac[j] = j! mod MOD",
            "    finv = [0] * SIZE  # finv[j] = (j!)^{-1} mod MOD",
            "    inv[1] = 1",
            "    fac[0] = fac[1] = 1",
            "    finv[0] = finv[1] = 1",
            "    for i in range(2, SIZE):",
            "        inv[i] = MOD - (MOD // i) * inv[MOD % i] % MOD",
            "        fac[i] = fac[i - 1] * i % MOD",
            "        finv[i] = finv[i - 1] * inv[i] % MOD",
            "    return fac, finv",
            "def kaijyo(n):",
            "    ret = [1]",
            "    for i in range(1, n + 1):",
            "        ret.append((ret[-1] * i)% MOD)",
            "    return ret",
            "def warshall_floyd(d, n):",
            "    #d[i][j]: iからjへの最短距離",
            "    for k in range(n):",
            "        for i in range(n):",
            "            for j in range(n):",
            "                d[i][j] = min(d[i][j],d[i][k] + d[k][j])",
            "    return d",
            "class TwoDimGrid:",
            "    # 2次元座標 -> 1次元",
            "    def __init__(self, h, w, wall=\"#\"):",
            "        self.h = h",
            "        self.w = w",
            "        self.size = (h+2) * (w+2)",
            "        self.wall = wall",
            "        self.get_grid()",
            "    def get_grid(self):",
            "        grid = [self.wall * (self.w + 2)]",
            "        for i in range(self.h):",
            "            grid.append(self.wall + getS() + self.wall)",
            "        grid.append(self.wall * (self.w + 2))",
            "        self.grid = grid",
            "    def pos(self, x, y):",
            "        return y * (self.w + 2) + x + 1",
            "    def search(self):",
            "        grid = self.grid",
            "        move = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
            "        move_eight = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]",
            "        ans = 0",
            "        for i in range(1, self.h + 1):",
            "            for j in range(1, self.w + 1):",
            "                # pass # ここから何か書いてね",
            "                cx, cy = j, i",
            "                if grid[cy][cx] == \".\":",
            "                    ret = self.search_each(cx, cy)",
            "                    ans = max(ans, ret)",
            "        print(ans)",
            "    def search_each(self, x, y):",
            "        grid = self.grid",
            "        d = deque()",
            "        d.append((x,y))",
            "        dist = [INF for i in range(self.size)]",
            "        # print(x,y, self.size, self.pos(x,y))",
            "        dist[self.pos(x,y)] = 0",
            "        move = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
            "        ret = 0",
            "        while d:",
            "            cx, cy = d.pop()",
            "            ccos = dist[self.pos(cx, cy)]",
            "            ret = max(ret, ccos)",
            "            for mv in move:",
            "                dx, dy = mv",
            "                nx, ny = cx + dx, cy + dy",
            "                # print(nx, ny)",
            "                if grid[ny][nx] == \".\":",
            "                    if dist[self.pos(nx, ny)] > ccos + 1:",
            "                        dist[self.pos(nx, ny)] = ccos + 1",
            "                        d.append((nx, ny))",
            "        return max([r for r in dist if r != INF])",
            "def solve():",
            "    h, w = getList()",
            "    G = TwoDimGrid(h, w)",
            "    G.search()",
            "    return",
            "def main():",
            "    n = getN()",
            "    for _ in range(n):",
            "        solve()",
            "if __name__ == \"__main__\":",
            "    # main()",
            "    solve()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1
        ]
    },
    {
        "content": [
            "# -*- coding: utf-8 -*-",
            "import sys",
            "import math",
            "import os",
            "import itertools",
            "import string",
            "import heapq",
            "import _collections",
            "from collections import Counter",
            "from collections import defaultdict",
            "from collections import deque",
            "from functools import lru_cache",
            "import bisect",
            "import re",
            "import queue",
            "import decimal",
            "class Scanner():",
            "    @staticmethod",
            "    def int():",
            "        return int(sys.stdin.readline().rstrip())",
            "    @staticmethod",
            "    def string():",
            "        return sys.stdin.readline().rstrip()",
            "    @staticmethod",
            "    def map_int():",
            "        return [int(x) for x in Scanner.string().split()]",
            "    @staticmethod",
            "    def string_list(n):",
            "        return [Scanner.string() for i in range(n)]",
            "    @staticmethod",
            "    def int_list_list(n):",
            "        return [Scanner.map_int() for i in range(n)]",
            "    @staticmethod",
            "    def int_cols_list(n):",
            "        return [Scanner.int() for i in range(n)]",
            "class Math():",
            "    @staticmethod",
            "    def gcd(a, b):",
            "        if b == 0:",
            "            return a",
            "        return Math.gcd(b, a % b)",
            "    @staticmethod",
            "    def lcm(a, b):",
            "        return (a * b) // Math.gcd(a, b)",
            "    @staticmethod",
            "    def divisor(n):",
            "        res = []",
            "        i = 1",
            "        for i in range(1, int(n ** 0.5) + 1):",
            "            if n % i == 0:",
            "                res.append(i)",
            "                if i != n // i:",
            "                    res.append(n // i)",
            "        return res",
            "    @staticmethod",
            "    def round_up(a, b):",
            "        return -(-a // b)",
            "    @staticmethod",
            "    def is_prime(n):",
            "        if n < 2:",
            "            return False",
            "        if n == 2:",
            "            return True",
            "        if n % 2 == 0:",
            "            return False",
            "        d = int(n ** 0.5) + 1",
            "        for i in range(3, d + 1, 2):",
            "            if n % i == 0:",
            "                return False",
            "        return True",
            "    @staticmethod",
            "    def fact(N):",
            "        res = {}",
            "        tmp = N",
            "        for i in range(2, int(N ** 0.5 + 1) + 1):",
            "            cnt = 0",
            "            while tmp % i == 0:",
            "                cnt += 1",
            "                tmp //= i",
            "            if cnt > 0:",
            "                res[i] = cnt",
            "        if tmp != 1:",
            "            res[tmp] = 1",
            "        if res == {}:",
            "            res[N] = 1",
            "        return res",
            "def pop_count(x):",
            "    x = x - ((x >> 1) & 0x5555555555555555)",
            "    x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)",
            "    x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f",
            "    x = x + (x >> 8)",
            "    x = x + (x >> 16)",
            "    x = x + (x >> 32)",
            "    return x & 0x0000007f",
            "MOD = int(1e09) + 7",
            "INF = int(1e15)",
            "H, W = (None, None)",
            "S = None",
            "def bfs(h, w):",
            "    if S[h][w] == '#':",
            "        return 0",
            "    q = queue.Queue()",
            "    q.put((w, h))",
            "    steps = [[-1 for _ in range(W)]for _ in range(H)]",
            "    steps[h][w] = 0",
            "    while not q.empty():",
            "        p = q.get()",
            "        DIR = [(-1, 0), (1, 0), (0, 1), (0, -1)]",
            "        for d in DIR:",
            "            n = (p[0] + d[0], p[1] + d[1])",
            "            if not (0 <= n[0] < W and 0 <= n[1] < H):",
            "                continue",
            "            if steps[n[1]][n[0]] != -1:",
            "                continue",
            "            if S[n[1]][n[0]] == '#':",
            "                continue",
            "            steps[n[1]][n[0]] = steps[p[1]][p[0]] + 1",
            "            q.put(n)",
            "    res = 0",
            "    for s in steps:",
            "        res = max(res, max(s))",
            "    return res",
            "def solve():",
            "    global H, W, S",
            "    H, W = Scanner.map_int()",
            "    S = Scanner.string_list(H)",
            "    ans = 0",
            "    for h in range(H):",
            "        for w in range(W):",
            "            ans = max(ans, bfs(h, w))",
            "    print(ans)",
            "def main():",
            "    # sys.stdin = open(\"sample.txt\")",
            "    # T = Scanner.int()",
            "    # for _ in range(T):",
            "    #     solve()",
            "    # print('YNeos'[not solve()::2])",
            "    solve()",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# input()",
            "# int(input())",
            "# map(int, input().split())",
            "# list(map(int, input().split()))",
            "# list(map(int, list(input()))) # スペースがない数字リストを読み込み",
            "import math",
            "import fractions",
            "import sys",
            "import bisect",
            "import heapq  # 優先度付きキュー(最小値取り出し)",
            "import collections",
            "from collections import Counter",
            "from collections import deque",
            "import pprint",
            "import itertools",
            "sr = lambda: input()",
            "ir = lambda: int(sr())",
            "lr = lambda: list(map(int, sr().split()))",
            "\"\"\"nを素因数分解\"\"\"",
            "\"\"\"2以上の整数n => [[素因数, 指数], ...]の2次元リスト\"\"\"",
            "def factorization(n):",
            "    arr = []",
            "    temp = n",
            "    if n == 1:",
            "        return arr",
            "    for i in range(2, int(-(-n ** 0.5 // 1)) + 1):",
            "        if temp % i == 0:",
            "            cnt = 0",
            "            while temp % i == 0:",
            "                cnt += 1",
            "                temp //= i",
            "            arr.append([i, cnt])",
            "    if temp != 1:",
            "        arr.append([temp, 1])",
            "    if arr == []:",
            "        arr.append([n, 1])",
            "    return arr",
            "# a^n",
            "def power(a, n, mod):",
            "    x = 1",
            "    while n:",
            "        if n & 1:",
            "            x *= a % mod",
            "        n >>= 1",
            "        a *= a % mod",
            "    return x % mod",
            "# n*(n-1)*...*(l+1)*l",
            "def kaijo(n, l, mod):",
            "    if n == 0:",
            "        return 1",
            "    a = n",
            "    tmp = n - 1",
            "    while (tmp >= l):",
            "        a = a * tmp % mod",
            "        tmp -= 1",
            "    return a",
            "# Union Find",
            "class UnionFind():",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parents = [-1] * n",
            "    def find(self, x):",
            "        if self.parents[x] < 0:",
            "            return x",
            "        else:",
            "            self.parents[x] = self.find(self.parents[x])",
            "            return self.parents[x]",
            "    def union(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "        if x == y:",
            "            return",
            "        if self.parents[x] > self.parents[y]:",
            "            x, y = y, x",
            "        self.parents[x] += self.parents[y]",
            "        self.parents[y] = x",
            "    def size(self, x):",
            "        return -self.parents[self.find(x)]",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "    def members(self, x):",
            "        root = self.find(x)",
            "        return [i for i in range(self.n) if self.find(i) == root]",
            "    def roots(self):",
            "        return [i for i, x in enumerate(self.parents) if x < 0]",
            "    def group_count(self):",
            "        return len(self.roots())",
            "    def all_group_members(self):",
            "        return {r: self.members(r) for r in self.roots()}",
            "    def __str__(self):",
            "        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())",
            "# 約数生成",
            "def make_divisors(n):",
            "    divisors = []",
            "    for i in range(1, int(n**0.5)+1):",
            "        if n % i == 0:",
            "            divisors.append(i)",
            "            if i != n // i:",
            "                divisors.append(n//i)",
            "    divisors.sort()",
            "    return divisors",
            "inf = 10 ** 18",
            "mod = 10 ** 9 + 7",
            "n,k = lr()",
            "a = lr()",
            "a.sort()",
            "a1 = [0]",
            "for num in a:",
            "    a1.append(a1[-1]+num)",
            "def sumArea(l,r):",
            "    return a1[r]-a1[l]",
            "N = n+1",
            "inv_t = [0]+[1]",
            "for i in range(2,N):",
            "    inv_t += [inv_t[mod % i] * (mod - int(mod / i)) % mod]",
            "def moddiv(a, b):",
            "    return a*inv_t[b]%mod",
            "if k == 1:",
            "    print(0)",
            "    sys.exit()",
            "else:",
            "    ans = 0",
            "    cdp = [1 for i in range(n-k+1)]",
            "    for i in range(n-k):",
            "        cdp[i+1] = moddiv(cdp[i]*(k-1+i)%mod, i+1)",
            "    for i in range(k,n+1):",
            "        tmp = (sumArea(i-1,n)-sumArea(0,n-i+1))%mod",
            "        tmp = (tmp*cdp[i-k])%mod",
            "        ans = (ans+tmp)%mod",
            "    print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            1,
            1,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": [
            "class Combination:",
            "    def __init__(self, n_max, mod=10**9+7):",
            "        # O(n_max + log(mod))",
            "        self.mod = mod",
            "        f = 1",
            "        self.fac = fac = [f]",
            "        for i in range(1, n_max+1):",
            "            f = f * i % mod",
            "            fac.append(f)",
            "        f = pow(f, mod-2, mod)",
            "        self.facinv = facinv = [f]",
            "        for i in range(n_max, 0, -1):",
            "            f = f * i % mod",
            "            facinv.append(f)",
            "        facinv.reverse()",
            "    # \"n 要素\" は区別できる n 要素",
            "    # \"k グループ\" はちょうど k グループ",
            "    def __call__(self, n, r):  # self.C と同じ",
            "        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod",
            "    def C(self, n, r):",
            "        if not 0 <= r <= n: return 0",
            "        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod",
            "    def P(self, n, r):",
            "        if not 0 <= r <= n: return 0",
            "        return self.fac[n] * self.facinv[n-r] % self.mod",
            "    def H(self, n, r):",
            "        if (n == 0 and r > 0) or r < 0: return 0",
            "        return self.fac[n+r-1] * self.facinv[r] % self.mod * self.facinv[n-1] % self.mod",
            "    def rising_factorial(self, n, r):  # 上昇階乗冪 n * (n+1) * ... * (n+r-1)",
            "        return self.fac[n+r-1] * self.facinv[n-1] % self.mod",
            "    def stirling_first(self, n, k):  # 第 1 種スターリング数  lru_cache を使うと O(nk)  # n 要素を k 個の巡回列に分割する場合の数",
            "        if n == k: return 1",
            "        if k == 0: return 0",
            "        return (self.stirling_first(n-1, k-1) + (n-1)*self.stirling_first(n-1, k)) % self.mod",
            "    def stirling_second(self, n, k):  # 第 2 種スターリング数 O(k + log(n))  # n 要素を区別のない k グループに分割する場合の数",
            "        if n == k: return 1  # n==k==0 のときのため",
            "        return self.facinv[k] * sum((-1)**(k-m) * self.C(k, m) * pow(m, n, self.mod) for m in range(1, k+1)) % self.mod",
            "    def balls_and_boxes_3(self, n, k):  # n 要素を区別のある k グループに分割する場合の数  O(k + log(n))",
            "        return sum((-1)**(k-m) * self.C(k, m) * pow(m, n, self.mod) for m in range(1, k+1)) % self.mod",
            "    def bernoulli(self, n):  # ベルヌーイ数  lru_cache を使うと O(n**2 * log(mod))",
            "        if n == 0: return 1",
            "        if n % 2 and n >= 3: return 0  # 高速化",
            "        return (- pow(n+1, self.mod-2, self.mod) * sum(self.C(n+1, k) * self.bernoulli(k) % self.mod for k in range(n))) % self.mod",
            "    def faulhaber(self, k, n):  # べき乗和 0^k + 1^k + ... + (n-1)^k",
            "        # bernoulli に lru_cache を使うと O(k**2 * log(mod))  bernoulli が計算済みなら O(k * log(mod))",
            "        return pow(k+1, self.mod-2, self.mod) * sum(self.C(k+1, j) * self.bernoulli(j) % self.mod * pow(n, k-j+1, self.mod) % self.mod for j in range(k+1)) % self.mod",
            "    def lah(self, n, k):  # n 要素を k 個の空でない順序付き集合に分割する場合の数  O(1)",
            "        return self.C(n-1, k-1) * self.fac[n] % self.mod * self.facinv[k] % self.mod",
            "    def bell(self, n, k):  # n 要素を k グループ以下に分割する場合の数  O(k**2 + k*log(mod))",
            "        return sum(self.stirling_second(n, j) for j in range(1, k+1)) % self.mod",
            "# x * x が選ばれ、かつそれ以外はすべて x 以下が選ばれる場合の数",
            "N, K = map(int, input().split())",
            "A = sorted(map(int, input().split()))",
            "ans_max = ans_min = 0",
            "mod = 10**9+7",
            "comb = Combination(101010)",
            "for i, a in enumerate(A):",
            "    ans_max += a * comb.C(i, K-1)",
            "    ans_min += a * comb.C(N-1-i, K-1)",
            "ans = (ans_max - ans_min) % mod",
            "print(ans)"
        ],
        "label": [
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "MOD = 1000000007  # type: int",
            "class Factorial:",
            "    def __init__(self, MOD):",
            "        self.MOD = MOD",
            "        self.factorials = [1, 1]  # 階乗を求めるためのキャッシュ",
            "        self.invModulos = [0, 1]  # n^-1のキャッシュ",
            "        self.invFactorial_ = [1, 1]  # (n^-1)!のキャッシュ",
            "    def calc(self, n):",
            "        if n <= -1:",
            "            print(\"Invalid argument to calculate n!\")",
            "            print(\"n must be non-negative value. But the argument was \" + str(n))",
            "            exit()",
            "        if n < len(self.factorials):",
            "            return self.factorials[n]",
            "        nextArr = [0]*(n+1-len(self.factorials))",
            "        initialI = len(self.factorials)",
            "        prev = self.factorials[-1]",
            "        m = self.MOD",
            "        for i in range(initialI, n+1):",
            "            prev = nextArr[i-initialI] = prev * i % m",
            "        self.factorials += nextArr",
            "        return self.factorials[n]",
            "    def inv(self, n):",
            "        if n <= -1:",
            "            print(\"Invalid argument to calculate n^(-1)\")",
            "            print(\"n must be non-negative value. But the argument was \" + str(n))",
            "            exit()",
            "        p = self.MOD",
            "        pi = n % p",
            "        if pi < len(self.invModulos):",
            "            return self.invModulos[pi]",
            "        nextArr = [0]*(n+1-len(self.invModulos))",
            "        initialI = len(self.invModulos)",
            "        for i in range(initialI, min(p, n+1)):",
            "            next = -self.invModulos[p % i]*(p//i) % p",
            "            self.invModulos.append(next)",
            "        return self.invModulos[pi]",
            "    def invFactorial(self, n):",
            "        if n <= -1:",
            "            print(\"Invalid argument to calculate (n^(-1))!\")",
            "            print(\"n must be non-negative value. But the argument was \" + str(n))",
            "            exit()",
            "        if n < len(self.invFactorial_):",
            "            return self.invFactorial_[n]",
            "        self.inv(n)  # To make sure already calculated n^-1",
            "        nextArr = [0]*(n+1-len(self.invFactorial_))",
            "        initialI = len(self.invFactorial_)",
            "        prev = self.invFactorial_[-1]",
            "        p = self.MOD",
            "        for i in range(initialI, n+1):",
            "            prev = nextArr[i-initialI] = (prev * self.invModulos[i % p]) % p",
            "        self.invFactorial_ += nextArr",
            "        return self.invFactorial_[n]",
            "class Combination:",
            "    def __init__(self, MOD):",
            "        self.MOD = MOD",
            "        self.factorial = Factorial(MOD)",
            "    def choose_k_from_n(self, n, k):",
            "        if k < 0 or n < k:",
            "            return 0",
            "        k = min(k, n-k)",
            "        f = self.factorial",
            "        return f.calc(n)*f.invFactorial(max(n-k, k))*f.invFactorial(min(k, n-k)) % self.MOD",
            "def solve(N: int, K: int, A: \"List[int]\"):",
            "    c = Combination(MOD)",
            "    A.sort()",
            "    minSum = 0",
            "    for i in range(N-K+1):",
            "        remain = N-i-1",
            "        minSum = (minSum + A[i]*c.choose_k_from_n(remain, K-1)) % MOD",
            "    maxSum = 0",
            "    A.reverse()",
            "    for i in range(N-K+1):",
            "        remain = N-i-1",
            "        maxSum = (maxSum + A[i]*c.choose_k_from_n(remain, K-1)) % MOD",
            "    print((maxSum - minSum + MOD) % MOD)",
            "    return",
            "# Generated by 1.1.6 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)",
            "def main():",
            "    def iterate_tokens():",
            "        for line in sys.stdin:",
            "            for word in line.split():",
            "                yield word",
            "    tokens = iterate_tokens()",
            "    N = int(next(tokens))  # type: int",
            "    K = int(next(tokens))  # type: int",
            "    A = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"",
            "    solve(N, K, A)",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "sys.setrecursionlimit(10**7) #再帰関数の上限,10**5以上の場合python",
            "import math",
            "from copy import copy, deepcopy",
            "from copy import deepcopy as dcp",
            "from operator import itemgetter",
            "from bisect import bisect_left, bisect, bisect_right#2分探索",
            "#bisect_left(l,x), bisect(l,x)#aはソート済みである必要あり。aの中からx未満の要素数を返す。rightだと以下",
            "from collections import deque, defaultdict",
            "#deque(l), pop(), append(x), popleft(), appendleft(x)",
            "#q.rotate(n)で → にn回ローテート",
            "from collections import Counter#文字列を個数カウント辞書に、",
            "#S=Counter(l),S.most_common(x),S.keys(),S.values(),S.items()",
            "from itertools import accumulate,combinations,permutations,product#累積和",
            "#list(accumulate(l))",
            "from heapq import heapify,heappop,heappush",
            "#heapify(q),heappush(q,a),heappop(q) #q=heapify(q)としないこと、返り値はNone",
            "from functools import reduce,lru_cache#pypyでもうごく",
            "#@lru_cache(maxsize = None)#maxsizeは保存するデータ数の最大値、2**nが最も高効率",
            "from decimal import Decimal",
            "def input():",
            "    x=sys.stdin.readline()",
            "    return x[:-1] if x[-1]==\"\\n\" else x",
            "def printe(*x):print(\"## \",*x,file=sys.stderr)",
            "def printl(li): _=print(*li, sep=\"\\n\") if li else None",
            "def argsort(s, return_sorted=False):",
            "    inds=sorted(range(len(s)), key=lambda k: s[k])",
            "    if return_sorted: return inds, [s[i] for i in inds]",
            "    return inds",
            "def alp2num(c,cap=False): return ord(c)-97 if not cap else ord(c)-65",
            "def num2alp(i,cap=False): return chr(i+97) if not cap else chr(i+65)",
            "def matmat(A,B):",
            "    K,N,M=len(B),len(A),len(B[0])",
            "    return [[sum([(A[i][k]*B[k][j]) for k in range(K)]) for j in range(M)] for i in range(N)]",
            "def matvec(M,v):",
            "    N,size=len(v),len(M)",
            "    return [sum([M[i][j]*v[j] for j in range(N)]) for i in range(size)]",
            "def T(M):",
            "    n,m=len(M),len(M[0])",
            "    return [[M[j][i] for j in range(n)] for i in range(m)]",
            "def binr(x): return bin(x)[2:]",
            "def bitcount(x): #xは64bit整数",
            "    x= x - ((x >> 1) & 0x5555555555555555)",
            "    x= (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)",
            "    x= (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f",
            "    x+= (x >> 8); x+= (x >> 16); x+= (x >> 32)",
            "    return x & 0x7f",
            "def main():",
            "    mod = 1000000007",
            "    #w.sort(key=itemgetter(1),reverse=True)  #二個目の要素で降順並び替え",
            "    #N = int(input())",
            "    N, K = map(int, input().split())",
            "    A = list(map(int, input().split())) #1行ベクトル",
            "    #L = tuple(int(input()) for i in range(N)) #改行ベクトル",
            "    #S = tuple(tuple(map(int, input().split())) for i in range(N)) #改行行列",
            "    ans=0",
            "    maxn=N",
            "    fact=[1]*(maxn+1)#NはnCrの最大のn",
            "    invs=[1]*(maxn+1);invs[0]=0",
            "    ifact=[1]*(maxn+1)",
            "    for i in range(2,maxn+1):",
            "        fact[i]=(fact[i-1]*i)%mod",
            "        invs[i]=invs[mod%i]*(-(mod//i))%mod",
            "        ifact[i]=(ifact[i-1]*invs[i])%mod",
            "    def perm(n,r): return fact[n]*ifact[n-r]%mod",
            "    def comb(n,r):",
            "        if r>n:return 0",
            "        return (fact[n]*ifact[r]%mod)*ifact[n-r]%mod",
            "    def multicomb(self,n,*rs):#n!/(r1!*r2!*r3!*...)",
            "        ans=fact[n]",
            "        for r in rs: ans=(ans*self.ifact[r])%self.mod",
            "        return ans",
            "    A.sort()",
            "    for i in range(N):",
            "        ans-=A[i]*comb(N-i-1,K-1)",
            "        ans%=mod",
            "    for i in range(N-1,-1,-1):",
            "        ans+=A[i]*comb(i,K-1)",
            "        ans%=mod",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "MOD = 1000000007  # type: int",
            "def solve(N: int, K: int, A: \"List[int]\"):",
            "    mf = ModFactorial(MOD, N+1)",
            "    A = sorted(A)",
            "    ans = 0",
            "    for i, a in enumerate(A, 1):",
            "        if N-i < K-1:",
            "            break",
            "        ans = (ans + (MOD - a) * mf.combination(N-i, K-1) % MOD) % MOD",
            "    for i, a in enumerate(reversed(A), 1):",
            "        if N-i < K-1:",
            "            break",
            "        ans = (ans + (MOD + a) * mf.combination(N-i, K-1) % MOD) % MOD",
            "    return ans",
            "def mod_range(mod, start, stop=None, step=1):",
            "    if stop == None:",
            "        stop = start",
            "        start = 0",
            "    return map(lambda i: i % mod, range(start, stop, step))",
            "def mod_inv(mod, n):",
            "    '''",
            "    >>> mod_inv(3, 2)",
            "    2",
            "    >>> mod_inv(1000000007, 2)",
            "    500000004",
            "    '''",
            "    return pow(n, mod-2, mod)",
            "def mod_permutation(mod, n, r):",
            "    '''",
            "    >>> mod_permutation(1000000007, 10, 2)",
            "    90",
            "    >>> mod_permutation(7, 10, 2)",
            "    6",
            "    '''",
            "    m = 1",
            "    for i in mod_range(mod, n-r+1, n+1):",
            "        m = (m * i) % mod",
            "    return m",
            "def mod_factorial(mod, n):",
            "    '''",
            "    >>> mod_factorial(1000000007, 10)",
            "    3628800",
            "    >>> mod_factorial(7, 6)",
            "    6",
            "    '''",
            "    return mod_permutation(mod, n, n)",
            "def mod_combination(mod, n, r):",
            "    '''",
            "    >>> mod_combination(1000000007, 10, 2)",
            "    45",
            "    >>> mod_combination(7, 10, 2)",
            "    3",
            "    '''",
            "    return mod_permutation(mod, n, r) * mod_inv(mod, mod_factorial(mod, r)) % mod",
            "class ModFactorial:",
            "    def __init__(self, mod, size=1):",
            "        '''",
            "        >>> ModFactorial(7, 7)",
            "        Traceback (most recent call last):",
            "        ...",
            "        AssertionError",
            "        '''",
            "        assert mod > size",
            "        self._mod = mod",
            "        self._init_factorials(size)",
            "    def _mod_range(self, start, stop=None, step=1):",
            "        return mod_range(self._mod, start, stop, step)",
            "    def _mod_inv(self, n):",
            "        return mod_inv(self._mod, n)",
            "    def _init_factorials(self, size):",
            "        '''",
            "        >>> mf1 = ModFactorial(1000000007)",
            "        >>> mf2 = ModFactorial(1000000007, 10)",
            "        >>> mf1.factorial(10) == mf2.factorial(10)",
            "        True",
            "        '''",
            "        self._factorials = [1] * size",
            "        n = 1 # リストの参照は遅いので減らす",
            "        for i, m in enumerate(self._mod_range(1, size), 1):",
            "            n = (n * m) % self._mod",
            "            self._factorials[i] = n",
            "    def _append_factorials(self, n):",
            "        for m in map(lambda i: i % self._mod, range(len(self._factorials), n+1)):",
            "            self._factorials.append((self._factorials[-1] * m) % self._mod)",
            "    def factorial(self, n):",
            "        '''",
            "        >>> ModFactorial(1000000007).factorial(10)",
            "        3628800",
            "        >>> ModFactorial(7).factorial(6)",
            "        6",
            "        >>> ModFactorial(7).factorial(7)",
            "        Traceback (most recent call last):",
            "        ...",
            "        AssertionError",
            "        '''",
            "        assert n < self._mod",
            "        if len(self._factorials) <= n:",
            "            self._append_factorials(n)",
            "        return self._factorials[n]",
            "    def factorial_inv(self, n):",
            "        '''",
            "        >>> MOD = 1000000007",
            "        >>> mf = ModFactorial(MOD)",
            "        >>> mf.factorial_inv(10)",
            "        283194722",
            "        >>> mf.factorial_inv(10) * mf.factorial(10) % MOD",
            "        1",
            "        >>> MOD = 7",
            "        >>> mf = ModFactorial(MOD)",
            "        >>> mf.factorial_inv(6)",
            "        6",
            "        >>> mf.factorial_inv(6) * mf.factorial(6) % MOD",
            "        1",
            "        '''",
            "        return self._mod_inv(self.factorial(n))",
            "    def permutation(self, n, r):",
            "        '''",
            "        >>> ModFactorial(1000000007).permutation(10, 2)",
            "        90",
            "        '''",
            "        return self.factorial(n) * self.factorial_inv(n-r) % self._mod",
            "    def combination(self, n, r):",
            "        '''",
            "        >>> ModFactorial(1000000007).combination(10, 2)",
            "        45",
            "        '''",
            "        return self.permutation(n, r) * self.factorial_inv(r) % self._mod",
            "# Generated by 1.1.6 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)",
            "def main():",
            "    def iterate_tokens():",
            "        for line in sys.stdin:",
            "            for word in line.split():",
            "                yield word",
            "    tokens = iterate_tokens()",
            "    N = int(next(tokens))  # type: int",
            "    K = int(next(tokens))  # type: int",
            "    A = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"",
            "    print(solve(N, K, A))",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product                # product(iter, repeat=n)",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4",
            "def main():",
            "    mod = 1000000007                  # 10^9+7",
            "    inf = float('inf')",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():  return int(input())",
            "    def mi():  return map(int, input().split())",
            "    def mi_0(): return map(lambda x: int(x)-1, input().split())",
            "    def lmi(): return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():  return list(input())",
            "    n, k = mi()",
            "    L = [-float('inf')] + lmi()    # 1-index",
            "    L.sort()",
            "    FACT_MOD = [1] * (n + 1)    # i! % mod が FACT_MOD(i) に登録される",
            "    for i in range(1, n+1):",
            "        FACT_MOD[i] = (FACT_MOD[i-1] * i) % mod",
            "    def combination(n, r, mod):",
            "        \"\"\"",
            "        フェルマーの小定理",
            "        a ^ p-1 ≡ 1 (mod p)",
            "        a ^ p-2 ≡ 1/a (mod p) (逆元)",
            "        nCr = (n!) / ((n-r)! * r!) だが、mod p の世界ではこの分母を逆元を用いて計算しておくことが可能",
            "        >>> m = 1000000007",
            "        >>> combination(10, 5, m)",
            "        252",
            "        >>> combination(100, 50, m)",
            "        538992043",
            "        \"\"\"",
            "        numerator = FACT_MOD[n]",
            "        denominator = (FACT_MOD[n-r] * FACT_MOD[r]) % mod",
            "        # pow はすでに繰り返し二乗法で効率的に実装されている",
            "        return (numerator * pow(denominator, mod-2, mod)) % mod",
            "    # ==================================",
            "    ans = 0",
            "    prev = 0",
            "    # k up to n",
            "    for i in range(k, n + 1):",
            "        prev = (prev + combination(i-2, k-2, mod)) % mod",
            "        # print(prev)",
            "        ans = (ans + prev * L[i]) % mod",
            "        # print(f\"{i} {ans}\")",
            "    prev = 0",
            "    # n-k+1 down to 1",
            "    for j in range(n - k + 1, 0, -1):",
            "        prev = (prev + combination(n-j-1, k-2, mod)) % mod",
            "        ans = (ans - prev * L[j]) % mod",
            "        # print(f\"{j} {ans}\")",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math, cmath",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import _heapify_max, _heappop_max, _siftdown_max",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    Num = Union[int, float]",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def isp():   return input().split()",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    # def _heappush_max(h, item): h.append(item); _siftdown_max(h, 0, len(h)-1)",
            "    n = ii()",
            "    name = []",
            "    duration = []",
            "    for _ in range(n):",
            "        s, t = isp()",
            "        name.append(s)",
            "        duration.append(int(t))",
            "    x = input()",
            "    ind = name.index(x)",
            "    print(sum(duration[ind+1:]))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "sys.setrecursionlimit(10**7) #再帰関数の上限,10**5以上の場合python",
            "import math",
            "from copy import copy, deepcopy",
            "from copy import deepcopy as dcp",
            "from operator import itemgetter",
            "from bisect import bisect_left, bisect, bisect_right#2分探索",
            "#bisect_left(l,x), bisect(l,x)#aはソート済みである必要あり。aの中からx未満の要素数を返す。rightだと以下",
            "from collections import deque, defaultdict",
            "#deque(l), pop(), append(x), popleft(), appendleft(x)",
            "#q.rotate(n)で → にn回ローテート",
            "from collections import Counter#文字列を個数カウント辞書に、",
            "#S=Counter(l),S.most_common(x),S.keys(),S.values(),S.items()",
            "from itertools import accumulate,combinations,permutations,product#累積和",
            "#list(accumulate(l))",
            "from heapq import heapify,heappop,heappush",
            "#heapify(q),heappush(q,a),heappop(q) #q=heapify(q)としないこと、返り値はNone",
            "from functools import reduce,lru_cache#pypyでもうごく",
            "#@lru_cache(maxsize = None)#maxsizeは保存するデータ数の最大値、2**nが最も高効率",
            "from decimal import Decimal",
            "from argparse import ArgumentParser",
            "args=ArgumentParser()",
            "args.add_argument('-loc', '--local', type=bool,default=False)",
            "LOCAL=args.parse_args().local",
            "def input():",
            "    x=sys.stdin.readline();",
            "    if x[-1]==\"\\n\":",
            "        return x.rstrip()",
            "    return x",
            "def printe(*x):_=print(\"## \",*x,file=sys.stderr) if LOCAL else 0",
            "def printl(li): _=print(*li, sep=\"\\n\") if li else None",
            "def argsort(s, return_sorted=False):",
            "    inds=sorted(range(len(s)), key=lambda k: s[k])",
            "    if return_sorted: return inds, [s[i] for i in inds]",
            "    return inds",
            "def alp2num(c,cap=False): return ord(c)-97 if not cap else ord(c)-65",
            "def num2alp(i,cap=False): return chr(i+97) if not cap else chr(i+65)",
            "def matmat(A,B):",
            "    K,N,M=len(B),len(A),len(B[0])",
            "    return [[sum([(A[i][k]*B[k][j]) for k in range(K)]) for j in range(M)] for i in range(N)]",
            "def matvec(M,v):",
            "    N,size=len(v),len(M)",
            "    return [sum([M[i][j]*v[j] for j in range(N)]) for i in range(size)]",
            "def T(M):",
            "    n,m=len(M),len(M[0])",
            "    return [[M[j][i] for j in range(n)] for i in range(m)]",
            "def binr(x): return bin(x)[2:]",
            "def bitcount(x): #xは64bit整数",
            "    x= x - ((x >> 1) & 0x5555555555555555)",
            "    x= (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)",
            "    x= (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f",
            "    x+= (x >> 8); x+= (x >> 16); x+= (x >> 32)",
            "    return x & 0x7f",
            "def main():",
            "    mod = 1000000007",
            "    #w.sort(key=itemgetter(1),reverse=True)  #二個目の要素で降順並び替え",
            "    #N = int(input())",
            "    N, K = map(int, input().split())",
            "    R,S,P=map(int, input().split())",
            "    T=input()",
            "    #A = tuple(map(int, input().split())) #1行ベクトル",
            "    #L = tuple(int(input()) for i in range(N)) #改行ベクトル",
            "    #S = tuple(tuple(map(int, input().split())) for i in range(N)) #改行行列",
            "    ans=0",
            "    for k in range(K):",
            "        i=0",
            "        l=[]",
            "        while i+k<N:",
            "            l.append(i+k)",
            "            i+=K",
            "        if not l:",
            "            continue",
            "        dp=[[0]*3 for _ in range(len(l)+1)]",
            "        for i in range(1,len(l)+1):",
            "            si=T[l[i-1]]",
            "            sc=[0]*3",
            "            if si==\"r\":",
            "                sc[2]=P",
            "            elif si==\"s\":",
            "                sc[0]=R",
            "            elif si==\"p\":",
            "                sc[1]=S",
            "            for j in range(3):",
            "                for j2 in range(3):",
            "                    if j==j2:continue",
            "                    dp[i][j]=max(dp[i][j],dp[i-1][j2]+sc[j])",
            "            ans+=max(dp[-1])",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "from collections import defaultdict",
            "class Tree:",
            "    def __init__(self, n, edges, weight=False):",
            "        self.n = n",
            "        self.adj = [[] for _ in range(n)]",
            "        self.parent = [-1] * self.n",
            "        self.children = [[] for _ in range(self.n)]",
            "        self.dist = [-1] * self.n  # 根からの距離",
            "        self.depth = [-1] * self.n  # 根からの深さ(cost=1での距離)",
            "        self.weight = defaultdict(lambda: 10**18)",
            "        if weight:",
            "            for u, v, weight in edges:",
            "                self.adj[u].append(v)",
            "                self.adj[v].append(u)",
            "                self.weight[(u, v)] = weight",
            "                self.weight[(v, u)] = weight",
            "        else:",
            "            for u, v in edges:",
            "                self.adj[u].append(v)",
            "                self.adj[v].append(u)",
            "                self.weight[(u, v)] = 1",
            "                self.weight[(v, u)] = 1",
            "    def set_root(self, root):  # O(n)",
            "        self.root = root",
            "        self.order = [root]",
            "        self.dist[root] = 0",
            "        self.depth[root] = 0",
            "        stack = [root]",
            "        while stack:",
            "            v = stack.pop()",
            "            for child in self.adj[v]:",
            "                if child == self.parent[v]:",
            "                    continue",
            "                else:",
            "                    self.parent[child] = v",
            "                    self.children[v].append(child)",
            "                    self.dist[child] = self.dist[v] + self.weight[(v, child)]",
            "                    self.depth[child] = self.depth[v] + 1",
            "                    self.order.append(child)",
            "                    stack.append(child)",
            "    def get_root_path(self, target):",
            "        path = [target]",
            "        v = target",
            "        while v != self.root:",
            "            path.append(self.parent[v])",
            "            v = self.parent[v]",
            "        path.reverse()",
            "        return path",
            "    def get_diameter(self, restore=False):  # double-sweepで求める  O(n)",
            "        u = self.dist.index(max(self.dist))  # 根から一番遠いものを根とし、そこから一番遠いものを見つける",
            "        dist_u = [-1] * self.n",
            "        dist_u[u] = 0",
            "        stack = [u]",
            "        parent_u = [None for _ in range(self.n)]",
            "        while stack:",
            "            v = stack.pop()",
            "            for child in self.adj[v]:",
            "                if dist_u[child] == -1:",
            "                    dist_u[child] = dist_u[v] + self.weight[(v, child)]",
            "                    parent_u[child] = v",
            "                    stack.append(child)",
            "        diameter = max(dist_u)",
            "        v = dist_u.index(diameter)",
            "        if restore:",
            "            path = [v]",
            "            while v != u:",
            "                v = parent_u[v]",
            "                path.append(v)",
            "            path.reverse()  # [u,...,v]",
            "            return diameter, path",
            "        else:",
            "            return diameter, u, v",
            "    # --- Heavy Light Decomposition --- #",
            "    def heavy_light_decompose(self):  # O(n)",
            "        self.subsize = [1] * self.n  # 部分木の要素数(自分含む)",
            "        self.head = [self.root] * self.n  # 分割された各部分木の先頭",
            "        self.tree_order = [0] * self.n",
            "        # 末端の方から各頂点の部分木の要素数(subsize)を計算していって、",
            "        # heavy-nodeがchildren[v][0]に来るようにする",
            "        for v in reversed(self.order):",
            "            v_kids = self.children[v]  # 名前が長いのでalias",
            "            for i, child in enumerate(v_kids):",
            "                self.subsize[v] += self.subsize[child]",
            "                if self.subsize[child] > self.subsize[v_kids[0]]:",
            "                    v_kids[i], v_kids[0] = v_kids[0], v_kids[i]",
            "        # それぞれのnodeについて分割されたchianの先頭(head)を記録",
            "        # また、DFSの行きがけ順をtree_orderとする headの浅い順でchainが入る",
            "        stack = [self.root]",
            "        tree_label = 0",
            "        while stack:",
            "            v = stack.pop()",
            "            self.tree_order[v] = tree_label",
            "            tree_label += 1",
            "            for child in reversed(self.children[v]):  # スタックを使ったdfsのため逆にしておく",
            "                if child == self.children[v][0]:",
            "                    self.head[child] = self.head[v]",
            "                else:",
            "                    self.head[child] = child  # light-nodeは切り離されたsub-treeのheadになる",
            "                stack.append(child)",
            "    def get_hld_chain_paths(self, u, v):  # (u,v)間の経路をchainごとに返す [l,r)",
            "        ret = []",
            "        while True:",
            "            if self.tree_order[u] > self.tree_order[v]:",
            "                u, v = v, u",
            "            if self.head[u] == self.head[v]:",
            "                ret.append((self.tree_order[u], self.tree_order[v] + 1))",
            "                return ret",
            "            else:",
            "                ret.append((self.tree_order[self.head[v]], self.tree_order[v] + 1))",
            "                v = self.parent[self.head[v]]",
            "    def get_hld_lca(self, u, v):  # Lowest Common Ancestor",
            "        while True:  # head[u] = head[v] になるまで遡る",
            "            if self.tree_order[u] > self.tree_order[v]:",
            "                u, v = v, u",
            "            if self.head[u] == self.head[v]:",
            "                return u",
            "            v = self.parent[self.head[v]]",
            "    def get_hld_distance(self, u, v):",
            "        return self.dist[u] + self.dist[v] - (2 * self.dist[self.get_hld_lca(u, v)])",
            "    def exist_on_path_hld(self, u, v, x):  # u,v間の最短経路上にxがあるかどうか",
            "        return self.get_hld_distance(u, x) + self.get_hld_distance(x, v) == self.get_hld_distance(u, v)",
            "# ---------------------- #",
            "n, u, v = (int(x) for x in input().split())",
            "u -= 1",
            "v -= 1",
            "edges = [tuple(int(x) - 1 for x in input().split()) for _ in range(n - 1)]",
            "tree = Tree(n, edges)",
            "tree.set_root(0)",
            "tree.heavy_light_decompose()",
            "ans = 0",
            "for i in range(n):",
            "    if tree.get_hld_distance(i, u) <= tree.get_hld_distance(i, v):",
            "        ans = max(ans, tree.get_hld_distance(i, v) - 1)",
            "print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            2,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "class LCA(object):",
            "    def __init__(self, n, root, edges, decrement=True):",
            "        \"\"\"",
            "        :param n: 頂点数",
            "        :param root: 木の根",
            "        :param edges: 辺のリスト",
            "        :param decrement:",
            "        :param self.depth: rootを根とした時の各頂点の深さ",
            "        \"\"\"",
            "        self.n = n",
            "        self.decrement = decrement",
            "        self.root = root - self.decrement",
            "        self.edges = [set() for _ in range(self.n)]",
            "        for x, y in edges:",
            "            self.add_edge(x,y)",
            "        self.k_max = (self.n - 1).bit_length()",
            "        self.depth = [-1 if i != self.root else 0 for i in range(self.n)]",
            "        self.doubling = [[-1] * self.n for _ in range(self.k_max)]",
            "        self.parent = [-1]*self.n",
            "        self.dfs()",
            "        for i in range(1, self.k_max):",
            "            for k in range(self.n):",
            "                if self.doubling[i - 1][k] != -1:",
            "                    self.doubling[i][k] = self.doubling[i - 1][self.doubling[i - 1][k]]",
            "    def add_edge(self, x, y):",
            "        \"\"\"",
            "        後から追加した場合は update() をする",
            "        \"\"\"",
            "        if self.decrement:",
            "            x -= 1",
            "            y -= 1",
            "        self.edges[x].add(y)",
            "        self.edges[y].add(x)",
            "    def update(self):",
            "        self.depth = [-1 if i != self.root else 0 for i in range(self.n)]",
            "        self.doubling = [[-1] * self.n for _ in range(self.k_max)]",
            "        self.dfs()",
            "        for i in range(1, self.k_max):",
            "            for k in range(self.n):",
            "                if self.doubling[i - 1][k] != -1:",
            "                    self.doubling[i][k] = self.doubling[i - 1][self.doubling[i - 1][k]]",
            "    def dfs(self):",
            "        next_set = [self.root]",
            "        while next_set:",
            "            p = next_set.pop()",
            "            for q in self.edges[p]:",
            "                if self.depth[q] == -1:",
            "                    self.depth[q] = self.depth[p] + 1",
            "                    self.doubling[0][q] = p",
            "                    next_set += [q]",
            "    def get(self, u, v):",
            "        \"\"\"",
            "        :return: u と v の最近共通祖先の頂点番号を返す",
            "        \"\"\"",
            "        if self.decrement:",
            "            u -= 1",
            "            v -= 1",
            "        if self.depth[v] < self.depth[u]:",
            "            u, v = v, u",
            "        for i in range(self.k_max):",
            "            \"\"\" v を u の位置まで遡らせる \"\"\"",
            "            if (self.depth[v] - self.depth[u]) >> i & 1:",
            "                v = self.doubling[i][v]",
            "        if v == u:",
            "            \"\"\" v の祖先が u だった場合\"\"\"",
            "            return u + self.decrement",
            "        for i in range(self.k_max-1, -1, -1):",
            "            \"\"\" k = 2**(k_max-1), ..., 2**0 について、",
            "            「k個先を確認して共通祖先でないなら u1,v1 をk個先に移動」ということを繰り返す\"\"\"",
            "            parent_u, parent_v = self.doubling[i][u], self.doubling[i][v]",
            "            if parent_u != parent_v:",
            "                u, v = parent_u, parent_v",
            "        return self.doubling[0][u] + self.decrement",
            "    def distance(self, u, v):",
            "        \"\"\"",
            "        :return: u と v の最短距離を求める",
            "        備考: 経路復元をしようとすると O(E)かかるので、経路復元が必要な場合は dfs を用いるとよい",
            "        \"\"\"",
            "        lca_at = self.get(u,v)",
            "        if self.decrement:",
            "            u -= 1",
            "            v -= 1",
            "            lca_at -= 1",
            "        return self.depth[u] + self.depth[v] - 2*self.depth[lca_at]",
            "    def distance_list(self, start=1, save=False):",
            "        \"\"\"",
            "        :param start: スタート地点",
            "        :return: スタート地点から各点への距離のリスト",
            "        \"\"\"",
            "        dist = [-1]*self.n",
            "        if self.decrement:",
            "            start -= 1",
            "        if not save:",
            "            self.parent = [-1] * self.n",
            "        p, t = start, 0",
            "        self.parent[p] = -2",
            "        dist[p] = 0",
            "        next_set = deque([(p, t)])",
            "        while next_set:",
            "            p, t = next_set.popleft()",
            "            for q in self.edges[p]:",
            "                if self.parent[q] != -1:",
            "                    continue",
            "                if q == xx-1:",
            "                    continue",
            "                dist[q] = t + 1",
            "                self.parent[q] = p",
            "                next_set.append((q, t + 1))",
            "        return dist",
            "    def most_distant_point(self, start=1, save=False):",
            "        \"\"\"",
            "        計算量　O(N)",
            "        :return: (start から最も遠い頂点, 距離)",
            "        \"\"\"",
            "        if not save:",
            "            self.parent = [-1] * self.n",
            "        res = (start - self.decrement, 0)",
            "        temp = 0",
            "        for i, dist in enumerate(self.distance_list(start, save=save)):",
            "            if dist > temp:",
            "                temp = dist",
            "                res = (i + self.decrement, dist)",
            "        return res",
            "#################################################################################################",
            "import sys",
            "from collections import deque",
            "input = sys.stdin.readline",
            "N, u, v = map(int, input().split())",
            "edges = []",
            "for _ in range(N-1):",
            "    x, y = map(int, input().split())",
            "    edges.append((x,y))",
            "xx = -3",
            "lca = LCA(N, 1, edges, decrement=True)",
            "p = lca.get(u,v)",
            "lu, lv = lca.depth[u-1] - lca.depth[p-1], lca.depth[v-1] - lca.depth[p-1]",
            "if lu <= lv:",
            "    q, _ = lca.most_distant_point(v)",
            "    print(lca.distance(q,v)-1)",
            "    exit()",
            "else:",
            "    L = (lu+lv)//2",
            "    cnt = 0",
            "    lca.distance_list()",
            "    if lca.depth[u-1] >= lca.depth[v-1]:",
            "        a = u-1",
            "        while cnt < L:",
            "            a = lca.parent[a]",
            "            cnt += 1",
            "        xx, s = lca.parent[a]+1, a+1",
            "    else:",
            "        a = v-1",
            "        while cnt < L+1:",
            "            a = lca.parent[a]",
            "            cnt += 1",
            "        xx, s = a+1, lca.parent[a]+1",
            "    q, _ = lca.most_distant_point(s)",
            "    print(lca.distance(q,v)-1)",
            "    exit()"
        ],
        "label": [
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            2,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "class Tree():",
            "    def __init__(self, n, edge, indexed=1):",
            "        self.n = n",
            "        self.tree = [[] for _ in range(n)]",
            "        for e in edge:",
            "            self.tree[e[0] - indexed].append(e[1] - indexed)",
            "            self.tree[e[1] - indexed].append(e[0] - indexed)",
            "    def setroot(self, root):",
            "        self.root = root",
            "        self.parent = [None for _ in range(self.n)]",
            "        self.parent[root] = -1",
            "        self.depth = [None for _ in range(self.n)]",
            "        self.depth[root] = 0",
            "        self.order = []",
            "        self.order.append(root)",
            "        self.size = [1 for _ in range(self.n)]",
            "        stack = [root]",
            "        while stack:",
            "            node = stack.pop()",
            "            for adj in self.tree[node]:",
            "                if self.parent[adj] is None:",
            "                    self.parent[adj] = node",
            "                    self.depth[adj] = self.depth[node] + 1",
            "                    self.order.append(adj)",
            "                    stack.append(adj)",
            "        for node in self.order[::-1]:",
            "            for adj in self.tree[node]:",
            "                if self.parent[node] == adj:",
            "                    continue",
            "                self.size[node] += self.size[adj]",
            "    def heavylight_decomposition(self):",
            "        self.order = [None for _ in range(self.n)]",
            "        self.head = [None for _ in range(self.n)]",
            "        self.head[self.root] = self.root",
            "        self.next = [None for _ in range(self.n)]",
            "        stack = [self.root]",
            "        order = 0",
            "        while stack:",
            "            node = stack.pop()",
            "            self.order[node] = order",
            "            order += 1",
            "            maxsize = 0",
            "            for adj in self.tree[node]:",
            "                if self.parent[node] == adj:",
            "                    continue",
            "                if maxsize < self.size[adj]:",
            "                    maxsize = self.size[adj]",
            "                    self.next[node] = adj",
            "            for adj in self.tree[node]:",
            "                if self.parent[node] == adj or self.next[node] == adj:",
            "                    continue",
            "                self.head[adj] = adj",
            "                stack.append(adj)",
            "            if self.next[node] is not None:",
            "                self.head[self.next[node]] = self.head[node]",
            "                stack.append(self.next[node])",
            "    def range_hld(self, u, v, edge=False):",
            "        res = []",
            "        while True:",
            "            if self.order[u] > self.order[v]: u, v = v, u",
            "            if self.head[u] != self.head[v]:",
            "                res.append((self.order[self.head[v]], self.order[v] + 1))",
            "                v = self.parent[self.head[v]]",
            "            else:",
            "                res.append((self.order[u] + edge, self.order[v] + 1))",
            "                return res",
            "    def subtree_hld(self, u):",
            "        return self.order[u], self.order[u] + self.size[u]",
            "    def lca_hld(self, u, v):",
            "        while True:",
            "            if self.order[u] > self.order[v]: u, v = v, u",
            "            if self.head[u] != self.head[v]:",
            "                v = self.parent[self.head[v]]",
            "            else:",
            "                return u",
            "class SegmentTree():",
            "    def __init__(self, arr, func=min, ie=2**63):",
            "        self.h = (len(arr) - 1).bit_length()",
            "        self.n = 2**self.h",
            "        self.ie = ie",
            "        self.func = func",
            "        self.tree = [ie for _ in range(2 * self.n)]",
            "        for i in range(len(arr)):",
            "            self.tree[self.n + i] = arr[i]",
            "        for i in range(1, self.n)[::-1]:",
            "            self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])",
            "    def set(self, idx, x):",
            "        idx += self.n",
            "        self.tree[idx] = x",
            "        while idx:",
            "            idx >>= 1",
            "            self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])",
            "    def query(self, lt, rt):",
            "        lt += self.n",
            "        rt += self.n",
            "        vl = vr = self.ie",
            "        while rt - lt > 0:",
            "            if lt & 1:",
            "                vl = self.func(vl, self.tree[lt])",
            "                lt += 1",
            "            if rt & 1:",
            "                rt -= 1",
            "                vr = self.func(self.tree[rt], vr)",
            "            lt >>= 1",
            "            rt >>= 1",
            "        return self.func(vl, vr)",
            "import sys",
            "input = sys.stdin.readline",
            "N, u, v = map(int, input().split())",
            "u -= 1; v -= 1",
            "E = [tuple(map(int, input().split())) for _ in range(N - 1)]",
            "t = Tree(N, E)",
            "t.setroot(v)",
            "t.heavylight_decomposition()",
            "d = t.depth[u]",
            "k = (d + 1) // 2 - 1",
            "for _ in range(k):",
            "    u = t.parent[u]",
            "arr = [None for _ in range(N)]",
            "for i in range(N):",
            "    arr[t.order[i]] = t.depth[i]",
            "st = SegmentTree(arr, max, -1)",
            "lt, rt = t.subtree_hld(u)",
            "maxdep = st.query(lt, rt)",
            "print(maxdep - 1)"
        ],
        "label": [
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "import sys",
            "input = sys.stdin.readline",
            "def I(): return int(input())",
            "def MI(): return map(int, input().split())",
            "def LI(): return list(map(int, input().split()))",
            "\"\"\"",
            "最初から高橋くんが葉にいる&その隣接に青木くん，というパターン以外は",
            "葉の1個手前で終わるかな，",
            "ある点に対しての距離を見ればいい，ゴールがそこなら青木くんはそこに最短で行くので．",
            "ある点が青木くんよりの場合，そこはゴールにならない",
            "\"\"\"",
            "def main():",
            "    ##########################################",
            "    import heapq",
            "    class Dijkstra():",
            "        \"\"\"",
            "        ・有向 / 無向は問わない(無向の場合は，逆向きの辺もたす)",
            "        ・負のコストがない場合のみ",
            "        ・計算量はO(E log|V|)",
            "        ・heapを使うことで頂点を走査する必要がなくなる（代わりに，距離更新したものは確定でなくともqueに入れておく）",
            "        ・復元なし",
            "        \"\"\"",
            "        #最短のpathをたす",
            "        class Edge():",
            "            #重み付き有向辺",
            "            def __init__(self, _to, _cost):",
            "                self.to =_to",
            "                self.cost = _cost",
            "        def __init__(self, V):",
            "            #引数Vは頂点数",
            "            self.inf=10**20",
            "            self.G = [[] for _ in range(V)] #隣接リストG[u][i]が頂点uのi番目の辺",
            "            self. _E = 0 #辺の数",
            "            self._V = V #頂点数",
            "        #proparty - 辺の数",
            "        def E(self):",
            "            return self._E",
            "        #proparty - 頂点数",
            "        def V(self):",
            "            return self._V",
            "        def add(self, _from, _to, _cost):",
            "            #2頂点と辺のコストを追加",
            "            self.G[_from].append(self.Edge(_to,_cost))",
            "            self._E +=1",
            "        def add2(self, _from, _to, _cost):",
            "            #2頂点と辺のコスト（無向）を追加",
            "            self.G[_from].append(self.Edge(_to, _cost))",
            "            self.G[_to].append(self.Edge(_from, _cost))",
            "            self._E +=2",
            "        def shortest_path(self,s):#,g):",
            "            #始点sから頂点iまでの最短経路長のリストを返す",
            "            que = [] #priority queue",
            "            d = [self.inf] * self.V()",
            "            #prev = [None]*self.V() #prev[j]は，sからjへ最短経路で行くときのjの一つ前の場所",
            "            #復元で使う",
            "            d[s] = 0",
            "            heapq.heappush(que,(0,s)) #始点の距離と頂点番号をヒープに追加",
            "            while len(que)!=0:",
            "                #キューに格納されてある中で一番コストが小さい頂点を取り出す",
            "                cost,v = heapq.heappop(que)",
            "                #キューに格納された最短経路長候補がdの距離よりも大きい場合に処理をスキップ",
            "                if d[v] < cost:",
            "                    continue",
            "                #頂点vに隣接する各頂点iに対して，vを経由した場合の距離を計算して，これがd[i]よりも小さい場合に更新",
            "                for i in range(len(self.G[v])):",
            "                    e = self.G[v][i] #vのi個目の隣接辺",
            "                    if d[e.to] > d[v] + e.cost:",
            "                        d[e.to] = d[v] + e.cost #更新",
            "                        #prev[e.to] = v",
            "                        #復元で使う",
            "                        heapq.heappush(que,(d[e.to],e.to)) #queに新たな最短経路長候補を追加",
            "            \"\"\"#sからgまでの最短経路",
            "            path = []",
            "            pos = g #今いる場所，ゴールで初期化",
            "            for _ in range(self.V()+1):",
            "                path.append(pos)",
            "                if pos == s:",
            "                    break",
            "                #print(\"pos:\",format(pos))",
            "                pos = prev[pos]",
            "            path.reverse()",
            "            #print(path)\"\"\"",
            "            return d#,path",
            "    ########################",
            "    mod=10**9+7",
            "    N,u,v=MI()",
            "    u-=1",
            "    v-=1",
            "    dim=[0]*N",
            "    adj=[[]for _ in range(N)]",
            "    djk=Dijkstra(N)",
            "    for _ in range(N-1):",
            "        a,b=MI()",
            "        a-=1",
            "        b-=1",
            "        djk.add2(a,b,1)",
            "        dim[a]+=1",
            "        dim[b]+=1",
            "        adj[a].append(b)",
            "        adj[b].append(a)",
            "    if dim[u]==1:",
            "        if adj[u][0]==v:",
            "            print(0)",
            "            exit()",
            "    L=[]",
            "    for i in range(N):",
            "        if dim[i]==1:",
            "            L.append(adj[i][0])",
            "    ans=0",
            "    lt=djk.shortest_path(u)",
            "    la=djk.shortest_path(v)",
            "    for i in L:",
            "        if lt[i]<=la[i]:",
            "            ans=max(ans,la[i])",
            "    print(ans)",
            "main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "# -*- coding: utf-8 -*-",
            "import sys",
            "import math",
            "import os",
            "import itertools",
            "import string",
            "import heapq",
            "import _collections",
            "from collections import Counter",
            "from collections import defaultdict",
            "from collections import deque",
            "from functools import lru_cache",
            "import bisect",
            "import re",
            "import queue",
            "import decimal",
            "class Scanner():",
            "    @staticmethod",
            "    def int():",
            "        return int(sys.stdin.readline().rstrip())",
            "    @staticmethod",
            "    def string():",
            "        return sys.stdin.readline().rstrip()",
            "    @staticmethod",
            "    def map_int():",
            "        return [int(x) for x in Scanner.string().split()]",
            "    @staticmethod",
            "    def string_list(n):",
            "        return [Scanner.string() for i in range(n)]",
            "    @staticmethod",
            "    def int_list_list(n):",
            "        return [Scanner.map_int() for i in range(n)]",
            "    @staticmethod",
            "    def int_cols_list(n):",
            "        return [Scanner.int() for i in range(n)]",
            "class Math():",
            "    @staticmethod",
            "    def gcd(a, b):",
            "        if b == 0:",
            "            return a",
            "        return Math.gcd(b, a % b)",
            "    @staticmethod",
            "    def lcm(a, b):",
            "        return (a * b) // Math.gcd(a, b)",
            "    @staticmethod",
            "    def divisor(n):",
            "        res = []",
            "        i = 1",
            "        for i in range(1, int(n ** 0.5) + 1):",
            "            if n % i == 0:",
            "                res.append(i)",
            "                if i != n // i:",
            "                    res.append(n // i)",
            "        return res",
            "    @staticmethod",
            "    def round_up(a, b):",
            "        return -(-a // b)",
            "    @staticmethod",
            "    def is_prime(n):",
            "        if n < 2:",
            "            return False",
            "        if n == 2:",
            "            return True",
            "        if n % 2 == 0:",
            "            return False",
            "        d = int(n ** 0.5) + 1",
            "        for i in range(3, d + 1, 2):",
            "            if n % i == 0:",
            "                return False",
            "        return True",
            "    @staticmethod",
            "    def fact(N):",
            "        res = {}",
            "        tmp = N",
            "        for i in range(2, int(N ** 0.5 + 1) + 1):",
            "            cnt = 0",
            "            while tmp % i == 0:",
            "                cnt += 1",
            "                tmp //= i",
            "            if cnt > 0:",
            "                res[i] = cnt",
            "        if tmp != 1:",
            "            res[tmp] = 1",
            "        if res == {}:",
            "            res[N] = 1",
            "        return res",
            "def pop_count(x):",
            "    x = x - ((x >> 1) & 0x5555555555555555)",
            "    x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)",
            "    x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f",
            "    x = x + (x >> 8)",
            "    x = x + (x >> 16)",
            "    x = x + (x >> 32)",
            "    return x & 0x0000007f",
            "MOD = int(1e09) + 7",
            "INF = int(1e15)",
            "def solve():",
            "    N = Scanner.int()",
            "    A = [[-1 for _ in range(N)] for _ in range(N)]",
            "    for i in range(N):",
            "        a = Scanner.int()",
            "        for _ in range(a):",
            "            x, y = Scanner.map_int()",
            "            x -= 1",
            "            A[i][x] = y",
            "    ans = 0",
            "    for i in range(1 << N):",
            "        truth = [False for _ in range(N)]",
            "        for j in range(N):",
            "            if i >> j & 1:",
            "                truth[j] = True",
            "        isOK = True",
            "        for j in range(N):",
            "            if not truth[j]:",
            "                continue",
            "            for k in range(N):",
            "                if j == k:",
            "                    continue",
            "                if A[j][k] == 0 and truth[k]:",
            "                    isOK = False",
            "                if A[j][k] == 1 and not truth[k]:",
            "                    isOK = False",
            "        if isOK:",
            "            ans = max(sum(truth), ans)",
            "    print(ans)",
            "def main():",
            "    # sys.stdin = open(\"sample.txt\")",
            "    # T = Scanner.int()",
            "    # for _ in range(T):",
            "    #     solve()",
            "    # print('YNeos'[not solve()::2])",
            "    solve()",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def isp():   return input().split()",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def solve():",
            "        x = (a1 - b1) * t1",
            "        y = (a2 - b2) * t2",
            "        # print(x, y, x + y)",
            "        if x * (x + y) > 0:",
            "            # 二度と会わない",
            "            return 0",
            "        elif abs(x) % abs(x + y) == 0:",
            "            return 1 - 1 + 2 * (abs(x) // abs(x + y))",
            "        else:",
            "            return 1 + 2 * (abs(x) // abs(x + y))",
            "    t1, t2 = mi()",
            "    a1, a2 = mi()",
            "    b1, b2 = mi()",
            "    if a1 * t1 + a2 * t2 == b1 * t1 + b2 * t2:",
            "        print('infinity')",
            "    else:",
            "        print(solve())",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# -*- coding: utf-8 -*-",
            "import sys",
            "import math",
            "import os",
            "import itertools",
            "import string",
            "import heapq",
            "import _collections",
            "from collections import Counter",
            "from collections import defaultdict",
            "from collections import deque",
            "from functools import lru_cache",
            "import bisect",
            "import re",
            "import queue",
            "import decimal",
            "class Scanner():",
            "    @staticmethod",
            "    def int():",
            "        return int(sys.stdin.readline().rstrip())",
            "    @staticmethod",
            "    def string():",
            "        return sys.stdin.readline().rstrip()",
            "    @staticmethod",
            "    def map_int():",
            "        return [int(x) for x in Scanner.string().split()]",
            "    @staticmethod",
            "    def string_list(n):",
            "        return [Scanner.string() for i in range(n)]",
            "    @staticmethod",
            "    def int_list_list(n):",
            "        return [Scanner.map_int() for i in range(n)]",
            "    @staticmethod",
            "    def int_cols_list(n):",
            "        return [Scanner.int() for i in range(n)]",
            "class Math():",
            "    @staticmethod",
            "    def gcd(a, b):",
            "        if b == 0:",
            "            return a",
            "        return Math.gcd(b, a % b)",
            "    @staticmethod",
            "    def lcm(a, b):",
            "        return (a * b) // Math.gcd(a, b)",
            "    @staticmethod",
            "    def divisor(n):",
            "        res = []",
            "        i = 1",
            "        for i in range(1, int(n ** 0.5) + 1):",
            "            if n % i == 0:",
            "                res.append(i)",
            "                if i != n // i:",
            "                    res.append(n // i)",
            "        return res",
            "    @staticmethod",
            "    def round_up(a, b):",
            "        return -(-a // b)",
            "    @staticmethod",
            "    def is_prime(n):",
            "        if n < 2:",
            "            return False",
            "        if n == 2:",
            "            return True",
            "        if n % 2 == 0:",
            "            return False",
            "        d = int(n ** 0.5) + 1",
            "        for i in range(3, d + 1, 2):",
            "            if n % i == 0:",
            "                return False",
            "        return True",
            "    @staticmethod",
            "    def fact(N):",
            "        res = {}",
            "        tmp = N",
            "        for i in range(2, int(N ** 0.5 + 1) + 1):",
            "            cnt = 0",
            "            while tmp % i == 0:",
            "                cnt += 1",
            "                tmp //= i",
            "            if cnt > 0:",
            "                res[i] = cnt",
            "        if tmp != 1:",
            "            res[tmp] = 1",
            "        if res == {}:",
            "            res[N] = 1",
            "        return res",
            "def pop_count(x):",
            "    x = x - ((x >> 1) & 0x5555555555555555)",
            "    x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)",
            "    x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f",
            "    x = x + (x >> 8)",
            "    x = x + (x >> 16)",
            "    x = x + (x >> 32)",
            "    return x & 0x0000007f",
            "MOD = int(1e09) + 7",
            "INF = int(1e15)",
            "class Edge:",
            "    def __init__(self, to_, id_):",
            "        self.to = to_",
            "        self.id = id_",
            "ans = None",
            "G = None",
            "K = None",
            "def dfs(to, c):",
            "    global G",
            "    global ans",
            "    nc = c % K + 1",
            "    for g in G[to]:",
            "        if ans[g.id] != -1:",
            "            continue",
            "        ans[g.id] = nc",
            "        dfs(g.to, nc)",
            "        nc = nc % K + 1",
            "def solve():",
            "    global G",
            "    global ans",
            "    global K",
            "    N = Scanner.int()",
            "    G = [[] for _ in range(N)]",
            "    for i in range(N - 1):",
            "        x, y = Scanner.map_int()",
            "        x -= 1",
            "        y -= 1",
            "        G[x].append(Edge(y, i))",
            "        G[y].append(Edge(x, i))",
            "    K = 0",
            "    for i in range(N):",
            "        K = max(K, len(G[i]))",
            "    ans = [-1 for _ in range(N - 1)]",
            "    dfs(0, 0)",
            "    print(K)",
            "    print(*ans, sep='\\n')",
            "def main():",
            "    sys.setrecursionlimit(1000000)",
            "    # sys.stdin = open(\"sample.txt\")",
            "    # T = Scanner.int()",
            "    # for _ in range(T):",
            "    #     solve()",
            "    # print('YNeos'[not solve()::2])",
            "    solve()",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# -*- coding: utf-8 -*-",
            "import sys",
            "import math",
            "from bisect import bisect_left",
            "from bisect import bisect_right",
            "import collections",
            "import copy",
            "import heapq",
            "from collections import defaultdict",
            "from heapq import heappop, heappush",
            "import itertools",
            "input = sys.stdin.readline",
            "from collections import defaultdict",
            "from heapq import heappop, heappush",
            "from decimal import *",
            "##### リストの 二分木検索 #####",
            "# bisect_left(lists, 3)",
            "# bisect_right(lists, 3)",
            "##### プライオリティキュー #####",
            "# heapq.heapify(a) #リストaのheap化",
            "# heapq.heappush(a,x) #heap化されたリストaに要素xを追加",
            "# heapq.heappop(a) #heap化されたリストaから最小値を削除＆その最小値を出力",
            "# heapq.heappush(a, -x) #最大値を取り出す時は、pushする時にマイナスにして入れよう",
            "# heapq.heappop(a) * (-1) #取り出す時は、-1を掛けて取り出すこと",
            "##### タプルリストのソート #####",
            "# sorted(ans) #(a, b) -> 1st : aの昇順, 2nd : bの昇順",
            "# sorted(SP, key=lambda x:(x[0],-x[1])) #(a, b) -> 1st : aの昇順, 2nd : bの降順",
            "# sorted(SP, key=lambda x:(-x[0],x[1])) #(a, b) -> 1st : aの降順, 2nd : bの昇順",
            "# sorted(SP, key=lambda x:(-x[0],-x[1])) #(a, b) -> 1st : aの降順, 2nd : bの降順",
            "# sorted(SP, key=lambda x:(x[1])) #(a, b) -> 1st : bの昇順",
            "# sorted(SP, key=lambda x:(-x[1])) #(a, b) -> 1st : bの降順",
            "##### 累乗 #####",
            "# pow(x, y, z) -> x**y % z",
            "##### 割り算の切り上げ #####",
            "# tmp = -(-4 // 3)",
            "##### dict の for文 #####",
            "# for k, v in d.items():",
            "#     print(k, v)",
            "def inputInt(): return int(input())",
            "def inputMap(): return map(int, input().split())",
            "def inputList(): return list(map(int, input().split()))",
            "def inputStr(): return input()[:-1]",
            "inf = float('inf')",
            "mod = 1000000007",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "def main():",
            "\tN = inputInt()",
            "\tki = [[] for i in range(N)]",
            "\tinp = {}",
            "\tans = [inf for i in range(N-1)]",
            "\tansInt = 0",
            "\tfor i in range(N-1):",
            "\t\ta,b = inputMap()",
            "\t\ta -= 1",
            "\t\tb -= 1",
            "\t\tki[a].append(b)",
            "\t\tki[b].append(a)",
            "\t\tinp[(a,b)] = i",
            "\tfor i in ki:",
            "\t\tif len(i) > ansInt:",
            "\t\t\tansInt = len(i)",
            "\tfor i in range(N):",
            "\t\tko = ki[i]",
            "\t\tdame = []",
            "\t\tmi = []",
            "\t\tfor j in ko:",
            "\t\t\t#print(\"{} {} {}\".format(i,j,ko))",
            "\t\t\tif i < j:",
            "\t\t\t\tmi.append(j)",
            "\t\t\telse:",
            "\t\t\t\tdame.append(ans[inp[(j,i)]])",
            "\t\t#dame.sort()",
            "\t\tmark = 0",
            "\t\tfor j in mi:",
            "\t\t\tfor ii in range(mark,ansInt+1):",
            "\t\t\t\tif ii in dame:",
            "\t\t\t\t\tpass",
            "\t\t\t\telse:",
            "\t\t\t\t\tans[inp[(i,j)]] = ii",
            "\t\t\t\t\tdame.append(ii)",
            "\t\t\t\t\tbreak",
            "\t\t\t\tmark += 1",
            "\t\t#print(ans)",
            "\t#print(ki)",
            "\t#print(inp)",
            "\t#print(ans)",
            "\tprint(ansInt)",
            "\tfor i in ans:",
            "\t\tprint(i+1)",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "# N 個のボールを K グループに分ける場合のパターン数",
            "def sunuke(N, K, mod=10**9+7):",
            "\tif N < K or K-1 < 0:",
            "\t\treturn 0",
            "\telse:",
            "\t\treturn combination(N-1, K-1, mod)",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "# nCr mod m",
            "# rがn/2に近いと非常に重くなる",
            "def combination(n, r, mod=10**9+7):",
            "    r = min(r, n-r)",
            "    res = 1",
            "    for i in range(r):",
            "        res = res * (n - i) * modinv(i+1, mod) % mod",
            "    return res",
            "# mを法とするaの乗法的逆元",
            "def modinv(a, mod=10**9+7):",
            "    return pow(a, mod-2, mod)",
            "def egcd(a, b):",
            "    if a == 0:",
            "        return b, 0, 1",
            "    else:",
            "        g, y, x = egcd(b % a, a)",
            "        return g, x - (b // a) * y, y",
            "# nHr mod m",
            "# 問題によって、combination()を切り替えること",
            "def H(n, r, mod=10**9+7):",
            "\t# comb = Combination(n+r-1, mod)",
            "\t# return comb(n+r-1, r)",
            "    return combination(n+r-1, r, mod)",
            "class Combination:",
            "    \"\"\"",
            "    O(n)の前計算を1回行うことで，O(1)でnCr mod mを求められる",
            "    n_max = 10**6のとき前処理は約950ms (PyPyなら約340ms, 10**7で約1800ms)",
            "    使用例：",
            "    comb = Combination(1000000)",
            "    print(comb(5, 3))  # 10",
            "    \"\"\"",
            "    def __init__(self, n_max, mod=10**9+7):",
            "        self.mod = mod",
            "        self.modinv = self.make_modinv_list(n_max)",
            "        self.fac, self.facinv = self.make_factorial_list(n_max)",
            "    def __call__(self, n, r):",
            "        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod",
            "    def make_factorial_list(self, n):",
            "        # 階乗のリストと階乗のmod逆元のリストを返す O(n)",
            "        # self.make_modinv_list()が先に実行されている必要がある",
            "        fac = [1]",
            "        facinv = [1]",
            "        for i in range(1, n+1):",
            "            fac.append(fac[i-1] * i % self.mod)",
            "            facinv.append(facinv[i-1] * self.modinv[i] % self.mod)",
            "        return fac, facinv",
            "    def make_modinv_list(self, n):",
            "        # 0からnまでのmod逆元のリストを返す O(n)",
            "        modinv = [0] * (n+1)",
            "        modinv[1] = 1",
            "        for i in range(2, n+1):",
            "            modinv[i] = self.mod - self.mod//i * modinv[self.mod%i] % self.mod",
            "        return modinv",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "# dfs のサンプル",
            "def dfs(graph,parent,counter,edge):",
            "    stk = []",
            "    stk.append(edge)",
            "    while len(stk) > 0:",
            "        p = stk.pop()",
            "        for e in graph[p]:",
            "            if parent[p] == e:",
            "                continue",
            "            else:",
            "                parent[e] = p",
            "                counter[e] += counter[p]",
            "                stk.append(e)",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "if __name__ == \"__main__\":",
            "\tmain()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, m = mi()",
            "    s = input()    # 長さは n + 1",
            "    minimum_turn = 1",
            "    ans = []",
            "    prev = n",
            "    current = prev - m",
            "    while current > 0:",
            "        for i in range(current, prev):",
            "            if s[i] == '0':",
            "                ans.append(m - (i - current))",
            "                prev = i",
            "                current = i - m",
            "                minimum_turn += 1    # 途中のマスで中継を行った",
            "                break",
            "        else:",
            "            print(-1)",
            "            exit()",
            "    # minimum_turn でたどり着くパスのうち辞書順最小を求める",
            "    ans.append(n - sum(ans))",
            "    ans.reverse()",
            "    print(*ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "class SegmentTree:",
            "    def __init__(self, size, fn=min, default=None, initial_values=None):",
            "        \"\"\"",
            "        :param int size:",
            "        :param callable fn: 区間に適用する関数。引数を 2 つ取る。min, max, operator.xor など",
            "        :param default:",
            "        :param list initial_values:",
            "        \"\"\"",
            "        default = default or 0",
            "        # size 以上である最小の 2 冪を size とする",
            "        n = 1",
            "        while n < size:",
            "            n *= 2",
            "        self._size = n",
            "        self._fn = fn",
            "        self._tree = [default] * (self._size * 2 - 1)",
            "        if initial_values:",
            "            i = self._size - 1",
            "            for v in initial_values:",
            "                self._tree[i] = v",
            "                i += 1",
            "            i = self._size - 2",
            "            while i >= 0:",
            "                self._tree[i] = self._fn(self._tree[i * 2 + 1], self._tree[i * 2 + 2])",
            "                i -= 1",
            "    def set(self, i, value):",
            "        \"\"\"",
            "        i 番目に value を設定",
            "        :param int i:",
            "        :param value:",
            "        :return:",
            "        \"\"\"",
            "        x = self._size - 1 + i",
            "        self._tree[x] = value",
            "        while x > 0:",
            "            x = (x - 1) // 2",
            "            self._tree[x] = self._fn(self._tree[x * 2 + 1], self._tree[x * 2 + 2])",
            "    def update(self, i, value):",
            "        \"\"\"",
            "        もとの i 番目と value に fn を適用したものを i 番目に設定",
            "        :param int i:",
            "        :param value:",
            "        :return:",
            "        \"\"\"",
            "        x = self._size - 1 + i",
            "        self.set(i, self._fn(self._tree[x], value))",
            "    def get(self, from_i, to_i=None, k=0, L=None, r=None):",
            "        \"\"\"",
            "        [from_i, to_i) に fn を適用した結果を返す",
            "        :param int from_i:",
            "        :param int to_i:",
            "        :param int k: self._tree[k] が、[L, r) に fn を適用した結果を持つ",
            "        :param int L:",
            "        :param int r:",
            "        :return:",
            "        \"\"\"",
            "        if to_i is None:",
            "            return self._tree[self._size - 1 + from_i]",
            "        L = 0 if L is None else L",
            "        r = self._size if r is None else r",
            "        if from_i <= L and r <= to_i:",
            "            return self._tree[k]",
            "        if to_i <= L or r <= from_i:",
            "            return None",
            "        ret_L = self.get(from_i, to_i, k * 2 + 1, L, (L + r) // 2)",
            "        ret_r = self.get(from_i, to_i, k * 2 + 2, (L + r) // 2, r)",
            "        if ret_L is None:",
            "            return ret_r",
            "        if ret_r is None:",
            "            return ret_L",
            "        return self._fn(ret_L, ret_r)",
            "    def __len__(self):",
            "        return self._size",
            "def resolve():",
            "    INF = float('inf')",
            "    N, M = map(int, input().split())",
            "    S = input()",
            "    dp = [INF] * (N + 1)",
            "    dp[0] = 0",
            "    seg = SegmentTree(N + 1, min, INF)",
            "    seg.update(N, 0)",
            "    for i in range(N - 1, -1, -1):",
            "        if S[i] == '1':",
            "            continue",
            "        # seg.query(l, r) := [l, r)の最小値",
            "        dp[i] = seg.get(i, i + M + 1) + 1",
            "        seg.update(i, dp[i])",
            "    ans = []",
            "    position = 0",
            "    while position < N:",
            "        for move in range(1, M + 1):",
            "            if position + move > N:",
            "                continue",
            "            if S[position + move] == '1':",
            "                continue",
            "            # 最短手数にならない",
            "            if dp[position + move] == dp[position]:",
            "                continue",
            "            ans.append(move)",
            "            position += move",
            "            break",
            "        else:",
            "            print(-1)",
            "            return",
            "    print(*ans)",
            "if __name__ == \"__main__\":",
            "    resolve()"
        ],
        "label": [
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "# -*- coding: utf-8 -*-",
            "import sys",
            "import math",
            "import os",
            "import itertools",
            "import string",
            "import heapq",
            "import _collections",
            "from collections import Counter",
            "from collections import defaultdict",
            "from functools import lru_cache",
            "import bisect",
            "import re",
            "import queue",
            "from decimal import *",
            "class Scanner():",
            "    @staticmethod",
            "    def int():",
            "        return int(sys.stdin.readline().rstrip())",
            "    @staticmethod",
            "    def string():",
            "        return sys.stdin.readline().rstrip()",
            "    @staticmethod",
            "    def map_int():",
            "        return [int(x) for x in Scanner.string().split()]",
            "    @staticmethod",
            "    def string_list(n):",
            "        return [input() for i in range(n)]",
            "    @staticmethod",
            "    def int_list_list(n):",
            "        return [Scanner.map_int() for i in range(n)]",
            "    @staticmethod",
            "    def int_cols_list(n):",
            "        return [int(input()) for i in range(n)]",
            "class Math():",
            "    @staticmethod",
            "    def gcd(a, b):",
            "        if b == 0:",
            "            return a",
            "        return Math.gcd(b, a % b)",
            "    @staticmethod",
            "    def lcm(a, b):",
            "        return (a * b) // Math.gcd(a, b)",
            "    @staticmethod",
            "    def divisor(n):",
            "        res = []",
            "        i = 1",
            "        for i in range(1, int(n ** 0.5) + 1):",
            "            if n % i == 0:",
            "                res.append(i)",
            "                if i != n // i:",
            "                    res.append(n // i)",
            "        return res",
            "    @staticmethod",
            "    def round_up(a, b):",
            "        return -(-a // b)",
            "    @staticmethod",
            "    def is_prime(n):",
            "        if n < 2:",
            "            return False",
            "        if n == 2:",
            "            return True",
            "        if n % 2 == 0:",
            "            return False",
            "        d = int(n ** 0.5) + 1",
            "        for i in range(3, d + 1, 2):",
            "            if n % i == 0:",
            "                return False",
            "        return True",
            "def pop_count(x):",
            "    x = x - ((x >> 1) & 0x5555555555555555)",
            "    x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)",
            "    x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f",
            "    x = x + (x >> 8)",
            "    x = x + (x >> 16)",
            "    x = x + (x >> 32)",
            "    return x & 0x0000007f",
            "MOD = int(1e09) + 7",
            "INF = int(1e15)",
            "def solve():",
            "    H, W, K = Scanner.map_int()",
            "    S = Scanner.string_list(H)",
            "    ans = [[0 for _ in range(W)] for _ in range(H)]",
            "    vec = []",
            "    for h in range(H):",
            "        if S[h].count('#') > 0:",
            "            vec.append(h)",
            "    for i in range(len(vec)):",
            "        v1, v2 = 0, H - 1",
            "        if i > 0:",
            "            v1 = vec[i - 1] + 1",
            "        if i < len(vec) - 1:",
            "            v2 = vec[i]",
            "        vec2 = []",
            "        for w in range(W):",
            "            cnt = 0",
            "            for h in range(v1, v2 + 1):",
            "                if S[h][w] == '#':",
            "                    cnt += 1",
            "            if cnt > 0:",
            "                vec2.append(w)",
            "        for j in range(len(vec2)):",
            "            w1, w2 = 0, W - 1",
            "            if j > 0:",
            "                w1 = vec2[j - 1] + 1",
            "            if j < len(vec2) - 1:",
            "                w2 = vec2[j]",
            "            for h in range(v1, v2 + 1):",
            "                for w in range(w1, w2 + 1):",
            "                    ans[h][w] = K",
            "            K -= 1",
            "    for a in ans:",
            "        print(*a)",
            "def main():",
            "    # sys.stdin = open(\"sample.txt\")",
            "    solve()",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import fileinput",
            "import numpy as np",
            "def solve(grid):",
            "    groups = np.zeros(grid.shape, dtype=int)",
            "    group = 0",
            "    group_left = 0",
            "    group_right = 0",
            "    for i in range(grid.shape[0]):",
            "        for j in range(grid.shape[1]):",
            "            # Continue to the next SB",
            "            if grid[i,j] != '#':",
            "                continue",
            "            group = group + 1",
            "            group_left = j",
            "            group_right = j",
            "            # Assign to current group",
            "            groups[i,j] = group",
            "            # Expand right",
            "            for j2 in range(j + 1, grid.shape[1]):",
            "                # Break if meet a strawberry / already assigned",
            "                if grid[i,j2] == '#':",
            "                    break",
            "                if groups[i,j2] != 0:",
            "                    break",
            "                # Expand",
            "                groups[i,j2] = group",
            "                group_right = j2",
            "            # Expand left",
            "            for j2 in range(j - 1, -1, -1):",
            "                # Break if meet a strawberry / already assigned",
            "                if grid[i,j2] == '#':",
            "                    break",
            "                if groups[i,j2] != 0:",
            "                    break",
            "                # Expand",
            "                groups[i,j2] = group",
            "                group_left = j2",
            "            # Expand Down",
            "            for i2 in range(i + 1, grid.shape[0]):",
            "                # Only expand if none of the squares are SBs or in a group already",
            "                expand = True",
            "                for j2 in range(group_left, group_right + 1):",
            "                    if grid[i2,j2] == '#':",
            "                        expand = False",
            "                        break",
            "                    if groups[i2,j2] != 0:",
            "                        expand = False",
            "                        break",
            "                if not expand:",
            "                    break",
            "                for j2 in range(group_left, group_right + 1):",
            "                    groups[i2,j2] = group",
            "            # Expand Up",
            "            for i2 in range(i - 1, -1, -1):",
            "                # Only expand if none of the squares are SBs or in a group already",
            "                expand = True",
            "                for j2 in range(group_left, group_right + 1):",
            "                    if grid[i2,j2] == '#':",
            "                        expand = False",
            "                        break",
            "                    if groups[i2,j2] != 0:",
            "                        expand = False",
            "                        break",
            "                if not expand:",
            "                    break",
            "                for j2 in range(group_left, group_right + 1):",
            "                    groups[i2,j2] = group",
            "    return groups",
            "def main():",
            "    grid = np.array([",
            "        ('.', '.', '.', '.', '.', '.', '.'),",
            "        ('#', '.', '.', '.', '#', '.', '#'),",
            "        ('.', '.', '.', '.', '#', '.', '.'),",
            "        ('.', '.', '#', '.', '.', '.', '#'),",
            "        ('.', '#', '.', '.', '#', '.', '.')])",
            "    grid = read_grid()",
            "    # print(grid)",
            "    groups = solve(grid)",
            "    # print(groups)",
            "    output_grid(groups)",
            "def output_grid(grid):",
            "    for i in range(grid.shape[0]):",
            "        for j in range(grid.shape[1]):",
            "            print(grid[i,j], end=' ')",
            "        print('')",
            "def read_grid():",
            "    grid = []",
            "    first = True",
            "    for line in fileinput.input():",
            "        if first:",
            "            first = False",
            "            continue",
            "        grid.append(list(line.rstrip('\\n')))",
            "    return np.array(grid)",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "# -*- coding: utf-8 -*-",
            "import sys",
            "import math",
            "import os",
            "import itertools",
            "import string",
            "import heapq",
            "import _collections",
            "from collections import Counter",
            "from collections import defaultdict",
            "from collections import deque",
            "from functools import lru_cache",
            "import bisect",
            "import re",
            "import queue",
            "import decimal",
            "class Scanner():",
            "    @staticmethod",
            "    def int():",
            "        return int(sys.stdin.readline().rstrip())",
            "    @staticmethod",
            "    def string():",
            "        return sys.stdin.readline().rstrip()",
            "    @staticmethod",
            "    def map_int():",
            "        return [int(x) for x in Scanner.string().split()]",
            "    @staticmethod",
            "    def string_list(n):",
            "        return [Scanner.string() for i in range(n)]",
            "    @staticmethod",
            "    def int_list_list(n):",
            "        return [Scanner.map_int() for i in range(n)]",
            "    @staticmethod",
            "    def int_cols_list(n):",
            "        return [Scanner.int() for i in range(n)]",
            "class Math():",
            "    @staticmethod",
            "    def gcd(a, b):",
            "        if b == 0:",
            "            return a",
            "        return Math.gcd(b, a % b)",
            "    @staticmethod",
            "    def lcm(a, b):",
            "        return (a * b) // Math.gcd(a, b)",
            "    @staticmethod",
            "    def divisor(n):",
            "        res = []",
            "        i = 1",
            "        for i in range(1, int(n ** 0.5) + 1):",
            "            if n % i == 0:",
            "                res.append(i)",
            "                if i != n // i:",
            "                    res.append(n // i)",
            "        return res",
            "    @staticmethod",
            "    def round_up(a, b):",
            "        return -(-a // b)",
            "    @staticmethod",
            "    def is_prime(n):",
            "        if n < 2:",
            "            return False",
            "        if n == 2:",
            "            return True",
            "        if n % 2 == 0:",
            "            return False",
            "        d = int(n ** 0.5) + 1",
            "        for i in range(3, d + 1, 2):",
            "            if n % i == 0:",
            "                return False",
            "        return True",
            "    @staticmethod",
            "    def fact(N):",
            "        res = {}",
            "        tmp = N",
            "        for i in range(2, int(N ** 0.5 + 1) + 1):",
            "            cnt = 0",
            "            while tmp % i == 0:",
            "                cnt += 1",
            "                tmp //= i",
            "            if cnt > 0:",
            "                res[i] = cnt",
            "        if tmp != 1:",
            "            res[tmp] = 1",
            "        if res == {}:",
            "            res[N] = 1",
            "        return res",
            "def pop_count(x):",
            "    x = x - ((x >> 1) & 0x5555555555555555)",
            "    x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)",
            "    x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f",
            "    x = x + (x >> 8)",
            "    x = x + (x >> 16)",
            "    x = x + (x >> 32)",
            "    return x & 0x0000007f",
            "MOD = int(1e09) + 7",
            "INF = int(1e15)",
            "def modinv(a):",
            "    b = MOD",
            "    u = 1",
            "    v = 0",
            "    while b:",
            "        t = a // b",
            "        a -= t * b",
            "        a, b = b, a",
            "        u -= t * v",
            "        u, v = v, u",
            "    u %= MOD",
            "    if u < 0:",
            "        u += MOD",
            "    return u",
            "def factorial(N):",
            "    if N == 0 or N == 1:",
            "        return 1",
            "    res = N",
            "    for i in range(N - 1, 1, -1):",
            "        res *= i",
            "        res %= MOD",
            "    return res",
            "def solve():",
            "    X, Y = Scanner.map_int()",
            "    if (X + Y) % 3 != 0:",
            "        print(0)",
            "        return",
            "    B = (2 * Y - X) // 3",
            "    A = (2 * X - Y) // 3",
            "    if A < 0 or B < 0:",
            "        print(0)",
            "        return",
            "    n = factorial(A + B)",
            "    m = factorial(A)",
            "    l = factorial(B)",
            "    ans = n * modinv(m * l % MOD) % MOD",
            "    print(ans)",
            "def main():",
            "    # sys.setrecursionlimit(1000000)",
            "    # sys.stdin = open(\"sample.txt\")",
            "    # T = Scanner.int()",
            "    # for _ in range(T):",
            "    #     solve()",
            "    # print('YNeos'[not solve()::2])",
            "    solve()",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "mod = 10 ** 9 + 7",
            "mod2 = 2**61+1",
            "from collections import deque",
            "import heapq",
            "from bisect import bisect_left, insort_left, bisect_right",
            "def iip(listed=True):",
            "    ret = [int(i) for i in input().split()]",
            "    if len(ret) == 1 and not listed:",
            "        return ret[0]",
            "    return ret",
            "def iip_ord():",
            "    return [ord(i) - ord(\"a\") for i in input()]",
            "def main():",
            "    ans = solve()",
            "    if ans is not None:",
            "        print(ans)",
            "def solve():",
            "    N, T = iip()",
            "    dp1 = [[0 for _ in range(T)] for _ in range(N + 1)]",
            "    dp2 = [[0 for _ in range(T)] for _ in range(N + 1)]",
            "    AB = [iip() for i in range(N)]",
            "    for i, ab in enumerate(AB, 1):",
            "        a, b = ab",
            "        for j in range(T):",
            "            dp1[i][j] = dp1[i-1][j]",
            "        for j in reversed(list(range(T))):",
            "            if j+a >= T:",
            "                continue",
            "            dp1[i][j + a] = max(dp1[i][j + a], dp1[i][j] + b)",
            "    for i, ab in enumerate(reversed(AB), 1):",
            "        a, b = ab",
            "        for j in range(T):",
            "            dp2[i][j] = dp2[i-1][j]",
            "        for j in reversed(list(range(T))):",
            "            if j + a >= T:",
            "                continue",
            "            dp2[i][j + a] = max(dp2[i][j + a], dp2[i][j] + b)",
            "    #dp2.reverse()",
            "    mm = 0",
            "    for i in range(N):",
            "        for j in range(T):",
            "            ii1 = i",
            "            ii2 = N-i-1",
            "            ii3 = i",
            "            ij1 = j",
            "            ij2 = T-j-1",
            "            a = dp1[ii1][ij1]",
            "            b = dp2[ii2][ij2]",
            "            c = AB[ii3][1]",
            "            #print(ii1, ii2, ij1, ij2, ii3, a, b, c, a+b+c)",
            "            #print(a, b, c)",
            "            mm = max(a+b+c, mm)",
            "            #print(i, j, cur, a, b)",
            "    #print(dp1)",
            "    #print(dp2)",
            "    print(mm)",
            "#####################################################ライブラリ集ここから",
            "def fprint(s):",
            "    for i in s:",
            "        print(i)",
            "def split_print_space(s):",
            "    print(\" \".join([str(i) for i in s]))",
            "def split_print_enter(s):",
            "    print(\"\\n\".join([str(i) for i in s]))",
            "def koenai_saidai_x_index(sorted_list, n):",
            "    l = 0",
            "    r = len(sorted_list)",
            "    if len(sorted_list) == 0:",
            "        return False",
            "    if sorted_list[0] > n:",
            "        return False",
            "    while r - l > 1:",
            "        x = (l + r) // 2",
            "        if sorted_list[x] == n:",
            "            return x",
            "        elif sorted_list[x] > n:",
            "            r = x",
            "        else:",
            "            l = x",
            "    return l",
            "def searchsorted(sorted_list, n, side):",
            "    if side not in [\"right\", \"left\"]:",
            "        raise Exception(\"sideはrightかleftで指定してください\")",
            "    l = 0",
            "    r = len(sorted_list)",
            "    if n > sorted_list[-1]:",
            "        # print(sorted_list)",
            "        return len(sorted_list)",
            "    if n < sorted_list[0]:",
            "        return 0",
            "    while r - l > 1:",
            "        x = (l + r) // 2",
            "        if sorted_list[x] > n:",
            "            r = x",
            "        elif sorted_list[x] < n:",
            "            l = x",
            "        else:",
            "            if side == \"left\":",
            "                r = x",
            "            elif side == \"right\":",
            "                l = x",
            "    if side == \"left\":",
            "        if sorted_list[l] == n:",
            "            return r - 1",
            "        else:",
            "            return r",
            "    if side == \"right\":",
            "        if sorted_list[l] == n:",
            "            return l + 1",
            "        else:",
            "            return l",
            "def soinsuu_bunkai(n):",
            "    ret = []",
            "    for i in range(2, int(n ** 0.5) + 1):",
            "        while n % i == 0:",
            "            n //= i",
            "            ret.append(i)",
            "        if i > n:",
            "            break",
            "    if n != 1:",
            "        ret.append(n)",
            "    return ret",
            "def conbination(n, r, mod, test=False):",
            "    if n <= 0:",
            "        return 0",
            "    if r == 0:",
            "        return 1",
            "    if r < 0:",
            "        return 0",
            "    if r == 1:",
            "        return n",
            "    ret = 1",
            "    for i in range(n - r + 1, n + 1):",
            "        ret *= i",
            "        ret = ret % mod",
            "    bunbo = 1",
            "    for i in range(1, r + 1):",
            "        bunbo *= i",
            "        bunbo = bunbo % mod",
            "    ret = (ret * inv(bunbo, mod)) % mod",
            "    if test:",
            "        # print(f\"{n}C{r} = {ret}\")",
            "        pass",
            "    return ret",
            "def inv(n, mod):",
            "    return power(n, mod - 2)",
            "def power(n, p, mod_= mod):",
            "    if p == 0:",
            "        return 1",
            "    if p % 2 == 0:",
            "        return (power(n, p // 2, mod_) ** 2) % mod_",
            "    if p % 2 == 1:",
            "        return (n * power(n, p - 1, mod_)) % mod_",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, t = mi()",
            "    eating_cost = [None]    # 1-index",
            "    energy = [None]    # 1-index",
            "    for _ in range(n):",
            "        a, b = mi()",
            "        eating_cost.append(a)",
            "        energy.append(b)",
            "    # dp_cost_until_i[k][i] = (時間コスト k (0<=k<=t-1) 以下で Ai (1<=i<=n) までを使用してエネルギーを最大化した時の値)",
            "    dp_cost_unitl_i = [[0] * (n + 2) for _ in range(t)]",
            "    for time_cost in range(1, t):",
            "        for i in range(1, n + 1):",
            "            tmp = energy[i] + dp_cost_unitl_i[time_cost - eating_cost[i]][i - 1] if time_cost - eating_cost[i] >= 0 else 0",
            "            dp_cost_unitl_i[time_cost][i] = max(dp_cost_unitl_i[time_cost][i - 1], tmp)",
            "    # dp_cost_from_i[k][i] = (時間コスト k (0<=k<=t-1) 以下で Ai (1<=i<=n) からを使用してエネルギーを最大化した時の値)",
            "    dp_cost_from_i = [[0] * (n + 2) for _ in range(t)]",
            "    for time_cost in range(1, t):",
            "        for i in range(n, 0, -1):",
            "            tmp = energy[i] + dp_cost_from_i[time_cost - eating_cost[i]][i + 1] if time_cost - eating_cost[i] >= 0 else 0",
            "            dp_cost_from_i[time_cost][i] = max(dp_cost_from_i[time_cost][i + 1], tmp)",
            "    maximum_energy = 0",
            "    for i in range(1, n + 1):",
            "        # Ai が最後に食べるものの時",
            "        for until_i_time in range(t):",
            "            a = dp_cost_unitl_i[until_i_time][i - 1]",
            "            b = dp_cost_from_i[t - 1 - until_i_time][i + 1]",
            "            maximum_energy = max(maximum_energy, energy[i] + a + b)",
            "    print(maximum_energy)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, k = mi()",
            "    A = sorted(lmi(), reverse=True)",
            "    F = sorted(lmi())",
            "    # O(K) * O(lgN)",
            "    # h = [[- A[i] * F[i], F[i]] for i in range(n)]",
            "    # heapify(h)",
            "    # # print(h)",
            "    # for _ in range(k):",
            "    #     minus_val, cost = heappop(h)",
            "    #     plus_val = - minus_val",
            "    #     # plus_val は max heap から取り出した最大値となる",
            "    #     if plus_val == 0:",
            "    #         # もう減らす場所はない。一応戻して抜ける",
            "    #         heappush(h, [plus_val, cost])",
            "    #         break",
            "    #     plus_val -= cost",
            "    #     heappush(h, [- plus_val, cost])",
            "    # minus_val, cost = heappop(h)",
            "    # print(- minus_val)",
            "    # O(lgK) * O(N)",
            "    def calc_total_training(A, F, n, key):",
            "        '各メンバーが秒数を key 以下にする必要がある時必要なトレーニングの総数を計算する'",
            "        cnt = 0",
            "        if key < 0:",
            "            return float('inf')",
            "        else:",
            "            for i in range(n):",
            "                diff = max(A[i] * F[i] - key, 0)",
            "                cnt += math.ceil(diff / F[i])",
            "            return cnt",
            "    def is_ok(A, F, n, k, key):",
            "        'k 回以下のトレーニングで各メンバーが秒数を key 以下にすることは可能か判定する'",
            "        return calc_total_training(A, F, n, key) <= k",
            "    def meguru_bisect(A, F, n, k):",
            "        'k 回以下のトレーニングで達成可能な最短秒数を求める'",
            "        left_sec = -1    # 必ず達成不可能",
            "        right_sec = 10 ** 12    # 必ず達成可能",
            "        while right_sec - left_sec > 1:",
            "            mid = left_sec + (right_sec - left_sec) // 2",
            "            if is_ok(A, F, n, k, mid):",
            "                right_sec = mid",
            "            else:",
            "                left_sec = mid",
            "        return right_sec",
            "    print(meguru_bisect(A, F, n, k))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "mod = 10 ** 9 + 7",
            "from collections import deque",
            "import heapq",
            "def iip(listed):",
            "    ret = [int(i) for i in input().split()]",
            "    if len(ret) == 1 and not listed:",
            "        return ret[0]",
            "    return ret",
            "def main():",
            "    r = solve()",
            "    print(r)",
            "def solve():",
            "    N, K = iip(False)",
            "    A = iip(True)",
            "    F = iip(True)",
            "    A.sort(reverse=False)",
            "    F.sort(reverse=True)",
            "    l = -1",
            "    r = 10**12",
            "    while r - l > 1:",
            "        x = (l+r)//2",
            "        nk = 0",
            "        for a, f in zip(A, F):",
            "            lima = x // f",
            "            #print(lima, a)",
            "            syugyou = a - lima",
            "            #print(syugyou)",
            "            if x <= 10:",
            "                #print(x, a, f, lima, syugyou)",
            "                pass",
            "            nk += max(0, syugyou)",
            "        if nk > K:",
            "            l = x",
            "        else:",
            "            r = x",
            "    #print(l, r)",
            "    return r",
            "#####################################################ライブラリ集ここから",
            "def split_print_space(s):",
            "    print(\" \".join([str(i) for i in s]))",
            "def split_print_enter(s):",
            "    print(\"\\n\".join([str(i) for i in s]))",
            "def koenai_saidai_x_index(sorted_list, n):",
            "    l = 0",
            "    r = len(sorted_list)",
            "    if len(sorted_list) == 0:",
            "        return False",
            "    if sorted_list[0] > n:",
            "        return False",
            "    while r - l > 1:",
            "        x = (l + r) // 2",
            "        if sorted_list[x] == n:",
            "            return x",
            "        elif sorted_list[x] > n:",
            "            r = x",
            "        else:",
            "            l = x",
            "    return l",
            "def searchsorted(sorted_list, n, side):",
            "    if side not in [\"right\", \"left\"]:",
            "        raise Exception(\"sideはrightかleftで指定してください\")",
            "    l = 0",
            "    r = len(sorted_list)",
            "    if n > sorted_list[-1]:",
            "        # print(sorted_list)",
            "        return len(sorted_list)",
            "    if n < sorted_list[0]:",
            "        return 0",
            "    while r - l > 1:",
            "        x = (l + r) // 2",
            "        if sorted_list[x] > n:",
            "            r = x",
            "        elif sorted_list[x] < n:",
            "            l = x",
            "        else:",
            "            if side == \"left\":",
            "                r = x",
            "            elif side == \"right\":",
            "                l = x",
            "    if side == \"left\":",
            "        if sorted_list[l] == n:",
            "            return r - 1",
            "        else:",
            "            return r",
            "    if side == \"right\":",
            "        if sorted_list[l] == n:",
            "            return l + 1",
            "        else:",
            "            return l",
            "def soinsuu_bunkai(n):",
            "    ret = []",
            "    for i in range(2, int(n ** 0.5) + 1):",
            "        while n % i == 0:",
            "            n //= i",
            "            ret.append(i)",
            "        if i > n:",
            "            break",
            "    if n != 1:",
            "        ret.append(n)",
            "    return ret",
            "def conbination(n, r, mod, test=False):",
            "    if n <= 0:",
            "        return 0",
            "    if r == 0:",
            "        return 1",
            "    if r < 0:",
            "        return 0",
            "    if r == 1:",
            "        return n",
            "    ret = 1",
            "    for i in range(n - r + 1, n + 1):",
            "        ret *= i",
            "        ret = ret % mod",
            "    bunbo = 1",
            "    for i in range(1, r + 1):",
            "        bunbo *= i",
            "        bunbo = bunbo % mod",
            "    ret = (ret * inv(bunbo, mod)) % mod",
            "    if test:",
            "        # print(f\"{n}C{r} = {ret}\")",
            "        pass",
            "    return ret",
            "def inv(n, mod):",
            "    return power(n, mod - 2)",
            "def power(n, p):",
            "    if p == 0:",
            "        return 1",
            "    if p % 2 == 0:",
            "        return (power(n, p // 2) ** 2) % mod",
            "    if p % 2 == 1:",
            "        return (n * power(n, p - 1)) % mod",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "mod = 10 ** 9 + 7",
            "mod2 = 2**61+1",
            "from collections import deque",
            "import heapq",
            "from bisect import bisect_left, insort_left, bisect_right",
            "def iip(listed=True):",
            "    ret = [int(i) for i in input().split()]",
            "    if len(ret) == 1 and not listed:",
            "        return ret[0]",
            "    return ret",
            "def iip_ord():",
            "    return [ord(i) - ord(\"a\") for i in input()]",
            "def main():",
            "    ans = solve()",
            "    if ans is not None:",
            "        print(ans)",
            "def solve():",
            "    N, M, L = iip()",
            "    dis_table = [[10 ** 12 for _ in range(N)] for _ in range(N)]",
            "    for i in range(N):",
            "        dis_table[i][i] = 0",
            "    for i in range(M):",
            "        a, b, c = iip()",
            "        a -= 1",
            "        b -= 1",
            "        if c <= L:",
            "            dis_table[a][b] = c",
            "            dis_table[b][a] = c",
            "    for k in range(N):",
            "        for i in range(N):",
            "            for j in range(N):",
            "                dis_table[i][j] = min(dis_table[i][j], dis_table[i][k] + dis_table[j][k])",
            "    #print(dis_table)",
            "    nt = [[10 ** 12 for _ in range(N)] for _ in range(N)]",
            "    for i in range(N):",
            "        for j in range(N):",
            "            if dis_table[i][j] <= L:",
            "                nt[i][j] = 1",
            "    for i in range(N):",
            "        nt[i][i] = 0",
            "    for k in range(N):",
            "        for i in range(N):",
            "            for j in range(N):",
            "                nt[i][j] = min(nt[i][j], nt[i][k] + nt[j][k])",
            "    q = iip(False)",
            "    ans = []",
            "    for i in range(q):",
            "        a, b = iip()",
            "        c = nt[a-1][b-1]",
            "        if c == 10**12:",
            "            ans.append(-1)",
            "        else:",
            "            ans.append(c-1)",
            "    split_print_enter(ans)",
            "#####################################################ライブラリ集ここから",
            "def split_print_space(s):",
            "    print(\" \".join([str(i) for i in s]))",
            "def split_print_enter(s):",
            "    print(\"\\n\".join([str(i) for i in s]))",
            "def koenai_saidai_x_index(sorted_list, n):",
            "    l = 0",
            "    r = len(sorted_list)",
            "    if len(sorted_list) == 0:",
            "        return False",
            "    if sorted_list[0] > n:",
            "        return False",
            "    while r - l > 1:",
            "        x = (l + r) // 2",
            "        if sorted_list[x] == n:",
            "            return x",
            "        elif sorted_list[x] > n:",
            "            r = x",
            "        else:",
            "            l = x",
            "    return l",
            "def searchsorted(sorted_list, n, side):",
            "    if side not in [\"right\", \"left\"]:",
            "        raise Exception(\"sideはrightかleftで指定してください\")",
            "    l = 0",
            "    r = len(sorted_list)",
            "    if n > sorted_list[-1]:",
            "        # print(sorted_list)",
            "        return len(sorted_list)",
            "    if n < sorted_list[0]:",
            "        return 0",
            "    while r - l > 1:",
            "        x = (l + r) // 2",
            "        if sorted_list[x] > n:",
            "            r = x",
            "        elif sorted_list[x] < n:",
            "            l = x",
            "        else:",
            "            if side == \"left\":",
            "                r = x",
            "            elif side == \"right\":",
            "                l = x",
            "    if side == \"left\":",
            "        if sorted_list[l] == n:",
            "            return r - 1",
            "        else:",
            "            return r",
            "    if side == \"right\":",
            "        if sorted_list[l] == n:",
            "            return l + 1",
            "        else:",
            "            return l",
            "def soinsuu_bunkai(n):",
            "    ret = []",
            "    for i in range(2, int(n ** 0.5) + 1):",
            "        while n % i == 0:",
            "            n //= i",
            "            ret.append(i)",
            "        if i > n:",
            "            break",
            "    if n != 1:",
            "        ret.append(n)",
            "    return ret",
            "def conbination(n, r, mod, test=False):",
            "    if n <= 0:",
            "        return 0",
            "    if r == 0:",
            "        return 1",
            "    if r < 0:",
            "        return 0",
            "    if r == 1:",
            "        return n",
            "    ret = 1",
            "    for i in range(n - r + 1, n + 1):",
            "        ret *= i",
            "        ret = ret % mod",
            "    bunbo = 1",
            "    for i in range(1, r + 1):",
            "        bunbo *= i",
            "        bunbo = bunbo % mod",
            "    ret = (ret * inv(bunbo, mod)) % mod",
            "    if test:",
            "        # print(f\"{n}C{r} = {ret}\")",
            "        pass",
            "    return ret",
            "def inv(n, mod):",
            "    return power(n, mod - 2)",
            "def power(n, p, mod_= mod):",
            "    if p == 0:",
            "        return 1",
            "    if p % 2 == 0:",
            "        return (power(n, p // 2, mod_) ** 2) % mod_",
            "    if p % 2 == 1:",
            "        return (n * power(n, p - 1, mod_)) % mod_",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools",
            "import time,random",
            "sys.setrecursionlimit(10**7)",
            "inf = 10**20",
            "eps = 1.0 / 10**10",
            "mod = 10**9+7",
            "mod2 = 998244353",
            "dd = [(-1,0),(0,1),(1,0),(0,-1)]",
            "ddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]",
            "def LI(): return list(map(int, sys.stdin.readline().split()))",
            "def LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]",
            "def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]",
            "def LF(): return [float(x) for x in sys.stdin.readline().split()]",
            "def LS(): return sys.stdin.readline().split()",
            "def I(): return int(sys.stdin.readline())",
            "def F(): return float(sys.stdin.readline())",
            "def S(): return input()",
            "def pf(s): return print(s, flush=True)",
            "def pe(s): return print(str(s), file=sys.stderr)",
            "def JA(a, sep): return sep.join(map(str, a))",
            "def JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)",
            "def wff(n,l,abc,st):",
            "    nl = list(range(n))",
            "    d = [[inf] * n for _ in nl]",
            "    for i in nl:",
            "        d[i][i] = 0",
            "    for a,b,c in abc:",
            "        a -= 1",
            "        b -= 1",
            "        d[a][b] = c",
            "        d[b][a] = c",
            "    for i in nl:",
            "        di = d[i]",
            "        for j in nl:",
            "            if i == j:",
            "                continue",
            "            dj = d[j]",
            "            for k in nl:",
            "                if i != k and j != k and dj[k] > dj[i] + di[k]:",
            "                    dj[k] = dj[i] + di[k]",
            "    dd = [[inf] * n for _ in nl]",
            "    for i in nl:",
            "        dd[i][i] = 0",
            "    for i in nl:",
            "        for j in nl:",
            "            if j != i and d[i][j] <= l:",
            "                dd[i][j] = 1",
            "    for i in nl:",
            "        di = dd[i]",
            "        for j in nl:",
            "            if i == j:",
            "                continue",
            "            dj = dd[j]",
            "            for k in nl:",
            "                if i != k and j != k and dj[k] > dj[i] + di[k]:",
            "                    dj[k] = dj[i] + di[k]",
            "    rr = []",
            "    for s,t in st:",
            "        if dd[s][t] == inf:",
            "            rr.append(-1)",
            "        else:",
            "            rr.append(dd[s][t] - 1)",
            "    return JA(rr, \"\\n\")",
            "def main():",
            "    n,m,l = LI()",
            "    abc = [LI() for _ in range(m)]",
            "    q = I()",
            "    st = [LI_() for _ in range(q)]",
            "    if m > 300 * 100:",
            "        return wff(n,l,abc,st)",
            "    e = collections.defaultdict(list)",
            "    for a,b,c in abc:",
            "        a -= 1",
            "        b -= 1",
            "        e[a].append((b, c))",
            "        e[b].append((a, c))",
            "    def search(s):",
            "        d = collections.defaultdict(lambda: inf)",
            "        d[s] = 0",
            "        q = []",
            "        heapq.heappush(q, (0, s))",
            "        v = collections.defaultdict(bool)",
            "        while len(q):",
            "            k, u = heapq.heappop(q)",
            "            if v[u]:",
            "                continue",
            "            v[u] = True",
            "            for uv, ud in e[u]:",
            "                if v[uv]:",
            "                    continue",
            "                vd = k + ud",
            "                if d[uv] > vd and vd <= l:",
            "                    d[uv] = vd",
            "                    heapq.heappush(q, (vd, uv))",
            "        return set([k for k,v in d.items() if v <= l])",
            "    d = {}",
            "    for i in range(n):",
            "        d[i] = search(i)",
            "    dd = [[inf] * n for _ in range(n)]",
            "    for i in range(n):",
            "        q = [(0, i)]",
            "        qi = 0",
            "        v = set([i])",
            "        while len(q) > qi:",
            "            k, t = q[qi]",
            "            qi += 1",
            "            u = d[t] - v",
            "            v |= u",
            "            dd[i][t] = k",
            "            for w in u:",
            "                q.append((k+1, w))",
            "    rr = []",
            "    for s,t in st:",
            "        if dd[s][t] == inf:",
            "            rr.append(-1)",
            "        else:",
            "            rr.append(dd[s][t] - 1)",
            "    return JA(rr, \"\\n\")",
            "print(main())"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2
        ]
    },
    {
        "content": [
            "# -*- coding: utf-8 -*-",
            "# D",
            "import sys",
            "from collections import defaultdict, deque",
            "from heapq import heappush, heappop",
            "import math",
            "import bisect",
            "input = sys.stdin.readline",
            "# 再起回数上限変更",
            "# sys.setrecursionlimit(1000000)",
            "a, b = map(int, input().split())",
            "class Mint(object):",
            "    \"\"\" 整数のお役立ち計算",
            "    - 繰り返し二乗法で効率的にn**kを求める（必要であればmodを指定）",
            "    - 素数判定",
            "    - 素因数分解",
            "    - 約数列挙",
            "    - nCrの計算(ピンポイントで求める or あるnまでのnCrを計算するのに必要な情報を一気に求める）",
            "    - ToDo:",
            "    # divisor : 配列をsortしているため遅い可能性あり",
            "    \"\"\"",
            "    def gcd(self, a, b):",
            "        # ユークリッドの互除法を用いる",
            "        while b:",
            "            a, b = b, a % b",
            "        return a",
            "    def lcm(self, a, b):",
            "        return a * b // self.gcd(a, b)",
            "    @staticmethod",
            "    def cmb_(n, r):",
            "        \"\"\" 普通にnCrを求める",
            "        >>> p = Mint()",
            "        >>> p.cmb_(10, 2)",
            "        45",
            "        \"\"\"",
            "        from operator import mul",
            "        from functools import reduce",
            "        r = min(n - r, r)",
            "        if r == 0:",
            "            return 1",
            "        over = reduce(mul, range(n, n - r, -1))",
            "        under = reduce(mul, range(1, r + 1))",
            "        return over // under",
            "    def cmb(self, n, r, mod: int = 10 ** 9 + 7):",
            "        \"\"\" 事前にあるnまでの範囲で、nCrを高速に計算する",
            "        >>> p = Mint()",
            "        >>> p.cmb_prep(10)",
            "        >>> p.cmb(10, 2)",
            "        45",
            "        \"\"\"",
            "        if (r < 0) or (r > n):",
            "            return 0",
            "        r = min(r, n - r)",
            "        return self.g1[n] * self.g2[r] * self.g2[n - r] % mod",
            "    def cmb_prep(self, N: int, mod: int = 10 ** 9 + 7):",
            "        self.g1 = [1, 1]  # 元テーブル",
            "        self.g2 = [1, 1]  # 逆元テーブル",
            "        inverse = [0, 1]  # 逆元テーブル計算用テーブル",
            "        for i in range(2, N + 1):",
            "            self.g1.append((self.g1[-1] * i) % mod)",
            "            inverse.append((-inverse[mod % i] * (mod // i)) % mod)",
            "            self.g2.append((self.g2[-1] * inverse[-1]) % mod)",
            "    @staticmethod",
            "    def iterated_power(z: int, n: int, mod=None) -> int:",
            "        \"\"\" 繰り返し二乗法でn**kを求める（再帰処理は使わない）",
            "        >>> p = Mint()",
            "        >>> p.iterated_power(3, 10)",
            "        59049",
            "        >>> p.iterated_power(3, 10, 10)",
            "        9",
            "        \"\"\"",
            "        beta = bin(n)[2:]",
            "        Z, q, t = z, 0, len(beta)",
            "        while beta[t - q - 1] == '0':",
            "            Z = Z * Z",
            "            if mod is not None:",
            "                Z = Z % mod",
            "            q += 1",
            "        result = Z",
            "        for k in range(q + 1, t):",
            "            Z = Z * Z",
            "            if mod is not None:",
            "                Z = Z % mod",
            "            if beta[t - k - 1] == '1':",
            "                result = result * Z",
            "                if mod is not None:",
            "                    result = result % mod",
            "        if mod is not None:",
            "            result = result % mod",
            "        return result",
            "    @staticmethod",
            "    def factorization(n: int) -> dict:",
            "        from collections import defaultdict",
            "        arr = defaultdict(int)",
            "        temp = n",
            "        for i in range(2, int(-(-n ** 0.5 // 1)) + 1):",
            "            if temp % i == 0:",
            "                cnt = 0",
            "                while temp % i == 0:",
            "                    cnt += 1",
            "                    temp //= i",
            "                arr[i] = cnt",
            "        if temp != 1:",
            "            arr[temp] = 1",
            "        if arr == []:",
            "            arr[n] = 1",
            "        return arr",
            "    @staticmethod",
            "    def enumerate_prime(n: int) -> (list, dict, list):",
            "        \"\"\"",
            "        n以下の素数を列挙する",
            "        何で割るかを記録しておくことで、素因数分解が高速にできる",
            "        >>> p = Mint()",
            "        >>> p.enumerate_prime(11)",
            "        ([2, 3, 5, 7, 11], {2: 0, 3: 1, 5: 2, 7: 3, 11: 4}, [0, 1, 2, 3, 2, 5, 3, 7, 2, 3, 5, 11])",
            "        \"\"\"",
            "        lis_prime = [True] * (n+1)",
            "        lis_prime[0] = False",
            "        lis_prime[1] = False",
            "        primes = []",
            "        div_prime = [i for i in range(n + 1)]",
            "        primes_idx = {}",
            "        cnt = 0",
            "        for i in range(2, n+1):",
            "            if lis_prime[i]:",
            "                primes.append(i)",
            "                primes_idx[i] = cnt",
            "                cnt += 1",
            "                j = 2 * i",
            "                while True:",
            "                    if j > n:",
            "                        break",
            "                    lis_prime[j] = False",
            "                    div_prime[j] = i",
            "                    j += i",
            "        return primes, primes_idx, div_prime",
            "    @staticmethod",
            "    def is_prime(n: int) -> bool:",
            "        \"\"\"",
            "        素数判定",
            "        >>> p = Mint()",
            "        >>> p.is_prime(2)",
            "        True",
            "        >>> p.is_prime(43)",
            "        True",
            "        >>> p.is_prime(4)",
            "        False",
            "        \"\"\"",
            "        if n == 1:",
            "            return False",
            "        if n == 2:",
            "            return True",
            "        for i in range(2, n):",
            "            if n % i == 0:",
            "                return False",
            "            if i * i > n:",
            "                return True",
            "    @staticmethod",
            "    def divisor(n: int) -> list:",
            "        \"\"\"",
            "        約数列挙",
            "        >>> p = Mint()",
            "        >>> p.divisor(6)",
            "        [1, 2, 3, 6]",
            "        \"\"\"",
            "        res = []",
            "        if n == 1:",
            "            return [1]",
            "        for i in range(1, n):",
            "            if n % i == 0:",
            "                res.append(i)",
            "                if i != n / i:",
            "                    res.append(int(n / i))",
            "            if (i+1) * (i+1) > n:",
            "                res.sort()",
            "                return res",
            "mint = Mint()",
            "c = mint.gcd(a, b)",
            "# print(c)",
            "candidates = mint.divisor(c)[1:]",
            "# print(candidates)",
            "res = [True] * len(candidates)",
            "for idx, i in enumerate(candidates):",
            "    # if i > len(candidates)**.5:",
            "    #     break",
            "    for j in range(idx+1, len(candidates)):",
            "        if candidates[j] % i == 0:",
            "            res[j] = False",
            "ans = 1",
            "for i in res:",
            "    if i:",
            "        ans += 1",
            "print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            2,
            2
        ]
    },
    {
        "content": [
            "mod = 10 ** 9 + 7",
            "from collections import deque",
            "import heapq",
            "def iip(listed):",
            "    ret = [int(i) for i in input().split()]",
            "    if len(ret) == 1 and not listed:",
            "        return ret[0]",
            "    return ret",
            "def main():",
            "    r = solve()",
            "    print(r)",
            "def solve():",
            "    N, M = iip(False)",
            "    dp = {\"0\"*N:0}",
            "    keys = []",
            "    for i in range(M):",
            "        a, b = iip(True)",
            "        c = iip(True)",
            "        keys.append((a, c))",
            "    for cost, boxes in keys:",
            "        for k, v in list(dp.items()):",
            "            k_add = list(k)",
            "            for box in boxes:",
            "                #print(k_add)",
            "                k_add[int(box) - 1] = \"1\"",
            "            v = v + cost",
            "            k_add = \"\".join(k_add)",
            "            if k_add not in dp:",
            "                dp[k_add] = v",
            "            else:",
            "                dp[k_add] = min(v, dp[k_add])",
            "        #print(cost)",
            "        #print(boxes)",
            "    #print(dp)",
            "    keyans = \"1\" * N",
            "    if keyans not in dp:",
            "        return -1",
            "    else:",
            "        return dp[keyans]",
            "#####################################################ライブラリ集ここから",
            "def split_print_space(s):",
            "    print(\" \".join([str(i) for i in s]))",
            "def split_print_enter(s):",
            "    print(\"\\n\".join([str(i) for i in s]))",
            "def koenai_saidai_x_index(sorted_list, n):",
            "    l = 0",
            "    r = len(sorted_list)",
            "    if len(sorted_list) == 0:",
            "        return False",
            "    if sorted_list[0] > n:",
            "        return False",
            "    while r - l > 1:",
            "        x = (l + r) // 2",
            "        if sorted_list[x] == n:",
            "            return x",
            "        elif sorted_list[x] > n:",
            "            r = x",
            "        else:",
            "            l = x",
            "    return l",
            "def searchsorted(sorted_list, n, side):",
            "    if side not in [\"right\", \"left\"]:",
            "        raise Exception(\"sideはrightかleftで指定してください\")",
            "    l = 0",
            "    r = len(sorted_list)",
            "    if n > sorted_list[-1]:",
            "        # print(sorted_list)",
            "        return len(sorted_list)",
            "    if n < sorted_list[0]:",
            "        return 0",
            "    while r - l > 1:",
            "        x = (l + r) // 2",
            "        if sorted_list[x] > n:",
            "            r = x",
            "        elif sorted_list[x] < n:",
            "            l = x",
            "        else:",
            "            if side == \"left\":",
            "                r = x",
            "            elif side == \"right\":",
            "                l = x",
            "    if side == \"left\":",
            "        if sorted_list[l] == n:",
            "            return r - 1",
            "        else:",
            "            return r",
            "    if side == \"right\":",
            "        if sorted_list[l] == n:",
            "            return l + 1",
            "        else:",
            "            return l",
            "def soinsuu_bunkai(n):",
            "    ret = []",
            "    for i in range(2, int(n ** 0.5) + 1):",
            "        while n % i == 0:",
            "            n //= i",
            "            ret.append(i)",
            "        if i > n:",
            "            break",
            "    if n != 1:",
            "        ret.append(n)",
            "    return ret",
            "def conbination(n, r, mod, test=False):",
            "    if n <= 0:",
            "        return 0",
            "    if r == 0:",
            "        return 1",
            "    if r < 0:",
            "        return 0",
            "    if r == 1:",
            "        return n",
            "    ret = 1",
            "    for i in range(n - r + 1, n + 1):",
            "        ret *= i",
            "        ret = ret % mod",
            "    bunbo = 1",
            "    for i in range(1, r + 1):",
            "        bunbo *= i",
            "        bunbo = bunbo % mod",
            "    ret = (ret * inv(bunbo, mod)) % mod",
            "    if test:",
            "        # print(f\"{n}C{r} = {ret}\")",
            "        pass",
            "    return ret",
            "def inv(n, mod):",
            "    return power(n, mod - 2)",
            "def power(n, p):",
            "    if p == 0:",
            "        return 1",
            "    if p % 2 == 0:",
            "        return (power(n, p // 2) ** 2) % mod",
            "    if p % 2 == 1:",
            "        return (n * power(n, p - 1)) % mod",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product                # product(iter, repeat=n)",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "def main():",
            "    mod = 1000000007                  # 10^9+7",
            "    inf = float('inf')",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():  return int(input())",
            "    def mi():  return map(int, input().split())",
            "    def mi_0(): return map(lambda x: int(x)-1, input().split())",
            "    def lmi(): return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():  return list(input())",
            "    n, m = mi()",
            "    # 1-index",
            "    k = [None]",
            "    for _ in range(m):",
            "        a, _ = mi()",
            "        k.append([a, lmi()])",
            "    d = 2 ** n",
            "    dp = [[0] * d for _ in range(m + 1)]",
            "    for j in range(1, d):",
            "        dp[0][j] = inf",
            "    for j in range(1, d):",
            "        for i in range(1, m + 1):",
            "            cost = k[i][0]",
            "            able_to_open = k[i][1]",
            "            mask = 0b0",
            "            for num in able_to_open:",
            "                mask |= (1 << (num - 1))",
            "            # print(bin(mask))",
            "            mask = ~mask",
            "            # print(bin(mask))",
            "            j_prime = j & mask",
            "            dp[i][j] = min(dp[i-1][j], dp[i-1][j_prime] + cost)",
            "    # print(dp)",
            "    print(dp[m][d-1]) if dp[m][d-1] != inf else print(-1)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# abc141_b.py",
            "# https://atcoder.jp/contests/abc141/tasks/abc141_b",
            "# B - Tap Dance /",
            "# 実行時間制限: 2 sec / メモリ制限: 1024 MB",
            "# 配点: 200点",
            "# 問題文",
            "# 高橋君はタップダンスをすることにしました。",
            "# タップダンスの動きは文字列 Sで表され、S の各文字は L, R, U, D のいずれかです。",
            "# 各文字は足を置く位置を表しており、1文字目から順番に踏んでいきます。",
            "# Sが以下の 2 条件を満たすとき、またその時に限り、Sを「踏みやすい」文字列といいます。",
            "#     奇数文字目がすべて R, U, D のいずれか。",
            "#     偶数文字目がすべて L, U, D のいずれか。",
            "# Sが「踏みやすい」文字列なら Yes を、そうでなければ No を出力してください。",
            "# 制約",
            "#     Sは長さ 1 以上 100以下の文字列",
            "#     Sの各文字は L, R, U, D のいずれか",
            "# 入力",
            "# 入力は以下の形式で標準入力から与えられます。",
            "# S",
            "# 出力",
            "# Sが「踏みやすい」文字列なら Yes を、そうでなければ No を出力してください。",
            "# 入力例 1",
            "# RUDLUDR",
            "# 出力例 1",
            "# Yes",
            "# 1,3,5,7文字目は R, U, D のいずれかです。",
            "# 2,4,6文字目は L, U, D のいずれかです。",
            "# したがって、この Sは「踏みやすい」文字列です。",
            "# 入力例 2",
            "# DULL",
            "# 出力例 2",
            "# No",
            "# 3文字目が R, U, D のいずれでもないので、この Sは「踏みやすい」文字列ではありません。",
            "# 入力例 3",
            "# UUUUUUUUUUUUUUU",
            "# 出力例 3",
            "# Yes",
            "# 入力例 4",
            "# ULURU",
            "# 出力例 4",
            "# No",
            "# 入力例 5",
            "# RDULULDURURLRDULRLR",
            "# 出力例 5",
            "# Yes",
            "global FLAG_LOG",
            "FLAG_LOG = False",
            "def log(value):",
            "    # FLAG_LOG = True",
            "    # FLAG_LOG = False",
            "    if FLAG_LOG:",
            "        print(str(value))",
            "def calculation(lines):",
            "    S = lines[0]",
            "    # N = int(lines[0])",
            "    # N, M = list(map(int, lines[0].split()))",
            "    # values = list(map(int, lines[1].split()))",
            "    # values = list(map(int, lines[2].split()))",
            "    # values = list()",
            "    # for i in range(N):",
            "    #     values.append(int(lines[i]))",
            "    # valueses = list()",
            "    # for i in range(N):",
            "    #     valueses.append(list(map(int, lines[i+1].split())))",
            "    rstr = ''",
            "    lstr = ''",
            "    for i, char in enumerate(S):",
            "        if i % 2 == 0:",
            "            rstr += char",
            "        else:",
            "            lstr += char",
            "    if 'L' in rstr:",
            "        result = 'No'",
            "    elif 'R' in lstr:",
            "        result = 'No'",
            "    else:",
            "        result = 'Yes'",
            "    return [result]",
            "# 引数を取得",
            "def get_input_lines(lines_count):",
            "    lines = list()",
            "    for _ in range(lines_count):",
            "        lines.append(input())",
            "    return lines",
            "# テストデータ",
            "def get_testdata(pattern):",
            "    if pattern == 1:",
            "        lines_input = ['RUDLUDR']",
            "        lines_export = ['Yes']",
            "    if pattern == 2:",
            "        lines_input = ['DULL']",
            "        lines_export = ['No']",
            "    if pattern == 3:",
            "        lines_input = ['UUUUUUUUUUUUUUU']",
            "        lines_export = ['Yes']",
            "    if pattern == 4:",
            "        lines_input = ['ULURU']",
            "        lines_export = ['No']",
            "    if pattern == 5:",
            "        lines_input = ['RDULULDURURLRDULRLR']",
            "        lines_export = ['Yes']",
            "    return lines_input, lines_export",
            "# 動作モード判別",
            "def get_mode():",
            "    import sys",
            "    args = sys.argv",
            "    global FLAG_LOG",
            "    if len(args) == 1:",
            "        mode = 0",
            "        FLAG_LOG = False",
            "    else:",
            "        mode = int(args[1])",
            "        FLAG_LOG = True",
            "    return mode",
            "# 主処理",
            "def main():",
            "    import time",
            "    started = time.time()",
            "    mode = get_mode()",
            "    if mode == 0:",
            "        lines_input = get_input_lines(1)",
            "    else:",
            "        lines_input, lines_export = get_testdata(mode)",
            "    lines_result = calculation(lines_input)",
            "    for line_result in lines_result:",
            "        print(line_result)",
            "    # if mode > 0:",
            "    #     print(f'lines_input=[{lines_input}]')",
            "    #     print(f'lines_export=[{lines_export}]')",
            "    #     print(f'lines_result=[{lines_result}]')",
            "    #     if lines_result == lines_export:",
            "    #         print('OK')",
            "    #     else:",
            "    #         print('NG')",
            "    # finished = time.time()",
            "    # duration = finished - started",
            "    # print(f'duration=[{duration}]')",
            "# 起動処理",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "mod = 10 ** 9 + 7",
            "mod2 = 2**61+1",
            "from collections import deque",
            "import heapq",
            "def iip(listed):",
            "    ret = [int(i) for i in input().split()]",
            "    if len(ret) == 1 and not listed:",
            "        return ret[0]",
            "    return ret",
            "def main():",
            "    r = solve()",
            "    print(r)",
            "def solve():",
            "    N = iip(False)",
            "    S = input()",
            "    dp = [[0]*(N+1) for _ in range(N+1)]",
            "    for i in reversed(range(N)):",
            "        for j in reversed(range(N)):",
            "            if S[j] == S[i]:",
            "                dp[i][j] = dp[i+1][j+1]+1",
            "    ans = 0",
            "    for i in range(N):",
            "        for j in range(N):",
            "            if i >= j:",
            "                continue",
            "            cnt = dp[i][j]",
            "            if cnt+i > j:",
            "                continue",
            "            ans = max(ans, cnt)",
            "    return ans",
            "#####################################################ライブラリ集ここから",
            "def split_print_space(s):",
            "    print(\" \".join([str(i) for i in s]))",
            "def split_print_enter(s):",
            "    print(\"\\n\".join([str(i) for i in s]))",
            "def koenai_saidai_x_index(sorted_list, n):",
            "    l = 0",
            "    r = len(sorted_list)",
            "    if len(sorted_list) == 0:",
            "        return False",
            "    if sorted_list[0] > n:",
            "        return False",
            "    while r - l > 1:",
            "        x = (l + r) // 2",
            "        if sorted_list[x] == n:",
            "            return x",
            "        elif sorted_list[x] > n:",
            "            r = x",
            "        else:",
            "            l = x",
            "    return l",
            "def searchsorted(sorted_list, n, side):",
            "    if side not in [\"right\", \"left\"]:",
            "        raise Exception(\"sideはrightかleftで指定してください\")",
            "    l = 0",
            "    r = len(sorted_list)",
            "    if n > sorted_list[-1]:",
            "        # print(sorted_list)",
            "        return len(sorted_list)",
            "    if n < sorted_list[0]:",
            "        return 0",
            "    while r - l > 1:",
            "        x = (l + r) // 2",
            "        if sorted_list[x] > n:",
            "            r = x",
            "        elif sorted_list[x] < n:",
            "            l = x",
            "        else:",
            "            if side == \"left\":",
            "                r = x",
            "            elif side == \"right\":",
            "                l = x",
            "    if side == \"left\":",
            "        if sorted_list[l] == n:",
            "            return r - 1",
            "        else:",
            "            return r",
            "    if side == \"right\":",
            "        if sorted_list[l] == n:",
            "            return l + 1",
            "        else:",
            "            return l",
            "def soinsuu_bunkai(n):",
            "    ret = []",
            "    for i in range(2, int(n ** 0.5) + 1):",
            "        while n % i == 0:",
            "            n //= i",
            "            ret.append(i)",
            "        if i > n:",
            "            break",
            "    if n != 1:",
            "        ret.append(n)",
            "    return ret",
            "def conbination(n, r, mod, test=False):",
            "    if n <= 0:",
            "        return 0",
            "    if r == 0:",
            "        return 1",
            "    if r < 0:",
            "        return 0",
            "    if r == 1:",
            "        return n",
            "    ret = 1",
            "    for i in range(n - r + 1, n + 1):",
            "        ret *= i",
            "        ret = ret % mod",
            "    bunbo = 1",
            "    for i in range(1, r + 1):",
            "        bunbo *= i",
            "        bunbo = bunbo % mod",
            "    ret = (ret * inv(bunbo, mod)) % mod",
            "    if test:",
            "        # print(f\"{n}C{r} = {ret}\")",
            "        pass",
            "    return ret",
            "def inv(n, mod):",
            "    return power(n, mod - 2)",
            "def power(n, p, mod_= mod):",
            "    if p == 0:",
            "        return 1",
            "    if p % 2 == 0:",
            "        return (power(n, p // 2, mod_) ** 2) % mod_",
            "    if p % 2 == 1:",
            "        return (n * power(n, p - 1, mod_)) % mod_",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "mod = 10 ** 9 + 7",
            "mod2 = 2**61+1",
            "from collections import deque",
            "import heapq",
            "def iip(listed):",
            "    ret = [int(i) for i in input().split()]",
            "    if len(ret) == 1 and not listed:",
            "        return ret[0]",
            "    return ret",
            "def main():",
            "    r = solve()",
            "    print(r)",
            "def z_algo(s):",
            "    n = len(s)",
            "    LCP = [0]*n",
            "    c = 0 #最も末尾側までLCPを求めたindex",
            "    for i in range(1, n): # i番目からのLCPが以前計算したcからのLCPに含まれている場合",
            "        if i+LCP[i-c] < c+LCP[c]:",
            "            LCP[i] = LCP[i-c]",
            "        else:",
            "            j = max(0, c+LCP[c]-i)",
            "            while i+j < n and s[j] == s[i+j]:",
            "                j += 1",
            "            LCP[i] = j",
            "            c = i",
            "    LCP[0] = n",
            "    return LCP",
            "def solve():",
            "    N = iip(False)",
            "    S = input()",
            "    ans = 0",
            "    for i in range(N):",
            "        LCP = z_algo(S[i:])",
            "        #print(LCP)",
            "        for j, k in enumerate(LCP):",
            "            left = k",
            "            if left > j:",
            "                #print(\"ng\", i, k, j)",
            "                continue",
            "            else:",
            "                #print(\"ok\", i, k)",
            "                ans = max(ans, k)",
            "    return ans",
            "#####################################################ライブラリ集ここから",
            "def split_print_space(s):",
            "    print(\" \".join([str(i) for i in s]))",
            "def split_print_enter(s):",
            "    print(\"\\n\".join([str(i) for i in s]))",
            "def koenai_saidai_x_index(sorted_list, n):",
            "    l = 0",
            "    r = len(sorted_list)",
            "    if len(sorted_list) == 0:",
            "        return False",
            "    if sorted_list[0] > n:",
            "        return False",
            "    while r - l > 1:",
            "        x = (l + r) // 2",
            "        if sorted_list[x] == n:",
            "            return x",
            "        elif sorted_list[x] > n:",
            "            r = x",
            "        else:",
            "            l = x",
            "    return l",
            "def searchsorted(sorted_list, n, side):",
            "    if side not in [\"right\", \"left\"]:",
            "        raise Exception(\"sideはrightかleftで指定してください\")",
            "    l = 0",
            "    r = len(sorted_list)",
            "    if n > sorted_list[-1]:",
            "        # print(sorted_list)",
            "        return len(sorted_list)",
            "    if n < sorted_list[0]:",
            "        return 0",
            "    while r - l > 1:",
            "        x = (l + r) // 2",
            "        if sorted_list[x] > n:",
            "            r = x",
            "        elif sorted_list[x] < n:",
            "            l = x",
            "        else:",
            "            if side == \"left\":",
            "                r = x",
            "            elif side == \"right\":",
            "                l = x",
            "    if side == \"left\":",
            "        if sorted_list[l] == n:",
            "            return r - 1",
            "        else:",
            "            return r",
            "    if side == \"right\":",
            "        if sorted_list[l] == n:",
            "            return l + 1",
            "        else:",
            "            return l",
            "def soinsuu_bunkai(n):",
            "    ret = []",
            "    for i in range(2, int(n ** 0.5) + 1):",
            "        while n % i == 0:",
            "            n //= i",
            "            ret.append(i)",
            "        if i > n:",
            "            break",
            "    if n != 1:",
            "        ret.append(n)",
            "    return ret",
            "def conbination(n, r, mod, test=False):",
            "    if n <= 0:",
            "        return 0",
            "    if r == 0:",
            "        return 1",
            "    if r < 0:",
            "        return 0",
            "    if r == 1:",
            "        return n",
            "    ret = 1",
            "    for i in range(n - r + 1, n + 1):",
            "        ret *= i",
            "        ret = ret % mod",
            "    bunbo = 1",
            "    for i in range(1, r + 1):",
            "        bunbo *= i",
            "        bunbo = bunbo % mod",
            "    ret = (ret * inv(bunbo, mod)) % mod",
            "    if test:",
            "        # print(f\"{n}C{r} = {ret}\")",
            "        pass",
            "    return ret",
            "def inv(n, mod):",
            "    return power(n, mod - 2)",
            "def power(n, p, mod_= mod):",
            "    if p == 0:",
            "        return 1",
            "    if p % 2 == 0:",
            "        return (power(n, p // 2, mod_) ** 2) % mod_",
            "    if p % 2 == 1:",
            "        return (n * power(n, p - 1, mod_)) % mod_",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "sys.setrecursionlimit(10 ** 5 + 10)",
            "def input(): return sys.stdin.readline().strip()",
            "def resolve():",
            "    class SuffixArray:",
            "        \"\"\"",
            "        construct:",
            "            suffix array: O(N(logN)^2)",
            "            lcp array: O(N)",
            "            sparse table: O(NlogN)",
            "        query:",
            "            get_lcp: O(1)",
            "        \"\"\"",
            "        def __init__(self, s):",
            "            \"\"\"",
            "            s: str",
            "            \"\"\"",
            "            self.__s = s",
            "            self.__n = len(s)",
            "            self.__suffix_array()",
            "            self.__lcp_array()",
            "            self.__sparse_table()",
            "        # suffix array",
            "        def __suffix_array(self):",
            "            s = self.__s",
            "            n = self.__n",
            "            # initialize",
            "            sa = list(range(n))",
            "            rank = [ord(s[i]) for i in range(n)]",
            "            tmp = [0]*n",
            "            k = 1",
            "            def cmp_key(i): return (rank[i], rank[i+k] if i+k < n else -1)",
            "            # iterate",
            "            while(k <= n):",
            "                sa.sort(key=cmp_key)",
            "                tmp[sa[0]] = 0",
            "                for i in range(1, n):",
            "                    tmp[sa[i]] = tmp[sa[i-1]]+(cmp_key(sa[i-1]) < cmp_key(sa[i]))",
            "                rank = tmp[:]",
            "                k <<= 1",
            "            self.__sa = sa",
            "            self.__rank = rank",
            "        # LCP array",
            "        def __lcp_array(self):",
            "            n = self.__n",
            "            s = self.__s",
            "            sa = self.__sa",
            "            rank = self.__rank",
            "            lcp = [0]*n",
            "            h = 0",
            "            for i in range(n):",
            "                j = sa[rank[i]-1]",
            "                if h > 0:",
            "                    h -= 1",
            "                while j+h < n and i+h < n and s[j+h] == s[i+h]:",
            "                    h += 1",
            "                lcp[rank[i]] = h",
            "            self.__lcp = lcp",
            "        # sparse table (LCPのminをとるindexを持つ)",
            "        def __sparse_table(self):",
            "            n = self.__n",
            "            logn = max(0, (n-1).bit_length())",
            "            table = [[0]*n for _ in range(logn)]",
            "            table[0] = list(range(n))",
            "            # construct",
            "            for i in range(1, logn):",
            "                for k in range(n):",
            "                    if k+(1 << (i-1)) >= n:",
            "                        table[i][k] = table[i-1][k]",
            "                        continue",
            "                    if self.__lcp[table[i-1][k]] <= self.__lcp[table[i-1][k+(1 << (i-1))]]:",
            "                        table[i][k] = table[i-1][k]",
            "                    else:",
            "                        table[i][k] = table[i-1][k+(1 << (i-1))]",
            "            self.__table = table",
            "        def get_lcp(self, a, b):",
            "            \"\"\"",
            "            a,b: int 0<=a,b<n",
            "            return LCP length between s[a:] and s[b:]",
            "            \"\"\"",
            "            if a == b:",
            "                return self.__n-a",
            "            l, r = self.__rank[a], self.__rank[b]",
            "            l, r = min(l, r)+1, max(l, r)+1",
            "            if r-l == 1:",
            "                return self.__lcp[l]",
            "            i = (r-l-1).bit_length()-1",
            "            if self.__lcp[self.__table[i][l]] <= self.__lcp[self.__table[i][r-(1 << i)]]:",
            "                return self.__lcp[self.__table[i][l]]",
            "            else:",
            "                return self.__lcp[self.__table[i][r-(1 << i)]]",
            "    n = int(input())",
            "    s = input()",
            "    sa = SuffixArray(s)",
            "    ans = 0",
            "    for i in range(n):",
            "        for j in range(i+1, n):",
            "            ans = max(ans, min(sa.get_lcp(i, j), j-i))",
            "    print(ans)",
            "resolve()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "# abc140_b.py",
            "# https://atcoder.jp/contests/abc140/tasks/abc140_b",
            "# B - Buffet /",
            "# 実行時間制限: 2 sec / メモリ制限: 1024 MB",
            "# 配点 : 200点",
            "# 問題文",
            "# 高橋くんは N種類の料理が食べ放題のビュッフェに行き、全種類の料理 (料理 1, 料理 2, …, 料理 N) を 1度ずつ食べました。",
            "# 高橋くんが i(1≤i≤N) 番目に食べた料理は料理 Aiでした。",
            "# 高橋くんは、料理 i(1≤i≤N) を食べると満足度 Biを得ます。",
            "# また、料理 i(1≤i≤N−1) を食べた直後に料理 i+1 を食べると満足度 Ciを追加で得ます。",
            "# 高橋くんが得た満足度の合計を求めてください。",
            "# 制約",
            "#     入力は全て整数である。",
            "#     2≤N≤20",
            "#     1≤Ai≤N",
            "#     A1,A2,...,AN",
            "#     は全て異なる。",
            "#     1≤Bi≤50",
            "#     1≤Ci≤50",
            "# 入力",
            "# 入力は以下の形式で標準入力から与えられる。",
            "# N",
            "# A1 A2 ... AN",
            "# B1 B2 ... BN",
            "# C1 C2 ... CN−1",
            "# 出力",
            "# 高橋くんが得た満足度の合計を整数で出力せよ。",
            "# 入力例 1",
            "# 3",
            "# 3 1 2",
            "# 2 5 4",
            "# 3 6",
            "# 出力例 1",
            "# 14",
            "# 以下のように高橋くんは合計 14の満足度を得ました。",
            "#     高橋くんはまず料理 3を食べ、満足度 4を得ました。",
            "#     高橋くんは次に料理 1を食べ、満足度 2を得ました。",
            "#     高橋くんは最後に料理 2を食べ、満足度 5+3=8を得ました。",
            "# 入力例 2",
            "# 4",
            "# 2 3 4 1",
            "# 13 5 8 24",
            "# 45 9 15",
            "# 出力例 2",
            "# 74",
            "# 入力例 3",
            "# 2",
            "# 1 2",
            "# 50 50",
            "# 50",
            "# 出力例 3",
            "# 150",
            "global FLAG_LOG",
            "FLAG_LOG = False",
            "def log(value):",
            "    # FLAG_LOG = True",
            "    # FLAG_LOG = False",
            "    if FLAG_LOG:",
            "        print(str(value))",
            "def calculation(lines):",
            "    # S = lines[0]",
            "    N = int(lines[0])",
            "    # N, M = list(map(int, lines[0].split()))",
            "    values_a = list(map(int, lines[1].split()))",
            "    values_b = list(map(int, lines[2].split()))",
            "    values_c = list(map(int, lines[3].split()))",
            "    # values = list()",
            "    # for i in range(N):",
            "    #     values.append(int(lines[i]))",
            "    # valueses = list()",
            "    # for i in range(N):",
            "    #     valueses.append(list(map(int, lines[i+1].split())))",
            "    # 最初の分を計算しておく",
            "    current = values_a[0]-1",
            "    result = values_b[current]",
            "    prev = current",
            "    for n in range(1, N):",
            "        current = values_a[n]-1",
            "        result += values_b[current]",
            "        log(f'n=[{n}], current=[{current}], prev=[{prev}]')",
            "        if current == prev+1:",
            "            result += values_c[prev]",
            "        prev = current",
            "    return [result]",
            "# 引数を取得",
            "def get_input_lines(lines_count):",
            "    lines = list()",
            "    for _ in range(lines_count):",
            "        lines.append(input())",
            "    return lines",
            "# テストデータ",
            "def get_testdata(pattern):",
            "    if pattern == 1:",
            "        lines_input = ['3', '3 1 2', '2 5 4', '3 6']",
            "        lines_export = [14]",
            "    if pattern == 2:",
            "        lines_input = ['4', '2 3 4 1', '13 5 8 24', '45 9 15']",
            "        lines_export = [74]",
            "    if pattern == 3:",
            "        lines_input = ['2', '1 2', '50 50', '50']",
            "        lines_export = [150]",
            "    return lines_input, lines_export",
            "# 動作モード判別",
            "def get_mode():",
            "    import sys",
            "    args = sys.argv",
            "    global FLAG_LOG",
            "    if len(args) == 1:",
            "        mode = 0",
            "        FLAG_LOG = False",
            "    else:",
            "        mode = int(args[1])",
            "        FLAG_LOG = True",
            "    return mode",
            "# 主処理",
            "def main():",
            "    import time",
            "    started = time.time()",
            "    mode = get_mode()",
            "    if mode == 0:",
            "        lines_input = get_input_lines(4)",
            "    else:",
            "        lines_input, lines_export = get_testdata(mode)",
            "    lines_result = calculation(lines_input)",
            "    for line_result in lines_result:",
            "        print(line_result)",
            "    # if mode > 0:",
            "    #     print(f'lines_input=[{lines_input}]')",
            "    #     print(f'lines_export=[{lines_export}]')",
            "    #     print(f'lines_result=[{lines_result}]')",
            "    #     if lines_result == lines_export:",
            "    #         print('OK')",
            "    #     else:",
            "    #         print('NG')",
            "    # finished = time.time()",
            "    # duration = finished - started",
            "    # print(f'duration=[{duration}]')",
            "# 起動処理",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def edge_to_vertex(n, i, j):",
            "        'convert edge(i,j) (1-index) to vertex'",
            "        return (2 * n - i) * (i - 1) // 2 + (j - i - 1)",
            "    def topological_bfs(m, adj):",
            "        sorted_vertices = []",
            "        dim = [0] * m",
            "        for i in range(m):",
            "            for j in adj[i]:",
            "                dim[j] += 1",
            "        q = deque()",
            "        for i in range(m):",
            "            if dim[i] == 0:",
            "                q.append(i)",
            "        while q:",
            "            u = q.popleft()",
            "            assert(dim[u] == 0)",
            "            sorted_vertices.append(u)",
            "            for v in adj[u]:",
            "                dim[v] -= 1",
            "                if dim[v] == 0:",
            "                    q.append(v)",
            "        return sorted_vertices",
            "    n = ii()",
            "    # 試合の組み合わせを頂点へと変換し有向グラフ隣接リストへと変換する前処理 O(n^2)",
            "    m = n * (n - 1) // 2",
            "    adj = [[] for _ in range(m)]",
            "    for i in range(1, n + 1):",
            "        L = lmi()",
            "        vertices = [edge_to_vertex(n, min(i, j), max(i, j)) for j in L]",
            "        for k in range(1, n - 1):",
            "            u, v = vertices[k-1], vertices[k]",
            "            adj[u].append(v)",
            "    # print(adj)",
            "    # BFS トポロジカルソートを用いて閉路判定 O(n^2)",
            "    topological_sorted = topological_bfs(m, adj)",
            "    if len(topological_sorted) != m:",
            "        print(-1)",
            "    # 入次数 0 の頂点からトポロジカルソート順に辺を緩和し、最大距離を返す O(n^2)",
            "    else:",
            "        cost = [1] * m",
            "        for u in topological_sorted:",
            "            for v in adj[u]:",
            "                cost[v] = max(cost[u], cost[u] + 1)",
            "        print(max(cost))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# abc138_c.py",
            "# https://atcoder.jp/contests/abc138/tasks/abc138_c",
            "# C - Alchemist /",
            "# 実行時間制限: 2 sec / メモリ制限: 1024 MB",
            "# 配点 : 300点",
            "# 問題文",
            "# あなたは鍋と N個の具材を持っています。各具材は 価値 と呼ばれる実数の値を持ち、i 個目 (1≤i≤N) の具材の価値は viです。",
            "# 2個の具材を鍋に入れると、それらは消滅して新たに 1 個の具材が生成されます。",
            "# この新たな具材の価値は元の 2 個の具材の価値を x,y として (x+y)/2であり、この具材を再び鍋に入れることもできます。",
            "# この具材の合成を N−1回行うと、最後に 1個の具材が残ります。この具材の価値として考えられる最大の値を求めてください。",
            "# 制約",
            "#     2≤N≤50",
            "#     1≤vi≤1000",
            "#     入力中の値はすべて整数である。",
            "# 入力",
            "# 入力は以下の形式で標準入力から与えられる。",
            "# N",
            "# v1 v2 … vN",
            "# 出力",
            "# 最後に残る 1個の具材の価値として考えられる最大の値を表す小数 (または整数) を出力せよ。",
            "# 出力は、ジャッジの出力との絶対誤差または相対誤差が 10−5以下のとき正解と判定される。",
            "# 入力例 1",
            "# 2",
            "# 3 4",
            "# 出力例 1",
            "# 3.5",
            "# はじめに持っている具材が 2個の場合、それらをともに鍋に入れるほかありません。",
            "# 価値 3,4 の具材から合成される具材の価値は (3+4)/2=3.5です。",
            "# なお、3.50001, 3.49999 などと出力しても正解となります。",
            "# 入力例 2",
            "# 3",
            "# 500 300 200",
            "# 出力例 2",
            "# 375",
            "# 今回ははじめに 3個の具材を持っており、一度目の合成で鍋にどの具材を入れるかに選択の余地があります。選択肢は次の 3通りです。",
            "#     価値 500,300の具材を入れ、価値 (500+300)/2=400 の具材を合成する。この場合、次の合成ではこれと価値 200 の具材を鍋に入れることになり、価値 (400+200)/2=300の具材が合成される。",
            "#     価値 500,200の具材を入れ、価値 (500+200)/2=350 の具材を合成する。この場合、次の合成ではこれと価値 300 の具材を鍋に入れることになり、価値 (350+300)/2=325の具材が合成される。",
            "#     価値 300,200の具材を入れ、価値 (300+200)/2=250 の具材を合成する。この場合、次の合成ではこれと価値 500 の具材を鍋に入れることになり、価値 (250+500)/2=375の具材が合成される。",
            "# よって、最後に残る 1個の具材の価値として考えられる最大の値は 375です。",
            "# なお、375.0 などと出力しても正解となります。",
            "# 入力例 3",
            "# 5",
            "# 138 138 138 138 138",
            "# 出力例 3",
            "# 138",
            "global FLAG_LOG",
            "FLAG_LOG = False",
            "def log(value):",
            "    # FLAG_LOG = True",
            "    # FLAG_LOG = False",
            "    if FLAG_LOG:",
            "        print(str(value))",
            "def calculation(lines):",
            "    # S = lines[0]",
            "    N = int(lines[0])",
            "    # X, A = list(map(int, lines[0].split()))",
            "    values = list(map(int, lines[1].split()))",
            "    # values = list(map(int, lines[2].split()))",
            "    # values = list()",
            "    # for i in range(6):",
            "    #     values.append(int(lines[i]))",
            "    # valueses = list()",
            "    # for i in range(M):",
            "    #     valueses.append(list(map(int, lines[i+1].split())))",
            "    values.sort()",
            "    ave = min(values)",
            "    log(f'ave=[{ave}]')",
            "    for n in range(1, N):",
            "        ave = (ave + values[n]) / 2",
            "        log(f'ave=[{ave}]')",
            "    return [ave]",
            "# 引数を取得",
            "def get_input_lines(lines_count):",
            "    lines = list()",
            "    for _ in range(lines_count):",
            "        lines.append(input())",
            "    return lines",
            "# テストデータ",
            "def get_testdata(pattern):",
            "    if pattern == 1:",
            "        lines_input = ['2', '3 4']",
            "        lines_export = [3.5]",
            "    if pattern == 2:",
            "        lines_input = ['3', '500 300 200']",
            "        lines_export = [375]",
            "    if pattern == 3:",
            "        lines_input = ['5', '138 138 138 138 138']",
            "        lines_export = [138]",
            "    return lines_input, lines_export",
            "# 動作モード判別",
            "def get_mode():",
            "    import sys",
            "    args = sys.argv",
            "    global FLAG_LOG",
            "    if len(args) == 1:",
            "        mode = 0",
            "        FLAG_LOG = False",
            "    else:",
            "        mode = int(args[1])",
            "        FLAG_LOG = True",
            "    return mode",
            "# 主処理",
            "def main():",
            "    import time",
            "    started = time.time()",
            "    mode = get_mode()",
            "    if mode == 0:",
            "        lines_input = get_input_lines(2)",
            "    else:",
            "        lines_input, lines_export = get_testdata(mode)",
            "    lines_result = calculation(lines_input)",
            "    for line_result in lines_result:",
            "        print(line_result)",
            "    # if mode > 0:",
            "    #     print(f'lines_input=[{lines_input}]')",
            "    #     print(f'lines_export=[{lines_export}]')",
            "    #     print(f'lines_result=[{lines_result}]')",
            "    #     if lines_result == lines_export:",
            "    #         print('OK')",
            "    #     else:",
            "    #         print('NG')",
            "    # finished = time.time()",
            "    # duration = finished - started",
            "    # print(f'duration=[{duration}]')",
            "# 起動処理",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# -*- coding: utf-8 -*-",
            "import sys",
            "import math",
            "import os",
            "import itertools",
            "import string",
            "import heapq",
            "import _collections",
            "from collections import Counter",
            "from collections import defaultdict",
            "from collections import deque",
            "from functools import lru_cache",
            "import bisect",
            "import re",
            "import queue",
            "import decimal",
            "class Scanner():",
            "    @staticmethod",
            "    def int():",
            "        return int(sys.stdin.readline().rstrip())",
            "    @staticmethod",
            "    def string():",
            "        return sys.stdin.readline().rstrip()",
            "    @staticmethod",
            "    def map_int():",
            "        return [int(x) for x in Scanner.string().split()]",
            "    @staticmethod",
            "    def string_list(n):",
            "        return [Scanner.string() for i in range(n)]",
            "    @staticmethod",
            "    def int_list_list(n):",
            "        return [Scanner.map_int() for i in range(n)]",
            "    @staticmethod",
            "    def int_cols_list(n):",
            "        return [Scanner.int() for i in range(n)]",
            "class Math():",
            "    @staticmethod",
            "    def gcd(a, b):",
            "        if b == 0:",
            "            return a",
            "        return Math.gcd(b, a % b)",
            "    @staticmethod",
            "    def lcm(a, b):",
            "        return (a * b) // Math.gcd(a, b)",
            "    @staticmethod",
            "    def divisor(n):",
            "        lower, upper = [], []",
            "        i = 1",
            "        while i * i <= n:",
            "            if n % i == 0:",
            "                lower.append(i)",
            "                if i != n // i:",
            "                    upper.append(n // i)",
            "            i += 1",
            "        return lower + upper[::-1]",
            "    @staticmethod",
            "    def round_up(a, b):",
            "        return -(-a // b)",
            "    @staticmethod",
            "    def is_prime(n):",
            "        if n < 2:",
            "            return False",
            "        if n == 2:",
            "            return True",
            "        if n % 2 == 0:",
            "            return False",
            "        d = int(n ** 0.5) + 1",
            "        for i in range(3, d + 1, 2):",
            "            if n % i == 0:",
            "                return False",
            "        return True",
            "    @staticmethod",
            "    def fact(N):",
            "        res = {}",
            "        tmp = N",
            "        for i in range(2, int(N ** 0.5 + 1) + 1):",
            "            cnt = 0",
            "            while tmp % i == 0:",
            "                cnt += 1",
            "                tmp //= i",
            "            if cnt > 0:",
            "                res[i] = cnt",
            "        if tmp != 1:",
            "            res[tmp] = 1",
            "        if res == {}:",
            "            res[N] = 1",
            "        return res",
            "def pop_count(x):",
            "    x = x - ((x >> 1) & 0x5555555555555555)",
            "    x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)",
            "    x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f",
            "    x = x + (x >> 8)",
            "    x = x + (x >> 16)",
            "    x = x + (x >> 32)",
            "    return x & 0x0000007f",
            "MOD = int(1e09) + 7",
            "INF = int(1e15)",
            "ans = None",
            "counter = None",
            "G = None",
            "def dfs(v, cnt):",
            "    global ans, counter, G",
            "    cnt += counter[v]",
            "    ans[v] = cnt",
            "    for g in G[v]:",
            "        if ans[g] != -1:",
            "            continue",
            "        dfs(g, cnt)",
            "def solve():",
            "    global ans, counter, G",
            "    N, Q = Scanner.map_int()",
            "    G = [[] for _ in range(N)]",
            "    for _ in range(N - 1):",
            "        a, b = Scanner.map_int()",
            "        a -= 1",
            "        b -= 1",
            "        G[a].append(b)",
            "        G[b].append(a)",
            "    counter = [0 for _ in range(N)]",
            "    for _ in range(Q):",
            "        p, x = Scanner.map_int()",
            "        p -= 1",
            "        counter[p] += x",
            "    ans = [-1 for _ in range(N)]",
            "    dfs(0, 0)",
            "    print(*ans)",
            "def main():",
            "    sys.setrecursionlimit(1000000)",
            "    # sys.stdin = open(\"sample.txt\")",
            "    # T = Scanner.int()",
            "    # for _ in range(T):",
            "    #     solve()",
            "    # print('YNeos'[not solve()::2])",
            "    solve()",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product                # product(iter, repeat=n)",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict",
            "from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4",
            "def main():",
            "    mod = 1000000007                  # 10^9+7",
            "    inf = float('inf')",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():  return int(input())",
            "    def mi():  return map(int, input().split())",
            "    def mi_0(): return map(lambda x: int(x)-1, input().split())",
            "    def lmi(): return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():  return list(input())",
            "    s = input()",
            "    t = input()",
            "    # 構成不可能な場合",
            "    set_s = set(s)",
            "    for char_t in t:",
            "        if char_t not in set_s:",
            "            print(-1)",
            "            exit()",
            "    # 構成可能な場合",
            "    # 前処理 O(n)",
            "    s_table = [[] for _ in range(ord('z') - ord('a') + 1)]",
            "    for i, s_char in enumerate(s):",
            "        s_table[ord(s_char) - ord('a')].append(i)",
            "    # print(s_table)",
            "    # O(nlgn)",
            "    loop_count = 0",
            "    prev = -1",
            "    for t_char in t:",
            "        candidate = s_table[ord(t_char) - ord('a')]",
            "        j = bisect_left(candidate, prev+1)    # prev より大きくないとだめ",
            "        if j == len(candidate):",
            "            loop_count += 1",
            "            prev = candidate[0]",
            "        else:",
            "            prev = candidate[j]",
            "    print(prev + loop_count * len(s) + 1)",
            "if __name__ == \"__main__\":",
            "    main()",
            "    \"\"\"",
            "    解説",
            "    俺の二分探索の方針以外にも「ある index 以降で次に char(a-z) が出現する index を O(alpha)*O(|s|) で求めておく」と言った方法がある。",
            "    こちらは O(|s|) + O(alpha) * O(|s|) + O(|t|)",
            "    二分探は O(|s|) + O(lg|s|) * O(|t|)",
            "    O(alpha) = 26, O(lg|10**5|) = 16, O(|s|) = O(|t|) より今回最悪計算量に変わりはない",
            "    s を二つ連結した文字列を用意して調べると楽らしい。確かに。(必ず探索場所がヒットするので)",
            "    \"\"\""
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "sys.setrecursionlimit(10**7) #再帰関数の上限,10**5以上の場合python",
            "import math",
            "from copy import copy, deepcopy",
            "from copy import deepcopy as dcp",
            "from operator import itemgetter",
            "from bisect import bisect_left, bisect, bisect_right#2分探索",
            "#bisect_left(l,x), bisect(l,x)#aはソート済みである必要あり。aの中からx未満の要素数を返す。rightだと以下",
            "from collections import deque",
            "#deque(l), pop(), append(x), popleft(), appendleft(x)",
            "##listでqueの代用をするとO(N)の計算量がかかってしまうので注意",
            "from collections import Counter#文字列を個数カウント辞書に、",
            "#S=Counter(l),S.most_common(x),S.keys(),S.values(),S.items()",
            "from itertools import accumulate,combinations,permutations#累積和",
            "#list(accumulate(l))",
            "from heapq import heapify,heappop,heappush",
            "#heapify(q),heappush(q,a),heappop(q) #q=heapify(q)としないこと、返り値はNone",
            "#import fractions#古いatcoderコンテストの場合GCDなどはここからimportする",
            "from functools import lru_cache#pypyでもうごく",
            "#@lru_cache(maxsize = None)#maxsizeは保存するデータ数の最大値、2**nが最も高効率",
            "from decimal import Decimal",
            "def input():",
            "    x=sys.stdin.readline()",
            "    return x[:-1] if x[-1]==\"\\n\" else x",
            "def printl(li): _=print(*li, sep=\"\\n\") if li else None",
            "def argsort(s, return_sorted=False):",
            "    inds=sorted(range(len(s)), key=lambda k: s[k])",
            "    if return_sorted: return inds, [s[i] for i in inds]",
            "    return inds",
            "def alp2num(c,cap=False): return ord(c)-97 if not cap else ord(c)-65",
            "def num2alp(i,cap=False): return chr(i+97) if not cap else chr(i+65)",
            "def matmat(A,B):",
            "    K,N,M=len(B),len(A),len(B[0])",
            "    return [[sum([(A[i][k]*B[k][j]) for k in range(K)]) for j in range(M)] for i in range(N)]",
            "def matvec(M,v):",
            "    N,size=len(v),len(M)",
            "    return [sum([M[i][j]*v[j] for j in range(N)]) for i in range(size)]",
            "def T(M):",
            "    n,m=len(M),len(M[0])",
            "    return [[M[j][i] for j in range(n)] for i in range(m)]",
            "def main():",
            "    mod = 1000000007",
            "    #w.sort(key=itemgetter(1),reversed=True)  #二個目の要素で降順並び替え",
            "    #N = int(input())",
            "    N, M, P = map(int, input().split())",
            "    #A = tuple(map(int, input().split())) #1行ベクトル",
            "    #L = tuple(int(input()) for i in range(N)) #改行ベクトル",
            "    #S = tuple(tuple(map(int, input().split())) for i in range(N)) #改行行列",
            "    def tree_init(N):",
            "        ws=[]",
            "        edgelist = [[] for _ in range(N)]",
            "        for a, b, w in [map(int, input().split()) for i in range(M)]:#木じゃない場合N-1をNに変える",
            "            edgelist[a-1].append((-w,b-1))",
            "            ws.append(-w)",
            "        return edgelist,ws",
            "    edge,ws=tree_init(N)",
            "    inf=10**14",
            "    def bellman_ford(N,s,edge):#ベルマンフォード法,負の経路がある場合も有効、O(VE)",
            "        inf=10**14",
            "        d=[inf]*N",
            "        upper=[set() for _ in range(N)]",
            "        d[s]=0",
            "        count=0",
            "        for _ in range(N):",
            "            update=False",
            "            for e in range(N):",
            "                if d[e]==inf:",
            "                    continue",
            "                for nd,ne in edge[e]:",
            "                    x=max(-inf,d[e]+nd+P)",
            "                    if x<d[ne]:",
            "                        d[ne]=x",
            "                        update=True",
            "            if update==False: break",
            "        for _ in range(N):",
            "            update=False",
            "            for e in range(N):",
            "                if d[e]==inf:",
            "                    continue",
            "                for nd,ne in edge[e]:",
            "                    x=max(-inf,d[e]+nd+P)",
            "                    if x<d[ne]:",
            "                        d[ne]=-inf",
            "                        update=True",
            "            if update==False: break",
            "        return d",
            "    visited=bellman_ford(N,0,edge)",
            "    if visited[-1]==-inf:",
            "        print(-1)",
            "        return",
            "    print(max(-visited[-1],0))",
            "    #print(visited)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "sys.setrecursionlimit(10**7) #再帰関数の上限,10**5以上の場合python",
            "import math",
            "from copy import copy, deepcopy",
            "from copy import deepcopy as dcp",
            "from operator import itemgetter",
            "from bisect import bisect_left, bisect, bisect_right#2分探索",
            "#bisect_left(l,x), bisect(l,x)#aはソート済みである必要あり。aの中からx未満の要素数を返す。rightだと以下",
            "from collections import deque, defaultdict",
            "#deque(l), pop(), append(x), popleft(), appendleft(x)",
            "#q.rotate(n)で → にn回ローテート",
            "from collections import Counter#文字列を個数カウント辞書に、",
            "#S=Counter(l),S.most_common(x),S.keys(),S.values(),S.items()",
            "from itertools import accumulate,combinations,permutations,product#累積和",
            "#list(accumulate(l))",
            "from heapq import heapify,heappop,heappush",
            "#heapify(q),heappush(q,a),heappop(q) #q=heapify(q)としないこと、返り値はNone",
            "from functools import reduce,lru_cache#pypyでもうごく",
            "#@lru_cache(maxsize = None)#maxsizeは保存するデータ数の最大値、2**nが最も高効率",
            "from decimal import Decimal",
            "def input():",
            "    x=sys.stdin.readline()",
            "    return x[:-1] if x[-1]==\"\\n\" else x",
            "def printe(*x):print(\"## \",*x,file=sys.stderr)",
            "def printl(li): _=print(*li, sep=\"\\n\") if li else None",
            "def argsort(s, return_sorted=False):",
            "    inds=sorted(range(len(s)), key=lambda k: s[k])",
            "    if return_sorted: return inds, [s[i] for i in inds]",
            "    return inds",
            "def alp2num(c,cap=False): return ord(c)-97 if not cap else ord(c)-65",
            "def num2alp(i,cap=False): return chr(i+97) if not cap else chr(i+65)",
            "def matmat(A,B):",
            "    K,N,M=len(B),len(A),len(B[0])",
            "    return [[sum([(A[i][k]*B[k][j]) for k in range(K)]) for j in range(M)] for i in range(N)]",
            "def matvec(M,v):",
            "    N,size=len(v),len(M)",
            "    return [sum([M[i][j]*v[j] for j in range(N)]) for i in range(size)]",
            "def T(M):",
            "    n,m=len(M),len(M[0])",
            "    return [[M[j][i] for j in range(n)] for i in range(m)]",
            "def binr(x): return bin(x)[2:]",
            "def bitcount(x): #xは64bit整数",
            "    x= x - ((x >> 1) & 0x5555555555555555)",
            "    x= (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)",
            "    x= (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f",
            "    x+= (x >> 8); x+= (x >> 16); x+= (x >> 32)",
            "    return x & 0x7f",
            "def main():",
            "    mod = 1000000007",
            "    #w.sort(key=itemgetter(1),reverse=True)  #二個目の要素で降順並び替え",
            "    #N = int(input())",
            "    N, M,P = map(int, input().split())",
            "    #A = tuple(map(int, input().split())) #1行ベクトル",
            "    #L = tuple(int(input()) for i in range(N)) #改行ベクトル",
            "    #S = tuple(tuple(map(int, input().split())) for i in range(N)) #改行行列",
            "    edge = [[] for i in range(N)]",
            "    for i in range(M):#木の場合M=N-1",
            "        a,b,w = map(int,input().split())",
            "        edge[a-1].append((P-w,b-1))",
            "    start=0",
            "    inf=10**14",
            "    d=[inf]*N",
            "    d[start]=0",
            "    for _ in range(N):#更新はせいぜい（ノード数)回",
            "        update=False",
            "        for e in range(N):",
            "            for nd,ne in edge[e]:",
            "                x=d[e]+nd",
            "                if x<d[ne] and d[e]!=inf:",
            "                    d[ne]=x",
            "                    update=True",
            "        if update==False: break",
            "    printe(d[-1])",
            "    for _ in range(N):#更新はせいぜい（ノード数)回",
            "        update=False",
            "        for e in range(N):",
            "            for nd,ne in edge[e]:",
            "                x=d[e]+nd",
            "                if x<d[ne] and d[e]!=inf:",
            "                    d[ne]=-inf",
            "                    update=True",
            "        if update==False: break",
            "    if d[-1]==-inf:",
            "        print(-1)",
            "        return",
            "    print(max(0,-d[N-1]))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def isp():   return input().split()",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def enum_divisor(num):",
            "        i = 1",
            "        left = []",
            "        right = []",
            "        while i ** 2 < num:",
            "            if num % i == 0:",
            "                left.append(i)",
            "                right.append(num // i)",
            "            i += 1",
            "        if i ** 2 == num:",
            "            return left + [i] + list(reversed(right))",
            "        else:",
            "            return left + list(reversed(right))",
            "    def is_ok(m, k, L):",
            "        mod_list = [elm % m for elm in L]",
            "        plus_group, minus_group = [], []",
            "        plus_cnt, minus_cnt = 0, 0",
            "        for mod_num in mod_list:",
            "            if mod_num <= m - mod_num:",
            "                minus_group.append(mod_num)",
            "                minus_cnt += mod_num",
            "            else:",
            "                plus_group.append(mod_num)",
            "                plus_cnt += m - mod_num",
            "        # print(f\"m {m} plus {plus_group} minus {minus_group}\")",
            "        # print(f\"pluscnt {plus_cnt} minuscnt {minus_cnt}\")",
            "        assert abs(plus_cnt - minus_cnt) % m == 0",
            "        cnt = plus_cnt + minus_cnt",
            "        if plus_cnt > minus_cnt:",
            "            # plus のグループを minus のグループに転じる必要がある",
            "            plus_group.sort()",
            "            for i in range((plus_cnt - minus_cnt) // m):",
            "                mod_num = plus_group[i]",
            "                cnt += (mod_num - (m - mod_num))",
            "        else:",
            "            # minus のグループを plus のグループに",
            "            minus_group.sort(reverse=True)",
            "            for i in range((minus_cnt - plus_cnt) // m):",
            "                mod_num = minus_group[i]",
            "                cnt += ((m - mod_num) - mod_num)",
            "        # print(f\"cnt {cnt}\")",
            "        assert cnt % 2 == 0",
            "        return cnt // 2 <= k",
            "    n, k = mi()",
            "    L = lmi()",
            "    s = sum(L)",
            "    div = enum_divisor(s)",
            "    div.reverse()",
            "    for m in div:",
            "        if is_ok(m, k, L):",
            "            print(m)",
            "            break",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# abc135_c.py",
            "# https://atcoder.jp/contests/abc135/tasks/abc135_c",
            "# C - City Savers /",
            "# 実行時間制限: 2 sec / メモリ制限: 1024 MB",
            "# 配点 : 300点",
            "# 問題文",
            "# N+1個の街があり、i 番目の街は Ai体のモンスターに襲われています。",
            "# N人の勇者が居て、i 番目の勇者は i 番目または i+1 番目の街を襲っているモンスターを合計で Bi体まで倒すことができます。",
            "# N人の勇者がうまく協力することで、合計して最大で何体のモンスターを倒せるでしょうか。",
            "# 制約",
            "#     入力は全て整数である。",
            "#     1≤N≤105",
            "#     1≤Ai≤109",
            "#     1≤Bi≤109",
            "# 入力",
            "# 入力は以下の形式で標準入力から与えられる。",
            "# N",
            "# A1 A2 ... AN+1",
            "# B1 B2 ... BN",
            "# 出力",
            "# 合計して倒せるモンスターの数の最大値を出力せよ。",
            "# 入力例 1",
            "# 2",
            "# 3 5 2",
            "# 4 5",
            "# 出力例 1",
            "# 9以下のようにモンスターを倒すと、合計 9体のモンスターを倒すことができ、このときが最大です。",
            "#     1番目の勇者が 1 番目の街を襲っているモンスターを 2 体、2 番目の街を襲っているモンスターを 2体倒します。",
            "#     2番目の勇者が 2 番目の街を襲っているモンスターを 3 体、3 番目の街を襲っているモンスターを 2体倒します。",
            "# 入力例 2",
            "# 3",
            "# 5 6 3 8",
            "# 5 100 8",
            "# 出力例 2",
            "# 22",
            "# 入力例 3",
            "# 2",
            "# 100 1 1",
            "# 1 100",
            "# 出力例 3",
            "# 3",
            "global FLAG_LOG",
            "FLAG_LOG = False",
            "def log(value):",
            "    # FLAG_LOG = True",
            "    # FLAG_LOG = False",
            "    if FLAG_LOG:",
            "        print(str(value))",
            "def calculation(lines):",
            "    # S = lines[0]",
            "    N = int(lines[0])",
            "    # X, A = list(map(int, lines[0].split()))",
            "    monsters = list(map(int, lines[1].split()))",
            "    braves = list(map(int, lines[2].split()))",
            "    # values = list()",
            "    # for i in range(6):",
            "    #     values.append(int(lines[i]))",
            "    # valueses = list()",
            "    # for i in range(M):",
            "    #     valueses.append(list(map(int, lines[i+1].split())))",
            "    cnt = 0",
            "    for n in range(N):",
            "        if monsters[n] >= braves[n]:",
            "            cnt += braves[n]",
            "            monsters[n] -= braves[n]",
            "            log(f'cnt=[{cnt}]')",
            "        else:",
            "            # 今の町で倒した数",
            "            cnt += monsters[n]",
            "            log(f'cnt=[{cnt}]')",
            "            # 次の町で倒す数",
            "            monster = min(braves[n]-monsters[n], monsters[n+1])",
            "            cnt += monster",
            "            log(f'cnt=[{cnt}]')",
            "            monsters[n+1] -= monster",
            "    return [cnt]",
            "# 引数を取得",
            "def get_input_lines(lines_count):",
            "    lines = list()",
            "    for _ in range(lines_count):",
            "        lines.append(input())",
            "    return lines",
            "# テストデータ",
            "def get_testdata(pattern):",
            "    if pattern == 1:",
            "        lines_input = ['2', '3 5 2', '4 5']",
            "        lines_export = [9]",
            "    if pattern == 2:",
            "        lines_input = ['3', '5 6 3 8', '5 100 8']",
            "        lines_export = [22]",
            "    if pattern == 3:",
            "        lines_input = ['2', '100 1 1', '1 100']",
            "        lines_export = [3]",
            "    return lines_input, lines_export",
            "# 動作モード判別",
            "def get_mode():",
            "    import sys",
            "    args = sys.argv",
            "    global FLAG_LOG",
            "    if len(args) == 1:",
            "        mode = 0",
            "        FLAG_LOG = False",
            "    else:",
            "        mode = int(args[1])",
            "        FLAG_LOG = True",
            "    return mode",
            "# 主処理",
            "def main():",
            "    import time",
            "    started = time.time()",
            "    mode = get_mode()",
            "    if mode == 0:",
            "        lines_input = get_input_lines(3)",
            "    else:",
            "        lines_input, lines_export = get_testdata(mode)",
            "    lines_result = calculation(lines_input)",
            "    for line_result in lines_result:",
            "        print(line_result)",
            "    # if mode > 0:",
            "    #     print(f'lines_input=[{lines_input}]')",
            "    #     print(f'lines_export=[{lines_export}]')",
            "    #     print(f'lines_result=[{lines_result}]')",
            "    #     if lines_result == lines_export:",
            "    #         print('OK')",
            "    #     else:",
            "    #         print('NG')",
            "    # finished = time.time()",
            "    # duration = finished - started",
            "    # print(f'duration=[{duration}]')",
            "# 起動処理",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# @oj: atcoder",
            "# @id: hitwanyang",
            "# @email: 296866643@qq.com",
            "# @date: 2020-05-19 17:18",
            "# @url:https://atcoder.jp/contests/abc135/tasks/abc135_d",
            "import sys,os",
            "from io import BytesIO, IOBase",
            "import collections,itertools,bisect,heapq,math,string",
            "# region fastio",
            "BUFSIZE = 8192",
            "BUFSIZE = 8192",
            "class FastIO(IOBase):",
            "    newlines = 0",
            "    def __init__(self, file):",
            "        self._fd = file.fileno()",
            "        self.buffer = BytesIO()",
            "        self.writable = \"x\" in file.mode or \"r\" not in file.mode",
            "        self.write = self.buffer.write if self.writable else None",
            "    def read(self):",
            "        while True:",
            "            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
            "            if not b:",
            "                break",
            "            ptr = self.buffer.tell()",
            "            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
            "        self.newlines = 0",
            "        return self.buffer.read()",
            "    def readline(self):",
            "        while self.newlines == 0:",
            "            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
            "            self.newlines = b.count(b\"\\n\") + (not b)",
            "            ptr = self.buffer.tell()",
            "            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
            "        self.newlines -= 1",
            "        return self.buffer.readline()",
            "    def flush(self):",
            "        if self.writable:",
            "            os.write(self._fd, self.buffer.getvalue())",
            "            self.buffer.truncate(0), self.buffer.seek(0)",
            "class IOWrapper(IOBase):",
            "    def __init__(self, file):",
            "        self.buffer = FastIO(file)",
            "        self.flush = self.buffer.flush",
            "        self.writable = self.buffer.writable",
            "        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))",
            "        self.read = lambda: self.buffer.read().decode(\"ascii\")",
            "        self.readline = lambda: self.buffer.readline().decode(\"ascii\")",
            "sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)",
            "input = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")",
            "# ------------------------------",
            "def main():",
            "    # python取模注意每次都需要取模，否则可能会导致tle",
            "    # 大数取模的运算通常可以分解为每个位置的权重进行取模运算，然后求和再取模的，例如：",
            "    # 1993%mod=(1000%mod+900%mod+90%mod+3%mod)%mod",
            "    # 利用模运算的基本性质：",
            "    # 加法：19%3=(10%3+9%3)%3 (a+b)%mod=(a%mod+b%mod)%mod",
            "    # 乘法：27%4=(9%4*3%4)%4  (a*b)%mod=(a%mod*b%mod)%mod",
            "    s=str(input())",
            "    S=s[::-1]",
            "    dp=[[0]*13 for i in range(len(S))]",
            "    mod=10**9+7",
            "    p=1 # 每位的权重10的幂次",
            "    for i in range(len(S)):",
            "        if i==0:",
            "            if S[i]!='?':",
            "                t=p*int(S[i])%13",
            "                dp[i][t]+=1",
            "            else:",
            "                for j in range(10):",
            "                    dp[i][j]+=1",
            "        else:",
            "            if S[i]!='?':",
            "                t=p*int(S[i])%13",
            "                for j in range(13):",
            "                    dp[i][(t+j)%13]=dp[i-1][j]%mod",
            "            else:",
            "                for j in range(10):",
            "                    for k in range(13):",
            "                        temp=(p*j%13+k)%13",
            "                        dp[i][temp]=(dp[i][temp]+dp[i-1][k])%mod",
            "        # 权重取模",
            "        p=(p%13*10%13)%13",
            "    # print (dp)",
            "    print (dp[len(S)-1][5])",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product                # product(iter, repeat=n)",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4",
            "def main():",
            "    mod = 1000000007                  # 10^9+7",
            "    inf = float('inf')",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():  return int(input())",
            "    def mi():  return map(int, input().split())",
            "    def mi_0(): return map(lambda x: int(x)-1, input().split())",
            "    def lmi(): return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():  return list(input())",
            "    s = input()",
            "    n = len(s)",
            "    s = list(reversed(s))",
            "    determined = 0    # 確定枠 (mod 13)",
            "    # 2, 3, 5 と入っていたら s*10^2, t*10^3, u*10^5 をたすことができる (s,t,u=0~9) というようにデータの保存も可能",
            "    # 一歩進めて mod を先に取ろう",
            "    L = []",
            "    for i in range(n):",
            "        if s[i] != '?':",
            "            determined += pow(10, i, 13) * int(s[i])",
            "            determined %= 13",
            "        else:",
            "            L.append(pow(10, i, 13))",
            "    # print(determined)",
            "    # print(L)",
            "    # elm in L に 0~9 をかけて (mod 13)、この余りを作れるような組み合わせを考えれば良い",
            "    target_res = ((13+5) - determined) % 13",
            "    m = len(L)",
            "    if m == 0:",
            "        print(1) if target_res == 0 else print(0)",
            "    else:",
            "        # dp[i][j] = L の i 番目 (0-ind) までの数を用いて (0~9 を自在に掛け合わせて) mod 13 で j にできるような組み合わせの数",
            "        dp = [[0] * 13 for _ in range(m)]",
            "        first_line = [(L[0] * x) % 13 for x in range(10)]",
            "        for j in range(13):",
            "            dp[0][j] = first_line.count(j)",
            "        for i in range(1, m):",
            "            for j in range(13):",
            "                elm = L[i]",
            "                for x in range(10):",
            "                    tmp = (x * elm) % 13",
            "                    j_prime = (j + 13 - tmp) % 13",
            "                    dp[i][j] += dp[i-1][j_prime]",
            "                    dp[i][j] %= mod",
            "        print(dp[m-1][target_res])",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# -*- coding: utf-8 -*-",
            "import sys",
            "import math",
            "from bisect import bisect_left",
            "from bisect import bisect_right",
            "import collections",
            "import copy",
            "import heapq",
            "from collections import defaultdict",
            "from heapq import heappop, heappush",
            "import itertools",
            "input = sys.stdin.readline",
            "from collections import defaultdict",
            "from heapq import heappop, heappush",
            "from decimal import *",
            "##### リストの 二分木検索 #####",
            "# bisect_left(lists, 3)",
            "# bisect_right(lists, 3)",
            "##### プライオリティキュー #####",
            "# heapq.heapify(a) #リストaのheap化",
            "# heapq.heappush(a,x) #heap化されたリストaに要素xを追加",
            "# heapq.heappop(a) #heap化されたリストaから最小値を削除＆その最小値を出力",
            "# heapq.heappush(a, -x) #最大値を取り出す時は、pushする時にマイナスにして入れよう",
            "# heapq.heappop(a) * (-1) #取り出す時は、-1を掛けて取り出すこと",
            "##### タプルリストのソート #####",
            "# sorted(ans) #(a, b) -> 1st : aの昇順, 2nd : bの昇順",
            "# sorted(SP, key=lambda x:(x[0],-x[1])) #(a, b) -> 1st : aの昇順, 2nd : bの降順",
            "# sorted(SP, key=lambda x:(-x[0],x[1])) #(a, b) -> 1st : aの降順, 2nd : bの昇順",
            "# sorted(SP, key=lambda x:(-x[0],-x[1])) #(a, b) -> 1st : aの降順, 2nd : bの降順",
            "# sorted(SP, key=lambda x:(x[1])) #(a, b) -> 1st : bの昇順",
            "# sorted(SP, key=lambda x:(-x[1])) #(a, b) -> 1st : bの降順",
            "##### 累乗 #####",
            "# pow(x, y, z) -> x**y % z",
            "##### 割り算の切り上げ #####",
            "# tmp = -(-4 // 3)",
            "##### dict の for文 #####",
            "# for k, v in d.items():",
            "#     print(k, v)",
            "def inputInt(): return int(input())",
            "def inputMap(): return map(int, input().split())",
            "def inputList(): return list(map(int, input().split()))",
            "def inputStr(): return input()[:-1]",
            "inf = float('inf')",
            "mod = 1000000007",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "def main():",
            "\tS = inputStr()",
            "\tS_len = len(S)",
            "\tDP = [[0 for j in range(13)] for i in range(S_len)]",
            "\tS = S[::-1]",
            "\tmut = 10",
            "\tfor i,val in enumerate(S):",
            "\t\tif i == 0:",
            "\t\t\tif val == \"?\":",
            "\t\t\t\tfor j in range(0,10):",
            "\t\t\t\t\tDP[i][j] += 1",
            "\t\t\telse:",
            "\t\t\t\tDP[i][int(val)] += 1",
            "\t\telse:",
            "\t\t\tif val == \"?\":",
            "\t\t\t\tfor j in range(0,10):",
            "\t\t\t\t\ttmp = (mut * j) % 13",
            "\t\t\t\t\tfor v,vol in enumerate(DP[i-1]):",
            "\t\t\t\t\t\tif vol == 0:",
            "\t\t\t\t\t\t\tcontinue",
            "\t\t\t\t\t\ttmptmp = (v + tmp) % 13",
            "\t\t\t\t\t\tDP[i][tmptmp] = (DP[i][tmptmp] + vol) % mod",
            "\t\t\telse:",
            "\t\t\t\ttmp = (mut * int(val)) % 13",
            "\t\t\t\tfor j,vol in enumerate(DP[i-1]):",
            "\t\t\t\t\tif vol == 0:",
            "\t\t\t\t\t\tcontinue",
            "\t\t\t\t\ttmptmp = (j + tmp) % 13",
            "\t\t\t\t\tDP[i][tmptmp] = (DP[i][tmptmp] + vol) % mod",
            "\t\t\tmut = (mut * 10) % 13",
            "\t#print(DP)",
            "\tprint(DP[S_len-1][5] % mod)",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "# N 個のボールを K グループに分ける場合のパターン数",
            "def sunuke(N, K, mod=10**9+7):",
            "\tif N < K or K-1 < 0:",
            "\t\treturn 0",
            "\telse:",
            "\t\treturn combination(N-1, K-1, mod)",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "# nCr mod m",
            "# rがn/2に近いと非常に重くなる",
            "def combination(n, r, mod=10**9+7):",
            "    r = min(r, n-r)",
            "    res = 1",
            "    for i in range(r):",
            "        res = res * (n - i) * modinv(i+1, mod) % mod",
            "    return res",
            "# mを法とするaの乗法的逆元",
            "def modinv(a, mod=10**9+7):",
            "    return pow(a, mod-2, mod)",
            "def egcd(a, b):",
            "    if a == 0:",
            "        return b, 0, 1",
            "    else:",
            "        g, y, x = egcd(b % a, a)",
            "        return g, x - (b // a) * y, y",
            "# nHr mod m",
            "# 問題によって、combination()を切り替えること",
            "def H(n, r, mod=10**9+7):",
            "\t# comb = Combination(n+r-1, mod)",
            "\t# return comb(n+r-1, r)",
            "    return combination(n+r-1, r, mod)",
            "class Combination:",
            "    \"\"\"",
            "    O(n)の前計算を1回行うことで，O(1)でnCr mod mを求められる",
            "    n_max = 10**6のとき前処理は約950ms (PyPyなら約340ms, 10**7で約1800ms)",
            "    使用例：",
            "    comb = Combination(1000000)",
            "    print(comb(5, 3))  # 10",
            "    \"\"\"",
            "    def __init__(self, n_max, mod=10**9+7):",
            "        self.mod = mod",
            "        self.modinv = self.make_modinv_list(n_max)",
            "        self.fac, self.facinv = self.make_factorial_list(n_max)",
            "    def __call__(self, n, r):",
            "        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod",
            "    def make_factorial_list(self, n):",
            "        # 階乗のリストと階乗のmod逆元のリストを返す O(n)",
            "        # self.make_modinv_list()が先に実行されている必要がある",
            "        fac = [1]",
            "        facinv = [1]",
            "        for i in range(1, n+1):",
            "            fac.append(fac[i-1] * i % self.mod)",
            "            facinv.append(facinv[i-1] * self.modinv[i] % self.mod)",
            "        return fac, facinv",
            "    def make_modinv_list(self, n):",
            "        # 0からnまでのmod逆元のリストを返す O(n)",
            "        modinv = [0] * (n+1)",
            "        modinv[1] = 1",
            "        for i in range(2, n+1):",
            "            modinv[i] = self.mod - self.mod//i * modinv[self.mod%i] % self.mod",
            "        return modinv",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "# dfs のサンプル",
            "def dfs(graph,parent,counter,edge):",
            "    stk = []",
            "    stk.append(edge)",
            "    while len(stk) > 0:",
            "        p = stk.pop()",
            "        for e in graph[p]:",
            "            if parent[p] == e:",
            "                continue",
            "            else:",
            "                parent[e] = p",
            "                counter[e] += counter[p]",
            "                stk.append(e)",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "if __name__ == \"__main__\":",
            "\tmain()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product                # product(iter, repeat=n)",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4",
            "def main():",
            "    mod = 1000000007                  # 10^9+7",
            "    inf = float('inf')",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():  return int(input())",
            "    def mi():  return map(int, input().split())",
            "    def mi_0(): return map(lambda x: int(x)-1, input().split())",
            "    def lmi(): return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():  return list(input())",
            "    def reverse_bisect(L, key):",
            "        \"\"\"",
            "        L は単調減少",
            "        key 未満となる最初の index を返す",
            "        - left は常に key 未満の条件を満たさない",
            "        - right は常に key 未満の条件を満たす",
            "        - right - left で表される区間幅が 1 になるまで狭める。right が答えになる。",
            "        \"\"\"",
            "        left = -1",
            "        right = len(L)",
            "        while right - left > 1:",
            "            mid = left + (right - left) // 2",
            "            if L[mid] < key:",
            "                right = mid",
            "            else:",
            "                left = mid",
            "        return right",
            "    # 広義最大減少部分列の長さが答え",
            "    n = ii()",
            "    L = [ii() for _ in range(n)]",
            "    # dp[i] には長さ i+1 の広義減少部分列を作った時、末尾の値が最大となるものの値のメモがなされる",
            "    # dp は広義単調減少",
            "    dp = [-float('inf')] * n",
            "    for elm in L:",
            "        insert_ind = reverse_bisect(dp, elm)",
            "        dp[insert_ind] = elm",
            "    prev = -1",
            "    for i, tail_max in enumerate(dp):",
            "        if tail_max == -float('inf'):",
            "            # dp[prev] が メモられてる最後の要素。長さ prev + 1 の広義減少部分列まで作成可能である。",
            "            break",
            "        prev = i",
            "    print(prev + 1)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "code = \"\"\"",
            "# distutils: language=c++",
            "# distutils: include_dirs=[/home/USERNAME/.local/lib/python3.8/site-packages/numpy/core/include, /opt/atcoder-stl]",
            "# cython: boundscheck=False",
            "# cython: wraparound=False",
            "from libcpp.utility cimport pair",
            "from libcpp.string cimport string",
            "from libcpp.vector cimport vector",
            "from cython.operator cimport dereference",
            "from libcpp cimport bool",
            "from cython.operator cimport preincrement",
            "from libc.stdio cimport getchar, printf",
            "from cython.operator cimport predecrement",
            "cpdef inline vector[int] ReadInt(int n):",
            "    cdef int b, c",
            "    cdef vector[int] *v = new vector[int]()",
            "    for i in range(n):",
            "        c = 0",
            "        while 1:",
            "            b = getchar() - 48",
            "            if b < 0: break",
            "            c = c * 10 + b",
            "        v.push_back(c)",
            "    return v[0]",
            "cpdef inline vector[string] Read(int n):",
            "    cdef char c",
            "    cdef vector[string] *vs = new vector[string]()",
            "    cdef string *s",
            "    for i in range(n):",
            "        s = new string()",
            "        while 1:",
            "            c = getchar()",
            "            if c<=32: break",
            "            s.push_back(c)",
            "        vs.push_back(s[0])",
            "    return vs[0]",
            "cpdef inline void PrintLongN(vector[long] l):",
            "    cdef int n = l.size()",
            "    for i in range(n): printf(\"%ld\\\\n\", l[i])",
            "cpdef inline void PrintLong(vector[long] l):",
            "    cdef int n = l.size()",
            "    for i in range(n): printf(\"%ld \", l[i])",
            "cdef extern from \"<set>\" namespace \"std\" nogil:",
            "    cdef cppclass multiset[T]:",
            "        ctypedef T value_type",
            "        cppclass iterator:",
            "            T& operator*()",
            "            iterator operator++()",
            "            iterator operator--()",
            "            bint operator==(iterator)",
            "            bint operator!=(iterator)",
            "        cppclass reverse_iterator:",
            "            T& operator*()",
            "            iterator operator++()",
            "            iterator operator--()",
            "            bint operator==(reverse_iterator)",
            "            bint operator!=(reverse_iterator)",
            "        cppclass const_iterator(iterator):",
            "            pass",
            "        cppclass const_reverse_iterator(reverse_iterator):",
            "            pass",
            "        multiset() except +",
            "        multiset(multiset&) except +",
            "        iterator begin()",
            "        reverse_iterator rbegin()",
            "        size_t count(const T&)",
            "        bint empty()",
            "        iterator end()",
            "        reverse_iterator rend()",
            "        iterator find(T&)",
            "        size_t size()",
            "        iterator upper_bound(const T&)",
            "        iterator lower_bound(T&)",
            "        pair[iterator, bint] insert(const T&) except +",
            "        iterator erase(iterator)",
            "cdef extern from *:",
            "    ctypedef long long ll \"long long\"",
            "cdef class MultiSet:",
            "    cdef multiset[ll] *_thisptr",
            "    def __cinit__(self):",
            "        self._thisptr = new multiset[ll]()",
            "    cpdef int size(self):",
            "        return self._thisptr.size()",
            "    cpdef bool empty(self):",
            "        return self._thisptr.empty()",
            "    cpdef void add(self, ll x):",
            "        self._thisptr.insert(x)",
            "    cpdef void remove(self, ll x):",
            "        self._thisptr.erase(self._thisptr.find(x))",
            "    cpdef int count(self, ll x):",
            "        return self._thisptr.count(x)",
            "    cpdef ll min(self):",
            "        return dereference(self._thisptr.begin())",
            "    cpdef ll max(self):",
            "        return dereference(self._thisptr.rbegin())",
            "    def lower_bound(self, x):",
            "        cdef multiset[ll].iterator itr = self._thisptr.lower_bound(x)",
            "        if itr == self._thisptr.end():",
            "            return None",
            "        else:",
            "            return dereference(itr)",
            "    def upper_bound(self, ll x):",
            "        cdef multiset[ll].iterator itr = self._thisptr.upper_bound(x)",
            "        if itr == self._thisptr.end():",
            "            return None",
            "        else:",
            "            return dereference(itr)",
            "    def next(self, x):",
            "        if x >= self.max():",
            "            return None",
            "        cdef multiset[ll].iterator itr = self._thisptr.find(x)",
            "        cdef int c = self._thisptr.count(x)",
            "        for i in range(c):",
            "            preincrement(itr)",
            "        return dereference(itr)",
            "    cpdef prev(self, x):",
            "        if x <= self.min():",
            "            return None",
            "        cdef multiset[ll].iterator itr = self._thisptr.find(x)",
            "        predecrement(itr)",
            "        return dereference(itr)",
            "    cpdef ll pop_min(self):",
            "        cdef multiset[ll].iterator itr = self._thisptr.begin()",
            "        cdef ll ret = dereference(itr)",
            "        self._thisptr.erase(itr)",
            "        return ret",
            "    cpdef ll pop_max(self):",
            "        cdef multiset[ll].reverse_iterator itr = self._thisptr.rbegin()",
            "        cdef ll ret = dereference(itr)",
            "        self._thisptr.erase(self._thisptr.find(ret))",
            "        return ret",
            "    def __contains__(self, x):",
            "        if self._thisptr.find(x)==self._thisptr.end():",
            "            return False",
            "        else:",
            "            return True",
            "\"\"\"",
            "import os, sys, getpass",
            "if sys.argv[-1] == 'ONLINE_JUDGE':",
            "    code = code.replace(\"USERNAME\", getpass.getuser())",
            "    open('atcoder.pyx','w').write(code)",
            "    os.system('cythonize -i -3 -b atcoder.pyx')",
            "    sys.exit(0)",
            "from atcoder import MultiSet, ReadInt",
            "def main():",
            "    ms = MultiSet()",
            "    N = ReadInt(1)[0]",
            "    for i in range(N):",
            "        A = ReadInt(1)[0]",
            "        if ms.empty():",
            "            ms.add(A)",
            "            continue",
            "        if A <= ms.min():",
            "            ms.add(A)",
            "        else:",
            "            b = ms.lower_bound(A)",
            "            if b is None:",
            "                ms.pop_max()",
            "                ms.add(A)",
            "            else:",
            "                c = ms.prev(b)",
            "                ms.remove(c)",
            "                ms.add(A)",
            "    print(ms.size())",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# abc133_b.py",
            "# https://atcoder.jp/contests/abc133/tasks/abc133_b",
            "# B - Good Distance /",
            "# 実行時間制限: 2 sec / メモリ制限: 1024 MB",
            "# 配点 : 200点",
            "# 問題文",
            "# D次元空間上に N個の点があります。",
            "# i番目の点の座標は (Xi1,Xi2,...,XiD)です。",
            "# 座標 (y1,y2,...,yD)の点と座標 (z1,z2,...,zD) の点の距離は √(y1−z1)2+(y2−z2)2+...+(yD−zD)2です。",
            "# i番目の点と j 番目の点の距離が整数となるような組 (i,j) (i<j)はいくつあるでしょうか。",
            "# 制約",
            "#     入力は全て整数である。",
            "#     2≤N≤10",
            "#     1≤D≤10",
            "#     −20≤Xij≤20",
            "#     同じ座標の点は与えられない。すなわち、i≠jならば Xik≠Xjk なる kが存在する。",
            "# 入力",
            "# 入力は以下の形式で標準入力から与えられる。",
            "# N D",
            "# X11 X12 ... X1D",
            "# X21 X22 ... X2D",
            "# ⋮",
            "# XN1 XN2 ... XND",
            "# 出力",
            "# i番目の点と j 番目の点の距離が整数となるような組 (i,j) (i<j)の数を出力せよ。",
            "# 入力例 1",
            "# 3 2",
            "# 1 2",
            "# 5 5",
            "# -2 8",
            "# 出力例 1",
            "# 1",
            "# 以下のように距離が整数となる点の組は 1組です。",
            "#     1番目の点と 2 番目の点の距離は √|1−5|2+|2−5|2=5で、これは整数です。",
            "#     2番目の点と 3 番目の点の距離は √|5−(−2)|2+|5−8|2=√58で、これは整数ではありません。",
            "#     3番目の点と 1 番目の点の距離は √|−2−1|2+|8−2|2=3√5で、これは整数ではありません。",
            "# 入力例 2",
            "# 3 4",
            "# -3 7 8 2",
            "# -12 1 10 2",
            "# -2 8 9 3",
            "# 出力例 2",
            "# 2",
            "# 入力例 3",
            "# 5 1",
            "# 1",
            "# 2",
            "# 3",
            "# 4",
            "# 5",
            "# 出力例 3",
            "# 10",
            "global FLAG_LOG",
            "FLAG_LOG = False",
            "def log(value):",
            "    # FLAG_LOG = True",
            "    # FLAG_LOG = False",
            "    if FLAG_LOG:",
            "        print(str(value))",
            "def calculation(lines):",
            "    # S = lines[0]",
            "    # N = int(lines[0])",
            "    N, D = list(map(int, lines[0].split()))",
            "    # values = list(map(int, lines[1].split()))",
            "    # values = list(map(int, lines[2].split()))",
            "    # values = list()",
            "    # for i in range(6):",
            "    #     values.append(int(lines[i]))",
            "    valueses = list()",
            "    for i in range(N):",
            "        valueses.append(list(map(int, lines[i+1].split())))",
            "    cnt = 0",
            "    for n1 in range(N-1):",
            "        for n2 in range(n1+1, N):",
            "            log(f'n1=[{n1}], n2=[{n2}]')",
            "            d = 0",
            "            for dd in range(D):",
            "                d += (valueses[n1][dd] - valueses[n2][dd])**2",
            "            d = d**0.5",
            "            if d == float(int(d)):",
            "                cnt += 1",
            "    return [cnt]",
            "# 引数を取得",
            "def get_input_lines():",
            "    line = input()",
            "    N, D = list(map(int, line.split()))",
            "    lines = list()",
            "    lines.append(line)",
            "    for _ in range(N):",
            "        lines.append(input())",
            "    return lines",
            "# テストデータ",
            "def get_testdata(pattern):",
            "    if pattern == 1:",
            "        lines_input = ['3 2', '1 2', '5 5', '-2 8']",
            "        lines_export = [1]",
            "    if pattern == 2:",
            "        lines_input = ['3 4', '-3 7 8 2', '-12 1 10 2', '-2 8 9 3']",
            "        lines_export = [2]",
            "    if pattern == 3:",
            "        lines_input = ['5 1', '1', '2', '3', '4', '5']",
            "        lines_export = [10]",
            "    return lines_input, lines_export",
            "# 動作モード判別",
            "def get_mode():",
            "    import sys",
            "    args = sys.argv",
            "    global FLAG_LOG",
            "    if len(args) == 1:",
            "        mode = 0",
            "        FLAG_LOG = False",
            "    else:",
            "        mode = int(args[1])",
            "        FLAG_LOG = True",
            "    return mode",
            "# 主処理",
            "def main():",
            "    import time",
            "    started = time.time()",
            "    mode = get_mode()",
            "    if mode == 0:",
            "        lines_input = get_input_lines()",
            "    else:",
            "        lines_input, lines_export = get_testdata(mode)",
            "    lines_result = calculation(lines_input)",
            "    for line_result in lines_result:",
            "        print(line_result)",
            "    # if mode > 0:",
            "    #     print(f'lines_input=[{lines_input}]')",
            "    #     print(f'lines_export=[{lines_export}]')",
            "    #     print(f'lines_result=[{lines_result}]')",
            "    #     if lines_result == lines_export:",
            "    #         print('OK')",
            "    #     else:",
            "    #         print('NG')",
            "    # finished = time.time()",
            "    # duration = finished - started",
            "    # print(f'duration=[{duration}]')",
            "# 起動処理",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, k = mi()",
            "    # O(10^5)",
            "    adj = [[] for _ in range(n)]",
            "    for _ in range(n - 1):",
            "        a, b = mi_0()",
            "        adj[a].append(b)",
            "        adj[b].append(a)",
            "    # O(10^5)",
            "    tree_parent_ind = [None] * n",
            "    tree_children_indices = [[] for _ in range(n)]",
            "    root = 0",
            "    stack = [[root, None]]",
            "    while stack:",
            "        u, prev = stack.pop()",
            "        tree_parent_ind[u] = prev",
            "        for v in adj[u]:",
            "            if v != prev:",
            "                tree_children_indices[u].append(v)",
            "                stack.append([v, u])",
            "    def calc_possible_colors(ind, k):",
            "        determined_colors = 0",
            "        p = tree_parent_ind[ind]",
            "        if p is not None:",
            "            determined_colors += 1",
            "            determined_colors += tree_inserted_children_num[p]",
            "            if tree_parent_ind[p] is not None:",
            "                determined_colors += 1",
            "        return max(k - determined_colors, 0)",
            "    # O(10^5)",
            "    tree_inserted_children_num = [0] * n",
            "    def calc_cases_bfs(start):",
            "        cases = 1",
            "        q = deque([start])",
            "        while q:",
            "            u = q.popleft()",
            "            possible_colors = calc_possible_colors(u, k)",
            "            if possible_colors == 0:",
            "                return 0",
            "            cases = (cases * possible_colors) % mod",
            "            # insert",
            "            if tree_parent_ind[u] is not None:",
            "                tree_inserted_children_num[tree_parent_ind[u]] += 1",
            "            for child in tree_children_indices[u]:",
            "                q.append(child)",
            "        return cases",
            "    print(calc_cases_bfs(root))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# でつoO(YOU PLAY WITH THE CARDS YOU'RE DEALT..)",
            "import sys",
            "def main(N, K, G):",
            "    fu = FactorialUtils(K)",
            "    p = [-1] * N",
            "    p[0] = 0",
            "    stk = [0]",
            "    ans = Mint(K)",
            "    while stk:",
            "        v = stk.pop()",
            "        t = 1 if v != 0 else 0",
            "        ans *= fu.permutation(K - t - 1, len(G[v]) - t)",
            "        for to in G[v]:",
            "            if p[to] >= 0:",
            "                continue",
            "            p[to] = v",
            "            stk.append(to)",
            "    print(ans)",
            "MOD = 10**9 + 7",
            "class FactorialUtils:",
            "    def __init__(self, n):",
            "        self.fac = [1] * (n + 1)",
            "        self.ifac = [1] * (n + 1)",
            "        for i in range(2, n + 1): self.fac[i] = self.fac[i - 1] * i % MOD",
            "        self.ifac[n] = pow(self.fac[n], MOD - 2, MOD)",
            "        for i in range(n, 1, -1): self.ifac[i - 1] = self.ifac[i] * i % MOD",
            "    def choose(self, n, r):",
            "        if r < 0 or r > n: return 0",
            "        return (self.fac[n] * self.ifac[n - r] % MOD) * self.ifac[r] % MOD",
            "    def multichoose(self, u, k):",
            "        return (self.fac[u + k - 1] * self.ifac[u - 1] % MOD) * self.ifac[k] % MOD",
            "    def permutation(self, n, r):",
            "        if r < 0 or r > n: return 0",
            "        return self.fac[n] * self.ifac[n - r] % MOD",
            "class Mint:",
            "    def __init__(self, value=0):",
            "        self.value = value % MOD",
            "        if self.value < 0: self.value += MOD",
            "    @staticmethod",
            "    def get_value(x): return x.value if isinstance(x, Mint) else x",
            "    def inverse(self):",
            "        a, b = self.value, MOD",
            "        u, v = 1, 0",
            "        while b:",
            "            t = a // b",
            "            b, a = a - t * b, b",
            "            v, u = u - t * v, v",
            "        if u < 0: u += MOD",
            "        return u",
            "    def __repr__(self): return str(self.value)",
            "    def __eq__(self, other): return self.value == other.value",
            "    def __neg__(self): return Mint(-self.value)",
            "    def __hash__(self): return hash(self.value)",
            "    def __bool__(self): return self.value != 0",
            "    def __iadd__(self, other):",
            "        self.value = (self.value + Mint.get_value(other)) % MOD",
            "        return self",
            "    def __add__(self, other):",
            "        new_obj = Mint(self.value)",
            "        new_obj += other",
            "        return new_obj",
            "    __radd__ = __add__",
            "    def __isub__(self, other):",
            "        self.value = (self.value - Mint.get_value(other)) % MOD",
            "        if self.value < 0: self.value += MOD",
            "        return self",
            "    def __sub__(self, other):",
            "        new_obj = Mint(self.value)",
            "        new_obj -= other",
            "        return new_obj",
            "    def __rsub__(self, other):",
            "        new_obj = Mint(Mint.get_value(other))",
            "        new_obj -= self",
            "        return new_obj",
            "    def __imul__(self, other):",
            "        self.value = self.value * Mint.get_value(other) % MOD",
            "        return self",
            "    def __mul__(self, other):",
            "        new_obj = Mint(self.value)",
            "        new_obj *= other",
            "        return new_obj",
            "    __rmul__ = __mul__",
            "    def __ifloordiv__(self, other):",
            "        other = other if isinstance(other, Mint) else Mint(other)",
            "        self *= other.inverse()",
            "        return self",
            "    def __floordiv__(self, other):",
            "        new_obj = Mint(self.value)",
            "        new_obj //= other",
            "        return new_obj",
            "    def __rfloordiv__(self, other):",
            "        new_obj = Mint(Mint.get_value(other))",
            "        new_obj //= self",
            "        return new_obj",
            "if __name__ == '__main__':",
            "    input = sys.stdin.readline",
            "    N, K = map(int, input().split())",
            "    G = [[] for _ in range(N)]",
            "    for _ in range(N - 1):",
            "        x, y = map(int, input().split())",
            "        x, y = x - 1, y - 1",
            "        G[x].append(y)",
            "        G[y].append(x)",
            "    main(N, K, G)"
        ],
        "label": [
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "content": [
            "# abc132_c.py",
            "# https://atcoder.jp/contests/abc132/tasks/abc132_c",
            "# C - Divide the Problems /",
            "# 実行時間制限: 2 sec / メモリ制限: 1024 MB",
            "# 配点 : 300点",
            "# 問題文",
            "# 高橋君は、 N個の競技プログラミング用の問題をつくりました。",
            "# それぞれの問題には 1 から N の番号がついており、問題 i の難易度は整数 diで表されます(大きいほど難しいです)。",
            "# 高橋君はある整数 Kを決めることで、",
            "#     難易度が K以上ならば「 ARC用の問題」",
            "#     難易度が K未満ならば「 ABC用の問題」",
            "# という風に、これらの問題を二種類に分類しようとしています。",
            "# 「ARC用の問題」と「ABC 用の問題」が同じ数になるような整数 Kの選び方は何通りあるでしょうか。",
            "# 制約",
            "#     2≦N≦105",
            "#     Nは偶数である。",
            "#     1≦di≦105",
            "#     入力は全て整数である。",
            "# 入力",
            "# 入力は以下の形式で標準入力から与えられます。",
            "# N",
            "# d1 d2 ... dN",
            "# 出力",
            "# 「ARC用の問題」と「ABC 用の問題」が同じ数になるような整数 Kの選び方の数を出力してください。",
            "# 入力例 1",
            "# 6",
            "# 9 1 4 4 6 7",
            "# 出力例 1",
            "# 2",
            "# K=5,6としたとき、問題 1,5,6 が「ARC 用の問題」、問題 2,3,4 が「ABC 用の問題」となり、",
            "# 条件を満たします。 よって、答えは 2通りです。",
            "# 入力例 2",
            "# 8",
            "# 9 1 14 5 5 4 4 14",
            "# 出力例 2",
            "# 0",
            "# 「ARC用の問題」と「ABC 用の問題」が同じ数になるような整数 Kの選び方が存在しない場合もあります。",
            "# 入力例 3",
            "# 14",
            "# 99592 10342 29105 78532 83018 11639 92015 77204 30914 21912 34519 80835 100000 1",
            "# 出力例 3",
            "# 42685",
            "global FLAG_LOG",
            "FLAG_LOG = False",
            "def log(value):",
            "    # FLAG_LOG = True",
            "    # FLAG_LOG = False",
            "    if FLAG_LOG:",
            "        print(str(value))",
            "def calculation(lines):",
            "    # S = lines[0]",
            "    N = int(lines[0])",
            "    # X, A = list(map(int, lines[0].split()))",
            "    values = list(map(int, lines[1].split()))",
            "    # values = list(map(int, lines[2].split()))",
            "    # values = list()",
            "    # for i in range(6):",
            "    #     values.append(int(lines[i]))",
            "    # valueses = list()",
            "    # for i in range(M):",
            "    #     valueses.append(list(map(int, lines[i+1].split())))",
            "    values.sort()",
            "    n = int(N/2)",
            "    log(f'values=[{values}]')",
            "    result = values[n] - values[n-1]",
            "    return [result]",
            "# 引数を取得",
            "def get_input_lines(lines_count):",
            "    lines = list()",
            "    for _ in range(lines_count):",
            "        lines.append(input())",
            "    return lines",
            "# テストデータ",
            "def get_testdata(pattern):",
            "    if pattern == 1:",
            "        lines_input = ['6', '9 1 4 4 6 7']",
            "        lines_export = [2]",
            "    if pattern == 2:",
            "        lines_input = ['8', '9 1 14 5 5 4 4 14']",
            "        lines_export = [0]",
            "    if pattern == 3:",
            "        lines_input = ['14', '99592 10342 29105 78532 83018 11639 92015 77204 30914 21912 34519 80835 100000 1']",
            "        lines_export = [42685]",
            "    return lines_input, lines_export",
            "# 動作モード判別",
            "def get_mode():",
            "    import sys",
            "    args = sys.argv",
            "    global FLAG_LOG",
            "    if len(args) == 1:",
            "        mode = 0",
            "        FLAG_LOG = False",
            "    else:",
            "        mode = int(args[1])",
            "        FLAG_LOG = True",
            "    return mode",
            "# 主処理",
            "def main():",
            "    import time",
            "    started = time.time()",
            "    mode = get_mode()",
            "    if mode == 0:",
            "        lines_input = get_input_lines(2)",
            "    else:",
            "        lines_input, lines_export = get_testdata(mode)",
            "    lines_result = calculation(lines_input)",
            "    for line_result in lines_result:",
            "        print(line_result)",
            "    # if mode > 0:",
            "    #     print(f'lines_input=[{lines_input}]')",
            "    #     print(f'lines_export=[{lines_export}]')",
            "    #     print(f'lines_result=[{lines_result}]')",
            "    #     if lines_result == lines_export:",
            "    #         print('OK')",
            "    #     else:",
            "    #         print('NG')",
            "    # finished = time.time()",
            "    # duration = finished - started",
            "    # print(f'duration=[{duration}]')",
            "# 起動処理",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "input = sys.stdin.readline",
            "def I(): return int(input())",
            "def MI(): return map(int, input().split())",
            "def LI(): return list(map(int, input().split()))",
            "def main():",
            "    ##########################################",
            "    import heapq",
            "    class Dijkstra():",
            "        \"\"\"",
            "        ・有向 / 無向は問わない(無向の場合は，逆向きの辺もたす)",
            "        ・負のコストがない場合のみ",
            "        ・計算量はO(E log|V|)",
            "        ・heapを使うことで頂点を走査する必要がなくなる（代わりに，距離更新したものは確定でなくともqueに入れておく）",
            "        ・復元なし",
            "        \"\"\"",
            "        #最短のpathをたす",
            "        class Edge():",
            "            #重み付き有向辺",
            "            def __init__(self, _to, _cost):",
            "                self.to =_to",
            "                self.cost = _cost",
            "        def __init__(self, V):",
            "            #引数Vは頂点数",
            "            self.inf=10**20",
            "            self.G = [[] for _ in range(V)] #隣接リストG[u][i]が頂点uのi番目の辺",
            "            self. _E = 0 #辺の数",
            "            self._V = V #頂点数",
            "        #proparty - 辺の数",
            "        def E(self):",
            "            return self._E",
            "        #proparty - 頂点数",
            "        def V(self):",
            "            return self._V",
            "        def add(self, _from, _to, _cost):",
            "            #2頂点と辺のコストを追加",
            "            self.G[_from].append(self.Edge(_to,_cost))",
            "            self._E +=1",
            "        def add2(self, _from, _to, _cost):",
            "            #2頂点と辺のコスト（無向）を追加",
            "            self.G[_from].append(self.Edge(_to, _cost))",
            "            self.G[_to].append(self.Edge(_from, _cost))",
            "            self._E +=2",
            "        def shortest_path(self,s):#,g):",
            "            #始点sから頂点iまでの最短経路長のリストを返す",
            "            que = [] #priority queue",
            "            d = [self.inf] * self.V()",
            "            #prev = [None]*self.V() #prev[j]は，sからjへ最短経路で行くときのjの一つ前の場所",
            "            #復元で使う",
            "            d[s] = 0",
            "            heapq.heappush(que,(0,s)) #始点の距離と頂点番号をヒープに追加",
            "            while len(que)!=0:",
            "                #キューに格納されてある中で一番コストが小さい頂点を取り出す",
            "                cost,v = heapq.heappop(que)",
            "                #キューに格納された最短経路長候補がdの距離よりも大きい場合に処理をスキップ",
            "                if d[v] < cost:",
            "                    continue",
            "                #頂点vに隣接する各頂点iに対して，vを経由した場合の距離を計算して，これがd[i]よりも小さい場合に更新",
            "                for i in range(len(self.G[v])):",
            "                    e = self.G[v][i] #vのi個目の隣接辺",
            "                    if d[e.to] > d[v] + e.cost:",
            "                        d[e.to] = d[v] + e.cost #更新",
            "                        #prev[e.to] = v",
            "                        #復元で使う",
            "                        heapq.heappush(que,(d[e.to],e.to)) #queに新たな最短経路長候補を追加",
            "            \"\"\"#sからgまでの最短経路",
            "            path = []",
            "            pos = g #今いる場所，ゴールで初期化",
            "            for _ in range(self.V()+1):",
            "                path.append(pos)",
            "                if pos == s:",
            "                    break",
            "                #print(\"pos:\",format(pos))",
            "                pos = prev[pos]",
            "            path.reverse()",
            "            #print(path)\"\"\"",
            "            return d#,path",
            "    ########################",
            "    mod=10**9+7",
            "    N,M=MI()",
            "    djk=Dijkstra(3*N)",
            "    for _ in range(M):",
            "        u,v=MI()",
            "        u-=1",
            "        v-=1",
            "        djk.add(u,v+N,1)",
            "        djk.add(u+N,v+2*N,1)",
            "        djk.add(u+2*N,v,1)",
            "    S,T=MI()",
            "    S-=1",
            "    T-=1",
            "    D=djk.shortest_path(S)",
            "    ans=D[T] //3",
            "    if ans>10**7:",
            "        ans=-1",
            "    print(ans)",
            "main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    # n, m = mi()",
            "    # inv_adj = [set() for _ in range(n)]",
            "    # inv_dist_2 = [set() for _ in range(n)]",
            "    # inv_hopstepjump = [set() for _ in range(n)]",
            "    # for _ in range(m):",
            "    #     u, v = mi_0()",
            "    #     inv_adj[v].add(u)",
            "    # for i in range(n):",
            "    #     for s in inv_adj[i]:",
            "    #         inv_dist_2[i] |= inv_adj[s]",
            "    # for i in range(n):",
            "    #     for s in inv_dist_2[i]:",
            "    #         inv_hopstepjump[i] |= inv_adj[s]",
            "    # start, goal = mi_0()",
            "    # appeared_vertice_set = set([goal])",
            "    # q = deque([(goal, 0)])",
            "    # while q:",
            "    #     # print(q)",
            "    #     u, turn = q.popleft()",
            "    #     if turn >= n:",
            "    #         break",
            "    #     if u == start:",
            "    #         print(turn)",
            "    #         exit()",
            "    #     for v in inv_hopstepjump[u]:",
            "    #         if v not in appeared_vertice_set:",
            "    #             appeared_vertice_set.add(v)",
            "    #             q.append((v, turn + 1))",
            "    # print(-1)",
            "    \"\"\"",
            "    set を作るところで最悪 O(n^2) より 2 つくらい TLE",
            "    経路長 3 の倍数というところで start からの経由数の剰余 (mod 3) を管理する、という方針は思いついたが... それをノードを増やすことで管理するという発想に至らず。",
            "    \"\"\"",
            "    n, m = mi()",
            "    adj = [[] for _ in range(n * 3)]",
            "    for _ in range(m):",
            "        a, b = mi_0()",
            "        adj[a * 3].append(b * 3 + 1)",
            "        adj[a * 3 + 1].append(b * 3 + 2)",
            "        adj[a * 3 + 2].append(b * 3)",
            "    start, goal = mi_0()",
            "    start *= 3",
            "    goal *= 3",
            "    q = deque([(start, 0)])",
            "    visited = [False] * (n * 3)",
            "    while q:",
            "        u, dist = q.popleft()",
            "        if dist > 3 * n:",
            "            break",
            "        if u == goal:",
            "            assert (dist % 3 == 0)",
            "            print(dist // 3)",
            "            return",
            "        if not visited[u]:",
            "            visited[u] = True",
            "            for v in adj[u]:",
            "                if not visited[v]:",
            "                    q.append((v, dist + 1))",
            "    print(-1)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# abc131_b.py",
            "# https://atcoder.jp/contests/abc131/tasks/abc131_b",
            "# B - Bite Eating /",
            "# 実行時間制限: 2 sec / メモリ制限: 1024 MB",
            "# 配点 : 200点",
            "# 問題文",
            "# N個のリンゴがあります。",
            "# これらはそれぞれリンゴ 1、リンゴ 2、リンゴ 3、...、リンゴ N と呼ばれており、リンゴ i の「味」は L+i−1です。",
            "# 「味」は負になることもありえます。",
            "# また、1個以上のリンゴを材料として、アップルパイをつくることができます。",
            "# その「味」は、材料となったリンゴの「味」の総和となります。",
            "# あなたはこれらのリンゴを全て材料として、アップルパイをつくる予定でしたが、おなかがすいたので 1個だけ食べることにしました。",
            "# 勿論、食べてしまったリンゴはアップルパイの材料にはできません。",
            "# つくる予定だったアップルパイとできるだけ同じものをつくりたいので、N個のリンゴ全てを材料としてできるアップルパイの「味」と、",
            "# 食べていない N−1個のリンゴを材料としてできるアップルパイの「味」の差の絶対値ができるだけ小さくなるように、",
            "# 食べるリンゴを選ぶことにしました。",
            "# このようにして選ばれたリンゴを食べた時、食べていない N−1個のリンゴを材料としてできるアップルパイの「味」を求めてください。",
            "# なお、この値は一意に定まることが証明できます。",
            "# 制約",
            "#     2≦N≦200",
            "#     −100≦L≦100",
            "#     入力は全て整数である。",
            "# 入力",
            "# 入力は以下の形式で標準入力から与えられます。",
            "# N L",
            "# 出力",
            "# 最適に食べるリンゴを選んだ時の、食べていない N−1個のリンゴを材料としてできるアップルパイの「味」を出力してください。",
            "# 入力例 1",
            "# 5 2",
            "# 出力例 1",
            "# 18",
            "# リンゴ 1,2,3,4,5の「味」は、それぞれ 2,3,4,5,6 です。リンゴ 1 を食べるのが最適で、答えは 3+4+5+6=18となります。",
            "# 入力例 2",
            "# 3 -1",
            "# 出力例 2",
            "# 0",
            "# リンゴ 1,2,3の「味」は、それぞれ −1,0,1 です。リンゴ 2 を食べるのが最適で、答えは (−1)+1=0となります。",
            "# 入力例 3",
            "# 30 -50",
            "# 出力例 3",
            "# -1044",
            "global FLAG_LOG",
            "FLAG_LOG = False",
            "def log(value):",
            "    # FLAG_LOG = True",
            "    # FLAG_LOG = False",
            "    if FLAG_LOG:",
            "        print(str(value))",
            "def calculation(lines):",
            "    # S = lines[0]",
            "    # N = int(lines[0])",
            "    N, L = list(map(int, lines[0].split()))",
            "    # values = list(map(int, lines[1].split()))",
            "    # values = list(map(int, lines[2].split()))",
            "    # values = list()",
            "    # for i in range(6):",
            "    #     values.append(int(lines[i]))",
            "    # valueses = list()",
            "    # for i in range(M):",
            "    #     valueses.append(list(map(int, lines[i+1].split())))",
            "    mi = None",
            "    su = 0",
            "    for i in range(N):",
            "        value = i + L",
            "        if mi is None:",
            "            mi = value",
            "        if abs(mi) > abs(value):",
            "            mi = value",
            "        su += value",
            "    return [su-mi]",
            "# 引数を取得",
            "def get_input_lines(lines_count):",
            "    lines = list()",
            "    for _ in range(lines_count):",
            "        lines.append(input())",
            "    return lines",
            "# テストデータ",
            "def get_testdata(pattern):",
            "    if pattern == 1:",
            "        lines_input = ['5 2']",
            "        lines_export = [18]",
            "    if pattern == 2:",
            "        lines_input = ['3 -1']",
            "        lines_export = [0]",
            "    if pattern == 3:",
            "        lines_input = ['30 -50']",
            "        lines_export = [-1044]",
            "    return lines_input, lines_export",
            "# 動作モード判別",
            "def get_mode():",
            "    import sys",
            "    args = sys.argv",
            "    global FLAG_LOG",
            "    if len(args) == 1:",
            "        mode = 0",
            "        FLAG_LOG = False",
            "    else:",
            "        mode = int(args[1])",
            "        FLAG_LOG = True",
            "    return mode",
            "# 主処理",
            "def main():",
            "    import time",
            "    started = time.time()",
            "    mode = get_mode()",
            "    if mode == 0:",
            "        lines_input = get_input_lines(1)",
            "    else:",
            "        lines_input, lines_export = get_testdata(mode)",
            "    lines_result = calculation(lines_input)",
            "    for line_result in lines_result:",
            "        print(line_result)",
            "    # if mode > 0:",
            "    #     print(f'lines_input=[{lines_input}]')",
            "    #     print(f'lines_export=[{lines_export}]')",
            "    #     print(f'lines_result=[{lines_result}]')",
            "    #     if lines_result == lines_export:",
            "    #         print('OK')",
            "    #     else:",
            "    #         print('NG')",
            "    # finished = time.time()",
            "    # duration = finished - started",
            "    # print(f'duration=[{duration}]')",
            "# 起動処理",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def isp():   return input().split()",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, m = mi()",
            "    s = lmi()",
            "    t = lmi()",
            "    dp = [[0] * (m + 1) for _ in range(n + 1)]",
            "    for i in range(n+1):",
            "        dp[i][0] = 1",
            "    for j in range(m+1):",
            "        dp[0][j] = 1",
            "    for i in range(n):",
            "        for j in range(m):",
            "            # print(dp)",
            "            if s[i] == t[j]:",
            "                dp[i+1][j+1] = (dp[i+1][j] + dp[i][j+1]) % mod",
            "            else:",
            "                # 片方使う or 両方使わない                   だぶりを 1 回減らす",
            "                dp[i+1][j+1] = (dp[i+1][j] + dp[i][j+1] - dp[i][j]) % mod",
            "    print(dp[n][m])",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#",
            "# 　　  ⋀_⋀",
            "#　　  (･ω･)",
            "# .／ Ｕ ∽ Ｕ＼",
            "#  │＊　合　＊│",
            "#  │＊　格　＊│",
            "#  │＊　祈　＊│",
            "#  │＊　願　＊│",
            "#  │＊　　　＊│",
            "#      ￣",
            "#",
            "import sys",
            "input=sys.stdin.readline",
            "from math import floor,ceil,sqrt,factorial,log #log2ないｙｐ",
            "from heapq import heappop, heappush, heappushpop",
            "from collections import Counter,defaultdict",
            "from itertools import accumulate,permutations,combinations,product,combinations_with_replacement",
            "from bisect import bisect_left, bisect_right",
            "from copy import copy",
            "inf=float('inf')",
            "mod = 10**9+7",
            "def INT_(n): return int(n)-1",
            "def MI(): return map(int,input().split())",
            "def MF(): return map(float, input().split())",
            "def MI_(): return map(INT_,input().split())",
            "def LI(): return list(MI())",
            "def LI_(): return [int(x) - 1 for x in input().split()]",
            "def LF(): return list(MF())",
            "def LIN(n:int): return [I() for _ in range(n)]",
            "def LLIN(n: int): return [LI() for _ in range(n)]",
            "def LLIN_(n: int): return [LI_() for _ in range(n)]",
            "def LLI(): return [list(map(int, l.split() )) for l in input()]",
            "def I(): return int(input())",
            "def F(): return float(input())",
            "def ST(): return input().replace('\\n', '')",
            "#mint",
            "class ModInt:",
            "    def __init__(self, x):",
            "        self.x = x % mod",
            "    def __str__(self):",
            "        return str(self.x)",
            "    __repr__ = __str__",
            "    def __add__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(self.x + other.x)",
            "        else:",
            "            return ModInt(self.x + other)",
            "    __radd__ = __add__",
            "    def __sub__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(self.x - other.x)",
            "        else:",
            "            return ModInt(self.x - other)",
            "    def __rsub__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(other.x - self.x)",
            "        else:",
            "            return ModInt(other - self.x)",
            "    def __mul__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(self.x * other.x)",
            "        else:",
            "            return ModInt(self.x * other)",
            "    __rmul__ = __mul__",
            "    def __truediv__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(self.x * pow(other.x, mod-2,mod))",
            "        else:",
            "            return ModInt(self.x * pow(other, mod - 2, mod))",
            "    def __rtruediv(self, other):",
            "        if isinstance(other, self):",
            "            return ModInt(other * pow(self.x, mod - 2, mod))",
            "        else:",
            "            return ModInt(other.x * pow(self.x, mod - 2, mod))",
            "    def __pow__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(pow(self.x, other.x, mod))",
            "        else:",
            "            return ModInt(pow(self.x, other, mod))",
            "    def __rpow__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(pow(other.x, self.x, mod))",
            "        else:",
            "            return ModInt(pow(other, self.x, mod))",
            "def main():",
            "    N, M = MI()",
            "    S = [i for i in ST().split()]",
            "    T = [i for i in ST().split()]",
            "    dp = [[ModInt(1)] * (M + 1) for _ in range(N + 1)] #dp[i][j]:=i,j文字目までの整数列組数",
            "    for i,s in enumerate(S,start = 1):",
            "        for j,t in enumerate(T,start = 1):",
            "            if t == s:",
            "                dp[i][j] = dp[i-1][j] + dp[i][j-1]",
            "            else:",
            "                dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1]",
            "    print(dp[-1][-1])",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math, cmath",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import _heapify_max, _heappop_max, _siftdown_max",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    Num = Union[int, float]",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def isp():   return input().split()",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    # def _heappush_max(h, item): h.append(item); _siftdown_max(h, 0, len(h)-1)",
            "    def calc_cost(p, q, points):",
            "        selected = [False] * n",
            "        cnt = 0",
            "        for i in range(n):",
            "            if not selected[i]:",
            "                selected[i] = True",
            "                cnt += 1",
            "                x, y = points[i]",
            "                while True:",
            "                    if [x + p, y + q] in points:",
            "                        selected[points.index([x + p, y + q])] = True",
            "                        x, y = x + p, y + q",
            "                    else:",
            "                        break",
            "                x, y = points[i]",
            "                while True:",
            "                    if [x - p, y - q] in points:",
            "                        selected[points.index([x - p, y - q])] = True",
            "                        x, y = x - p, y - q",
            "                    else:",
            "                        break",
            "        return cnt",
            "    n = ii()",
            "    points = [lmi() for _ in range(n)]",
            "    if n == 1:",
            "        print(1)",
            "    else:",
            "        cost = inf",
            "        for i in range(n):",
            "            for j in range(n):",
            "                if i != j:",
            "                    p = points[i][0] - points[j][0]",
            "                    q = points[i][1] - points[j][1]",
            "                    cost = min(cost, calc_cost(p, q, points))",
            "        print(cost)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!usr/bin/env python3",
            "from collections import defaultdict",
            "from collections import deque",
            "from heapq import heappush, heappop",
            "import sys",
            "import math",
            "import bisect",
            "import random",
            "import itertools",
            "sys.setrecursionlimit(10**5)",
            "stdin = sys.stdin",
            "bisect_left = bisect.bisect_left",
            "bisect_right = bisect.bisect_right",
            "def LI(): return list(map(int, stdin.readline().split()))",
            "def LF(): return list(map(float, stdin.readline().split()))",
            "def LI_(): return list(map(lambda x: int(x)-1, stdin.readline().split()))",
            "def II(): return int(stdin.readline())",
            "def IF(): return float(stdin.readline())",
            "def LS(): return list(map(list, stdin.readline().split()))",
            "def S(): return list(stdin.readline().rstrip())",
            "def IR(n): return [II() for _ in range(n)]",
            "def LIR(n): return [LI() for _ in range(n)]",
            "def FR(n): return [IF() for _ in range(n)]",
            "def LFR(n): return [LI() for _ in range(n)]",
            "def LIR_(n): return [LI_() for _ in range(n)]",
            "def SR(n): return [S() for _ in range(n)]",
            "def LSR(n): return [LS() for _ in range(n)]",
            "mod = 1000000007",
            "inf = float('INF')",
            "#A",
            "def A():",
            "    n, k = LI()",
            "    a = n - k",
            "    if k == 1:",
            "        print(0)",
            "        return",
            "    print(a)",
            "    return",
            "#B",
            "def B():",
            "    n = II()",
            "    xy = LIR(n)",
            "    if n == 1:",
            "        print(1)",
            "        return",
            "    ans = inf",
            "    for i in range(n):",
            "        for k in range(n):",
            "            if i != k:",
            "                b = 1",
            "                check = []",
            "                check.append((i,k))",
            "                p = xy[i][0] - xy[k][0]",
            "                q = xy[i][1] - xy[k][1]",
            "                for l in range(n):",
            "                    for m in range(n):",
            "                        if not((l,m) in check) and p == xy[l][0] - xy[m][0] and q == xy[l][1] - xy[m][1]:",
            "                            b += 1",
            "                            check.append((l, m))",
            "                ans = min(ans, n-b)",
            "    print(ans)",
            "    return",
            "#C",
            "def C():",
            "    n = II()",
            "    a = LI()",
            "    a.sort(key=abs)",
            "    ans = deque()",
            "    positive = deque()",
            "    negative = deque()",
            "    for i in range(n):",
            "        if a[i] >= 0:",
            "            positive.append(a[i])",
            "        else:",
            "            negative.append(a[i])",
            "    a = deque(a)",
            "    lenp = len(positive)",
            "    lenn = len(negative)",
            "    if lenp == 0:",
            "        for i in range(n - 1):",
            "            b, c = a.popleft(), a.popleft()",
            "            ans.append((b, c))",
            "            b -= c",
            "            a.appendleft(b)",
            "        print(b)",
            "    elif lenn == 0:",
            "        for i in range(n - 2):",
            "            b, c = a.popleft(), a.popleft()",
            "            ans.append((b, c))",
            "            b -= c",
            "            a.appendleft(b)",
            "        b, c = a.popleft(), a.popleft()",
            "        ans.append((c, b))",
            "        c -= b",
            "        print(c)",
            "    else:",
            "        p = positive.popleft()",
            "        negative.appendleft(p)",
            "        for i in range(lenn - 1):",
            "            b, c = negative.popleft(), negative.popleft()",
            "            ans.append((b, c))",
            "            b -= c",
            "            negative.appendleft(b)",
            "        p, c = negative.popleft(), negative.popleft()",
            "        positive.appendleft(c)",
            "        for i in range(lenp - 1):",
            "            b, c = positive.popleft(), positive.popleft()",
            "            ans.append((b, c))",
            "            b -= c",
            "            positive.appendleft(b)",
            "        b = positive.popleft()",
            "        ans.append((p, b))",
            "        p -= b",
            "        print(p)",
            "    for an in ans:",
            "        print(\" \".join(map(str, an)))",
            "    return",
            "#D",
            "def D():",
            "    return",
            "#E",
            "def E():",
            "    return",
            "#F",
            "def F():",
            "    return",
            "#G",
            "def G():",
            "    return",
            "#H",
            "def H():",
            "    return",
            "#Solve",
            "if __name__ == '__main__':",
            "    C()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "###template###",
            "import sys",
            "def input(): return sys.stdin.readline().rstrip()",
            "def mi(): return map(int, input().split())",
            "###template###",
            "N = int(input())",
            "As = list(mi())",
            "TL = [[], [], []]",
            "#[0] : zeroList",
            "#[1] : minusList",
            "#[2] : plusList",
            "for a in As:",
            "  if a == 0: TL[0].append(a)",
            "  elif a < 0: TL[1].append(a)",
            "  else: TL[2].append(a)",
            "#print(TL)",
            "ans = 0",
            "printlist = []",
            "#全てxxの場合（3パターン）",
            "if len(TL[0])==N: #全てゼロの場合",
            "  print(0)",
            "  for i in range(N-1):",
            "    print(0, 0)",
            "  exit()",
            "elif len(TL[1])==N: #全てminusの場合",
            "  TL[1] = sorted(TL[1], reverse=True) #降順に並べる（-値の低いものから）",
            "  printlist.append((TL[1][0],TL[1][1])) #痛みを最小に",
            "  hand = TL[1][0]-TL[1][1] #これでプラスになった",
            "  idx = 2",
            "  while idx < N:",
            "    printlist.append((hand, TL[1][idx]))",
            "    hand -= TL[1][idx]",
            "    idx += 1",
            "  ans = hand",
            "  #答えを出力する",
            "  print(ans)",
            "  for x, y in printlist:",
            "    print(x, y)",
            "  exit()",
            "elif len(TL[2])==N: #全てplusの場合",
            "  TL[2] = sorted(TL[2]) #昇順に並べる",
            "  printlist.append((TL[2][0],TL[2][1])) #痛みを最小に",
            "  hand = TL[2][0]-TL[2][1] #これで-になった",
            "  idx = 2",
            "  while idx < N-1:",
            "    printlist.append((hand, TL[2][idx]))",
            "    hand -= TL[2][idx]",
            "    idx += 1",
            "  #idx==N-1",
            "  printlist.append((TL[2][idx], hand))",
            "  hand = TL[2][idx]-hand",
            "  ans = hand",
            "  #答えを出力する",
            "  print(ans)",
            "  for x, y in printlist:",
            "    print(x, y)",
            "  exit()",
            "# ここから先は、0,-,+のうちどれか2つはあるので、全て集合させられる",
            "# ただし、0と-が1つずつ、0と+が1つずつというパターンは別途処理する必要がある",
            "# 以下、そのパターンを処理",
            "if len(TL[0])==1 and len(TL[1])==1:",
            "  #0と-が1つずつ。0から-を引いて終わり",
            "  left, right = TL[0].pop(), TL[1].pop()",
            "  print(left-right)",
            "  print(left, right)",
            "  exit()",
            "elif len(TL[0])==1 and len(TL[2])==1:",
            "  #0と+が1つずつ。+から0を引いて終わり",
            "  left, right = TL[2].pop(), TL[0].pop()",
            "  print(left-right)",
            "  print(left, right)",
            "  exit()",
            "# ここから先は、0,-,+のうちどれか2つはあり、前述のパターンも無いので、全て集合させられるし、最後に-と+が1つずつという最終処理パターンに持っていける",
            "# よって一律のループ処理でOK",
            "# 0が0個、+が1つ、-が1つになったら処理を抜け、最終手順に向かう",
            "# 最初からそうなら、while文は実行されないのでＯＫ",
            "# また、全てを集合させられる＝取り出す順番はどうでもいいので、高速化のため全てpop()で取り出していく",
            "while not (len(TL[0])==0 and len(TL[1])==1 and len(TL[2])==1):",
            "  left = 0",
            "  right = 0",
            "  if len(TL[0])>=1:",
            "    #0があれば、まず0を消化する",
            "    if len(TL[1])==0: #-がなければ、0を使って-を作る",
            "      left, right = TL[0].pop(), TL[2].pop()",
            "      printlist.append((left, right))",
            "      TL[1].append(left-right)",
            "    elif len(TL[2])==0: #+がなければ、0を使って+を作る",
            "      left, right = TL[0].pop(), TL[1].pop()",
            "      printlist.append((left, right))",
            "      TL[2].append(left-right)",
            "    else: #-も+もあるなら消化するだけなので、どっちでもいいが、-で消化する",
            "      left, right = TL[1].pop(), TL[0].pop()",
            "      printlist.append((left, right))",
            "      TL[1].append(left-right)",
            "    continue",
            "  #ここからは、0がなくなったパターン",
            "  #0がなくなったということは、+と-は必ず両方あることになる",
            "  #またwhile文の条件から、「どちらも1つしかない」ということはありえない",
            "  if len(TL[1])>=len(TL[2]): #-のが多い、もしくは同じ（もちろん2:2以上）",
            "    left, right = TL[2].pop(), TL[1].pop()",
            "    printlist.append((left, right))",
            "    TL[2].append(left-right)",
            "  else: #+のが多いパターン",
            "    left, right = TL[1].pop(), TL[2].pop()",
            "    printlist.append((left, right))",
            "    TL[1].append(left-right)",
            "# 最後に、プラス-マイナスでプラス数字を作って終わり",
            "left, right = TL[2].pop(), TL[1].pop()",
            "printlist.append((left, right))",
            "ans = left-right",
            "#答えを出力する",
            "print(ans)",
            "for x, y in printlist:",
            "  print(x, y)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#",
            "# 　　  ⋀_⋀",
            "#　　  (･ω･)",
            "# .／ Ｕ ∽ Ｕ＼",
            "#  │＊　合　＊│",
            "#  │＊　格　＊│",
            "#  │＊　祈　＊│",
            "#  │＊　願　＊│",
            "#  │＊　　　＊│",
            "#      ￣",
            "#",
            "import sys",
            "input=sys.stdin.readline",
            "from math import floor,ceil,sqrt,factorial,log #log2ないｙｐ",
            "from heapq import heappop, heappush, heappushpop",
            "from collections import Counter,defaultdict",
            "from itertools import accumulate,permutations,combinations,product,combinations_with_replacement",
            "from bisect import bisect_left,bisect_right",
            "inf=float('inf')",
            "mod = 10**9+7",
            "def INT_(n): return int(n)-1",
            "def MI(): return map(int,input().split())",
            "def MF(): return map(float, input().split())",
            "def MI_(): return map(INT_,input().split())",
            "def LI(): return list(MI())",
            "def LI_(): return [int(x) - 1 for x in input().split()]",
            "def LF(): return list(MF())",
            "def LIN(n:int): return [I() for _ in range(n)]",
            "def LLIN(n: int): return [LI() for _ in range(n)]",
            "def LLIN_(n: int): return [LI_() for _ in range(n)]",
            "def LLI(): return [list(map(int, l.split() )) for l in input()]",
            "def I(): return int(input())",
            "def F(): return float(input())",
            "def ST(): return input().replace('\\n', '')",
            "def main():",
            "    minus = []",
            "    plus = []",
            "    M = I()",
            "    A = LI()",
            "    zero = []",
            "    ans = []",
            "    for a in A:",
            "        if a < 0:",
            "            minus.append(a)",
            "        elif a > 0:",
            "            plus.append(a)",
            "        else:",
            "            zero.append(0)",
            "    minus.sort()",
            "    plus.sort(reverse = True)",
            "    if not minus:",
            "        #print(minus,plus,zero)",
            "        if zero and plus:",
            "            a = zero.pop()",
            "            b = plus.pop()",
            "            minus.append(a-b)",
            "            ans.append(\"{} {}\".format(a, b))",
            "        elif len(plus) >= 2:",
            "            a = plus.pop()",
            "            b = plus.pop()",
            "            minus.append(a-b)",
            "            ans.append(\"{} {}\".format(a, b))",
            "    if not plus:",
            "        if zero and minus:",
            "            a = zero.pop()",
            "            b = minus.pop()",
            "            plus.append(a-b)",
            "            ans.append(\"{} {}\".format(a, b))",
            "        elif len(minus):",
            "            a = minus.pop()",
            "            b = minus.pop()",
            "            plus.append(a-b)",
            "            ans.append(\"{} {}\".format(a, b))",
            "    while minus and plus:",
            "        if len(minus) == len(plus) == 1:",
            "            a = plus.pop()",
            "            b = minus.pop()",
            "            ans.append(\"{} {}\".format(a,b))",
            "            plus.append(a - b)",
            "            break",
            "        a = minus.pop()",
            "        b = plus.pop()",
            "        if len(minus) > len(plus):",
            "            ans.append(\"{} {}\".format(b,a))",
            "            plus.append(b-a)",
            "        else:",
            "            ans.append(\"{} {}\".format(a,b))",
            "            minus.append(a - b)",
            "    while zero:",
            "        if minus:",
            "            a = zero.pop()",
            "            b = minus.pop()",
            "            #print(a, b)",
            "        elif plus:",
            "            a = plus.pop()",
            "            b = zero.pop()",
            "            #print(a, b)",
            "        elif len(zero) >= 2:",
            "            a = zero.pop()",
            "            b = zero.pop()",
            "            #print(a,b)",
            "        else:",
            "            break",
            "        plus.append(a - b)",
            "        ans.append(\"{} {}\".format(a,b))",
            "    if zero:",
            "        print(*zero)",
            "    elif minus:",
            "        print(*minus)",
            "    else:",
            "        print(*plus)",
            "    print(*ans,sep=\"\\n\")",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# -*- coding: utf-8 -*-",
            "import sys",
            "import math",
            "from bisect import bisect_left",
            "from bisect import bisect_right",
            "import collections",
            "import copy",
            "import heapq",
            "from collections import defaultdict",
            "from heapq import heappop, heappush",
            "import itertools",
            "input = sys.stdin.readline",
            "from collections import defaultdict",
            "from heapq import heappop, heappush",
            "from decimal import *",
            "##### リストの 二分木検索 #####",
            "# bisect_left(lists, 3)",
            "# bisect_right(lists, 3)",
            "##### プライオリティキュー #####",
            "# heapq.heapify(a) #リストaのheap化",
            "# heapq.heappush(a,x) #heap化されたリストaに要素xを追加",
            "# heapq.heappop(a) #heap化されたリストaから最小値を削除＆その最小値を出力",
            "# heapq.heappush(a, -x) #最大値を取り出す時は、pushする時にマイナスにして入れよう",
            "# heapq.heappop(a) * (-1) #取り出す時は、-1を掛けて取り出すこと",
            "##### タプルリストのソート #####",
            "# sorted(ans) #(a, b) -> 1st : aの昇順, 2nd : bの昇順",
            "# sorted(SP, key=lambda x:(x[0],-x[1])) #(a, b) -> 1st : aの昇順, 2nd : bの降順",
            "# sorted(SP, key=lambda x:(-x[0],x[1])) #(a, b) -> 1st : aの降順, 2nd : bの昇順",
            "# sorted(SP, key=lambda x:(-x[0],-x[1])) #(a, b) -> 1st : aの降順, 2nd : bの降順",
            "# sorted(SP, key=lambda x:(x[1])) #(a, b) -> 1st : bの昇順",
            "# sorted(SP, key=lambda x:(-x[1])) #(a, b) -> 1st : bの降順",
            "##### 累乗 #####",
            "# pow(x, y, z) -> x**y % z",
            "##### 割り算の切り上げ #####",
            "# tmp = -(-4 // 3)",
            "##### dict の for文 #####",
            "# for k, v in d.items():",
            "#     print(k, v)",
            "def inputInt(): return int(input())",
            "def inputMap(): return map(int, input().split())",
            "def inputList(): return list(map(int, input().split()))",
            "def inputStr(): return input()[:-1]",
            "inf = float('inf')",
            "mod = 1000000007",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "def main():",
            "\tH,W = inputMap()",
            "\tS = []",
            "\tfor i in range(H):",
            "\t\ttmp = inputStr()",
            "\t\tS.append(list(tmp))",
            "\tpart_x = []",
            "\tx = 0",
            "\tfor i in range(H):",
            "\t\ttmp = []",
            "\t\tfor j in range(W):",
            "\t\t\tif S[i][j] == \"#\":",
            "\t\t\t\ttmp.append(x)",
            "\t\t\t\tx = 0",
            "\t\t\t\tcontinue",
            "\t\t\tx += 1",
            "\t\ttmp.append(x)",
            "\t\tx = 0",
            "\t\tpart_x.append(tmp)",
            "\tpart_y = []",
            "\tx = 0",
            "\tfor j in range(W):",
            "\t\ttmp = []",
            "\t\tfor i in range(H):",
            "\t\t\tif S[i][j] == \"#\":",
            "\t\t\t\ttmp.append(x)",
            "\t\t\t\tx = 0",
            "\t\t\t\tcontinue",
            "\t\t\tx += 1",
            "\t\ttmp.append(x)",
            "\t\tx = 0",
            "\t\tpart_y.append(tmp)",
            "\t#print(part_x)",
            "\t#print(part_y)",
            "\tans = 0",
            "\tmem = [0 for i in range(W)]",
            "\tindex_xx = 0",
            "\tindex_xy = 0",
            "\tindex_yx = 0",
            "\tindex_yy = 0",
            "\tfor i in range(H):",
            "\t\tindex_yx = 0",
            "\t\tfor j in range(W):",
            "\t\t\tindex_yx += 1",
            "\t\t\tif S[i][j] == \"#\":",
            "\t\t\t\tindex_xx += 1",
            "\t\t\t\tmem[j] += 1",
            "\t\t\t\tcontinue",
            "\t\t\ttmp = part_x[index_xy][index_xx] + part_y[index_yx-1][mem[j]]",
            "\t\t\t#print(\"{} {} {}\".format(i,j,part_y[index_yx-1][mem[j]]))",
            "\t\t\tif ans < tmp:",
            "\t\t\t\t#print(\"{} {}\".format(i,j))",
            "\t\t\t\tans = tmp",
            "\t\tindex_xx = 0",
            "\t\tindex_xy += 1",
            "\tprint(ans-1)",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "# nCr mod m",
            "# rがn/2に近いと非常に重くなる",
            "def combination(n, r, mod=10**9+7):",
            "    r = min(r, n-r)",
            "    res = 1",
            "    for i in range(r):",
            "        res = res * (n - i) * modinv(i+1, mod) % mod",
            "    return res",
            "# mを法とするaの乗法的逆元",
            "def modinv(a, mod=10**9+7):",
            "    return pow(a, mod-2, mod)",
            "def egcd(a, b):",
            "    if a == 0:",
            "        return b, 0, 1",
            "    else:",
            "        g, y, x = egcd(b % a, a)",
            "        return g, x - (b // a) * y, y",
            "# nHr mod m",
            "# 問題によって、combination()を切り替えること",
            "def H(n, r, mod=10**9+7):",
            "\t# comb = Combination(n+r-1, mod)",
            "\t# return comb(n+r-1, r)",
            "    return combination(n+r-1, r, mod)",
            "class Combination:",
            "    \"\"\"",
            "    O(n)の前計算を1回行うことで，O(1)でnCr mod mを求められる",
            "    n_max = 10**6のとき前処理は約950ms (PyPyなら約340ms, 10**7で約1800ms)",
            "    使用例：",
            "    comb = Combination(1000000)",
            "    print(comb(5, 3))  # 10",
            "    \"\"\"",
            "    def __init__(self, n_max, mod=10**9+7):",
            "        self.mod = mod",
            "        self.modinv = self.make_modinv_list(n_max)",
            "        self.fac, self.facinv = self.make_factorial_list(n_max)",
            "    def __call__(self, n, r):",
            "        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod",
            "    def make_factorial_list(self, n):",
            "        # 階乗のリストと階乗のmod逆元のリストを返す O(n)",
            "        # self.make_modinv_list()が先に実行されている必要がある",
            "        fac = [1]",
            "        facinv = [1]",
            "        for i in range(1, n+1):",
            "            fac.append(fac[i-1] * i % self.mod)",
            "            facinv.append(facinv[i-1] * self.modinv[i] % self.mod)",
            "        return fac, facinv",
            "    def make_modinv_list(self, n):",
            "        # 0からnまでのmod逆元のリストを返す O(n)",
            "        modinv = [0] * (n+1)",
            "        modinv[1] = 1",
            "        for i in range(2, n+1):",
            "            modinv[i] = self.mod - self.mod//i * modinv[self.mod%i] % self.mod",
            "        return modinv",
            "#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
            "# dfs のサンプル",
            "def dfs(graph,parent,counter,edge):",
            "    stk = []",
            "    stk.append(edge)",
            "    while len(stk) > 0:",
            "        p = stk.pop()",
            "        for e in graph[p]:",
            "            if parent[p] == e:",
            "                continue",
            "            else:",
            "                parent[e] = p",
            "                counter[e] += counter[p]",
            "                stk.append(e)",
            "if __name__ == \"__main__\":",
            "\tmain()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product                # product(iter, repeat=n)",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4",
            "def main():",
            "    mod = 1000000007                  # 10^9+7",
            "    inf = float('inf')",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():  return int(input())",
            "    def mi():  return map(int, input().split())",
            "    def mi_0(): return map(lambda x: int(x)-1, input().split())",
            "    def lmi(): return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():  return list(input())",
            "    h, w = mi()",
            "    L = [li() for _ in range(h)]",
            "    memo = [[0] * w for _ in range(h)]",
            "    # x 方向 scan",
            "    for i in range(h):",
            "        # 順方向",
            "        cnt = 0",
            "        for j in range(w):",
            "            if L[i][j] == '#':",
            "                cnt = 0",
            "            else:",
            "                memo[i][j] += cnt",
            "                cnt += 1",
            "        cnt = 1",
            "        # 逆方向",
            "        for j in range(w-1, -1, -1):",
            "            if L[i][j] == '#':",
            "                cnt = 1",
            "            else:",
            "                memo[i][j] += cnt",
            "                cnt += 1",
            "    # y 方向 scan",
            "    for j in range(w):",
            "        # 順方向",
            "        cnt = 0",
            "        for i in range(h):",
            "            if L[i][j] == '#':",
            "                cnt = 0",
            "            else:",
            "                memo[i][j] += cnt",
            "                cnt += 1",
            "        # 逆方向",
            "        cnt = 1",
            "        for i in range(h-1, -1, -1):",
            "            if L[i][j] == '#':",
            "                cnt = 1",
            "            else:",
            "                memo[i][j] += cnt",
            "                cnt += 1",
            "    print(max([max(line) for line in memo]) - 1)    # 縦横で自身を重複して数えている",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "sys.setrecursionlimit(10**7) #再帰関数の上限,10**5以上の場合python",
            "import math",
            "from copy import copy, deepcopy",
            "from copy import deepcopy as dcp",
            "from operator import itemgetter",
            "from bisect import bisect_left, bisect, bisect_right#2分探索",
            "#bisect_left(l,x), bisect(l,x)#aはソート済みである必要あり。aの中からx未満の要素数を返す。rightだと以下",
            "from collections import deque, defaultdict",
            "#deque(l), pop(), append(x), popleft(), appendleft(x)",
            "#q.rotate(n)で → にn回ローテート",
            "from collections import Counter#文字列を個数カウント辞書に、",
            "#S=Counter(l),S.most_common(x),S.keys(),S.values(),S.items()",
            "from itertools import accumulate,combinations,permutations#累積和",
            "#list(accumulate(l))",
            "from heapq import heapify,heappop,heappush",
            "#heapify(q),heappush(q,a),heappop(q) #q=heapify(q)としないこと、返り値はNone",
            "#import fractions#古いatcoderコンテストの場合GCDなどはここからimportする",
            "from functools import reduce,lru_cache#pypyでもうごく",
            "#@lru_cache(maxsize = None)#maxsizeは保存するデータ数の最大値、2**nが最も高効率",
            "from decimal import Decimal",
            "def input():",
            "    x=sys.stdin.readline()",
            "    return x[:-1] if x[-1]==\"\\n\" else x",
            "def printe(*x):print(\"## \",*x,file=sys.stderr)",
            "def printl(li): _=print(*li, sep=\"\\n\") if li else None",
            "def argsort(s, return_sorted=False):",
            "    inds=sorted(range(len(s)), key=lambda k: s[k])",
            "    if return_sorted: return inds, [s[i] for i in inds]",
            "    return inds",
            "def alp2num(c,cap=False): return ord(c)-97 if not cap else ord(c)-65",
            "def num2alp(i,cap=False): return chr(i+97) if not cap else chr(i+65)",
            "def matmat(A,B):",
            "    K,N,M=len(B),len(A),len(B[0])",
            "    return [[sum([(A[i][k]*B[k][j]) for k in range(K)]) for j in range(M)] for i in range(N)]",
            "def matvec(M,v):",
            "    N,size=len(v),len(M)",
            "    return [sum([M[i][j]*v[j] for j in range(N)]) for i in range(size)]",
            "def T(M):",
            "    n,m=len(M),len(M[0])",
            "    return [[M[j][i] for j in range(n)] for i in range(m)]",
            "def main():",
            "    mod = 1000000007",
            "    #w.sort(key=itemgetter(1),reverse=True)  #二個目の要素で降順並び替え",
            "    #N = int(input())",
            "    H, W = map(int, input().split())",
            "    #A = tuple(map(int, input().split())) #1行ベクトル",
            "    #L = tuple(int(input()) for i in range(N)) #改行ベクトル",
            "    S = tuple(tuple(input()) for i in range(H)) #改行行列",
            "    cnt=[[[0]*W for _ in range(H)] for _ in range(4)]",
            "    for i in range(0,H):",
            "        mj=-1",
            "        for j in range(0,W):",
            "            if S[i][j]==\"#\":",
            "                mj=j",
            "                continue",
            "            cnt[0][i][j]=(j-mj-1)",
            "    for i in range(0,H):",
            "        mj=W",
            "        for j in range(W-1,-1,-1):",
            "            if S[i][j]==\"#\":",
            "                mj=j",
            "                continue",
            "            cnt[1][i][j]=(mj-j-1)",
            "    for i in range(0,W):",
            "        mj=-1",
            "        for j in range(0,H):",
            "            if S[j][i]==\"#\":",
            "                mj=j",
            "                continue",
            "            #printe(j,i)",
            "            cnt[2][j][i]=(j-mj-1)",
            "    for i in range(0,W):",
            "        mj=H",
            "        for j in range(H-1,-1,-1):",
            "            if S[j][i]==\"#\":",
            "                mj=j",
            "                continue",
            "            cnt[3][j][i]=(mj-j-1)",
            "    ans=0",
            "    for i in range(0,H):",
            "        for j in range(0,W):",
            "            if S[i][j]==\"#\":",
            "                continue",
            "            x=cnt[0][i][j]+cnt[1][i][j]+cnt[2][i][j]+cnt[3][i][j]+1",
            "            ans=max(x,ans)",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product                # product(iter, repeat=n)",
            "from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4",
            "def main():",
            "    mod = 1000000007                  # 10^9+7",
            "    inf = float('inf')",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():  return int(input())",
            "    def mi():  return map(int, input().split())",
            "    def mi_0(): return map(lambda x: int(x)-1, input().split())",
            "    def lmi(): return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():  return list(input())",
            "    # binary str",
            "    bs = input()",
            "    l = len(bs)",
            "    # 条件 2 について",
            "    # a, b を各桁同士見て行った時 1 が両方立っているとアウト",
            "    # a を固定したら各桁の数に対し 0 => 0 or 1, 1 => 0 と b の取りうる値が決定する",
            "    # binary 表記でちょうど x 桁の数を a が全て取りうる時、対応する b の取りうる値の個数 (条件 2 のみ考える) を A_x とすると、",
            "    # A_x = A_(x-1) * 3 (x>=3)",
            "    # A_1 = 3",
            "    # A_2 = 3",
            "    # A_x はそれぞれ x-1 桁までを「自由に使って」a, b を決めた時の条件を満たすペアの数も同時に示している。",
            "    # L を l 桁とすると、a が l-1 桁で b が l-1 桁以下 (制約から l-2 以下にどうせなるけど) の加算までは何があっても L 以上となることはない (bit carry が起きないので)。",
            "    # ここまでを計算すると A_l",
            "    # これに a が l 桁で b が l 桁以下 (制約から l-1 以下にどうせなるけど) の任意の数の場合を加算する。これは L より上になることがある。",
            "    # L の 1 がたつ bit に注目し、左から L_1, L_2, ... とする",
            "    # a の MSB はもちろん 1, b の MSB はもちろん 0",
            "    # a, b は L_1 までは 0 digit をコピーする必要がある",
            "    # a と b でこの L_1 に 0 を立てると、ビットキャリーをしない a, b を考えるのでその次の桁から a は自由に取りうる。",
            "    # 自由に取りうる桁が y 桁残っていたならば a, b のペアは a_(y+1) + ... + a_1",
            "    # a, b のどちらか一つで L_1 に 1 を立てると (2 通り)、a, b  は次の L_2 直前まで L の 0 digit をコピーしなくてはならぬ (そうしないと over)",
            "    # 次の L_2 についても上記同様に計算していく",
            "    A = [0] * (l+1)    # A[i] = A_i",
            "    A[1] = 3",
            "    for i in range(2, l+1):",
            "        if i == 2:",
            "            A[i] = 3",
            "        else:",
            "            A[i] = (A[i-1] * 3) % mod",
            "    # 最後の L を over するかもしれないものの処理",
            "    def calc_pair(s, i):",
            "        n = len(s)",
            "        if i >= n:",
            "            return 0",
            "        while i <= n - 1 and s[i] == '0':",
            "            i += 1",
            "        if i == n:",
            "            return 1",
            "        else:",
            "            return (A[n - i] + 2 * calc_pair(s, i+1)) % mod",
            "    print(calc_pair(bs, 0))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# for i, a in enumerate(iterable)",
            "# q, mod = divmod(a, b)",
            "# divmod(x, y) returns the tuple (x//y, x%y)",
            "# manage median(s) using two heapq https://atcoder.jp/contests/abc127/tasks/abc127_f",
            "# visual studio code shortcut https://qiita.com/TakahiRoyte/items/cdab6fca64da386a690b",
            "# delete line: Ctrl+Shift+k",
            "# choose same words: Ctrl+Shift+l",
            "import sys",
            "sys.setrecursionlimit(10**7)",
            "INF = 10 ** 18",
            "MOD = 10 ** 9 + 7",
            "from itertools import combinations, permutations # https://docs.python.org/ja/3/library/itertools.html",
            "from math import factorial",
            "def combinations_count(n, r):",
            "    # faster than the following code",
            "    # def combinations_count(n, r):",
            "    #     return factorial(n) // (factorial(n - r) * factorial(r))",
            "    if n - r < r: r = n - r",
            "    if r == 0: return 1",
            "    if r == 1: return n",
            "    numerator = [n - r + k + 1 for k in range(r)]",
            "    denominator = [k + 1 for k in range(r)]",
            "    for p in range(2,r+1):",
            "        pivot = denominator[p - 1]",
            "        if pivot > 1:",
            "            offset = (n - r) % p",
            "            for k in range(p-1,r,p):",
            "                numerator[k - offset] /= pivot",
            "                denominator[k] /= pivot",
            "    result = 1",
            "    for k in range(r):",
            "        if numerator[k] > 1:",
            "            result *= int(numerator[k])",
            "    return result",
            "def combination_with_repetition_count(n, r):",
            "    return combinations_count(n + r - 1, r)",
            "from collections import deque, Counter # https://docs.python.org/ja/3/library/collections.html#collections.deque",
            "from heapq import heapify, heappop, heappush, heappushpop, heapreplace,nlargest,nsmallest # https://docs.python.org/ja/3/library/heapq.html",
            "from copy import deepcopy, copy # https://docs.python.org/ja/3/library/copy.html",
            "from functools import reduce",
            "from fractions import gcd # Deprecated since version 3.5: Use math.gcd() instead.",
            "def gcds(numbers):",
            "    return reduce(gcd, numbers)",
            "def lcm(x, y):",
            "    return (x * y) // gcd(x, y)",
            "def lcms(numbers):",
            "    return reduce(lcm, numbers, 1)",
            "# set the inputs",
            "    # open(0).read() is a convenient method:",
            "    # ex) n, m, *x = map(int, open(0).read().split())",
            "    #     min(x[::2]) - max(x[1::2])",
            "    # ex2) *x, = map(int, open(0).read().split())",
            "    #     don't forget to add comma after *x if only one variable is used",
            "    # R = lambda: map(int, input().split()) :it's fashionable, isn't it?",
            "    # ex1) n, k = R()",
            "    # ex2) v = list(R())",
            "    # ex3) bc = [list(R()) for i in range(m)]",
            "# n = 3",
            "# ab = [[1, 3],[2, 3]]",
            "# c = [1, 2, 3]",
            "# c.sort(reverse=True)",
            "R = lambda: list(map(int, input().split()))",
            "input2 = sys.stdin.readline",
            "R2 = lambda: list(map(int, input2().split()))",
            "n = int(input())",
            "ab = [R2() for i in range(n-1)]",
            "c = R2()",
            "c.sort(reverse=True)",
            "# calculate",
            "dic = {}",
            "l = deque()",
            "for a, b in ab:",
            "    dic.setdefault(a, []).append(b)",
            "    dic.setdefault(b, []).append(a)",
            "m = sum(c) - max(c)",
            "d = [-1] * n",
            "l.extend(dic[1])",
            "d[0] = c[0]",
            "i = 1",
            "while l:",
            "    deq = l.popleft()",
            "    if d[deq-1] >= 0:",
            "        pass",
            "    else:",
            "        if deq in dic:",
            "            l.extend(dic[deq])",
            "        d[deq-1] = c[i]",
            "        i += 1",
            "print(m)",
            "print(*d)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            2,
            2
        ]
    },
    {
        "content": [
            "# abc128_b.py",
            "# https://atcoder.jp/contests/abc128/tasks/abc128_b",
            "# B - Guidebook /",
            "# 実行時間制限: 2 sec / メモリ制限: 1024 MB",
            "# 配点 : 200点",
            "# 問題文",
            "# あなたは美味しいレストランを紹介する本を書くことにしました。",
            "# あなたは N個のレストラン、レストラン 1、レストラン 2、…、レストラン N を紹介しようとしています。",
            "# レストラン i は Si 市にあり、あなたは 100 点満点中 Pi 点と評価しています。",
            "# 異なる 2個のレストランに同じ点数がついていることはありません。",
            "# この本では、次のような順でレストランを紹介しようとしています。",
            "#     市名が辞書順で早いものから紹介していく。",
            "#     同じ市に複数レストランがある場合は、点数が高いものから紹介していく。",
            "# この本で紹介される順にレストランの番号を出力してください。",
            "# 制約",
            "#     1≤N≤100",
            "#     Sは英小文字のみからなる長さ 1 以上 10以下の文字列",
            "#     0≤Pi≤100",
            "#     Piは整数",
            "#     Pi≠Pj(1≤i<j≤N)",
            "# 入力",
            "# 入力は以下の形式で標準入力から与えられる。",
            "# N",
            "# S1 P1",
            "# :",
            "# SN PN",
            "# 出力",
            "# N行出力せよ。i 行目 (1≤i≤N) には、i番目に紹介されるレストランの番号を出力せよ。",
            "# 入力例 1",
            "# 6",
            "# khabarovsk 20",
            "# moscow 10",
            "# kazan 50",
            "# kazan 35",
            "# moscow 60",
            "# khabarovsk 40",
            "# 出力例 1",
            "# 3",
            "# 4",
            "# 6",
            "# 1",
            "# 5",
            "# 2",
            "# 3種類の市名は辞書順で kazan < khabarovsk < moscow です。",
            "# それぞれの市について、点数が高いレストランから順に紹介されていきます。",
            "# よって、レストランは 3,4,6,1,5,2の順に紹介されていきます。",
            "# 入力例 2",
            "# 10",
            "# yakutsk 10",
            "# yakutsk 20",
            "# yakutsk 30",
            "# yakutsk 40",
            "# yakutsk 50",
            "# yakutsk 60",
            "# yakutsk 70",
            "# yakutsk 80",
            "# yakutsk 90",
            "# yakutsk 100",
            "# 出力例 2",
            "# 10",
            "# 9",
            "# 8",
            "# 7",
            "# 6",
            "# 5",
            "# 4",
            "# 3",
            "# 2",
            "# 1",
            "global FLAG_LOG",
            "FLAG_LOG = False",
            "def log(value):",
            "    # FLAG_LOG = True",
            "    # FLAG_LOG = False",
            "    if FLAG_LOG:",
            "        print(str(value))",
            "def calculation(lines):",
            "    # S = lines[0]",
            "    N = int(lines[0])",
            "    # A, P = list(map(int, lines[0].split()))",
            "    # values = list(map(int, lines[1].split()))",
            "    # values = list(map(int, lines[2].split()))",
            "    # values = list()",
            "    # for i in range(N):",
            "    #     values.append(int(lines[i]))",
            "    # valueses = list()",
            "    # for i in range(N):",
            "    #     valueses.append(list(map(int, lines[i+1].split())))",
            "    tmps1 = list()",
            "    tmps2 = list()",
            "    for i in range(1, N+1):",
            "        s, p = lines[i].split()",
            "        # 整形",
            "        tmp = (s+(' ')*10)[:11] + str(200-int(p))",
            "        tmps1.append(tmp)",
            "        tmps2.append(tmp)",
            "    tmps1.sort()",
            "    results = list()",
            "    for tmp1 in tmps1:",
            "        for i in range(N):",
            "            if tmps2[i] == tmp1:",
            "                results.append(i+1)",
            "    return results",
            "# 引数を取得",
            "def get_input_lines():",
            "    line = input()",
            "    N = int(line)",
            "    lines = list()",
            "    lines.append(line)",
            "    for _ in range(N):",
            "        lines.append(input())",
            "    return lines",
            "# テストデータ",
            "def get_testdata(pattern):",
            "    if pattern == 1:",
            "        lines_input = ['6', 'khabarovsk 20', 'moscow 10', 'kazan 50', 'kazan 35', 'moscow 60', 'khabarovsk 40']",
            "        lines_export = [3, 4, 6, 1, 5, 2]",
            "    if pattern == 2:",
            "        lines_input = ['10', 'yakutsk 10', 'yakutsk 20', 'yakutsk 30', 'yakutsk 40', 'yakutsk 50', 'yakutsk 60', 'yakutsk 70', 'yakutsk 80', 'yakutsk 90', 'yakutsk 100']",
            "        lines_export = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]",
            "    return lines_input, lines_export",
            "# 動作モード判別",
            "def get_mode():",
            "    import sys",
            "    args = sys.argv",
            "    global FLAG_LOG",
            "    if len(args) == 1:",
            "        mode = 0",
            "        FLAG_LOG = False",
            "    else:",
            "        mode = int(args[1])",
            "        FLAG_LOG = True",
            "    return mode",
            "# 主処理",
            "def main():",
            "    import time",
            "    started = time.time()",
            "    mode = get_mode()",
            "    if mode == 0:",
            "        lines_input = get_input_lines()",
            "    else:",
            "        lines_input, lines_export = get_testdata(mode)",
            "    lines_result = calculation(lines_input)",
            "    for line_result in lines_result:",
            "        print(line_result)",
            "    # if mode > 0:",
            "    #     print(f'lines_input=[{lines_input}]')",
            "    #     print(f'lines_export=[{lines_export}]')",
            "    #     print(f'lines_result=[{lines_result}]')",
            "    #     if lines_result == lines_export:",
            "    #         print('OK')",
            "    #     else:",
            "    #         print('NG')",
            "    # finished = time.time()",
            "    # duration = finished - started",
            "    # print(f'duration=[{duration}]')",
            "# 起動処理",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# abc128_c.py",
            "# https://atcoder.jp/contests/abc128/tasks/abc128_c",
            "# C - Switches /",
            "# 実行時間制限: 2 sec / メモリ制限: 1024 MB",
            "# 配点 : 300点",
            "# 問題文",
            "# on と off の状態を持つ N個の スイッチと、M 個の電球があります。",
            "# スイッチには 1 から N の、電球には 1 から Mの番号がついています。",
            "# 電球 iは ki 個のスイッチに繋がっており、スイッチ si1,si2,...,siki のうち on になっているスイッチの個数を 2 で割った余りが piに等しい時に点灯します。",
            "# 全ての電球が点灯するようなスイッチの on/off の状態の組み合わせは何通りあるでしょうか。",
            "# 制約",
            "#     1≤N,M≤10",
            "#     1≤ki≤N",
            "#     1≤sij≤N",
            "#     sia≠sib(a≠b)",
            "#     piは 0 または 1入力は全て整数である",
            "# 入力",
            "# 入力は以下の形式で標準入力から与えられる。",
            "# N M",
            "# k1 s11 s12 ... s1k1",
            "# :",
            "# kM sM1 sM2 ... sMkM",
            "# p1 p2 ... pM",
            "# 出力",
            "# 全ての電球が点灯するようなスイッチの on/off の状態の組み合わせの個数を出力せよ。",
            "# 入力例 1",
            "# 2 2",
            "# 2 1 2",
            "# 1 2",
            "# 0 1",
            "# 出力例 1",
            "# 1",
            "#     電球 1は、次のスイッチのうち偶数個が on の時に点灯します: スイッチ 1,2",
            "#     電球 2は、次のスイッチのうち奇数個が on の時に点灯します: スイッチ 2",
            "# (スイッチ 1、スイッチ 2) の状態としては (on,on),(on,off),(off,on),(off,off) が考えられますが、",
            "# このうち (on,on) のみが条件を満たすので、1を出力してください。",
            "# 入力例 2",
            "# 2 3",
            "# 2 1 2",
            "# 1 1",
            "# 1 2",
            "# 0 0 1",
            "# 出力例 2",
            "# 0",
            "#     電球 1は、次のスイッチのうち偶数個が on の時に点灯します: スイッチ 1,2",
            "#     電球 2は、次のスイッチのうち偶数個が on の時に点灯します: スイッチ 1",
            "#     電球 3は、次のスイッチのうち奇数個が on の時に点灯します: スイッチ 2",
            "# 電球 2を点灯させるためには スイッチ 1 が off,",
            "# 電球 3 を点灯させるためにはスイッチ 2 が on である必要がありますが、この時電球 1は点灯しません。",
            "# よって、全ての電球が点灯するようなスイッチの on/off の状態の組み合わせは存在しないので、0を出力してください。",
            "# 入力例 3",
            "# 5 2",
            "# 3 1 2 5",
            "# 2 2 3",
            "# 1 0",
            "# 出力例 3",
            "# 8",
            "global FLAG_LOG",
            "FLAG_LOG = False",
            "def log(value):",
            "    # FLAG_LOG = True",
            "    # FLAG_LOG = False",
            "    if FLAG_LOG:",
            "        print(str(value))",
            "def calculation(lines):",
            "    # S = lines[0]",
            "    # N = int(lines[0])",
            "    N, M = list(map(int, lines[0].split()))",
            "    # values = list(map(int, lines[1].split()))",
            "    values_p = list(map(int, lines[M+1].split()))",
            "    # values = list()",
            "    # for i in range(N):",
            "    #     values.append(int(lines[i]))",
            "    valueses = list()",
            "    for i in range(M):",
            "        valueses.append(list(map(int, lines[i+1].split())))",
            "    # 指定ビットのパターンを繰り返す",
            "    result = 0",
            "    # for i in range(2, 3):",
            "    for i in range(2**N):",
            "        # 評価するパターン",
            "        pattern = format(int(format(i, 'b')), '0=' + str(N))",
            "        log(f'pattern=[{pattern}]')",
            "        on_cnt1 = 0",
            "        # ランプの数分繰り返す",
            "        for m in range(M):",
            "            on_cnt2 = 0",
            "            log(f'm=[{m}]')",
            "            ss = valueses[m][1:]",
            "            log(f'ss=[{ss}]')",
            "            for s in ss:",
            "                if pattern[s-1] == '1':",
            "                    on_cnt2 += 1",
            "                    log(f'on_cnt2=[{on_cnt2}]')",
            "                else:",
            "                    log(f'pattern[s-1]=[{pattern[s-1]}]')",
            "            log(f'on_cnt2=[{on_cnt2}]')",
            "            if on_cnt2 % 2 == values_p[m]:",
            "                on_cnt1 += 1",
            "                log(f'result++, on_cnt2=[{on_cnt2}]')",
            "        if on_cnt1 == M:",
            "            result += 1",
            "    return [result]",
            "# 引数を取得",
            "def get_input_lines():",
            "    line = input()",
            "    N, M = list(map(int, line.split()))",
            "    lines = list()",
            "    lines.append(line)",
            "    for _ in range(M+1):",
            "        lines.append(input())",
            "    return lines",
            "# テストデータ",
            "def get_testdata(pattern):",
            "    if pattern == 1:",
            "        lines_input = ['2 2', '2 1 2', '1 2', '0 1']",
            "        lines_export = [1]",
            "    if pattern == 2:",
            "        lines_input = ['2 3', '2 1 2', '1 1', '1 2', '0 0 1']",
            "        lines_export = [0]",
            "    if pattern == 3:",
            "        lines_input = ['5 2', '3 1 2 5', '2 2 3', '1 0']",
            "        lines_export = [8]",
            "    return lines_input, lines_export",
            "# 動作モード判別",
            "def get_mode():",
            "    import sys",
            "    args = sys.argv",
            "    global FLAG_LOG",
            "    if len(args) == 1:",
            "        mode = 0",
            "        FLAG_LOG = False",
            "    else:",
            "        mode = int(args[1])",
            "        FLAG_LOG = True",
            "    return mode",
            "# 主処理",
            "def main():",
            "    import time",
            "    started = time.time()",
            "    mode = get_mode()",
            "    if mode == 0:",
            "        lines_input = get_input_lines()",
            "    else:",
            "        lines_input, lines_export = get_testdata(mode)",
            "    lines_result = calculation(lines_input)",
            "    for line_result in lines_result:",
            "        print(line_result)",
            "    # if mode > 0:",
            "    #     print(f'lines_input=[{lines_input}]')",
            "    #     print(f'lines_export=[{lines_export}]')",
            "    #     print(f'lines_result=[{lines_result}]')",
            "    #     if lines_result == lines_export:",
            "    #         print('OK')",
            "    #     else:",
            "    #         print('NG')",
            "    # finished = time.time()",
            "    # duration = finished - started",
            "    # print(f'duration=[{duration}]')",
            "# 起動処理",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "mod = 10 ** 9 + 7",
            "from collections import deque",
            "import heapq",
            "def iip(listed):",
            "    ret = [int(i) for i in input().split()]",
            "    if len(ret) == 1 and not listed:",
            "        return ret[0]",
            "    return ret",
            "def main():",
            "    r = solve()",
            "    print(r)",
            "def solve():",
            "    N, K = iip(False)",
            "    V = iip(True)",
            "    V2 = [i for i in V]",
            "    V2.reverse()",
            "    mm = 0",
            "    for i in range(N+1):",
            "        for j in range(N+1):",
            "            if i+j > K:",
            "                continue",
            "            if i+j > N:",
            "                continue",
            "            jewels = V[:i]",
            "            jewels.extend(V2[:j])",
            "            zyokyo = K - (i+j)",
            "            while zyokyo >= 1:",
            "                zyokyo -= 1",
            "                if not jewels:",
            "                    break",
            "                mj = min(jewels)",
            "                if min(jewels) < 0:",
            "                    jewels.remove(mj)",
            "                else:",
            "                    break",
            "            mm = max(mm, sum(jewels))",
            "    return mm",
            "#####################################################ライブラリ集ここから",
            "def split_print_space(s):",
            "    print(\" \".join([str(i) for i in s]))",
            "def split_print_enter(s):",
            "    print(\"\\n\".join([str(i) for i in s]))",
            "def koenai_saidai_x_index(sorted_list, n):",
            "    l = 0",
            "    r = len(sorted_list)",
            "    if len(sorted_list) == 0:",
            "        return False",
            "    if sorted_list[0] > n:",
            "        return False",
            "    while r - l > 1:",
            "        x = (l + r) // 2",
            "        if sorted_list[x] == n:",
            "            return x",
            "        elif sorted_list[x] > n:",
            "            r = x",
            "        else:",
            "            l = x",
            "    return l",
            "def searchsorted(sorted_list, n, side):",
            "    if side not in [\"right\", \"left\"]:",
            "        raise Exception(\"sideはrightかleftで指定してください\")",
            "    l = 0",
            "    r = len(sorted_list)",
            "    if n > sorted_list[-1]:",
            "        # print(sorted_list)",
            "        return len(sorted_list)",
            "    if n < sorted_list[0]:",
            "        return 0",
            "    while r - l > 1:",
            "        x = (l + r) // 2",
            "        if sorted_list[x] > n:",
            "            r = x",
            "        elif sorted_list[x] < n:",
            "            l = x",
            "        else:",
            "            if side == \"left\":",
            "                r = x",
            "            elif side == \"right\":",
            "                l = x",
            "    if side == \"left\":",
            "        if sorted_list[l] == n:",
            "            return r - 1",
            "        else:",
            "            return r",
            "    if side == \"right\":",
            "        if sorted_list[l] == n:",
            "            return l + 1",
            "        else:",
            "            return l",
            "def soinsuu_bunkai(n):",
            "    ret = []",
            "    for i in range(2, int(n ** 0.5) + 1):",
            "        while n % i == 0:",
            "            n //= i",
            "            ret.append(i)",
            "        if i > n:",
            "            break",
            "    if n != 1:",
            "        ret.append(n)",
            "    return ret",
            "def conbination(n, r, mod, test=False):",
            "    if n <= 0:",
            "        return 0",
            "    if r == 0:",
            "        return 1",
            "    if r < 0:",
            "        return 0",
            "    if r == 1:",
            "        return n",
            "    ret = 1",
            "    for i in range(n - r + 1, n + 1):",
            "        ret *= i",
            "        ret = ret % mod",
            "    bunbo = 1",
            "    for i in range(1, r + 1):",
            "        bunbo *= i",
            "        bunbo = bunbo % mod",
            "    ret = (ret * inv(bunbo, mod)) % mod",
            "    if test:",
            "        # print(f\"{n}C{r} = {ret}\")",
            "        pass",
            "    return ret",
            "def inv(n, mod):",
            "    return power(n, mod - 2)",
            "def power(n, p):",
            "    if p == 0:",
            "        return 1",
            "    if p % 2 == 0:",
            "        return (power(n, p // 2) ** 2) % mod",
            "    if p % 2 == 1:",
            "        return (n * power(n, p - 1)) % mod",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "class LazySegmentTree:",
            "    \"\"\"",
            "    op: 区間取得クエリでreduceする際に使う演算子",
            "    apply: 更新則の(n回)適用",
            "    comp: 更新則の合成",
            "    rep: f(x,m)+f(y,m) != f(x+y,m)となる場合に、m^nを高速に計算する用",
            "    range_query: reduce(op, (apply(x,m) for x,m in zip(X,M)))",
            "    満たすべき性質:",
            "    集合X (要素)",
            "    op[+]: X,X -> X",
            "    (X, op)はモノイド",
            "    集合M (更新則)",
            "    comp[*]: M,M -> M",
            "    (M, compose)はモノイド",
            "    apply[f(x,m,n)]: X,M,Z+ -> X",
            "    (Z+は区間長)",
            "    f(x,e_M,n) = x",
            "    f(x,m*n,p) = f(f(x,m,p),n,p)",
            "    f(x,m,p)+f(y,m,q) = f(x+y,m,p+q)",
            "    参考: https://algo-logic.info/segment-tree/#toc_id_3",
            "    \"\"\"",
            "    @classmethod",
            "    def all_identity(cls, op, op_e, comp, comp_e, apply, size):",
            "        size = 1 << (size-1).bit_length()",
            "        return cls(",
            "            op,",
            "            op_e,",
            "            comp,",
            "            comp_e,",
            "            apply,",
            "            [op_e]*(2*size),",
            "            [comp_e]*size",
            "        )",
            "    @classmethod",
            "    def from_initial_data(cls, op, op_e, comp, comp_e, apply, data):",
            "        size = 1 << (len(data)-1).bit_length()",
            "        temp = [op_e]*(2*size)",
            "        temp[size:size+len(data)] = data",
            "        for i in reversed(range(size)):",
            "            temp[i] = op(temp[2*i],temp[2*i+1])",
            "        return cls(",
            "            op,",
            "            op_e,",
            "            comp,",
            "            comp_e,",
            "            apply,",
            "            temp,",
            "            [comp_e]*size",
            "        )",
            "    # これ使わずファクトリーメソッド使いましょうね",
            "    def __init__(self, op, op_e, comp, comp_e, apply, data, lazy):",
            "        self.op = op",
            "        self.op_e = op_e",
            "        self.comp = comp",
            "        self.comp_e = comp_e",
            "        self.apply = apply",
            "        self.data = data",
            "        self.lazy = lazy",
            "        self.size = len(self.data)//2",
            "        self.depth = self.size.bit_length()-1",
            "        self._l_indices = [0]*self.depth",
            "        self._r_indices = [0]*self.depth",
            "    def _update_indices(self, i, l):",
            "        m = i//(i&-i)",
            "        i >>= 1",
            "        for k in range(self.depth):",
            "            l[k] = i if i < m else 0",
            "            i >>= 1",
            "    def _propagate_top_down(self):",
            "        data = self.data",
            "        lazy = self.lazy",
            "        apply = self.apply",
            "        comp = self.comp",
            "        comp_e = self.comp_e",
            "        k = self.size >> 1",
            "        for i,j in zip(reversed(self._l_indices), reversed(self._r_indices)):",
            "            if i > 0:",
            "                temp = self.lazy[i]",
            "                if temp != comp_e:",
            "                    lazy[i] = comp_e",
            "                    a = i << 1",
            "                    b = a | 1",
            "                    data[a] = apply(data[a], temp, k)",
            "                    data[b] = apply(data[b], temp, k)",
            "                    if k > 1:",
            "                        lazy[a] = comp(lazy[a], temp)",
            "                        lazy[b] = comp(lazy[b], temp)",
            "            if i < j:",
            "                temp = self.lazy[j]",
            "                if temp != comp_e:",
            "                    lazy[j] = comp_e",
            "                    a = j << 1",
            "                    b = a | 1",
            "                    data[a] = apply(data[a], temp, k)",
            "                    data[b] = apply(data[b], temp, k)",
            "                    if k > 1:",
            "                        lazy[a] = comp(lazy[a], temp)",
            "                        lazy[b] = comp(lazy[b], temp)",
            "            k >>= 1",
            "    def _propagate_bottom_up(self):",
            "        data = self.data",
            "        op = self.op",
            "        for i,j in zip(self._l_indices, self._r_indices):",
            "            if i < j:",
            "                data[j] = op(data[j<<1],data[j<<1|1])",
            "            if i > 0:",
            "                data[i] = op(data[i<<1],data[i<<1|1])",
            "    def update_interval(self, l, r, m):",
            "        lazy = self.lazy",
            "        data = self.data",
            "        comp = self.comp",
            "        apply = self.apply",
            "        l += self.size",
            "        r += self.size",
            "        self._update_indices(l, self._l_indices)",
            "        self._update_indices(r, self._r_indices)",
            "        self._propagate_top_down()",
            "        k = 1",
            "        while l < r:",
            "            if l & 1:",
            "                data[l] = apply(data[l],m,k)",
            "                if k > 1:",
            "                    lazy[l] = comp(lazy[l],m)",
            "                l += 1",
            "            if r & 1:",
            "                r -= 1",
            "                data[r] = apply(data[r],m,k)",
            "                if k > 1:",
            "                    lazy[r] = comp(lazy[r],m)",
            "            l >>= 1",
            "            r >>= 1",
            "            k <<= 1",
            "        self._propagate_bottom_up()",
            "    def get_interval(self, l, r):",
            "        data = self.data",
            "        op = self.op",
            "        l += self.size",
            "        r += self.size",
            "        self._update_indices(l, self._l_indices)",
            "        self._update_indices(r, self._r_indices)",
            "        self._propagate_top_down()",
            "        lx = self.op_e",
            "        rx = self.op_e",
            "        while l < r:",
            "            if l & 1:",
            "                lx = op(lx, data[l])",
            "                l += 1",
            "            if r & 1:",
            "                r -= 1",
            "                rx = op(data[r], rx)",
            "            l >>= 1",
            "            r >>= 1",
            "        return op(lx,rx)",
            "import sys",
            "from bisect import *",
            "max2 = lambda x,y: x if x > y else y",
            "min2 = lambda x,y: x if x < y else y",
            "input = sys.stdin.readline",
            "N, Q = map(int, input().split())",
            "st = LazySegmentTree.all_identity(max2,-1, lambda x,m: x if m < 0 else m,-1,lambda x,m,l: x if m < 0 else m,Q)",
            "Qu = [list(map(int, input().split())) for _ in range(N)]",
            "Qu.sort(key=lambda x:x[2], reverse=True)",
            "D = [int(input()) for _ in range(Q)]",
            "for q in Qu:",
            "    S, T, X = q",
            "    L = bisect_left(D,S-X)",
            "    R = bisect_left(D,T-X)",
            "    st.update_interval(L, R, X)",
            "print(*(st.get_interval(i,i+1) for i in range(Q)), sep=\"\\n\")"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "import sys",
            "sys.setrecursionlimit(10**7)",
            "def LI(): return [int(x) for x in sys.stdin.readline().split()]",
            "def LI_(): return [int(x) - 1 for x in sys.stdin.readline().split()]",
            "def LF(): return [float(x) for x in sys.stdin.readline().split()]",
            "def LS(): return sys.stdin.readline().split()",
            "def II(): return int(sys.stdin.readline())",
            "def SI(): return sys.stdin.readline().strip()",
            "MOD = 10 ** 9 + 7",
            "INF = 10 ** 18",
            "from collections.abc import Sequence, Set",
            "from bisect import bisect_left",
            "from itertools import chain",
            "from heapq import heappush, heappop",
            "class HeapqSet():",
            "    def __init__(self):",
            "        self._set = set()",
            "        self._list = list()",
            "    def add(self, a):",
            "        if a in self._set:",
            "            return",
            "        else:",
            "            self._set.add(a)",
            "            heappush(self._list, a)",
            "    def remove(self, a):",
            "        if a not in self._set:",
            "            raise ValueError",
            "        else:",
            "            self._set.remove(a)",
            "    def pop_min(self):",
            "        if not self._set:",
            "            self._list = list()",
            "            return None",
            "        while True:",
            "            a = heappop(self._list)",
            "            if a not in self._set:",
            "                continue",
            "            else:",
            "                self._set.remove(a)",
            "                break",
            "        return a",
            "    def peek_min(self):",
            "        if not self._set:",
            "            self._list = list()",
            "            return None",
            "        while True:",
            "            a = self._list[0]",
            "            if a not in self._set:",
            "                heappop(self._list)",
            "                continue",
            "            else:",
            "                break",
            "        return a",
            "    def is_empty(self):",
            "        return not self._set",
            "    def __bool__(self):",
            "        return True if self._set else False",
            "def main():",
            "    N, Q = LI()",
            "    events = []",
            "    for _ in range(N):",
            "        stx = LI()",
            "        # events.append((s - x, x, True))  # S-X, X, add_flag",
            "        # events.append((t - x, x, False))  # T-X, X, add_flag",
            "        events.append((stx[0] - stx[2], stx[2], True))  # S-X, X, add_flag",
            "        events.append((stx[1] - stx[2], stx[2], False))  # T-X, X, add_flag",
            "    for _ in range(Q):",
            "        events.append((II(), INF, -1))",
            "    # events.sort(key=lambda x:x[0])  # O(N log N), stable",
            "    events.sort()  # O(N log N), stable, False (==0) < True (==1)",
            "    from array import array",
            "    ans = array('i')",
            "    # m = SortedList()",
            "    m = HeapqSet()",
            "    # for time, x, add_flag in events:",
            "    change_flag = True",
            "    min_ = INF",
            "    for txa in events:",
            "        if txa[2] == -1:",
            "            if not m:",
            "                ans.append(-1)",
            "                # ans += '-1\\n'",
            "            else:",
            "                if change_flag:",
            "                    min_ = m.peek_min()",
            "                    change_flag = False",
            "                ans.append(min_)",
            "                # ans += str(m[0])+'\\n'",
            "        elif txa[2]:",
            "            m.add(txa[1])",
            "            if txa[1] < min_:",
            "                min_ = txa[1]",
            "                change_flag = False",
            "        else:",
            "            m.remove(txa[1])",
            "            if txa[1] == min_ and m:",
            "                min_ = m.peek_min()",
            "                change_flag = False",
            "            elif not m:",
            "                min_ = INF",
            "                change_flag = False",
            "    # for i in ans: print(i)",
            "    # print('\\n'.join(map(str, ans)))",
            "    print('\\n'.join(map(str, ans.tolist())))",
            "main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "import sys",
            "INF = 1 << 30",
            "class Node:",
            "    def __init__(self, key):",
            "        self.key = key",
            "        self.lch = None",
            "        self.rch = None",
            "        self.bias = 0",
            "class AVLTree:",
            "    def __init__(self):",
            "        self.root = None",
            "    def rotate_left(self, v):",
            "        u = v.rch",
            "        v.rch = u.lch",
            "        u.lch = v",
            "        if u.bias == -1:",
            "            u.bias = v.bias = 0",
            "        else:",
            "            u.bias = 1",
            "            v.bias = -1",
            "        return u",
            "    def rotate_right(self, v):",
            "        u = v.lch",
            "        v.lch = u.rch",
            "        u.rch = v",
            "        if u.bias == 1:",
            "            u.bias = v.bias = 0",
            "        else:",
            "            u.bias = -1",
            "            v.bias = 1",
            "        return u",
            "    def rotateLR(self, v):",
            "        u = v.lch",
            "        t = u.rch",
            "        u.rch = t.lch",
            "        t.lch = u",
            "        v.lch = t.rch",
            "        t.rch = v",
            "        self.update_bias_double(t)",
            "        return t",
            "    def rotateRL(self, v):",
            "        u = v.rch",
            "        t = u.lch",
            "        u.lch = t.rch",
            "        t.rch = u",
            "        v.rch = t.lch",
            "        t.lch = v",
            "        self.update_bias_double(t)",
            "        return t",
            "    def update_bias_double(self, v):",
            "        if v.bias == 1:",
            "            v.rch.bias = -1",
            "            v.lch.bias = 0",
            "        elif v.bias == -1:",
            "            v.rch.bias = 0",
            "            v.lch.bias = 1",
            "        else:",
            "            v.rch.bias = 0",
            "            v.lch.bias = 0",
            "        v.bias = 0",
            "    def add(self, key):",
            "        if self.root is None:",
            "            self.root = Node(key)",
            "            return",
            "        v = self.root",
            "        history = []",
            "        while v is not None:",
            "            if key < v.key:",
            "                history.append((v, 1))",
            "                v = v.lch",
            "            elif v.key < key:",
            "                history.append((v, -1))",
            "                v = v.rch",
            "            else:",
            "                return",
            "        p, pdir = history[-1]",
            "        if pdir == 1:",
            "            p.lch = Node(key)",
            "        else:",
            "            p.rch = Node(key)",
            "        while history:",
            "            v, direction = history.pop()",
            "            v.bias += direction",
            "            new_v = None",
            "            b = v.bias",
            "            if b == 0:",
            "                break",
            "            if b == 2:",
            "                u = v.lch",
            "                if u.bias == -1:",
            "                    new_v = self.rotateLR(v)",
            "                else:",
            "                    new_v = self.rotate_right(v)",
            "                break",
            "            if b == -2:",
            "                u = v.rch",
            "                if u.bias == 1:",
            "                    new_v = self.rotateRL(v)",
            "                else:",
            "                    new_v = self.rotate_left(v)",
            "                break",
            "        if new_v is not None:",
            "            if len(history) == 0:",
            "                self.root = new_v",
            "                return",
            "            p, pdir = history.pop()",
            "            if pdir == 1:",
            "                p.lch = new_v",
            "            else:",
            "                p.rch = new_v",
            "    def remove(self, key):",
            "        v = self.root",
            "        history = []",
            "        while v is not None:",
            "            if key < v.key:",
            "                history.append((v, 1))",
            "                v = v.lch",
            "            elif v.key < key:",
            "                history.append((v, -1))",
            "                v = v.rch",
            "            else:",
            "                break",
            "        else:",
            "            return False",
            "        if v.lch is not None:",
            "            history.append((v, 1))",
            "            lmax = v.lch",
            "            while lmax.rch is not None:",
            "                history.append((lmax, -1))",
            "                lmax = lmax.rch",
            "            v.key = lmax.key",
            "            v = lmax",
            "        c = v.rch if v.lch is None else v.lch",
            "        if history:",
            "            p, pdir = history[-1]",
            "            if pdir == 1:",
            "                p.lch = c",
            "            else:",
            "                p.rch = c",
            "        else:",
            "            self.root = c",
            "            return True",
            "        while history:",
            "            new_p = None",
            "            p, pdir = history.pop()",
            "            p.bias -= pdir",
            "            b = p.bias",
            "            if b == 2:",
            "                if p.lch.bias == -1:",
            "                    new_p = self.rotateLR(p)",
            "                else:",
            "                    new_p = self.rotate_right(p)",
            "            elif b == -2:",
            "                if p.rch.bias == 1:",
            "                    new_p = self.rotateRL(p)",
            "                else:",
            "                    new_p = self.rotate_left(p)",
            "            elif b != 0:",
            "                break",
            "            if new_p is not None:",
            "                if len(history) == 0:",
            "                    self.root = new_p",
            "                    return True",
            "                gp, gpdir = history[-1]",
            "                if gpdir == 1:",
            "                    gp.lch = new_p",
            "                else:",
            "                    gp.rch = new_p",
            "                if new_p.bias != 0:",
            "                    break",
            "        return True",
            "    def lower_bound(self, key):",
            "        ret = INF",
            "        v = self.root",
            "        while v is not None:",
            "            if v.key >= key:",
            "                if ret > v.key:",
            "                    ret = v.key",
            "                v = v.lch",
            "            else:",
            "                v = v.rch",
            "        return ret",
            "read = sys.stdin.buffer.read",
            "input = sys.stdin.buffer.readline",
            "N, Q = map(int, input().split())",
            "event = []",
            "for i in range(N):",
            "    s, t, x = map(int, input().split())",
            "    event.append((s-x, 1, x))",
            "    event.append((t-x, 0, x))",
            "event.sort(reverse=True)",
            "avl = AVLTree()",
            "ans = []",
            "for d in map(int, read().split()):",
            "    while event and event[-1][0] <= d:",
            "        time, k, x = event.pop()",
            "        if k == 1:",
            "            avl.add(x)",
            "        else:",
            "            avl.remove(x)",
            "    x = avl.lower_bound(-INF)",
            "    ans.append(x if x < INF else -1)",
            "print('\\n'.join(map(str, ans)))"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            2,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "import sys",
            "class Node:",
            "    def __init__(self, key, val):",
            "        self.key = key",
            "        self.val = val",
            "        self.lst = None",
            "        self.rst = None",
            "        self.bias = 0",
            "class AVLTree:",
            "    def __init__(self):",
            "        self.root = None",
            "    def rotate_left(self, v):",
            "        u = v.rst",
            "        v.rst = u.lst",
            "        u.lst = v",
            "        if u.bias == -1:",
            "            u.bias = v.bias = 0",
            "        else:",
            "            u.bias = 1",
            "            v.bias = -1",
            "        return u",
            "    def rotate_right(self, v):",
            "        u = v.lst",
            "        v.lst = u.rst",
            "        u.rst = v",
            "        if u.bias == 1:",
            "            u.bias = v.bias = 0",
            "        else:",
            "            u.bias = -1",
            "            v.bias = 1",
            "        return u",
            "    def rotateLR(self, v):",
            "        u = v.lst",
            "        t = u.rst",
            "        u.rst = t.lst",
            "        t.lst = u",
            "        v.lst = t.rst",
            "        t.rst = v",
            "        self.update_bias_double(t)",
            "        return t",
            "    def rotateRL(self, v):",
            "        u = v.rst",
            "        t = u.lst",
            "        u.lst = t.rst",
            "        t.rst = u",
            "        v.rst = t.lst",
            "        t.lst = v",
            "        self.update_bias_double(t)",
            "        return t",
            "    def update_bias_double(self, v):",
            "        if v.bias == 1:",
            "            v.rst.bias = -1",
            "            v.lst.bias = 0",
            "        elif v.bias == -1:",
            "            v.rst.bias = 0",
            "            v.lst.bias = 1",
            "        else:",
            "            v.rst.bias = 0",
            "            v.lst.bias = 0",
            "        v.bias = 0",
            "    def insert(self, key, val):",
            "        if self.root is None:",
            "            self.root = Node(key, val)",
            "            return",
            "        v = self.root",
            "        history = []",
            "        while v is not None:",
            "            if key < v.key:",
            "                history.append((v, 1))",
            "                v = v.lst",
            "            elif v.key < key:",
            "                history.append((v, -1))",
            "                v = v.rst",
            "            elif v.key == key:",
            "                v.val = val",
            "                return",
            "        p, pdir = history[-1]",
            "        if pdir == 1:",
            "            p.lst = Node(key, val)",
            "        else:",
            "            p.rst = Node(key, val)",
            "        while history:",
            "            v, direction = history.pop()",
            "            v.bias += direction",
            "            new_v = None",
            "            b = v.bias",
            "            if b == 0:",
            "                break",
            "            if b == 2:",
            "                u = v.lst",
            "                if u.bias == -1:",
            "                    new_v = self.rotateLR(v)",
            "                else:",
            "                    new_v = self.rotate_right(v)",
            "                break",
            "            if b == -2:",
            "                u = v.rst",
            "                if u.bias == 1:",
            "                    new_v = self.rotateRL(v)",
            "                else:",
            "                    new_v = self.rotate_left(v)",
            "                break",
            "        if new_v is not None:",
            "            if len(history) == 0:",
            "                self.root = new_v",
            "                return",
            "            p, pdir = history.pop()",
            "            if pdir == 1:",
            "                p.lst = new_v",
            "            else:",
            "                p.rst = new_v",
            "    def delete(self, key):",
            "        v = self.root",
            "        history = []",
            "        while v is not None:",
            "            if key < v.key:",
            "                history.append((v, 1))",
            "                v = v.lst",
            "            elif v.key < key:",
            "                history.append((v, -1))",
            "                v = v.rst",
            "            else:",
            "                break",
            "        else:",
            "            return False",
            "        if v.lst is not None:",
            "            history.append((v, 1))",
            "            lmax = v.lst",
            "            while lmax.rst is not None:",
            "                history.append((lmax, -1))",
            "                lmax = lmax.rst",
            "            v.key = lmax.key",
            "            v.val = lmax.val",
            "            v = lmax",
            "        c = v.rst if v.lst is None else v.lst",
            "        if history:",
            "            p, pdir = history[-1]",
            "            if pdir == 1:",
            "                p.lst = c",
            "            else:",
            "                p.rst = c",
            "        else:",
            "            self.root = c",
            "            return True",
            "        while history:",
            "            new_p = None",
            "            p, pdir = history.pop()",
            "            p.bias -= pdir",
            "            b = p.bias",
            "            if b == 2:",
            "                if p.lst.bias == -1:",
            "                    new_p = self.rotateLR(p)",
            "                else:",
            "                    new_p = self.rotate_right(p)",
            "            elif b == -2:",
            "                if p.rst.bias == 1:",
            "                    new_p = self.rotateRL(p)",
            "                else:",
            "                    new_p = self.rotate_left(p)",
            "            elif b != 0:",
            "                break",
            "            if new_p is not None:",
            "                if len(history) == 0:",
            "                    self.root = new_p",
            "                    return True",
            "                gp, gpdir = history[-1]",
            "                if gpdir == 1:",
            "                    gp.lst = new_p",
            "                else:",
            "                    gp.rst = new_p",
            "                if new_p.bias != 0:",
            "                    break",
            "        return True",
            "    def member(self, key):",
            "        v = self.root",
            "        while v is not None:",
            "            if key < v.key:",
            "                v = v.lst",
            "            elif v.key < key:",
            "                v = v.rst",
            "            else:",
            "                return True",
            "        return False",
            "    def get(self, key):",
            "        v = self.root",
            "        while v is not None:",
            "            if key < v.key:",
            "                v = v.lst",
            "            elif v.key < key:",
            "                v = v.rst",
            "            else:",
            "                return v.val",
            "        return None",
            "    def lower_bound(self, key):",
            "        ret = (float('inf'), 0)",
            "        v = self.root",
            "        while v is not None:",
            "            if v.key >= key:",
            "                if ret > v.key:",
            "                    ret = v.key",
            "                v = v.lst",
            "            else:",
            "                v = v.rst",
            "        return ret",
            "    def upper_bound(self, key):",
            "        ret = -float('inf')",
            "        v = self.root",
            "        while v is not None:",
            "            if v.key <= key:",
            "                if ret < v.key:",
            "                    ret = v.key",
            "                v = v.rst",
            "            else:",
            "                v = v.lst",
            "        return ret",
            "    def __contains__(self, key): return self.member(key)",
            "    def __getitem__(self, key): return self.get(key)",
            "    def __setitem__(self, key, val): return self.insert(key, val)",
            "    def __delitem__(self, key): return self.delete(key)",
            "    def __bool__(self): return self.root is not None",
            "    def __str__(self):",
            "        return self.tostr_rec(\"\", \"\", self.root)",
            "    def tostr_rec(self, head, bar, t):",
            "        graph = \"\"",
            "        if t != None:",
            "            graph += self.tostr_rec(head + \"    \", \"／\", t.rst)",
            "            node = str(t.key) + \":\" + str(t.bias)",
            "            graph += head + bar + node + \"\\n\"",
            "            graph += self.tostr_rec(head + \"    \", \"＼\", t.lst)",
            "        return graph",
            "read = sys.stdin.buffer.read",
            "readlines = sys.stdin.buffer.readlines",
            "input = sys.stdin.buffer.readline",
            "N, Q = map(int, input().split())",
            "S = []",
            "T = []",
            "for i in range(N):",
            "    s, t, x = map(int, input().split())",
            "    S.append((s-x, s, x))",
            "    T.append((t-x, s, x))",
            "S.sort(reverse=True)",
            "T.sort(reverse=True)",
            "INF = 10**10",
            "avl = AVLTree()",
            "ans = []",
            "for d in map(int, read().split()):",
            "    while S and S[-1][0] <= d:",
            "        sx, s, x = S.pop()",
            "        avl[(x, sx+x)] = x",
            "    while T and T[-1][0] <= d:",
            "        tx, s, x = T.pop()",
            "        del avl[(x, s)]",
            "    x, s = avl.lower_bound((-INF, 0))",
            "    ans.append(x if x < INF else -1)",
            "print('\\n'.join(map(str, ans)))"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            2,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "import sys",
            "input = sys.stdin.readline",
            "def I(): return int(input())",
            "def MI(): return map(int, input().split())",
            "def LI(): return list(map(int, input().split()))",
            "def main():",
            "    \"\"\"",
            "    とりあえず，S,TはXだけ左にずらして，0秒の時にどの時間ならXで止まるかにする．",
            "    そのあと，グラフ(x-tグラフ)を書いて，縦棒を左から動かしていく（イベントソート）",
            "    通行止めとなるXを複数持っておく必要があり，追加，参照，削除の機能が欲しい",
            "    \"\"\"",
            "    ##############################",
            "    from bisect import bisect_left, bisect_right, insort_right",
            "    class SquareSkipList:",
            "        # SkipList の層数を 2 にした感じの何か",
            "        # std::multiset の代用になる",
            "        def __init__(self, values=None, sorted_=False, square=1000, seed=42):",
            "            # values: 初期値のリスト",
            "            # sorted_: 初期値がソート済みであるか",
            "            # square: 最大データ数の平方根",
            "            # seed: 乱数のシード",
            "            ### pop関数は　for を回すので重め、使うなら square パラメータを大きめにするべき",
            "            self.cnt=0#要素数を持っておくか",
            "            inf = float(\"inf\")",
            "            self.square = square",
            "            if values is None:",
            "                self.rand_y = seed",
            "                self.layer1 = [inf]",
            "                self.layer0 = [[]]",
            "            else:",
            "                self.layer1 = layer1 = []",
            "                self.layer0 = layer0 = []",
            "                if not sorted_:",
            "                    values.sort()",
            "                y = seed",
            "                l0 = []",
            "                for v in values:",
            "                    y ^= (y & 0x7ffff) << 13",
            "                    y ^= y >> 17",
            "                    y ^= (y & 0x7ffffff) << 5",
            "                    if y % square == 0:",
            "                        layer0.append(l0)",
            "                        l0 = []",
            "                        layer1.append(v)",
            "                    else:",
            "                        l0.append(v)",
            "                layer1.append(inf)",
            "                layer0.append(l0)",
            "                self.rand_y = y",
            "        def add(self, x):  # 要素の追加  # O(sqrt(n))",
            "            # xorshift",
            "            y = self.rand_y",
            "            y ^= (y & 0x7ffff) << 13",
            "            y ^= y >> 17",
            "            y ^= (y & 0x7ffffff) << 5",
            "            self.rand_y = y",
            "            if y % self.square == 0:",
            "                layer1, layer0 = self.layer1, self.layer0",
            "                idx1 = bisect_right(layer1, x)",
            "                layer1.insert(idx1, x)",
            "                layer0_idx1 = layer0[idx1]",
            "                idx0 = bisect_right(layer0_idx1, x)",
            "                layer0.insert(idx1+1, layer0_idx1[idx0:])  # layer0 は dict で管理した方が良いかもしれない  # dict 微妙だった",
            "                del layer0_idx1[idx0:]",
            "            else:",
            "                idx1 = bisect_right(self.layer1, x)",
            "                insort_right(self.layer0[idx1], x)",
            "            self.cnt+=1#追加",
            "        def remove(self, x):  # 要素の削除  # O(sqrt(n))",
            "            # x が存在しない場合、x 以上の最小の要素が削除される",
            "            idx1 = bisect_left(self.layer1, x)",
            "            layer0_idx1 = self.layer0[idx1]",
            "            idx0 = bisect_left(layer0_idx1, x)",
            "            if idx0 == len(layer0_idx1):",
            "                del self.layer1[idx1]",
            "                self.layer0[idx1] += self.layer0.pop(idx1+1)",
            "            else:",
            "                del layer0_idx1[idx0]",
            "            self.cnt-=1",
            "        def search_higher_equal(self, x):  # x 以上の最小の値を返す  O(log(n))",
            "            idx1 = bisect_left(self.layer1, x)",
            "            layer0_idx1 = self.layer0[idx1]",
            "            idx0 = bisect_left(layer0_idx1, x)",
            "            if idx0 == len(layer0_idx1):",
            "                return self.layer1[idx1]",
            "            return layer0_idx1[idx0]",
            "        def search_higher(self, x):  # x を超える最小の値を返す  O(log(n))",
            "            idx1 = bisect_right(self.layer1, x)",
            "            layer0_idx1 = self.layer0[idx1]",
            "            idx0 = bisect_right(layer0_idx1, x)",
            "            if idx0 == len(layer0_idx1):",
            "                return self.layer1[idx1]",
            "            return layer0_idx1[idx0]",
            "        def search_lower(self, x):  # x 未満の最大の値を返す  O(log(n))",
            "            #x未満のものがない場合，infが返るかも！！！",
            "            idx1 = bisect_left(self.layer1, x)",
            "            layer0_idx1 = self.layer0[idx1]",
            "            idx0 = bisect_left(layer0_idx1, x)",
            "            if idx0 == 0:  # layer0_idx1 が空の場合とすべて x 以上の場合",
            "                return self.layer1[idx1-1]",
            "            return layer0_idx1[idx0-1]",
            "        def pop(self, idx):",
            "            # 小さい方から idx 番目の要素を削除してその要素を返す（0-indexed）",
            "            # O(sqrt(n))",
            "            # for を回すので重め、使うなら square パラメータを大きめにするべき",
            "            self.cnt-=1",
            "            layer0 = self.layer0",
            "            s = -1",
            "            for i, l0 in enumerate(layer0):",
            "                s += len(l0) + 1",
            "                if s >= idx:",
            "                    break",
            "            if s==idx:",
            "                layer0[i] += layer0.pop(i+1)",
            "                return self.layer1.pop(i)",
            "            else:",
            "                return layer0[i].pop(idx-s)",
            "        def all(self):",
            "            print(self.layer1)",
            "            print(self.layer0)",
            "        def len(self):",
            "            return self.cnt",
            "    ##############################",
            "    N,Q=MI()",
            "    L=[]#0なら追加，1なら削除，2ならクエリ，半開区間なので順番大事",
            "    for _ in range(N):",
            "        s,t,x=MI()",
            "        s-=x",
            "        t-=x",
            "        L.append([s,0,x])",
            "        L.append([t,1,x])",
            "    #制約よりDは昇順",
            "    for _ in range(Q):",
            "        d=I()",
            "        L.append([d,2,0])#3つに揃えておくか",
            "    L.sort()",
            "    anss=[]",
            "    inf=10**10",
            "    ssl = SquareSkipList(square=2000)",
            "    ssl.add(inf)",
            "    for t,q,x in L:",
            "        if q==0:",
            "            ssl.add(x)",
            "        elif q==2:",
            "            temp=ssl.search_higher_equal(-1)#最小値検索",
            "            if temp==inf:",
            "                ans=-1",
            "            else:",
            "                ans=temp",
            "            anss.append(ans)",
            "        else:",
            "            ssl.remove(x)",
            "    for i in range(Q):",
            "        print(anss[i])",
            "main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            1,
            0,
            1,
            0,
            1,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "# using main() makes code faster from the point of view of \"access to variables in global name-space\"",
            "# def main():",
            "\"\"\" convenient functions",
            "# for i, a in enumerate(iterable)",
            "# q, mod = divmod(a, b)",
            "# divmod(x, y) returns the tuple (x//y, x%y)",
            "# manage median(s) using two heapq https://atcoder.jp/contests/abc127/tasks/abc127_f",
            "\"\"\"",
            "import sys",
            "sys.setrecursionlimit(10**7)",
            "from itertools import accumulate, combinations, permutations, product # https://docs.python.org/ja/3/library/itertools.html",
            "# accumulate() returns iterator! to get list: list(accumulate())",
            "from math import factorial, ceil, floor",
            "def factorize(n):",
            "    \"\"\"return the factors of the Arg and count of each factor",
            "    Args:",
            "        n (long): number to be resolved into factors",
            "    Returns:",
            "        list of tuples: factorize(220) returns [(2, 2), (5, 1), (11, 1)]",
            "    \"\"\"",
            "    fct = []  # prime factor",
            "    b, e = 2, 0  # base, exponent",
            "    while b * b <= n:",
            "        while n % b == 0:",
            "            n = n // b",
            "            e = e + 1",
            "        if e > 0:",
            "            fct.append((b, e))",
            "        b, e = b + 1, 0",
            "    if n > 1:",
            "        fct.append((n, 1))",
            "    return fct",
            "def combinations_count(n, r):",
            "    \"\"\"Return the number of selecting r pieces of items from n kinds of items.",
            "    Args:",
            "        n (long): number",
            "        r (long): number",
            "    Raises:",
            "        Exception: not defined when n or r is negative",
            "    Returns:",
            "        long: number",
            "    \"\"\"",
            "    # TODO: How should I do when n - r is negative?",
            "    if n < 0 or r < 0:",
            "        raise Exception('combinations_count(n, r) not defined when n or r is negative')",
            "    if n - r < r: r = n - r",
            "    if r < 0: return 0",
            "    if r == 0: return 1",
            "    if r == 1: return n",
            "    numerator = [n - r + k + 1 for k in range(r)]",
            "    denominator = [k + 1 for k in range(r)]",
            "    for p in range(2,r+1):",
            "        pivot = denominator[p - 1]",
            "        if pivot > 1:",
            "            offset = (n - r) % p",
            "            for k in range(p-1,r,p):",
            "                numerator[k - offset] /= pivot",
            "                denominator[k] /= pivot",
            "    result = 1",
            "    for k in range(r):",
            "        if numerator[k] > 1:",
            "            result *= int(numerator[k])",
            "    return result",
            "def combinations_with_replacement_count(n, r):",
            "    \"\"\"Return the number of selecting r pieces of items from n kinds of items allowing individual elements to be repeated more than once.",
            "    Args:",
            "        n (long): number",
            "        r (long): number",
            "    Raises:",
            "        Exception: not defined when n or r is negative",
            "    Returns:",
            "        long: number",
            "    \"\"\"",
            "    if n < 0 or r < 0:",
            "        raise Exception('combinations_with_replacement_count(n, r) not defined when n or r is negative')",
            "    elif n == 0:",
            "        return 1",
            "    else:",
            "        return combinations_count(n + r - 1, r)",
            "from bisect import bisect_left, bisect_right",
            "from collections import deque, Counter, defaultdict # https://docs.python.org/ja/3/library/collections.html#collections.deque",
            "from heapq import heapify, heappop, heappush, heappushpop, heapreplace,nlargest,nsmallest # https://docs.python.org/ja/3/library/heapq.html",
            "from copy import deepcopy, copy # https://docs.python.org/ja/3/library/copy.html",
            "from operator import itemgetter",
            "# ex1: List.sort(key=itemgetter(1))",
            "# ex2: sorted(tuples, key=itemgetter(1,2))",
            "from functools import reduce",
            "def chmin(x, y):",
            "    \"\"\"change minimum",
            "    if x > y, x = y and return (x, True).",
            "    convenient when solving problems of dp[i]",
            "    Args:",
            "        x (long): current minimum value",
            "        y (long): potential minimum value",
            "    Returns:",
            "        (x, bool): (x, True) when updated, else (x, False)",
            "    \"\"\"",
            "    if x > y:",
            "        x = y",
            "        return (x, True)",
            "    else:",
            "        return (x, False)",
            "def chmax(x, y):",
            "    \"\"\"change maximum",
            "    if x < y, x = y and return (x, True).",
            "    convenient when solving problems of dp[i]",
            "    Args:",
            "        x (long): current maximum value",
            "        y (long): potential maximum value",
            "    Returns:",
            "        (x, bool): (x, True) when updated, else (x, False)",
            "    \"\"\"",
            "    if x < y:",
            "        x = y",
            "        return (x, True)",
            "    else:",
            "        return (x, False)",
            "from fractions import gcd # Deprecated since version 3.5: Use math.gcd() instead.",
            "def gcds(numbers):",
            "    return reduce(gcd, numbers)",
            "def lcm(x, y):",
            "    return (x * y) // gcd(x, y)",
            "def lcms(numbers):",
            "    return reduce(lcm, numbers, 1)",
            "# first create factorial_list",
            "# fac_list = mod_factorial_list(n)",
            "INF = 10 ** 18",
            "MOD = 10 ** 9 + 7",
            "modpow = lambda a, n, p = MOD: pow(a, n, p) # Recursive function in python is slow!",
            "def modinv(a, p = MOD):",
            "    # evaluate reciprocal using Fermat's little theorem:",
            "    # a**(p-1) is identical to 1 (mod p) when a and p is coprime",
            "    return modpow(a, p-2, p)",
            "def modinv_list(n, p = MOD):",
            "    if n <= 1:",
            "        return [0,1][:n+1]",
            "    else:",
            "        inv_t = [0,1]",
            "        for i in range(2, n+1):",
            "            inv_t += [inv_t[p % i] * (p - int(p / i)) % p]",
            "        return inv_t",
            "def modfactorial_list(n, p = MOD):",
            "    if n == 0:",
            "        return [1]",
            "    else:",
            "        l = [0] * (n+1)",
            "        tmp = 1",
            "        for i in range(1, n+1):",
            "            tmp = tmp * i % p",
            "            l[i] = tmp",
            "        return l",
            "def modcomb(n, k, fac_list = [], p = MOD):",
            "    # fac_list = modfactorial_list(100)",
            "    # print(modcomb(100, 5, modfactorial_list(100)))",
            "    from math import factorial",
            "    if n < 0 or k < 0 or n < k: return 0",
            "    if n == 0 or k == 0: return 1",
            "    if len(fac_list) <= n:",
            "        a = factorial(n) % p",
            "        b = factorial(k) % p",
            "        c = factorial(n-k) % p",
            "    else:",
            "        a = fac_list[n]",
            "        b = fac_list[k]",
            "        c = fac_list[n-k]",
            "    return (a * modpow(b, p-2, p) * modpow(c, p-2, p)) % p",
            "def modadd(a, b, p = MOD):",
            "    return (a + b) % MOD",
            "def modsub(a, b, p = MOD):",
            "    return (a - b) % p",
            "def modmul(a, b, p = MOD):",
            "    return ((a % p) * (b % p)) % p",
            "def moddiv(a, b, p = MOD):",
            "    return modmul(a, modpow(b, p-2, p))",
            "\"\"\" initialize variables and set inputs",
            "# initialize variables",
            "    # to initialize list, use [0] * n",
            "    # to initialize two dimentional array, use [[0] * N for _ in range(N)]",
            "# set inputs",
            "    # open(0).read() is a convenient method:",
            "    # ex) n, m, *x = map(int, open(0).read().split())",
            "    #     min(x[::2]) - max(x[1::2])",
            "    # ex2) *x, = map(int, open(0).read().split())",
            "    #     don't forget to add comma after *x if only one variable is used",
            "# preprocessing",
            "    # transpose = [x for x in zip(*data)]",
            "    # ex) [[1, 2, 3], [4, 5, 6], [7, 8, 9]] => [(1, 4, 7), (2, 5, 8), (3, 6, 9)]",
            "    # flat = [flatten for inner in data for flatten in inner]",
            "    # ex) [[1, 2, 3], [4, 5, 6], [7, 8, 9]] => [1, 2, 3, 4, 5, 6, 7, 8, 9]",
            "# calculate and output",
            "    # output pattern",
            "    # ex1) print(*l) => when l = [2, 5, 6], printed 2 5 6",
            "\"\"\"",
            "# functions used",
            "r = lambda: sys.stdin.readline().strip()",
            "r_int = lambda: int(r())",
            "R = lambda: list(map(int, r().split()))",
            "Rfloat = lambda: list(map(float, r().split()))",
            "Rtuple = lambda: tuple(map(int, r().split()))",
            "Rmap = lambda: map(int, r().split())",
            "\"\"\" how to treat input",
            "# single int: int(r())",
            "# single string: r()",
            "# single float: float(r())",
            "# line int: R()",
            "# line string: r().split()",
            "# line (str, int, int): [j if i == 0 else int(j) for i, j in enumerate(r().split())]",
            "# lines int: [R() for _ in range(n)]",
            "\"\"\"",
            "# main",
            "N, Q = R()",
            "STX = [R() for _ in range(N)]",
            "STX.sort(key=itemgetter(2))",
            "D = [int(r()) for _ in range(Q)]",
            "Stopped = [-1] * Q",
            "ans = [-1] * Q",
            "for s, t, x in STX:",
            "    l = bisect_left(D, s-x)",
            "    r = bisect_left(D,t-x)",
            "    a = l",
            "    while a < r:",
            "        if Stopped[a] == -1:",
            "            ans[a] = x",
            "            Stopped[a] = r",
            "            a += 1",
            "        else:",
            "            a = Stopped[a]",
            "for i in ans:",
            "    print(i)",
            "\"\"\"memo: how to use defaultdict of list",
            "# initialize",
            "Dic = defaultdict(list)",
            "# append / extend",
            "Dic[x].append(y)",
            "# for",
            "for k, v in Dic.items():",
            "\"\"\"",
            "# if __name__ == '__main__':",
            "#     main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            2,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            1,
            1,
            1,
            1,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "import sys",
            "INF = 1 << 30",
            "class Node:",
            "    def __init__(self, key, val):",
            "        self.key = key",
            "        self.val = val",
            "        self.lst = None",
            "        self.rst = None",
            "        self.bias = 0",
            "class AVLTree:",
            "    def __init__(self):",
            "        self.root = None",
            "    def rotate_left(self, v):",
            "        u = v.rst",
            "        v.rst = u.lst",
            "        u.lst = v",
            "        if u.bias == -1:",
            "            u.bias = v.bias = 0",
            "        else:",
            "            u.bias = 1",
            "            v.bias = -1",
            "        return u",
            "    def rotate_right(self, v):",
            "        u = v.lst",
            "        v.lst = u.rst",
            "        u.rst = v",
            "        if u.bias == 1:",
            "            u.bias = v.bias = 0",
            "        else:",
            "            u.bias = -1",
            "            v.bias = 1",
            "        return u",
            "    def rotateLR(self, v):",
            "        u = v.lst",
            "        t = u.rst",
            "        u.rst = t.lst",
            "        t.lst = u",
            "        v.lst = t.rst",
            "        t.rst = v",
            "        self.update_bias_double(t)",
            "        return t",
            "    def rotateRL(self, v):",
            "        u = v.rst",
            "        t = u.lst",
            "        u.lst = t.rst",
            "        t.rst = u",
            "        v.rst = t.lst",
            "        t.lst = v",
            "        self.update_bias_double(t)",
            "        return t",
            "    def update_bias_double(self, v):",
            "        if v.bias == 1:",
            "            v.rst.bias = -1",
            "            v.lst.bias = 0",
            "        elif v.bias == -1:",
            "            v.rst.bias = 0",
            "            v.lst.bias = 1",
            "        else:",
            "            v.rst.bias = 0",
            "            v.lst.bias = 0",
            "        v.bias = 0",
            "    def insert(self, key, val):",
            "        if self.root is None:",
            "            self.root = Node(key, val)",
            "            return",
            "        v = self.root",
            "        history = []",
            "        while v is not None:",
            "            if key < v.key:",
            "                history.append((v, 1))",
            "                v = v.lst",
            "            elif v.key < key:",
            "                history.append((v, -1))",
            "                v = v.rst",
            "            elif v.key == key:",
            "                v.val = val",
            "                return",
            "        p, pdir = history[-1]",
            "        if pdir == 1:",
            "            p.lst = Node(key, val)",
            "        else:",
            "            p.rst = Node(key, val)",
            "        while history:",
            "            v, direction = history.pop()",
            "            v.bias += direction",
            "            new_v = None",
            "            b = v.bias",
            "            if b == 0:",
            "                break",
            "            if b == 2:",
            "                u = v.lst",
            "                if u.bias == -1:",
            "                    new_v = self.rotateLR(v)",
            "                else:",
            "                    new_v = self.rotate_right(v)",
            "                break",
            "            if b == -2:",
            "                u = v.rst",
            "                if u.bias == 1:",
            "                    new_v = self.rotateRL(v)",
            "                else:",
            "                    new_v = self.rotate_left(v)",
            "                break",
            "        if new_v is not None:",
            "            if len(history) == 0:",
            "                self.root = new_v",
            "                return",
            "            p, pdir = history.pop()",
            "            if pdir == 1:",
            "                p.lst = new_v",
            "            else:",
            "                p.rst = new_v",
            "    def delete(self, key):",
            "        v = self.root",
            "        history = []",
            "        while v is not None:",
            "            if key < v.key:",
            "                history.append((v, 1))",
            "                v = v.lst",
            "            elif v.key < key:",
            "                history.append((v, -1))",
            "                v = v.rst",
            "            else:",
            "                break",
            "        else:",
            "            return False",
            "        if v.lst is not None:",
            "            history.append((v, 1))",
            "            lmax = v.lst",
            "            while lmax.rst is not None:",
            "                history.append((lmax, -1))",
            "                lmax = lmax.rst",
            "            v.key = lmax.key",
            "            v.val = lmax.val",
            "            v = lmax",
            "        c = v.rst if v.lst is None else v.lst",
            "        if history:",
            "            p, pdir = history[-1]",
            "            if pdir == 1:",
            "                p.lst = c",
            "            else:",
            "                p.rst = c",
            "        else:",
            "            self.root = c",
            "            return True",
            "        while history:",
            "            new_p = None",
            "            p, pdir = history.pop()",
            "            p.bias -= pdir",
            "            b = p.bias",
            "            if b == 2:",
            "                if p.lst.bias == -1:",
            "                    new_p = self.rotateLR(p)",
            "                else:",
            "                    new_p = self.rotate_right(p)",
            "            elif b == -2:",
            "                if p.rst.bias == 1:",
            "                    new_p = self.rotateRL(p)",
            "                else:",
            "                    new_p = self.rotate_left(p)",
            "            elif b != 0:",
            "                break",
            "            if new_p is not None:",
            "                if len(history) == 0:",
            "                    self.root = new_p",
            "                    return True",
            "                gp, gpdir = history[-1]",
            "                if gpdir == 1:",
            "                    gp.lst = new_p",
            "                else:",
            "                    gp.rst = new_p",
            "                if new_p.bias != 0:",
            "                    break",
            "        return True",
            "    def get(self, key):",
            "        v = self.root",
            "        while v is not None:",
            "            if key < v.key:",
            "                v = v.lst",
            "            elif v.key < key:",
            "                v = v.rst",
            "            else:",
            "                return v.val",
            "        return None",
            "    def lower_bound(self, key):",
            "        ret = float('inf')",
            "        v = self.root",
            "        while v is not None:",
            "            if v.key >= key:",
            "                if ret > v.key:",
            "                    ret = v.key",
            "                v = v.lst",
            "            else:",
            "                v = v.rst",
            "        return ret",
            "    def __contains__(self, key): return self.member(key)",
            "    def __getitem__(self, key): return self.get(key)",
            "    def __setitem__(self, key, val): return self.insert(key, val)",
            "    def __delitem__(self, key): return self.delete(key)",
            "    def __bool__(self): return self.root is not None",
            "read = sys.stdin.buffer.read",
            "input = sys.stdin.buffer.readline",
            "N, Q = map(int, input().split())",
            "event = []",
            "for i in range(N):",
            "    s, t, x = map(int, input().split())",
            "    event.append((s-x, 1, x))",
            "    event.append((t-x, -1, x))",
            "event.sort(reverse=True)",
            "avl = AVLTree()",
            "ans = []",
            "for d in map(int, read().split()):",
            "    while event and event[-1][0] <= d:",
            "        time, k, x = event.pop()",
            "        if k == 1:",
            "            avl.insert(x, 1)",
            "        else:",
            "            avl.delete(x)",
            "    x = avl.lower_bound(-INF)",
            "    ans.append(x if x < INF else -1)",
            "print('\\n'.join(map(str, ans)))"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            2,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "#!usr/bin/env python3",
            "from collections import defaultdict",
            "from collections import deque",
            "from heapq import heappush, heappop",
            "import sys",
            "import math",
            "import bisect",
            "import random",
            "import itertools",
            "sys.setrecursionlimit(10**5)",
            "stdin = sys.stdin",
            "bisect_left = bisect.bisect_left",
            "bisect_right = bisect.bisect_right",
            "def LI(): return list(map(int, stdin.readline().split()))",
            "def LF(): return list(map(float, stdin.readline().split()))",
            "def LI_(): return list(map(lambda x: int(x)-1, stdin.readline().split()))",
            "def II(): return int(stdin.readline())",
            "def IF(): return float(stdin.readline())",
            "def LS(): return list(map(list, stdin.readline().split()))",
            "def S(): return list(stdin.readline().rstrip())",
            "def IR(n): return [II() for _ in range(n)]",
            "def LIR(n): return [LI() for _ in range(n)]",
            "def FR(n): return [IF() for _ in range(n)]",
            "def LFR(n): return [LI() for _ in range(n)]",
            "def LIR_(n): return [LI_() for _ in range(n)]",
            "def SR(n): return [S() for _ in range(n)]",
            "def LSR(n): return [LS() for _ in range(n)]",
            "mod = 1000000007",
            "inf = float('INF')",
            "#A",
            "def A():",
            "    a, p = LI()",
            "    print((a*3+p)//2)",
            "    return",
            "#B",
            "def B():",
            "    n = II()",
            "    sp = []",
            "    for i in range(n):",
            "        sp.append(input().split())",
            "    another = [(s[0], -1 * int(s[1]),num) for num,s in enumerate(sp)]",
            "    another.sort()",
            "    for s,p,q in another:",
            "        print(q+1)",
            "    return",
            "#C",
            "def C():",
            "    n, m = LI()",
            "    ks = LIR_(m)",
            "    p = LI()",
            "    patern = itertools.product(range(2), repeat=n)",
            "    ans = 0",
            "    for on in patern:",
            "        ki = [0 for i in range(m)]",
            "        for num, oni in enumerate(on):",
            "            if oni:",
            "                for i,ksi in enumerate(ks):",
            "                    ksi = ksi[1::]",
            "                    if num in ksi:",
            "                        ki[i] ^= 1",
            "        for num, pi in enumerate(p):",
            "            if pi != ki[num]:",
            "                break",
            "        else:",
            "            ans += 1",
            "    print(ans)",
            "    return",
            "#D",
            "def D():",
            "    N, K = LI()#random.randint(1,50),random.randint(1,100)",
            "    v = LI()#[random.randint(-10 ** 2, 10 ** 2) for i in range(N)]",
            "    ans = 0",
            "    for a in range(min(N, K) + 1):",
            "        for b in range(min(N, K) + 1):",
            "            if a + b > min(K,N):",
            "                break",
            "            if a == b == 0:",
            "                continue",
            "            deletes = K - a - b",
            "            left = v[:a]",
            "            right = v[:-b-1:-1]",
            "            x = left + right",
            "            x.sort()",
            "            tmp = sum(x)",
            "            for delete in range(min(deletes, len(x))):",
            "                if x[delete] >= 0:",
            "                    break",
            "                tmp -= x[delete]",
            "            ans = max(ans,tmp)",
            "    print(ans)",
            "    return",
            "#E",
            "def E():",
            "    N,q = LI()",
            "    STX = LIR(N)",
            "    D = IR(q)",
            "    LV = (q - 1).bit_length()",
            "    N0 = 1 << LV",
            "    data = [inf] * (N0 << 1)",
            "    INF = inf",
            "    def update(l, r, x):",
            "        #  区間[l, r)のdataの値を更新",
            "        L = N0 + l; R = N0 + r",
            "        while L < R:",
            "            if R & 1:",
            "                R -= 1",
            "                data[R-1] = min(data[R-1], x)",
            "            if L & 1:",
            "                data[L-1] = min(data[L-1], x)",
            "                L += 1",
            "            L >>= 1; R >>= 1",
            "    def query(x):",
            "        L = N0 + x - 1",
            "        #  xの最小値を求める",
            "        s = INF",
            "        while L >= 0:",
            "            s = min(s, data[L])",
            "            L = (L - 1) >> 1",
            "        return s",
            "    for s, t, x in STX:",
            "        XS = max(-1, s - x)",
            "        XT = max(-1, t - x)",
            "        XS_index = bisect_left(D, XS)",
            "        XT_index = bisect_left(D, XT)",
            "        update(XS_index, XT_index, x)",
            "    for i in range(q):",
            "        a = query(i)",
            "        print(a if a != inf else -1)",
            "#F",
            "def F():",
            "    return",
            "#Solve",
            "if __name__ == '__main__':",
            "    E()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            2,
            2,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# Solution using a lazy segment tree",
            "from bisect import bisect_left",
            "import sys",
            "sys.setrecursionlimit(10 ** 7)",
            "input = sys.stdin.readline",
            "class SegmentTree:  # 0-indexed",
            "    def __init__(self, array, operation=min, identity=10**30):",
            "        self.identity = identity",
            "        self.n = len(array)",
            "        self.N = 1 << (self.n - 1).bit_length()",
            "        self.tree = [self.identity] * 2 * self.N",
            "        self.lazy = [None] * 2 * self.N",
            "        self.opr = operation",
            "        for i in range(self.n):",
            "            self.tree[i+self.N-1] = array[i]",
            "        for i in range(self.N-2, -1, -1):",
            "            self.tree[i] = self.opr(self.tree[2*i+1], self.tree[2*i+2])",
            "    def values(self):",
            "        for i in range(self.n-1):",
            "            self.query(i, i+1)",
            "        return self.tree[self.N-1:self.n+self.N-1]",
            "    def getindex(self, l, r):",
            "        l = (l + self.N)",
            "        r = (r + self.N)",
            "        lm = l // (l & -l) >> 1",
            "        rm = r // (r & -r) >> 1",
            "        while r-l > 0:",
            "            if r <= rm:",
            "                yield r",
            "            if l <= lm:",
            "                yield l",
            "            l = l >> 1",
            "            r = r >> 1",
            "        while l:",
            "            yield l",
            "            l = l >> 1",
            "    def propagates(self, *indices):",
            "        for i in reversed(indices):",
            "            i -= 1",
            "            v = self.lazy[i]",
            "            if v is None:",
            "                continue",
            "            self.lazy[2*i+1] = self.tree[2*i+1] = v >> 1",
            "            self.lazy[2*i+2] = self.tree[2*i+2] = v >> 1",
            "            self.lazy[i] = None",
            "    def update(self, p, q, x):",
            "        if p == q:",
            "            return None",
            "        indices = tuple(self.getindex(p, q))",
            "        self.propagates(*indices)",
            "        p += self.N-1",
            "        q += self.N-2",
            "        while q-p > 0:",
            "            if p % 2 == 0:",
            "                self.lazy[p] = self.tree[p] = x",
            "            if q % 2 == 1:",
            "                self.lazy[q] = self.tree[q] = x",
            "            p = p//2",
            "            q = q//2 - 1",
            "            x <<= 1",
            "        if p == q:",
            "            self.lazy[p] = self.tree[p] = x",
            "        for i in indices:",
            "            i -= 1",
            "            self.tree[i] = self.opr(self.tree[2*i+1], self.tree[2*i+2])",
            "    def query(self, p, q):  # [p,q)",
            "        if q <= p:",
            "            print(\"Oops!  That was no valid number.  Try again...\")",
            "            exit()",
            "        self.propagates(*self.getindex(p, q))",
            "        p += self.N-1",
            "        q += self.N-2",
            "        res = self.identity",
            "        while q-p > 0:",
            "            if p % 2 == 0:",
            "                res = self.opr(res, self.tree[p])",
            "            if q % 2 == 1:",
            "                res = self.opr(res, self.tree[q])",
            "            p = p//2",
            "            q = q//2 - 1",
            "        if p == q:",
            "            res = self.opr(res, self.tree[p])",
            "        return res",
            "n, q = map(int, input().split())",
            "Works = []",
            "for _ in range(n):",
            "    s, t, x = map(int, input().split())",
            "    Works.append((s, t, x))",
            "Works = sorted(Works, key=lambda w: -w[2])",
            "People = []",
            "for _ in range(q):",
            "    People.append(int(input()))",
            "ST = SegmentTree([-1]*q)",
            "for s, t, x in Works:",
            "    left = bisect_left(People, s-x)",
            "    right = bisect_left(People, t-x)",
            "    ST.update(left, right, x)",
            "for x in ST.values():",
            "    print(x)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "sys.setrecursionlimit(10**7)",
            "def LI(): return [int(x) for x in sys.stdin.readline().split()]",
            "def LI_(): return [int(x) - 1 for x in sys.stdin.readline().split()]",
            "def LF(): return [float(x) for x in sys.stdin.readline().split()]",
            "def LS(): return sys.stdin.readline().split()",
            "def II(): return int(sys.stdin.readline())",
            "def SI(): return sys.stdin.readline().strip()",
            "MOD = 10 ** 9 + 7",
            "INF = 10 ** 18",
            "from collections.abc import Sequence, Set",
            "from bisect import bisect_left",
            "from itertools import chain",
            "from heapq import heappush, heappop",
            "class HeapSet():",
            "    # 最小値を O(log n) で取り出せる set. 中身としては、入っているものを set で管理し、順番を heapq で管理しているだけ。",
            "    def __init__(self):",
            "        self._set = set()",
            "        self._list = list()",
            "    def add(self, a):",
            "        if a in self._set:",
            "            return",
            "        else:",
            "            self._set.add(a)",
            "            heappush(self._list, a)",
            "    def remove(self, a):",
            "        if a not in self._set:",
            "            raise ValueError",
            "        else:",
            "            self._set.remove(a)",
            "    def pop(self):",
            "        if not self._set:",
            "            self._list = list()",
            "            raise IndexError",
            "        while True:",
            "            a = self._list[0]",
            "            if a not in self._set:",
            "                heappop(self._list)",
            "                continue",
            "            else:",
            "                break",
            "        self._set.remove(a)",
            "        return a",
            "    def peek(self):",
            "        if not self._set:",
            "            self._list = list()",
            "            raise IndexError",
            "        while True:",
            "            a = self._list[0]",
            "            if a not in self._set:",
            "                heappop(self._list)",
            "                continue",
            "            else:",
            "                break",
            "        return a",
            "    def get_set(self): return self._set",
            "    def get_heapq(self): return self._list",
            "    def get_list(self): return self._list",
            "    def __bool__(self): return True if self._set else False",
            "    def __contains__(self, a): return a in self._set",
            "    def __len__(self): return len(self._set)",
            "    def __repr__(self):",
            "        return \"HeapSet(\" + (repr(self._set) if self._set else '') + \")\"",
            "def main():",
            "    N, Q = LI()",
            "    events = []",
            "    for _ in range(N):",
            "        stx = LI()",
            "        # events.append((s - x, x, True))  # S-X, X, add_flag",
            "        # events.append((t - x, x, False))  # T-X, X, add_flag",
            "        events.append((stx[0] - stx[2], stx[2], True))  # S-X, X, add_flag",
            "        events.append((stx[1] - stx[2], stx[2], False))  # T-X, X, add_flag",
            "    for _ in range(Q):",
            "        events.append((II(), INF, -1))",
            "    # events.sort(key=lambda x:x[0])  # O(N log N), stable",
            "    events.sort()  # O(N log N), stable, False (==0) < True (==1)",
            "    from array import array",
            "    ans = array('i')",
            "    # m = SortedList()",
            "    m = HeapSet()",
            "    # for time, x, add_flag in events:",
            "    change_flag = True",
            "    min_ = INF",
            "    for txa in events:",
            "        if txa[2] == -1:",
            "            if not m:",
            "                ans.append(-1)",
            "                # ans += '-1\\n'",
            "            else:",
            "                if change_flag:",
            "                    min_ = m.peek()",
            "                    change_flag = False",
            "                ans.append(min_)",
            "                # ans += str(m[0])+'\\n'",
            "        elif txa[2]:",
            "            m.add(txa[1])",
            "            if txa[1] < min_:",
            "                min_ = txa[1]",
            "                change_flag = False",
            "        else:",
            "            m.remove(txa[1])",
            "            if txa[1] == min_ and m:",
            "                min_ = m.peek()",
            "                change_flag = False",
            "            elif not m:",
            "                min_ = INF",
            "                change_flag = False",
            "    # for i in ans: print(i)",
            "    # print('\\n'.join(map(str, ans)))",
            "    print('\\n'.join(map(str, ans.tolist())))",
            "main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            2,
            2
        ]
    },
    {
        "content": [
            "import sys",
            "sys.setrecursionlimit(10**7)",
            "def LI(): return [int(x) for x in sys.stdin.readline().split()]",
            "def LI_(): return [int(x) - 1 for x in sys.stdin.readline().split()]",
            "def LF(): return [float(x) for x in sys.stdin.readline().split()]",
            "def LS(): return sys.stdin.readline().split()",
            "def II(): return int(sys.stdin.readline())",
            "def SI(): return sys.stdin.readline().strip()",
            "MOD = 10 ** 9 + 7",
            "INF = 10 ** 18",
            "from collections.abc import Sequence, Set",
            "from bisect import bisect_left",
            "from itertools import chain",
            "from heapq import heappush, heappop",
            "class HeapSet():",
            "    # 最小値を O(log n) で取り出せる set. 中身としては、入っているものを set で管理し、順番を heapq で管理しているだけ。",
            "    def __init__(self):",
            "        self._set = set()",
            "        self._list = list()",
            "    def add(self, a):",
            "        if a in self._set:",
            "            return",
            "        else:",
            "            self._set.add(a)",
            "            heappush(self._list, a)",
            "    def remove(self, a):",
            "        if a not in self._set:",
            "            raise ValueError",
            "        else:",
            "            self._set.remove(a)",
            "    def peek(self):",
            "        if not self._set:",
            "            self._list = list()",
            "            raise IndexError",
            "        while True:",
            "            a = self._list[0]",
            "            if a not in self._set:",
            "                heappop(self._list)",
            "                continue",
            "            else:",
            "                break",
            "        return a",
            "    def pop(self):",
            "        a = self.peek()",
            "        self._set.remove(a)",
            "        heappop(self._list)",
            "        return a",
            "    def get_set(self): return self._set",
            "    def get_heapq(self): return self._list",
            "    def get_list(self): return self._list",
            "    def __bool__(self): return True if self._set else False",
            "    def __contains__(self, a): return a in self._set",
            "    def __len__(self): return len(self._set)",
            "    def __repr__(self): return \"HeapSet(\" + (repr(self._set) if self._set else '') + \")\"",
            "def main():",
            "    N, Q = LI()",
            "    events = []",
            "    for _ in range(N):",
            "        stx = LI()",
            "        # events.append((s - x, x, True))  # S-X, X, add_flag",
            "        # events.append((t - x, x, False))  # T-X, X, add_flag",
            "        events.append((stx[0] - stx[2], stx[2], True))  # S-X, X, add_flag",
            "        events.append((stx[1] - stx[2], stx[2], False))  # T-X, X, add_flag",
            "    for _ in range(Q):",
            "        events.append((II(), INF, -1))",
            "    # events.sort(key=lambda x:x[0])  # O(N log N), stable",
            "    events.sort()  # O(N log N), stable, False (==0) < True (==1)",
            "    from array import array",
            "    ans = array('i')",
            "    # m = SortedList()",
            "    m = HeapSet()",
            "    # for time, x, add_flag in events:",
            "    change_flag = True",
            "    min_ = INF",
            "    for txa in events:",
            "        if txa[2] == -1:",
            "            if not m:",
            "                ans.append(-1)",
            "                # ans += '-1\\n'",
            "            else:",
            "                if change_flag:",
            "                    min_ = m.peek()",
            "                    change_flag = False",
            "                ans.append(min_)",
            "                # ans += str(m[0])+'\\n'",
            "        elif txa[2]:",
            "            m.add(txa[1])",
            "            if txa[1] < min_:",
            "                min_ = txa[1]",
            "                change_flag = False",
            "        else:",
            "            m.remove(txa[1])",
            "            if txa[1] == min_ and m:",
            "                min_ = m.peek()",
            "                change_flag = False",
            "            elif not m:",
            "                min_ = INF",
            "                change_flag = False",
            "    # for i in ans: print(i)",
            "    # print('\\n'.join(map(str, ans)))",
            "    print('\\n'.join(map(str, ans.tolist())))",
            "main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "import math",
            "import numpy as np",
            "import decimal",
            "import collections",
            "import itertools",
            "import sys",
            "import random",
            "#Union-Find",
            "class UnionFind():",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.par = [-1 for i in range(self.n)]",
            "    def find(self, x):",
            "        if self.par[x] < 0:",
            "            return x",
            "        else:",
            "            self.par[x] = self.find(self.par[x])",
            "            return self.par[x]",
            "    def unite(self, x, y):",
            "        p = self.find(x)",
            "        q = self.find(y)",
            "        if p == q:",
            "            return None",
            "        if p > q:",
            "            p, q = q, p",
            "        self.par[p] += self.par[q]",
            "        self.par[q] = p",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "    def size(self, x):",
            "        return -self.par[self.find(x)]",
            "#素数関連",
            "def prime_numbers(x):",
            "    if x < 2:",
            "        return []",
            "    prime_numbers = [i for i in range(x)]",
            "    prime_numbers[1] = 0",
            "    for prime_number in prime_numbers:",
            "        if prime_number > math.sqrt(x):",
            "            break",
            "        if prime_number == 0:",
            "            continue",
            "        for composite_number in range(2 * prime_number, x, prime_number):",
            "            prime_numbers[composite_number] = 0",
            "    return [prime_number for prime_number in prime_numbers if prime_number != 0]",
            "def is_prime(x):",
            "    if x < 2:",
            "        return False",
            "    if x == 2 or x == 3 or x == 5:",
            "        return True",
            "    if x % 2 == 0 or x % 3 == 0 or x % 5 == 0:",
            "        return False",
            "    prime_number = 7",
            "    difference = 4",
            "    while prime_number <= math.sqrt(x):",
            "        if x % prime_number == 0:",
            "            return False",
            "        prime_number += difference",
            "        difference = 6 - difference",
            "    return True",
            "#Prime-Factorize",
            "def prime_factorize(n):",
            "    res = []",
            "    while n % 2 == 0:",
            "        res.append(2)",
            "        n //= 2",
            "    f = 3",
            "    while f ** 2 <= n:",
            "        if n % f == 0:",
            "            res.append(f)",
            "            n //= f",
            "        else:",
            "            f += 2",
            "    if n != 1:",
            "        res.append(n)",
            "    return res",
            "#nCr",
            "mod = 10 ** 9 + 7",
            "class nCr():",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.fa = [1] * (self.n + 1)",
            "        self.fi = [1] * (self.n + 1)",
            "        for i in range(1, self.n + 1):",
            "            self.fa[i] = self.fa[i - 1] * i % mod",
            "            self.fi[i] = pow(self.fa[i], mod - 2, mod)",
            "    def comb(self, n, r):",
            "        if n < r:return 0",
            "        if n < 0 or r < 0:return 0",
            "        return self.fa[n] * self.fi[r] % mod * self.fi[n - r] % mod",
            "#拡張Euclidの互除法",
            "def extgcd(a, b, d = 0):",
            "    g = a",
            "    if b == 0:",
            "        x, y = 1, 0",
            "    else:",
            "        x, y, g = extgcd(b, a % b)",
            "        x, y = y, x - a // b * y",
            "    return x, y, g",
            "#BIT",
            "class BinaryIndexedTree():",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.BIT = [0] * (self.n + 1)",
            "    def add(self, i, x):",
            "        while i <= self.n:",
            "            self.BIT[i] += x",
            "            i += i & -i",
            "    def query(self, i):",
            "        res = 0",
            "        while i > 0:",
            "            res += self.BIT[i]",
            "            i -= i & -i",
            "        return res",
            "#Associative Array",
            "class AssociativeArray():",
            "    def __init__(self, q):",
            "        self.dic = dict()",
            "        self.q = q",
            "    def solve(self):",
            "        for i in range(self.q):",
            "            Query = list(map(int, input().split()))",
            "            if Query[0] == 0:",
            "                x, y, z = Query",
            "                self.dic[y] = z",
            "            else:",
            "                x, y = Query",
            "                if y in self.dic:",
            "                    print(self.dic[y])",
            "                else:",
            "                    print(0)",
            "#Floor Sum",
            "def floor_sum(n, m, a, b):",
            "    res = 0",
            "    if a >= m:",
            "        res += (n - 1) * n * (a // m) // 2",
            "        a %= m",
            "    if b >= m:",
            "        res += n * (b // m)",
            "        b %= m",
            "    y_max = (a * n + b) // m",
            "    x_max = y_max * m - b",
            "    if y_max == 0:",
            "        return res",
            "    res += y_max * (n + (-x_max // a))",
            "    res += floor_sum(y_max, a, m, (a - x_max % a) % a)",
            "    return res",
            "#Z-Algorithm",
            "def z_algorithm(s):",
            "    str_len = len(s)",
            "    res = [0] * str_len",
            "    res[str_len - 1] = str_len",
            "    i, j = 1, 0",
            "    while i < str_len:",
            "        while i + j < str_len and s[i + j] == s[j]:",
            "            j += 1",
            "        res[i] = j",
            "        if j == 0:",
            "            i += 1",
            "            continue",
            "        k = 1",
            "        while i + k < str_len and j > res[k] + k:",
            "            res[i + k] = res[k]",
            "            k += 1",
            "        i += k",
            "        j -= k",
            "    return res",
            "class Manacher():",
            "    def __init__(self, s):",
            "        self.s = s",
            "    def coustruct(self):",
            "        i, j = 0, 0",
            "        s_len = len(self.s)",
            "        res = [0] * s_len",
            "        while i < s_len:",
            "            while i - j >= 0 and i + j < s_len and self.s[i - j] == self.s[i + j]:",
            "                j += 1",
            "            res[i] = j",
            "            k = 1",
            "            while i - k >= 0 and k + res[i - k] < j:",
            "                k += 1",
            "            i += k",
            "            j -= k",
            "#mod-sqrt",
            "def mod_sqrt(a, p):",
            "    if a == 0:",
            "        return 0",
            "    if p == 2:",
            "        return 1",
            "    k = (p - 1) // 2",
            "    if pow(a, k, p) != 1:",
            "        return -1",
            "    while True:",
            "        n = random.randint(2, p - 1)",
            "        r = (n ** 2 - a) % p",
            "        if r == 0:",
            "            return n",
            "        if pow(r, k, p) == p - 1:",
            "            break",
            "    k += 1",
            "    w, x, y, z = n, 1, 1, 0",
            "    while k:",
            "        if k % 2:",
            "            y, z = w * y + r * x * z, x * y + w * z",
            "        w, x = w * w + r * x * x, 2 * w * x",
            "        w %= p",
            "        x %= p",
            "        y %= p",
            "        z %= p",
            "        k >>= 1",
            "    return y",
            "import bisect",
            "n, q = map(int, input().split())",
            "stx = [list(map(int, input().split())) for i in range(n)]",
            "d = [int(input()) for i in range(q)]",
            "stx.sort(key=lambda x: x[2])",
            "ans = [-1 for i in range(q)]",
            "lis = [-1 for i in range(q)]",
            "for s, t, x in stx:",
            "    l = bisect.bisect_left(d, s - x)",
            "    r = bisect.bisect_left(d, t - x)",
            "    while l < r:",
            "        if lis[l] == -1:",
            "            ans[l] = x",
            "            lis[l] = r",
            "            l += 1",
            "        else:",
            "            l = lis[l]",
            "print(*ans, sep=\"\\n\")"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2
        ]
    },
    {
        "content": [
            "import sys",
            "INF = 1 << 30",
            "class Node:",
            "    __slots__ = [\"key\", \"val\", \"lch\", \"rch\", \"bias\"]",
            "    def __init__(self, key, val):",
            "        self.key = key",
            "        self.val = val",
            "        self.lch = None",
            "        self.rch = None",
            "        self.bias = 0",
            "class AVLTree:",
            "    __slots__ = [\"root\"]",
            "    def __init__(self):",
            "        self.root = None",
            "    def rotate_left(self, v):",
            "        u = v.rch",
            "        v.rch = u.lch",
            "        u.lch = v",
            "        if u.bias == -1:",
            "            u.bias = v.bias = 0",
            "        else:",
            "            u.bias = 1",
            "            v.bias = -1",
            "        return u",
            "    def rotate_right(self, v):",
            "        u = v.lch",
            "        v.lch = u.rch",
            "        u.rch = v",
            "        if u.bias == 1:",
            "            u.bias = v.bias = 0",
            "        else:",
            "            u.bias = -1",
            "            v.bias = 1",
            "        return u",
            "    def rotateLR(self, v):",
            "        u = v.lch",
            "        t = u.rch",
            "        u.rch = t.lch",
            "        t.lch = u",
            "        v.lch = t.rch",
            "        t.rch = v",
            "        self.update_bias_double(t)",
            "        return t",
            "    def rotateRL(self, v):",
            "        u = v.rch",
            "        t = u.lch",
            "        u.lch = t.rch",
            "        t.rch = u",
            "        v.rch = t.lch",
            "        t.lch = v",
            "        self.update_bias_double(t)",
            "        return t",
            "    def update_bias_double(self, v):",
            "        if v.bias == 1:",
            "            v.rch.bias = -1",
            "            v.lch.bias = 0",
            "        elif v.bias == -1:",
            "            v.rch.bias = 0",
            "            v.lch.bias = 1",
            "        else:",
            "            v.rch.bias = 0",
            "            v.lch.bias = 0",
            "        v.bias = 0",
            "    def insert(self, key, val):",
            "        if self.root is None:",
            "            self.root = Node(key, val)",
            "            return",
            "        v = self.root",
            "        history = []",
            "        while v is not None:",
            "            if key < v.key:",
            "                history.append((v, 1))",
            "                v = v.lch",
            "            elif v.key < key:",
            "                history.append((v, -1))",
            "                v = v.rch",
            "            elif v.key == key:",
            "                v.val = val",
            "                return",
            "        p, pdir = history[-1]",
            "        if pdir == 1:",
            "            p.lch = Node(key, val)",
            "        else:",
            "            p.rch = Node(key, val)",
            "        while history:",
            "            v, direction = history.pop()",
            "            v.bias += direction",
            "            new_v = None",
            "            b = v.bias",
            "            if b == 0:",
            "                break",
            "            if b == 2:",
            "                u = v.lch",
            "                if u.bias == -1:",
            "                    new_v = self.rotateLR(v)",
            "                else:",
            "                    new_v = self.rotate_right(v)",
            "                break",
            "            if b == -2:",
            "                u = v.rch",
            "                if u.bias == 1:",
            "                    new_v = self.rotateRL(v)",
            "                else:",
            "                    new_v = self.rotate_left(v)",
            "                break",
            "        if new_v is not None:",
            "            if len(history) == 0:",
            "                self.root = new_v",
            "                return",
            "            p, pdir = history.pop()",
            "            if pdir == 1:",
            "                p.lch = new_v",
            "            else:",
            "                p.rch = new_v",
            "    def delete(self, key):",
            "        v = self.root",
            "        history = []",
            "        while v is not None:",
            "            if key < v.key:",
            "                history.append((v, 1))",
            "                v = v.lch",
            "            elif v.key < key:",
            "                history.append((v, -1))",
            "                v = v.rch",
            "            else:",
            "                break",
            "        else:",
            "            return False",
            "        if v.lch is not None:",
            "            history.append((v, 1))",
            "            lmax = v.lch",
            "            while lmax.rch is not None:",
            "                history.append((lmax, -1))",
            "                lmax = lmax.rch",
            "            v.key = lmax.key",
            "            v.val = lmax.val",
            "            v = lmax",
            "        c = v.rch if v.lch is None else v.lch",
            "        if history:",
            "            p, pdir = history[-1]",
            "            if pdir == 1:",
            "                p.lch = c",
            "            else:",
            "                p.rch = c",
            "        else:",
            "            self.root = c",
            "            return True",
            "        while history:",
            "            new_p = None",
            "            p, pdir = history.pop()",
            "            p.bias -= pdir",
            "            b = p.bias",
            "            if b == 2:",
            "                if p.lch.bias == -1:",
            "                    new_p = self.rotateLR(p)",
            "                else:",
            "                    new_p = self.rotate_right(p)",
            "            elif b == -2:",
            "                if p.rch.bias == 1:",
            "                    new_p = self.rotateRL(p)",
            "                else:",
            "                    new_p = self.rotate_left(p)",
            "            elif b != 0:",
            "                break",
            "            if new_p is not None:",
            "                if len(history) == 0:",
            "                    self.root = new_p",
            "                    return True",
            "                gp, gpdir = history[-1]",
            "                if gpdir == 1:",
            "                    gp.lch = new_p",
            "                else:",
            "                    gp.rch = new_p",
            "                if new_p.bias != 0:",
            "                    break",
            "        return True",
            "    def get(self, key):",
            "        v = self.root",
            "        while v is not None:",
            "            if key < v.key:",
            "                v = v.lch",
            "            elif v.key < key:",
            "                v = v.rch",
            "            else:",
            "                return v.val",
            "        return None",
            "    def lower_bound(self, key):",
            "        ret = INF",
            "        v = self.root",
            "        while v is not None:",
            "            if v.key >= key:",
            "                if ret > v.key:",
            "                    ret = v.key",
            "                v = v.lch",
            "            else:",
            "                v = v.rch",
            "        return ret",
            "    def __getitem__(self, key): return self.get(key)",
            "    def __setitem__(self, key, val): return self.insert(key, val)",
            "    def __delitem__(self, key): return self.delete(key)",
            "    def __bool__(self): return self.root is not None",
            "read = sys.stdin.buffer.read",
            "input = sys.stdin.buffer.readline",
            "N, Q = map(int, input().split())",
            "event = []",
            "for i in range(N):",
            "    s, t, x = map(int, input().split())",
            "    event.append((s-x, 1, x))",
            "    event.append((t-x, -1, x))",
            "event.sort(reverse=True)",
            "avl = AVLTree()",
            "ans = []",
            "for d in map(int, read().split()):",
            "    while event and event[-1][0] <= d:",
            "        time, k, x = event.pop()",
            "        if k == 1:",
            "            avl.insert(x, 1)",
            "        else:",
            "            avl.delete(x)",
            "    x = avl.lower_bound(-INF)",
            "    ans.append(x if x < INF else -1)",
            "print('\\n'.join(map(str, ans)))"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            2,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "class DualSegmentTree():",
            "    def __init__(self, n, op, e):",
            "        \"\"\"",
            "        :param n: 配列の要素数",
            "        :param op: 作用素（モノイド＝結合則＋単位元存在）",
            "        :param e:  単位元",
            "        \"\"\"",
            "        self.n = n",
            "        self.op = op",
            "        self.e = e",
            "        self.size = 1 << (self.n - 1).bit_length()",
            "        self.lazy = [self.e] * (self.size << 1)",
            "    def update(self, l, r, x):",
            "        \"\"\"",
            "        半開区間 [l, r) の値を x に更新 （ 0-indexed ）　（ O(logN) ）",
            "        \"\"\"",
            "        l += (self.size - 1)",
            "        r += (self.size - 1)",
            "        self.propagate(l)",
            "        self.propagate(r-1)",
            "        while l < r:",
            "            if r&1 == 0:",
            "                r -= 1              # 半開区間なので先に引いてる",
            "                self.lazy[r] = self.op(x, self.lazy[r])",
            "            if l&1 == 0:",
            "                self.lazy[l] = self.op(x, self.lazy[l])",
            "                l += 1",
            "            l = (l - 1) // 2",
            "            r = (r - 1) // 2",
            "    def propagate(self, i):",
            "        \"\"\"",
            "        根から葉に伝搬させる。可換モノイドの場合は更新時の伝搬をサボれる。　（ O(logN) ）",
            "        \"\"\"",
            "        tmp = []",
            "        while i>0:",
            "            i -= 1",
            "            i >>= 1",
            "            tmp.append(i)",
            "        for x in reversed(tmp):",
            "            if self.lazy[x] == self.e:",
            "                continue",
            "            self.lazy[2*x+1] = self.op(self.lazy[x], self.lazy[2*x+1])",
            "            self.lazy[2*x+2] = self.op(self.lazy[x], self.lazy[2*x+2])",
            "            self.lazy[x] = self.e",
            "    def get(self, i):",
            "        \"\"\"",
            "        i 番目の値を取得（ 0-indexed ） ( O(logN) )",
            "        \"\"\"",
            "        i += (self.size - 1)",
            "        self.propagate(i)",
            "        return self.lazy[i]",
            "    def __getitem__(self, i):",
            "        return self.get(i)",
            "    def __iter__(self):",
            "        for x in range(self.size-1):",
            "            if self.lazy[x] == self.e:",
            "                continue",
            "            self.lazy[2*x+1] = self.op(self.lazy[x], self.lazy[2*x+1])",
            "            self.lazy[2*x+2] = self.op(self.lazy[x], self.lazy[2*x+2])",
            "            self.lazy[x] = self.e",
            "        for a in self.lazy[self.size-1:self.size-1+self.n]:",
            "            yield a",
            "    def __str__(self):",
            "        for x in range(self.size-1):",
            "            if self.lazy[x] == self.e:",
            "                continue",
            "            self.lazy[2*x+1] = self.op(self.lazy[x], self.lazy[2*x+1])",
            "            self.lazy[2*x+2] = self.op(self.lazy[x], self.lazy[2*x+2])",
            "            self.lazy[x] = self.e",
            "        return str(self.lazy[self.size-1:self.size-1 + self.n])",
            "class ListList:",
            "    \"\"\" tupleを一番目の添え字に関してソートする\"\"\"",
            "    def __init__(self, max_value_list):",
            "        \"\"\"",
            "        :param max_value_list: tuple = (i, j, k) を考えた時、  max_value_list = (j_max, k_max)",
            "        \"\"\"",
            "        self.list_list = []",
            "        self.separation = [0]",
            "        self.max_value_list = list(map(lambda x: x.bit_length(), max_value_list))",
            "        for a in self.max_value_list:",
            "            self.separation.append(self.separation[-1] + a)",
            "        self.separation.reverse()",
            "        self.mask = list(map(lambda x: x-1, self.separation))",
            "    def append(self, array):",
            "        temp = 0",
            "        for x, i in zip(array, self.separation):",
            "            temp += x<<i",
            "        self.list_list.append(temp)",
            "    def sort(self, reverse=False):",
            "        return self.list_list.sort(reverse=reverse)",
            "    def __getitem__(self, item):",
            "        temp = self.list_list[item]",
            "        array = []",
            "        for a in self.max_value_list:",
            "            array = [temp&((1<<a)-1)] + array",
            "            temp>>=a",
            "        array = [temp] + array",
            "        return array",
            "    def __iter__(self):",
            "        for i in range(len(self.list_list)):",
            "            yield self[i]",
            "    def __str__(self):",
            "        text = []",
            "        for a in self:",
            "            text.append(\"[\" + \", \".join(list(map(str, a))) + \"]\")",
            "        return \"[\" + \", \".join(text) + \"]\"",
            "##################################################################################################################",
            "import sys",
            "from bisect import *",
            "input = sys.stdin.readline",
            "N, Q = map(int, input().split())",
            "e = -1",
            "op = lambda x, y: x if x != e else y",
            "st = DualSegmentTree(Q, op, e)",
            "Qu = ListList([10**9,10**9])",
            "for _ in range(N):",
            "    S, T, X = map(int, input().split())",
            "    Qu.append((X, S, T))",
            "Qu.sort(reverse=True)",
            "D = [int(input()) for _ in range(Q)]",
            "for q in Qu:",
            "    X, S, T = q",
            "    L = bisect_left(D,S-X)",
            "    R = bisect_left(D,T-X)",
            "    st.update(L, R, X)",
            "print(*st, sep=\"\\n\")"
        ],
        "label": [
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            0,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "#! /usr/bin/env python3",
            "import bisect",
            "import sys",
            "sys.setrecursionlimit(10**9)",
            "# Ref: https://qiita.com/takayg1/items/b7b3f7d458915bcc7a4e",
            "class LazySegTree:",
            "    def __init__(self, init_val, segfunc, ide_ele = 2**31 - 1):",
            "        n = len(init_val)",
            "        self.segfunc = segfunc",
            "        self.ide_ele = ide_ele",
            "        self.num = 1 << (n - 1).bit_length()",
            "        self.data = [ide_ele] * 2 * self.num",
            "        self.lazy = [None] * 2 * self.num",
            "        # 配列の値を葉にセット",
            "        for i in range(n):",
            "            self.data[self.num + i] = init_val[i]",
            "        # 構築していく",
            "        for i in range(self.num - 1, 0, -1):",
            "            self.data[i] = self.segfunc(self.data[2 * i], self.data[2 * i + 1])",
            "    def propagates(self, *ids):",
            "        for i in reversed(ids):",
            "            v = self.lazy[i]",
            "            if v is None:",
            "                continue",
            "            self.lazy[2 * i] = v",
            "            self.lazy[2 * i + 1] = v",
            "            self.data[2 * i] = v",
            "            self.data[2 * i + 1] = v",
            "            self.lazy[i] = None",
            "    def update(self, l, r, x): # [l, r)",
            "        *ids, = self.gindex(l, r)",
            "        self.propagates(*ids)",
            "        l += self.num",
            "        r += self.num",
            "        while l < r:",
            "            if l & 1:",
            "                self.lazy[l] = x",
            "                self.data[l] = x",
            "                l += 1",
            "            if r & 1:",
            "                self.lazy[r - 1] = x",
            "                self.data[r - 1] = x",
            "            r >>= 1",
            "            l >>= 1",
            "        for i in ids:",
            "            self.data[i] = self.segfunc(self.data[2 * i], self.data[2 * i + 1])",
            "    def query(self, l, r): # [l, r)",
            "        *ids, = self.gindex(l, r)",
            "        self.propagates(*ids)",
            "        res = self.ide_ele",
            "        l += self.num",
            "        r += self.num",
            "        while l < r:",
            "            if l & 1:",
            "                res = self.segfunc(res, self.data[l])",
            "                l += 1",
            "            if r & 1:",
            "                res = self.segfunc(res, self.data[r - 1])",
            "            l >>= 1",
            "            r >>= 1",
            "        return res",
            "    def gindex(self, l, r):",
            "        l += self.num",
            "        r += self.num",
            "        lm = l >> (l & -l).bit_length()",
            "        rm = r >> (r & -r).bit_length()",
            "        while r > l:",
            "            if l <= lm:",
            "                yield l",
            "            if r <= rm:",
            "                yield r",
            "            r >>= 1",
            "            l >>= 1",
            "        while l:",
            "            yield l",
            "            l >>= 1",
            "def zarts(D,x): # 座標圧縮",
            "    return bisect.bisect_left(D,x)",
            "INF=10**20",
            "def solve(N: int, Q: int, S: \"List[int]\", T: \"List[int]\", X: \"List[int]\", D: \"List[int]\"):",
            "    def segfunc(x,y):",
            "        return min(x,y)",
            "    v = [INF] * (Q+1)",
            "    seg = LazySegTree(v,segfunc,ide_ele=INF)",
            "    _X = list(enumerate(X))",
            "    _X.sort(key=lambda x:x[1],reverse=True)",
            "    for i,x in _X:",
            "        l = zarts(D,S[i]-X[i])",
            "        r = zarts(D,T[i]-X[i])",
            "        if l == r: continue",
            "        seg.update(l,r,X[i])",
            "    for q in range(Q):",
            "        d = q",
            "        # print(\"d\",d)",
            "        x = seg.query(d,d+1)",
            "        if x == INF:",
            "            x = -1",
            "        print(x)",
            "    return",
            "def main():",
            "    def iterate_tokens():",
            "        for line in sys.stdin:",
            "            for word in line.split():",
            "                yield word",
            "    tokens = iterate_tokens()",
            "    N = int(next(tokens))  # type: int",
            "    Q = int(next(tokens))  # type: int",
            "    S = [int()] * (N)  # type: \"List[int]\"",
            "    T = [int()] * (N)  # type: \"List[int]\"",
            "    X = [int()] * (N)  # type: \"List[int]\"",
            "    # X = [(int(),int())] * (N)  # type: \"List[int]\"",
            "    for i in range(N):",
            "        S[i] = int(next(tokens))",
            "        T[i] = int(next(tokens))",
            "        X[i] = int(next(tokens))",
            "        # X[i] = (-1 * int(next(tokens)),i)",
            "    D = [int(next(tokens)) for _ in range(Q)]  # type: \"List[int]\"",
            "    solve(N, Q, S, T, X, D)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "import sys,bisect,string,math,time,functools,random,fractions",
            "from heapq import heappush,heappop,heapify",
            "from collections import deque,defaultdict,Counter",
            "from itertools import permutations,combinations,groupby",
            "rep=range;R=range",
            "def Golf():n,*t=map(int,open(0).read().split())",
            "def I():return int(input())",
            "def S_():return input()",
            "def IS():return input().split()",
            "def LS():return [i for i in input().split()]",
            "def MI():return map(int,input().split())",
            "def LI():return [int(i) for i in input().split()]",
            "def LI_():return [int(i)-1 for i in input().split()]",
            "def NI(n):return [int(input()) for i in range(n)]",
            "def NI_(n):return [int(input())-1 for i in range(n)]",
            "def StoLI():return [ord(i)-97 for i in input()]",
            "def ItoS(n):return chr(n+97)",
            "def LtoS(ls):return ''.join([chr(i+97) for i in ls])",
            "def RA():return map(int,open(0).read().split())",
            "def GI(V,E,ls=None,Directed=False,index=1):",
            "    org_inp=[];g=[[] for i in range(V)]",
            "    FromStdin=True if ls==None else False",
            "    for i in range(E):",
            "        if FromStdin:",
            "            inp=LI()",
            "            org_inp.append(inp)",
            "        else:",
            "            inp=ls[i]",
            "        if len(inp)==2:",
            "            a,b=inp;c=1",
            "        else:",
            "            a,b,c=inp",
            "        if index==1:a-=1;b-=1",
            "        aa=(a,c);bb=(b,c);g[a].append(bb)",
            "        if not Directed:g[b].append(aa)",
            "    return g,org_inp",
            "def GGI(h,w,search=None,replacement_of_found='.',mp_def={'#':1,'.':0},boundary=1):",
            "    #h,w,g,sg=GGI(h,w,search=['S','G'],replacement_of_found='.',mp_def={'#':1,'.':0},boundary=1) # sample usage",
            "    mp=[boundary]*(w+2);found={}",
            "    for i in R(h):",
            "        s=input()",
            "        for char in search:",
            "            if char in s:",
            "                found[char]=((i+1)*(w+2)+s.index(char)+1)",
            "                mp_def[char]=mp_def[replacement_of_found]",
            "        mp+=[boundary]+[mp_def[j] for j in s]+[boundary]",
            "    mp+=[boundary]*(w+2)",
            "    return h+2,w+2,mp,found",
            "def TI(n):return GI(n,n-1)",
            "def accum(ls):",
            "    rt=[0]",
            "    for i in ls:rt+=[rt[-1]+i]",
            "    return rt",
            "def bit_combination(n,base=2):",
            "    rt=[]",
            "    for tb in R(base**n):s=[tb//(base**bt)%base for bt in R(n)];rt+=[s]",
            "    return rt",
            "def gcd(x,y):",
            "    if y==0:return x",
            "    if x%y==0:return y",
            "    while x%y!=0:x,y=y,x%y",
            "    return y",
            "def YN(x):print(['NO','YES'][x])",
            "def Yn(x):print(['No','Yes'][x])",
            "def show(*inp,end='\\n'):",
            "    if show_flg:print(*inp,end=end)",
            "mo=10**9+7",
            "inf=float('inf')",
            "FourNb=[(-1,0),(1,0),(0,1),(0,-1)];EightNb=[(-1,0),(1,0),(0,1),(0,-1),(1,1),(-1,-1),(1,-1),(-1,1)];compas=dict(zip('WENS',FourNb));cursol=dict(zip('LRUD',FourNb))",
            "l_alp=string.ascii_lowercase",
            "#sys.setrecursionlimit(10**7)",
            "read=sys.stdin.buffer.read;readline=sys.stdin.buffer.readline;input=lambda:sys.stdin.readline().rstrip()",
            "########################################################################################################################################################################",
            "# Binary Indexed Tree",
            "# Bit.add(i,x)    : add x at i-th value",
            "# Bit.sum(i)      : get sum up to i-th value",
            "show_flg=False",
            "#show_flg=True",
            "ans=0",
            "a=[]",
            "n,q=LI()",
            "for i in range(n):",
            "    s,t,x=LI()",
            "    a+=(x,(s-x,t-x)),",
            "a.sort(key=lambda x:-x[1][0])",
            "d=NI(q)",
            "p=[]",
            "g=[]",
            "for i in range(q):",
            "    c=d[i]",
            "    while a and a[-1][1][0]<=c:",
            "        x,(l,r)=a.pop()",
            "        heappush(p,(x,(l,r)))",
            "    while p and p[0][1][1]<=c:",
            "        x,(l,r)=heappop(p)",
            "    if p:",
            "        ans=p[0][0]",
            "    else:",
            "        ans=-1",
            "    g+=ans,",
            "for i in g:",
            "    print(i)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            2,
            1,
            1,
            1,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "class DualSegmentTree():",
            "    def __init__(self, n, op, e):",
            "        \"\"\"",
            "        :param n: 配列の要素数",
            "        :param op: 作用素（モノイド＝結合則＋単位元存在）",
            "        :param e:  単位元",
            "        \"\"\"",
            "        self.n = n",
            "        self.op = op",
            "        self.e = e",
            "        self.depth = (self.n - 1).bit_length()",
            "        self.size = 1 << self.depth",
            "        self.lazy = [self.e] * ((self.size << 1) + 1)",
            "    def built(self, array):",
            "        \"\"\"",
            "        arrayを初期値とするセグメント木を構築",
            "        \"\"\"",
            "        n, size, lazy = self.n, self.size, self.lazy",
            "        for i in range(n):",
            "            lazy[size + i] = array[i]",
            "    def update(self, l, r, x):",
            "        \"\"\"",
            "        半開区間 [l, r) の各々の要素 a に op(x, a)を作用させる （ 0-indexed ）　（ O(logN) ）",
            "        \"\"\"",
            "        op, lazy = self.op, self.lazy",
            "        l += self.size",
            "        r += self.size",
            "        self.propagate(l//(l&-l))",
            "        self.propagate((r//(r&-r))-1)",
            "        while l < r:",
            "            if r&1:",
            "                r -= 1              # 半開区間なので先に引いてる",
            "                lazy[r] = op(x, lazy[r])",
            "            if l&1:",
            "                lazy[l] = op(x, lazy[l])",
            "                l += 1",
            "            l >>= 1",
            "            r >>= 1",
            "    def propagate(self, i):",
            "        \"\"\"",
            "        根から葉に伝搬させる。可換モノイドの場合は更新時の伝搬をサボれる。　（ O(logN) ）",
            "        \"\"\"",
            "        e, op, lazy = self.e, self.op, self.lazy",
            "        for k in range(i.bit_length()-1, 0,-1):",
            "            x = i>>k",
            "            if lazy[x] == e:",
            "                continue",
            "            lazy[(x<<1)|1] = op(lazy[x], lazy[(x<<1)|1])",
            "            lazy[x<<1] = op(lazy[x], lazy[x<<1])",
            "            lazy[x] = e",
            "    def get(self, i):",
            "        \"\"\"",
            "        i 番目の値を取得（ 0-indexed ） ( O(logN) )",
            "        \"\"\"",
            "        i += self.size",
            "        self.propagate(i)",
            "        return self.lazy[i]",
            "    def __getitem__(self, i):",
            "        return self.get(i)",
            "    def __iter__(self):",
            "        n, size, e, op, lazy = self.n, self.size, self.e, self.op, self.lazy",
            "        for x in range(1, size):",
            "            if lazy[x] == e:",
            "                continue",
            "            lazy[(x<<1)|1] = op(lazy[x], lazy[(x<<1)|1])",
            "            lazy[x<<1] = op(lazy[x], lazy[x<<1])",
            "            lazy[x] = e",
            "        for a in lazy[size:size+n]:",
            "            yield a",
            "    def __str__(self):",
            "        n, size, e, op, lazy = self.n, self.size, self.e, self.op, self.lazy",
            "        for x in range(1, size):",
            "            if lazy[x] == e:",
            "                continue",
            "            lazy[(x << 1) | 1] = op(lazy[x], lazy[(x << 1) | 1])",
            "            lazy[x << 1] = op(lazy[x], lazy[x << 1])",
            "            lazy[x] = e",
            "        return str(lazy[size:size + n])",
            "##################################################################################################################",
            "import sys",
            "from bisect import *",
            "input = sys.stdin.readline",
            "N, Q = map(int, input().split())",
            "e = -1",
            "op = lambda x, y: x if x != e else y",
            "st = DualSegmentTree(Q, op, e)",
            "Qu = [list(map(int, input().split())) for _ in range(N)]",
            "Qu.sort(key=lambda x:x[2], reverse=True)",
            "D = [int(input()) for _ in range(Q)]",
            "for q in Qu:",
            "    S, T, X = q",
            "    L = bisect_left(D,S-X)",
            "    R = bisect_left(D,T-X)",
            "    st.update(L, R, X)",
            "print(*st, sep=\"\\n\")"
        ],
        "label": [
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            2
        ]
    },
    {
        "content": [
            "# using main() makes code faster from the point of view of \"access to variables in global name-space\"",
            "def main():",
            "    \"\"\" convenient functions",
            "    # for i, a in enumerate(iterable)",
            "    # q, mod = divmod(a, b)",
            "    # divmod(x, y) returns the tuple (x//y, x%y)",
            "    # manage median(s) using two heapq https://atcoder.jp/contests/abc127/tasks/abc127_f",
            "    \"\"\"",
            "    import sys",
            "    sys.setrecursionlimit(10**7)",
            "    from itertools import accumulate, combinations, permutations, product # https://docs.python.org/ja/3/library/itertools.html",
            "    # accumulate() returns iterator! to get list: list(accumulate())",
            "    from math import factorial, ceil, floor",
            "    def factorize(n):",
            "        \"\"\"return the factors of the Arg and count of each factor",
            "        Args:",
            "            n (long): number to be resolved into factors",
            "        Returns:",
            "            list of tuples: factorize(220) returns [(2, 2), (5, 1), (11, 1)]",
            "        \"\"\"",
            "        fct = []  # prime factor",
            "        b, e = 2, 0  # base, exponent",
            "        while b * b <= n:",
            "            while n % b == 0:",
            "                n = n // b",
            "                e = e + 1",
            "            if e > 0:",
            "                fct.append((b, e))",
            "            b, e = b + 1, 0",
            "        if n > 1:",
            "            fct.append((n, 1))",
            "        return fct",
            "    def combinations_count(n, r):",
            "        \"\"\"Return the number of selecting r pieces of items from n kinds of items.",
            "        Args:",
            "            n (long): number",
            "            r (long): number",
            "        Raises:",
            "            Exception: not defined when n or r is negative",
            "        Returns:",
            "            long: number",
            "        \"\"\"",
            "        # TODO: How should I do when n - r is negative?",
            "        if n < 0 or r < 0:",
            "            raise Exception('combinations_count(n, r) not defined when n or r is negative')",
            "        if n - r < r: r = n - r",
            "        if r < 0: return 0",
            "        if r == 0: return 1",
            "        if r == 1: return n",
            "        numerator = [n - r + k + 1 for k in range(r)]",
            "        denominator = [k + 1 for k in range(r)]",
            "        for p in range(2,r+1):",
            "            pivot = denominator[p - 1]",
            "            if pivot > 1:",
            "                offset = (n - r) % p",
            "                for k in range(p-1,r,p):",
            "                    numerator[k - offset] /= pivot",
            "                    denominator[k] /= pivot",
            "        result = 1",
            "        for k in range(r):",
            "            if numerator[k] > 1:",
            "                result *= int(numerator[k])",
            "        return result",
            "    def combinations_with_replacement_count(n, r):",
            "        \"\"\"Return the number of selecting r pieces of items from n kinds of items allowing individual elements to be repeated more than once.",
            "        Args:",
            "            n (long): number",
            "            r (long): number",
            "        Raises:",
            "            Exception: not defined when n or r is negative",
            "        Returns:",
            "            long: number",
            "        \"\"\"",
            "        if n < 0 or r < 0:",
            "            raise Exception('combinations_with_replacement_count(n, r) not defined when n or r is negative')",
            "        elif n == 0:",
            "            return 1",
            "        else:",
            "            return combinations_count(n + r - 1, r)",
            "    from bisect import bisect_left, bisect_right",
            "    from collections import deque, Counter, defaultdict # https://docs.python.org/ja/3/library/collections.html#collections.deque",
            "    from heapq import heapify, heappop, heappush, heappushpop, heapreplace,nlargest,nsmallest # https://docs.python.org/ja/3/library/heapq.html",
            "    from copy import deepcopy, copy # https://docs.python.org/ja/3/library/copy.html",
            "    from operator import itemgetter",
            "    # ex1: List.sort(key=itemgetter(1))",
            "    # ex2: sorted(tuples, key=itemgetter(1,2))",
            "    from functools import reduce",
            "    def chmin(x, y):",
            "        \"\"\"change minimum",
            "        if x > y, x = y and return (x, True).",
            "        convenient when solving problems of dp[i]",
            "        Args:",
            "            x (long): current minimum value",
            "            y (long): potential minimum value",
            "        Returns:",
            "            (x, bool): (x, True) when updated, else (x, False)",
            "        \"\"\"",
            "        if x > y:",
            "            x = y",
            "            return (x, True)",
            "        else:",
            "            return (x, False)",
            "    def chmax(x, y):",
            "        \"\"\"change maximum",
            "        if x < y, x = y and return (x, True).",
            "        convenient when solving problems of dp[i]",
            "        Args:",
            "            x (long): current maximum value",
            "            y (long): potential maximum value",
            "        Returns:",
            "            (x, bool): (x, True) when updated, else (x, False)",
            "        \"\"\"",
            "        if x < y:",
            "            x = y",
            "            return (x, True)",
            "        else:",
            "            return (x, False)",
            "    from fractions import gcd # Deprecated since version 3.5: Use math.gcd() instead.",
            "    def gcds(numbers):",
            "        return reduce(gcd, numbers)",
            "    def lcm(x, y):",
            "        return (x * y) // gcd(x, y)",
            "    def lcms(numbers):",
            "        return reduce(lcm, numbers, 1)",
            "    # first create factorial_list",
            "    # fac_list = mod_factorial_list(n)",
            "    INF = 10 ** 18",
            "    MOD = 10 ** 9 + 7",
            "    modpow = lambda a, n, p = MOD: pow(a, n, p) # Recursive function in python is slow!",
            "    def modinv(a, p = MOD):",
            "        # evaluate reciprocal using Fermat's little theorem:",
            "        # a**(p-1) is identical to 1 (mod p) when a and p is coprime",
            "        return modpow(a, p-2, p)",
            "    def modinv_list(n, p = MOD):",
            "        if n <= 1:",
            "            return [0,1][:n+1]",
            "        else:",
            "            inv_t = [0,1]",
            "            for i in range(2, n+1):",
            "                inv_t += [inv_t[p % i] * (p - int(p / i)) % p]",
            "            return inv_t",
            "    def modfactorial_list(n, p = MOD):",
            "        if n == 0:",
            "            return [1]",
            "        else:",
            "            l = [0] * (n+1)",
            "            tmp = 1",
            "            for i in range(1, n+1):",
            "                tmp = tmp * i % p",
            "                l[i] = tmp",
            "            return l",
            "    def modcomb(n, k, fac_list = [], p = MOD):",
            "        # fac_list = modfactorial_list(100)",
            "        # print(modcomb(100, 5, modfactorial_list(100)))",
            "        from math import factorial",
            "        if n < 0 or k < 0 or n < k: return 0",
            "        if n == 0 or k == 0: return 1",
            "        if len(fac_list) <= n:",
            "            a = factorial(n) % p",
            "            b = factorial(k) % p",
            "            c = factorial(n-k) % p",
            "        else:",
            "            a = fac_list[n]",
            "            b = fac_list[k]",
            "            c = fac_list[n-k]",
            "        return (a * modpow(b, p-2, p) * modpow(c, p-2, p)) % p",
            "    def modadd(a, b, p = MOD):",
            "        return (a + b) % MOD",
            "    def modsub(a, b, p = MOD):",
            "        return (a - b) % p",
            "    def modmul(a, b, p = MOD):",
            "        return ((a % p) * (b % p)) % p",
            "    def moddiv(a, b, p = MOD):",
            "        return modmul(a, modpow(b, p-2, p))",
            "    \"\"\" initialize variables and set inputs",
            "    # initialize variables",
            "        # to initialize list, use [0] * n",
            "        # to initialize two dimentional array, use [[0] * N for _ in range(N)]",
            "    # set inputs",
            "        # open(0).read() is a convenient method:",
            "        # ex) n, m, *x = map(int, open(0).read().split())",
            "        #     min(x[::2]) - max(x[1::2])",
            "        # ex2) *x, = map(int, open(0).read().split())",
            "        #     don't forget to add comma after *x if only one variable is used",
            "    # preprocessing",
            "        # transpose = [x for x in zip(*data)]",
            "        # ex) [[1, 2, 3], [4, 5, 6], [7, 8, 9]] => [(1, 4, 7), (2, 5, 8), (3, 6, 9)]",
            "        # flat = [flatten for inner in data for flatten in inner]",
            "        # ex) [[1, 2, 3], [4, 5, 6], [7, 8, 9]] => [1, 2, 3, 4, 5, 6, 7, 8, 9]",
            "    # calculate and output",
            "        # output pattern",
            "        # ex1) print(*l) => when l = [2, 5, 6], printed 2 5 6",
            "    \"\"\"",
            "    # functions used",
            "    r = lambda: sys.stdin.readline().strip()",
            "    r_int = lambda: int(r())",
            "    R = lambda: list(map(int, r().split()))",
            "    Rfloat = lambda: list(map(float, r().split()))",
            "    Rtuple = lambda: tuple(map(int, r().split()))",
            "    Rmap = lambda: map(int, r().split())",
            "    \"\"\" how to treat input",
            "    # single int: int(r())",
            "    # single string: r()",
            "    # single float: float(r())",
            "    # line int: R()",
            "    # line string: r().split()",
            "    # line (str, int, int): [j if i == 0 else int(j) for i, j in enumerate(r().split())]",
            "    # lines int: [R() for _ in range(n)]",
            "    \"\"\"",
            "    # main",
            "    N, Q = R()",
            "    STX = [R() for _ in range(N)]",
            "    STX.sort(key=itemgetter(2))",
            "    D = [int(r()) for _ in range(Q)]",
            "    Stopped = [-1] * Q",
            "    ans = [-1] * Q",
            "    for s, t, x in STX:",
            "        l = bisect_left(D, s-x)",
            "        r = bisect_left(D,t-x)",
            "        a = l",
            "        while a < r:",
            "            if Stopped[a] == -1:",
            "                ans[a] = x",
            "                Stopped[a] = r",
            "                a += 1",
            "            else:",
            "                a = Stopped[a]",
            "    for i in ans:",
            "        print(i)",
            "    \"\"\"memo: how to use defaultdict of list",
            "    # initialize",
            "    Dic = defaultdict(list)",
            "    # append / extend",
            "    Dic[x].append(y)",
            "    # for",
            "    for k, v in Dic.items():",
            "    \"\"\"",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            2,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            1,
            1,
            1,
            1,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "from heapq import *",
            "class MultisetBIT:",
            "    \"\"\"",
            "    最大値が小さい数について、その重複を許した集合を管理する。",
            "    最大値 maxvalue を受け取り、[0, maxvalue] を管理する。",
            "    counter は辞書型かリスト型で、counter[i] が i の個数を持つことを仮定する。",
            "    counter が与えられなかった場合は、全て個数 0 で初期化される。",
            "    基本的に閉区間で管理する。",
            "    内部では受け取った数を +1 したものをindexとして持っているので注意。",
            "    \"\"\"",
            "    __slots__ = [\"n\", \"k\", \"data\"]",
            "    def __init__(self, maxvalue, counter = None):",
            "        self.n = maxvalue + 1",
            "        self.k = 1 << ((self.n + 1).bit_length() - 1)",
            "        self.data = [0] * (self.n + 1)",
            "        if counter is not None:",
            "            self.update(counter)",
            "    def update(self, counter):",
            "        \"\"\"",
            "        counter を受け取って、それを反映させる。",
            "        counter は辞書型かリスト型で、counter[i] が i の個数を持つことを仮定する。",
            "        計算量は、n を要素の最大値として、 O(n) となる。",
            "        \"\"\"",
            "        if isinstance(counter, list):",
            "            self.data = [0] + counter + [0] * (self.n - len(counter))",
            "        else:",
            "            self.data = [0] * (self.n + 1)",
            "            for k, v in counter.items():",
            "                self.data[k + 1] = v",
            "        for i in range(1, self.n + 1):",
            "            if i + (i & -i) <= self.n:",
            "                self.data[i + (i & -i)] += self.data[i]",
            "    def add(self, value):",
            "        \"\"\"",
            "        与えられた引数を Multiset に加える。",
            "        計算量は、n を要素の最大値として、 O(log n) となる。",
            "        \"\"\"",
            "        value += 1",
            "        while value <= self.n:",
            "            self.data[value] += 1",
            "            value += value & -value",
            "    def pop(self, value):",
            "        \"\"\"",
            "        Multiset から与えられた引数を取り除く。",
            "        与えられた引数が Multiset に入っているかのチェックは行わなず、",
            "        単にその個数を 1 減らすだけなので注意。",
            "        計算量は、n を要素の最大値として、 O(log n) となる。",
            "        \"\"\"",
            "        value += 1",
            "        while value <= self.n:",
            "            self.data[value] -= 1",
            "            value += value & -value",
            "    def count_le(self, value):",
            "        \"\"\"",
            "        Multiset 内の要素 elem のうち、0 <= elem <= value を満たすものを数える。",
            "        計算量は、n を要素の最大値として、 O(log n) となる。",
            "        \"\"\"",
            "        value += 1",
            "        ret = 0",
            "        while value > 0:",
            "            ret += self.data[value]",
            "            value -= value & -value",
            "        return ret",
            "    def count(self, first, last):",
            "        \"\"\"",
            "        Multiset 内の要素 elem のうち、first <= elem <= last を満たすものを数える。",
            "        計算量は、n を要素の最大値として、 O(log n) となる。",
            "        \"\"\"",
            "        last += 1",
            "        ret = 0",
            "        while first < last:",
            "            ret += self.data[last]",
            "            last -= last & -last",
            "        while last < first:",
            "            ret -= self.data[first]",
            "            first -= first & -first",
            "        return ret",
            "    def bisect(self, count):",
            "        \"\"\"",
            "        Multiset 内の要素 elem のうち、count <= count_le(elem) を満たす最小のelemを返す。",
            "        計算量は、n を要素の最大値として、 O(log n) となる。",
            "        \"\"\"",
            "        ret = 0",
            "        k = self.k",
            "        while k > 0:",
            "            if ret + k <= self.n and self.data[ret + k] < count:",
            "                count -= self.data[ret + k]",
            "                ret += k",
            "            k //= 2",
            "        return ret",
            "    def lower_bound(self, value):",
            "        \"\"\"",
            "        Multiset 内の要素 elem のうち、value <= elem を満たす最小のelemを返す。",
            "        計算量は、n を要素の最大値として、 O(log n) となる。",
            "        \"\"\"",
            "        return self.bisect(self.count_le(value - 1) + 1)",
            "    def upper_bound(self, value):",
            "        \"\"\"",
            "        Multiset 内の要素 elem のうち、value < elem を満たす最小のelemを返す。",
            "        計算量は、n を要素の最大値として、 O(log n) となる。",
            "        \"\"\"",
            "        return self.bisect(self.count_le(value) + 1)",
            "N, Q = map(int, input().split())",
            "STXs = [tuple(map(int, input().split())) for _ in range(N)]",
            "Ds = [int(input()) for _ in range(Q)]",
            "i2X = sorted(map(lambda t: t[2], STXs))",
            "X2i = {X:i for i, X in enumerate(i2X)}",
            "max_i = len(i2X) - 1",
            "mbit = MultisetBIT(max_i)",
            "events = []",
            "for S, T, X in STXs:",
            "    events.append( ((S - X) << 32) + (X2i[X] << 1)     )",
            "    events.append( ((T - X) << 32) + (X2i[X] << 1) + 1 )",
            "heapify(events)",
            "mask = (1 << 32) - 1",
            "for D in Ds:",
            "    while events:",
            "        if events[0] % 2 == 0:",
            "            if (events[0] >> 32) <= D:",
            "                e = heappop(events)",
            "                mbit.add((e & mask) >> 1)",
            "            else:",
            "                break",
            "        else:",
            "            if (events[0] >> 32) <= D:",
            "                e = heappop(events)",
            "                mbit.pop((e & mask) >> 1)",
            "            else:",
            "                break",
            "    # print([mbit.count(i, i) for i in range(max_i + 1)])",
            "    ans_i = mbit.lower_bound(0)",
            "    print(-1 if ans_i > max_i else i2X[ans_i])"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "# -*- coding: utf-8 -*-",
            "from bisect import bisect, bisect_left",
            "from collections import Counter",
            "from functools import reduce",
            "from itertools import accumulate",
            "from operator import itemgetter, xor",
            "import sys",
            "input = sys.stdin.readline",
            "def inpl(): return list(map(int, input().split()))",
            "class BIT:",
            "    def __init__(self, N):",
            "        # Nは入れたい要素の個数",
            "        self.size = 2 ** (int.bit_length(N+1))",
            "        self.node = [0]*(self.size + 1)",
            "    def initialize(self, S):",
            "        # S[0] = 0にしておく",
            "        # 1-indexed",
            "        if len(S) < self.size + 1:",
            "            S += [S[-1]] * (self.size+1 - len(S))",
            "        for i in range(1, self.size+1):",
            "            self.node[i] = S[i] - S[i - (i&-i)]",
            "    def sum(self, i):",
            "        res = 0",
            "        while i:",
            "            res += self.node[i]",
            "            i -= (i & -(i))",
            "        return res",
            "    def add(self, i, x):",
            "        if i == 0:",
            "            return",
            "        while i <= self.size:",
            "            self.node[i] += x",
            "            i += (i & -(i))",
            "    def bisect_left(self, x):",
            "        res = 0",
            "        tmp = 0",
            "        b = 2**(int.bit_length(self.size)-2)",
            "        while b:",
            "            if tmp + self.node[res+b] < x:",
            "                res += b",
            "                tmp += self.node[res]",
            "            b //= 2",
            "        return res + 1",
            "    def bisect(self, x):",
            "        res = 0",
            "        tmp = 0",
            "        b = 2**(int.bit_length(self.size)-2)",
            "        while b:",
            "            if tmp + self.node[res+b] <= x:",
            "                res += b",
            "                tmp += self.node[res]",
            "            b //= 2",
            "        return res + 1",
            "class DammySet:",
            "    def __init__(self, counter, INF=2**32, counter_is_unique_and_sorted=True):",
            "        if not counter_is_unique_and_sorted:",
            "            if type(counter) != Counter:",
            "                counter = Counter(counter)",
            "            self.bit = BIT(len(counter.keys())+3)",
            "            self.key = sorted([-INF, -INF] + sorted(counter.keys()) + [INF])",
            "            self.val = [counter[k] for k in self.key]",
            "            S = list(accumulate(self.val))",
            "            self.bit.initialize(S)",
            "        else:",
            "            self.bit = BIT(len(counter) + 3)",
            "            self.key = [-INF] * (len(counter) + 3)",
            "            self.val = [0] * (len(counter) + 3)",
            "            S = [0] * (len(counter) + 3)",
            "            for i in range(2, len(counter)+2):",
            "                self.key[i] = counter[i-2]",
            "                self.val[i] = 1",
            "                S[i] = i-1",
            "            self.key[-1] = INF",
            "            S[-1] = len(counter)",
            "            self.bit.initialize(S)",
            "    def add(self, val):",
            "        ix = bisect_left(self.key, val)",
            "        assert self.key[ix] == val",
            "        self.bit.add(ix, 1)",
            "    def update(self, vals):",
            "        for k, v in Counter(vals).items():",
            "            ix = bisect_left(self.key, k)",
            "            if self.key[ix] != k:",
            "                raise KeyError",
            "            self.bit.add(ix, v)",
            "    def remove(self, vals):",
            "        for k, v in Counter(vals).items():",
            "            ix = bisect_left(self.key, k)",
            "            if self.key[ix] != k:",
            "                raise KeyError",
            "            # 空の値を削除しないかのチェック",
            "            # 時間が厳しそうなときはコメントアウト",
            "            assert self.bit.sum(ix) - self.bit.sum(ix-1) > 0",
            "            self.bit.add(ix, -v)",
            "    def pop_vals(self, l, r):",
            "        assert l <= r",
            "        rix = bisect(self.key, r) - 1",
            "        lix = bisect_left(self.key, l) - 1",
            "        # (lix, rix]になるのに注意",
            "        rv = self.bit.sum(rix)",
            "        lv = self.bit.sum(lix)",
            "        delta = rv - lv",
            "        tv = lv+1",
            "        tix = lix*1",
            "        vix = 0",
            "        rmvix = 0",
            "        vals = [0]*delta",
            "        rmvk = [0]*delta",
            "        rmvv = [0]*delta",
            "        while delta:",
            "            OK = self.bit.bisect_left(tv)",
            "            c = self.bit.sum(OK)",
            "            d = c - tv + 1",
            "            for _ in range(d):",
            "                vals[vix] = self.key[OK]",
            "                vix += 1",
            "            rmvk[rmvix] = OK",
            "            rmvv[rmvix] = d",
            "            rmvix += 1",
            "            tv += d",
            "            tix = OK",
            "            delta -= d",
            "        for i in range(rmvix):",
            "            self.bit.add(rmvk[i], -rmvv[i])",
            "        return vals",
            "N, M = inpl()",
            "Q = sorted([inpl() for _ in range(N)], key=itemgetter(2))",
            "D = [int(input()) for _ in range(M)]",
            "rD = {v:i for i, v in enumerate(D)}",
            "ans = [-1]*(M)",
            "dmap = DammySet(D)",
            "for s, t, x in Q:",
            "    val = dmap.pop_vals(s-x, t-1-x)",
            "    for v in val:",
            "        ans[rD[v]] = x",
            "print(*ans, sep=\"\\n\")"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2
        ]
    },
    {
        "content": [
            "def examA():",
            "    def calc_L(x1,y1,x2,y2):",
            "        return ((x2-x1)**2 + (y2-y1)**2)**0.5",
            "    N = I()",
            "    X = [LI()for _ in range(N)]",
            "    ans = 0",
            "    for x in itertools.permutations(X):",
            "        cur = 0",
            "        for i in range(1,N):",
            "            cur += calc_L(x[i-1][0],x[i-1][1],x[i][0],x[i][1])",
            "        #print(x,cur)",
            "        ans += cur",
            "    for i in range(1,N+1):",
            "        ans /= i",
            "    print(ans)",
            "    return",
            "def examB():",
            "    def judge(n):",
            "        sn = 0",
            "        for i in n:",
            "            sn += int(i)",
            "        if int(n)%sn==0:",
            "            return \"Yes\"",
            "        return \"No\"",
            "    N = SI()",
            "    ans = judge(N)",
            "    print(ans)",
            "    return",
            "def examC():",
            "    N, K = LI()",
            "    P = LI()",
            "    ans = 0",
            "    S = [0]*(N+1)",
            "    for i in range(N):",
            "        S[i+1] = S[i]+(P[i]+1)/2",
            "    for i in range(N-K+1):",
            "        cur = S[i+K] - S[i]",
            "        if cur>ans:",
            "            ans = cur",
            "    print(ans)",
            "    return",
            "def examD():",
            "    def bfs(n,V,s,W):",
            "        visited = [False]*n",
            "        que = deque()",
            "        que.append(s)",
            "        while(que):",
            "            now = que.pop()",
            "            visited[now] = True",
            "            for ne in V[now]:",
            "                if visited[ne]:",
            "                    continue",
            "                W[ne] += W[now]",
            "                que.append(ne)",
            "        return W",
            "    N, Q = LI()",
            "    V = [[]for _ in range(N)]",
            "    for _ in range(N-1):",
            "        a, b = LI()",
            "        a -= 1; b -= 1",
            "        V[a].append(b)",
            "        V[b].append(a)",
            "    W = [0] * N",
            "    for _ in range(Q):",
            "        p, x = LI()",
            "        W[p-1] += x",
            "    ans = bfs(N,V,0,W)",
            "    print(\" \".join(map(str,ans)))",
            "    return",
            "def examE():",
            "    def bfs(n,edges,s):",
            "        L = [inf]*n",
            "        que = deque()",
            "        que.append(s)",
            "        L[s] = 0",
            "        while(que):",
            "            now = que.popleft()",
            "            for ne in edges[now]:",
            "                if L[ne]>L[now]+1:",
            "                    L[ne] = L[now]+1",
            "                    que.append(ne)",
            "        return L",
            "    N = I()",
            "    V = [[]for _ in range(N)]",
            "    for _ in range(N-1):",
            "        a, b = LI()",
            "        a -= 1; b -= 1",
            "        V[a].append(b)",
            "        V[b].append(a)",
            "    F = bfs(N,V,0)",
            "    S = bfs(N,V,N-1)",
            "    f = 0; s = 0",
            "    for i in range(N):",
            "        if F[i]>S[i]:",
            "            s += 1",
            "        else:",
            "            f += 1",
            "    if f>s:",
            "        print(\"Fennec\")",
            "    else:",
            "        print(\"Snuke\")",
            "    return",
            "def examF():",
            "    # 区間加算、上書き、一点取得",
            "    class SegmentTree:",
            "        def __init__(self, n, ele, segfun):",
            "            #####単位元######要設定0or1orinf",
            "            self.ide_ele = ele",
            "            self.segfun = segfun",
            "            ####################",
            "            self.n = n",
            "            self.N0 = 1 << n.bit_length()",
            "            self.data = [self.ide_ele] * (self.N0 * 2)",
            "        def update_add(self, l, r, val):",
            "            l += self.N0",
            "            r += self.N0",
            "            while l < r:",
            "                if l & 1:",
            "                    self.data[l] += val",
            "                    l += 1",
            "                if r & 1:",
            "                    self.data[r - 1] += val",
            "                    r -= 1",
            "                l //= 2",
            "                r //= 2",
            "        def update(self, l, r, val):",
            "            l += self.N0",
            "            r += self.N0",
            "            while l < r:",
            "                if l & 1:",
            "                    self.data[l] = self.segfun(self.data[l], val)",
            "                    l += 1",
            "                if r & 1:",
            "                    self.data[r - 1] = self.segfun(self.data[r - 1], val)",
            "                    r -= 1",
            "                l //= 2",
            "                r //= 2",
            "        def query(self, i):",
            "            i += len(self.data) // 2",
            "            ret = self.data[i]",
            "            while i > 0:",
            "                i //= 2",
            "                ret = self.segfun(ret, self.data[i])",
            "            return ret",
            "    N, Q = LI()",
            "    X = []",
            "    for _ in range(N):",
            "        s,t,x = LI()",
            "        l = max(0,s-x)",
            "        r = t-x",
            "        X.append([x,l,r])",
            "    D = [I()for _ in range(Q)]",
            "    seg_min = SegmentTree(Q,inf,lambda a,b:min(a,b))",
            "    for x,l,r in X:",
            "        L = bisect.bisect_left(D,l)",
            "        R = bisect.bisect_left(D,r)",
            "        seg_min.update(L,R,x)",
            "    ans = []",
            "    for i in range(Q):",
            "        cur = seg_min.query(i)",
            "        if cur==inf:",
            "            ans.append(-1)",
            "        else:",
            "            ans.append(cur)",
            "    for v in ans:",
            "        print(v)",
            "    return",
            "import sys,bisect,itertools,heapq,math,random",
            "from copy import deepcopy",
            "from heapq import heappop,heappush,heapify",
            "from collections import Counter,defaultdict,deque",
            "def I(): return int(sys.stdin.readline())",
            "def LI(): return list(map(int,sys.stdin.readline().split()))",
            "def LSI(): return list(map(str,sys.stdin.readline().split()))",
            "def LS(): return sys.stdin.readline().split()",
            "def SI(): return sys.stdin.readline().strip()",
            "global mod,mod2,inf,alphabet,_ep",
            "mod = 10**9 + 7",
            "mod2 = 998244353",
            "inf = 10**18",
            "_ep = 10**(-12)",
            "alphabet = [chr(ord('a') + i) for i in range(26)]",
            "sys.setrecursionlimit(10**6)",
            "if __name__ == '__main__':",
            "    examF()",
            "\"\"\"",
            "\"\"\""
        ],
        "label": [
            2,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "def main():",
            "    import os",
            "    import sys",
            "    from io import BytesIO, IOBase",
            "    BUFSIZE = 8192",
            "    class FastIO(IOBase):",
            "        newlines = 0",
            "        def __init__(self, file):",
            "            self._fd = file.fileno()",
            "            self.buffer = BytesIO()",
            "            self.writable = \"x\" in file.mode or \"r\" not in file.mode",
            "            self.write = self.buffer.write if self.writable else None",
            "        def read(self):",
            "            while True:",
            "                b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
            "                if not b:",
            "                    break",
            "                ptr = self.buffer.tell()",
            "                self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
            "            self.newlines = 0",
            "            return self.buffer.read()",
            "        def readline(self):",
            "            while self.newlines == 0:",
            "                b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
            "                self.newlines = b.count(b\"\\n\") + (not b)",
            "                ptr = self.buffer.tell()",
            "                self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
            "            self.newlines -= 1",
            "            return self.buffer.readline()",
            "        def flush(self):",
            "            if self.writable:",
            "                os.write(self._fd, self.buffer.getvalue())",
            "                self.buffer.truncate(0), self.buffer.seek(0)",
            "    class IOWrapper(IOBase):",
            "        def __init__(self, file):",
            "            self.buffer = FastIO(file)",
            "            self.flush = self.buffer.flush",
            "            self.writable = self.buffer.writable",
            "            self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))",
            "            self.read = lambda: self.buffer.read().decode(\"ascii\")",
            "            self.readline = lambda: self.buffer.readline().decode(\"ascii\")",
            "    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)",
            "    input = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")",
            "    mod = 10**9 + 7",
            "    n, q = map(int, input().split())",
            "    stx = []",
            "    for _ in range(n):",
            "        s, t, x = map(int, input().split())",
            "        stx.append([x, s - x, t - x])",
            "    stx.sort(reverse=True)",
            "    d = [int(input()) for _ in range(q)]",
            "    N = q",
            "    N0 = 2**(N-1).bit_length()",
            "    data = [None]*(2*N0)",
            "    INF = (-1, 10**9 + 1)",
            "    def update(l, r, v):",
            "        L = l + N0; R = r + N0",
            "        while L < R:",
            "            if R & 1:",
            "                R -= 1",
            "                data[R-1] = v",
            "            if L & 1:",
            "                data[L-1] = v",
            "                L += 1",
            "            L >>= 1; R >>= 1",
            "    def _query(k):",
            "        k += N0-1",
            "        s = INF",
            "        while k >= 0:",
            "            if data[k]:",
            "                s = max(s, data[k])",
            "            k = (k - 1) // 2",
            "        return s",
            "    def query(k):",
            "        return _query(k)[1]",
            "    import bisect",
            "    for i, (x, start, last) in enumerate(stx):",
            "        l = bisect.bisect_left(d, start)",
            "        r = bisect.bisect_left(d, last)",
            "        update(l, r, (i, x))",
            "    for i in range(q):",
            "        res = query(i)",
            "        if res == 10**9 + 1:",
            "            print(-1)",
            "        else:",
            "            print(res)",
            "main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            2,
            2
        ]
    },
    {
        "content": [
            "# abc127_c.py",
            "# https://atcoder.jp/contests/abc127/tasks/abc127_c",
            "# C - Prison /",
            "# 実行時間制限: 2 sec / メモリ制限: 1024 MB",
            "# 配点 : 300点",
            "# 問題文",
            "# N枚の ID カードと M個のゲートがあります。",
            "# i番目のゲートは Li,Li+1,...,Ri 番目の ID カードのうちどれか 1枚を持っていれば通過できます。",
            "# 1枚だけで全てのゲートを通過できる ID カードは何枚あるでしょうか。",
            "# 制約",
            "#     入力は全て整数である。",
            "#     1≤N≤105",
            "#     1≤M≤105",
            "#     1≤Li≤Ri≤N",
            "# 入力",
            "# 入力は以下の形式で標準入力から与えられる。",
            "# N M",
            "# L1 R1",
            "# L2 R2",
            "# ⋮",
            "# LM RM",
            "# 出力",
            "# 1枚だけで全てのゲートを通過できる ID カードの枚数を出力せよ。",
            "# 入力例 1",
            "# 4 2",
            "# 1 3",
            "# 2 4",
            "# 出力例 1",
            "# 2",
            "# 以下のように、1",
            "# 枚だけで全てのゲートを通過できる ID カードは 2枚です。",
            "#     1番目の ID カードでは 2番目のゲートを通過できません。",
            "#     2番目の ID カードでは全てのゲートを通過できます。",
            "#     3番目の ID カードでは全てのゲートを通過できます。",
            "#     4番目の ID カードでは 1番目のゲートを通過できません。",
            "# 入力例 2",
            "# 10 3",
            "# 3 6",
            "# 5 7",
            "# 6 9",
            "# 出力例 2",
            "# 1",
            "# 入力例 3",
            "# 100000 1",
            "# 1 100000",
            "# 出力例 3",
            "# 100000",
            "global FLAG_LOG",
            "FLAG_LOG = False",
            "def log(value):",
            "    # FLAG_LOG = True",
            "    FLAG_LOG = False",
            "    if FLAG_LOG:",
            "        print(str(value))",
            "def calculation(lines):",
            "    # S = lines[0]",
            "    # N = int(lines[0])",
            "    N, M = list(map(int, lines[0].split()))",
            "    # values = list(map(int, lines[1].split()))",
            "    # values = list(map(int, lines[2].split()))",
            "    # values = list()",
            "    # for i in range(6):",
            "    #     values.append(int(lines[i]))",
            "    valueses = list()",
            "    for i in range(M):",
            "        valueses.append(list(map(int, lines[i+1].split())))",
            "    ll = None",
            "    rr = None",
            "    log(f'valueses=[{valueses}]')",
            "    for i in range(M):",
            "        l = valueses[i][0]",
            "        r = valueses[i][1]",
            "        if ll is None:",
            "            ll = l",
            "        elif ll < l:",
            "            ll = l",
            "        else:",
            "            log(f'll=[{l}], l=[{l}]')",
            "        if rr is None:",
            "            rr = r",
            "        elif rr > r:",
            "            rr = r",
            "        else:",
            "            log(f'rr=[{rr}], r=[{r}]')",
            "    log(f'l=[{l}]')",
            "    log(f'r=[{r}]')",
            "    return [max(rr-ll+1, 0)]",
            "# 引数を取得",
            "def get_input_lines():",
            "    line = input()",
            "    N, M = list(map(int, line.split()))",
            "    lines = list()",
            "    lines.append(line)",
            "    for _ in range(M):",
            "        lines.append(input())",
            "    return lines",
            "# テストデータ",
            "def get_testdata(pattern):",
            "    if pattern == 1:",
            "        lines_input = ['4 2', '1 3', '2 4']",
            "        lines_export = [2]",
            "    if pattern == 2:",
            "        lines_input = ['10 3','3 6', '5 7', '6 9']",
            "        lines_export = [1]",
            "    if pattern == 3:",
            "        lines_input = ['100000 1', '1 100000']",
            "        lines_export = [100000]",
            "    return lines_input, lines_export",
            "# 動作モード判別",
            "def get_mode():",
            "    import sys",
            "    args = sys.argv",
            "    global FLAG_LOG",
            "    if len(args) == 1:",
            "        mode = 0",
            "        FLAG_LOG = False",
            "    else:",
            "        mode = int(args[1])",
            "        FLAG_LOG = True",
            "    return mode",
            "# 主処理",
            "def main():",
            "    import time",
            "    started = time.time()",
            "    mode = get_mode()",
            "    if mode == 0:",
            "        lines_input = get_input_lines()",
            "    else:",
            "        lines_input, lines_export = get_testdata(mode)",
            "    lines_result = calculation(lines_input)",
            "    for line_result in lines_result:",
            "        print(line_result)",
            "    # if mode > 0:",
            "    #     print(f'lines_input=[{lines_input}]')",
            "    #     print(f'lines_export=[{lines_export}]')",
            "    #     print(f'lines_result=[{lines_result}]')",
            "    #     if lines_result == lines_export:",
            "    #         print('OK')",
            "    #     else:",
            "    #         print('NG')",
            "    # finished = time.time()",
            "    # duration = finished - started",
            "    # print(f'duration=[{duration}]')",
            "# 起動処理",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "def examA():",
            "    C1 = SI()",
            "    C2 = SI()",
            "    ans = \"YES\"",
            "    if C1[0]!=C2[2] or C1[1]!=C2[1] or C1[2]!=C2[0]:",
            "        ans = \"NO\"",
            "    print(ans)",
            "    return",
            "def examB():",
            "    A, B, C, X, Y = LI()",
            "    loop = max(X,Y)",
            "    ans = inf",
            "    for i in range(loop+1):",
            "        cost = i*2*C",
            "        if X>i:",
            "            cost += A*(X-i)",
            "        if Y>i:",
            "            cost += B*(Y-i)",
            "        ans = min(ans,cost)",
            "    print(ans)",
            "    return",
            "def examC():",
            "    def gcd(x, y):",
            "        if y == 0:",
            "            return x",
            "        while (y != 0):",
            "            x, y = y, x % y",
            "        return x",
            "    N, x = LI()",
            "    X = LI()",
            "    if N==1:",
            "        print(abs(X[0]-x))",
            "        return",
            "    for i in range(N):",
            "        X[i] = abs(X[i]-x)",
            "    now = gcd(X[0],X[1])",
            "    for i in range(2,N):",
            "        now = gcd(now,X[i])",
            "    ans = now",
            "    print(ans)",
            "    return",
            "def examD():",
            "    N = I()",
            "    C = [LI()for _ in range(N-1)]",
            "    ans = [inf]*N",
            "    for i in range(N):",
            "        cur = 0",
            "        for j in range(i,N-1):",
            "            c, s, f = C[j]",
            "            next = 0",
            "            if cur<=s:",
            "                cur = s+c",
            "            else:",
            "                cur = (1+(cur-1)//f)*f + c",
            "        ans[i] = cur",
            "    for v in ans:",
            "        print(v)",
            "    return",
            "def examE():",
            "    N, C = LI()",
            "    S = defaultdict(list)",
            "    S = [LI()for _ in range(N)]",
            "    ans = C",
            "    print(ans)",
            "    return",
            "def examF():",
            "    class combination():",
            "        # 素数のmod取るときのみ　速い",
            "        def __init__(self, n, mod):",
            "            self.n = n",
            "            self.mod = mod",
            "            self.fac = [1] * (n + 1)",
            "            self.inv = [1] * (n + 1)",
            "            for j in range(1, n + 1):",
            "                self.fac[j] = self.fac[j - 1] * j % mod",
            "            self.inv[n] = pow(self.fac[n], mod - 2, mod)",
            "            for j in range(n - 1, -1, -1):",
            "                self.inv[j] = self.inv[j + 1] * (j + 1) % mod",
            "        def comb(self, n, r):",
            "            if r > n or n < 0 or r < 0:",
            "                return 0",
            "            return self.fac[n] * self.inv[n - r] * self.inv[r] % self.mod",
            "    N, M, K = LI()",
            "    B = N*M",
            "    C = combination(B,mod)",
            "    ans = 0",
            "    for i in range(N):",
            "        for j in range(M):",
            "            if i>0 and j>0:",
            "                ans += (i+j)*(N - i) * (M - j) * C.comb(B - 2, K-2) *2",
            "            else:",
            "                ans += (i+j)*(N - i) * (M - j) * C.comb(B - 2, K-2)",
            "            ans %= mod",
            "            #print(ans)",
            "    print(ans)",
            "    return",
            "from decimal import Decimal as dec",
            "import sys,bisect,itertools,heapq,math,random",
            "from copy import deepcopy",
            "from heapq import heappop,heappush,heapify",
            "from collections import Counter,defaultdict,deque",
            "read = sys.stdin.buffer.read",
            "readline = sys.stdin.buffer.readline",
            "readlines = sys.stdin.buffer.readlines",
            "def I(): return int(input())",
            "def LI(): return list(map(int,sys.stdin.readline().split()))",
            "def DI(): return dec(input())",
            "def LDI(): return list(map(dec,sys.stdin.readline().split()))",
            "def LSI(): return list(map(str,sys.stdin.readline().split()))",
            "def LS(): return sys.stdin.readline().split()",
            "def SI(): return sys.stdin.readline().strip()",
            "global mod,mod2,inf,alphabet,_ep",
            "mod = 10**9 + 7",
            "mod2 = 998244353",
            "inf = 10**18",
            "_ep = 10**(-12)",
            "alphabet = [chr(ord('a') + i) for i in range(26)]",
            "sys.setrecursionlimit(10**7)",
            "if __name__ == '__main__':",
            "    examF()",
            "\"\"\"",
            "142",
            "12 9 1445 0 1",
            "asd dfg hj o o",
            "aidn",
            "\"\"\""
        ],
        "label": [
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "###############################################################################",
            "from sys import stdout",
            "from bisect import bisect_left as binl",
            "from copy import copy, deepcopy",
            "from collections import defaultdict",
            "import math",
            "mod = 1",
            "def intin():",
            "    input_tuple = input().split()",
            "    if len(input_tuple) <= 1:",
            "        return int(input_tuple[0])",
            "    return tuple(map(int, input_tuple))",
            "def intina():",
            "    return [int(i) for i in input().split()]",
            "def intinl(count):",
            "    return [intin() for _ in range(count)]",
            "def modadd(x, y):",
            "    global mod",
            "    return (x + y) % mod",
            "def modmlt(x, y):",
            "    global mod",
            "    return (x * y) % mod",
            "def lcm(x, y):",
            "    while y != 0:",
            "        z = x % y",
            "        x = y",
            "        y = z",
            "    return x",
            "def combination(x, y):",
            "    assert(x >= y)",
            "    ret = math.factorial(x)",
            "    ret = ret // (math.factorial(x - y) * math.factorial(y))",
            "    return ret",
            "def get_divisors(x):",
            "    retlist = []",
            "    for i in range(1, int(x**0.5) + 3):",
            "        if x % i == 0:",
            "            retlist.append(i)",
            "            retlist.append(x // i)",
            "    return retlist",
            "def get_factors(x):",
            "    retlist = []",
            "    for i in range(2, int(x**0.5) + 3):",
            "        while x % i == 0:",
            "            retlist.append(i)",
            "            x = x // i",
            "    retlist.append(x)",
            "    return retlist",
            "def make_linklist(xylist):",
            "    linklist = {}",
            "    for a, b in xylist:",
            "        linklist.setdefault(a, [])",
            "        linklist.setdefault(b, [])",
            "        linklist[a].append(b)",
            "        linklist[b].append(a)",
            "    return linklist",
            "def calc_longest_distance(linklist, v=1):",
            "    distance_list = {}",
            "    distance_count = 0",
            "    distance = 0",
            "    vlist_previous = []",
            "    vlist = [v]",
            "    nodecount = len(linklist)",
            "    while distance_count < nodecount:",
            "        vlist_next = []",
            "        for v in vlist:",
            "            distance_list[v] = distance",
            "            distance_count += 1",
            "            vlist_next.extend(linklist[v])",
            "        distance += 1",
            "        vlist_to_del = vlist_previous",
            "        vlist_previous = vlist",
            "        vlist = list(set(vlist_next) - set(vlist_to_del))",
            "    max_distance = -1",
            "    max_v = None",
            "    for v, distance in distance_list.items():",
            "        if distance > max_distance:",
            "            max_distance = distance",
            "            max_v = v",
            "    return (max_distance, max_v)",
            "def calc_tree_diameter(linklist, v=1):",
            "    _, u = calc_longest_distance(linklist, v)",
            "    distance, _ = calc_longest_distance(linklist, u)",
            "    return distance",
            "class UnionFind:",
            "    def __init__(self, n):",
            "        self.parent = [i for i in range(n)]",
            "    def root(self, i):",
            "        if self.parent[i] == i:",
            "            return i",
            "        self.parent[i] = self.root(self.parent[i])",
            "        return self.parent[i]",
            "    def unite(self, i, j):",
            "        rooti = self.root(i)",
            "        rootj = self.root(j)",
            "        if rooti == rootj:",
            "            return",
            "        if rooti < rootj:",
            "            self.parent[rootj] = rooti",
            "        else:",
            "            self.parent[rooti] = rootj",
            "    def same(self, i, j):",
            "        return self.root(i) == self.root(j)",
            "###############################################################################",
            "mod = 10**9 + 7",
            "def main():",
            "    n, m, k = intin()",
            "    c = combination(n * m - 2, k - 2) % mod",
            "    x_ans = ((n - 1) * n * (n + 1)) // 6",
            "    x_ans = modmlt(x_ans, m)",
            "    x_ans = modmlt(x_ans, m)",
            "    x_ans = modmlt(x_ans, c)",
            "    y_ans = ((m - 1) * m * (m + 1)) // 6",
            "    y_ans = modmlt(y_ans, n)",
            "    y_ans = modmlt(y_ans, n)",
            "    y_ans = modmlt(y_ans, c)",
            "    print(modadd(x_ans, y_ans))",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!usr/bin/env python3",
            "from collections import defaultdict",
            "from collections import deque",
            "from heapq import heappush, heappop",
            "import sys",
            "import math",
            "import bisect",
            "import random",
            "def LI(): return list(map(int, sys.stdin.readline().split()))",
            "def I(): return int(sys.stdin.readline())",
            "def LS():return list(map(list, sys.stdin.readline().split()))",
            "def S(): return list(sys.stdin.readline())[:-1]",
            "def IR(n):",
            "    l = [None for i in range(n)]",
            "    for i in range(n):l[i] = I()",
            "    return l",
            "def LIR(n):",
            "    l = [None for i in range(n)]",
            "    for i in range(n):l[i] = LI()",
            "    return l",
            "def SR(n):",
            "    l = [None for i in range(n)]",
            "    for i in range(n):l[i] = S()",
            "    return l",
            "def LSR(n):",
            "    l = [None for i in range(n)]",
            "    for i in range(n):l[i] = LS()",
            "    return l",
            "sys.setrecursionlimit(1000000)",
            "mod = 1000000007",
            "#A",
            "def A():",
            "    return",
            "#B",
            "def B():",
            "    return",
            "#C",
            "def C():",
            "    n,m = LI()",
            "    t = [0 for i in range(n+1)]",
            "    for i in range(m):",
            "        l,r = LI()",
            "        t[l-1] += 1",
            "        t[r] -= 1",
            "    for i in range(n):",
            "        t[i+1] += t[i]",
            "        if t[i] == m:",
            "            t[i] = 1",
            "        else:",
            "            t[i] = 0",
            "    print(sum(t[:n]))",
            "    return",
            "#D",
            "def D():",
            "    n,m = LI()",
            "    a = LI()",
            "    q = []",
            "    for i in range(n):",
            "        heappush(q,a[i])",
            "    l = LIR(m)",
            "    l.sort(key = lambda x:-x[1])",
            "    for b,c in l:",
            "        for i in range(b):",
            "            x = heappop(q)",
            "            if x < c:",
            "                x = c",
            "                heappush(q,x)",
            "            else:",
            "                heappush(q,x)",
            "                break",
            "    print(sum(q))",
            "    return",
            "#E",
            "def E():",
            "    n,m,k = LI()",
            "    M = n*m",
            "    fact = [1]*(M+1)",
            "    for i in range(M):",
            "        fact[i+1] = fact[i]*(i+1)%mod",
            "    inv = [1]*(M+1)",
            "    inv[M] = pow(fact[M],mod-2,mod)",
            "    for i in range(M)[::-1]:",
            "        inv[i] = inv[i+1]*(i+1)%mod",
            "    ans = fact[M-2]*inv[k-2]*inv[M-k]%mod",
            "    s = 0",
            "    for i in range(1,M):",
            "        s += i*(max(0,n-i)*m**2+max(0,m-i)*n**2)%mod",
            "        s %= mod",
            "    ans = ans*s%mod",
            "    print(ans)",
            "    return",
            "#F",
            "def F():",
            "    q = I()",
            "    m = 0",
            "    l = [-float(\"inf\"),float(\"inf\")]",
            "    x = 0",
            "    num = 0",
            "    for _ in range(q):",
            "        Q = LI()",
            "        if len(Q) == 1:",
            "            print(x,m)",
            "        else:",
            "            z,a,b = Q",
            "            m += b",
            "            if num == 0:",
            "                num += 1",
            "                l = [a,float(\"inf\")]",
            "                x = a",
            "            elif num == 1:",
            "                if a != l[0]:",
            "                    num += 1",
            "                    l = [min(a,l[0]),max(a,l[0])]",
            "                    x = l[0]",
            "                    m += l[1]-l[0]",
            "            else:",
            "                num += 1",
            "                if num % 2:",
            "                    if l[0] <= a < l[1]:",
            "                        m += min(a-l[0],l[1]-a)",
            "                        x = a",
            "                    elif a < l[0]:",
            "                        m += l[0]-a",
            "                        x = l[0]",
            "                        l = [a,l[1]]",
            "                    else:",
            "                        m += a-l[1]",
            "                        x = l[1]",
            "                        l = [l[0],a]",
            "                else:",
            "                    if l[0] <= a < l[1]:",
            "                        if a < x:",
            "                            m += x-a",
            "                            l = [a,x]",
            "                            x = a",
            "                        else:",
            "                            m += a-x",
            "                            l = [x,a]",
            "                    elif a < l[0]:",
            "                        m += x-a",
            "                        x = l[0]",
            "                        l = [l[0],x]",
            "                    else:",
            "                        m += a-x",
            "                        l = [x,l[1]]",
            "    return",
            "#G",
            "def G():",
            "    return",
            "#H",
            "def H():",
            "    return",
            "#I",
            "def I_():",
            "    return",
            "#J",
            "def J():",
            "    return",
            "#Solve",
            "if __name__ == \"__main__\":",
            "    E()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            1,
            1,
            1,
            2,
            1,
            1,
            1,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product                # product(iter, repeat=n)",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4",
            "def main():",
            "    mod = 1000000007                  # 10^9+7",
            "    inf = float('inf')",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():  return int(input())",
            "    def mi():  return map(int, input().split())",
            "    def mi_0(): return map(lambda x: int(x)-1, input().split())",
            "    def lmi(): return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():  return list(input())",
            "    class UnionFindTree:",
            "        def __init__(self, num_of_elm):",
            "            self.n = num_of_elm",
            "            self.table = [i for i in range(self.n)]",
            "            self.rank = [0] * self.n",
            "            self.group_size = [1] * self.n",
            "        def _find_set(self, x):",
            "            parent = self.table[x]",
            "            if x == parent:",
            "                return x",
            "            else:",
            "                root = self._find_set(parent)",
            "                # 経路圧縮",
            "                self.table[x] = root",
            "                return root",
            "        def is_same(self, x, y):",
            "            return self._find_set(x) == self._find_set(y)",
            "        def union(self, x, y):",
            "            shallow_root = self._find_set(x)",
            "            deep_root = self._find_set(y)",
            "            if self.rank[shallow_root] > self.rank[deep_root]:",
            "                shallow_root, deep_root = deep_root, shallow_root",
            "            # そもそも同一グループだった時",
            "            if shallow_root == deep_root:",
            "                return False",
            "            # グループが異なるので union",
            "            else:",
            "                self.table[shallow_root] = deep_root",
            "                self.group_size[deep_root] += self.group_size[shallow_root]",
            "                # 深さが等しかったときはつけ加えられた側の rank をインクリメントする",
            "                if self.rank[shallow_root] == self.rank[deep_root]:",
            "                    self.rank[deep_root] += 1",
            "                return True",
            "        def akin_num(self, x):",
            "            x_root = self._find_set(x)",
            "            return self.group_size[x_root]",
            "        def print_group_id(self):",
            "            print([self._find_set(x) for x in self.table])",
            "    n, m = mi()",
            "    uf = UnionFindTree(n)",
            "    groups = n",
            "    for _ in range(m):",
            "        x, y, _ = mi()",
            "        x -= 1",
            "        y -= 1",
            "        if uf.union(x, y):",
            "            groups -= 1",
            "    print(groups)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#import sys",
            "MOD = 10 ** 9 + 7",
            "INFI = 10**10",
            "#input = sys.stdin.readline",
            "import math",
            "from collections import deque",
            "import itertools",
            "import heapq",
            "#import bisect",
            "from fractions import Fraction",
            "import copy",
            "from functools import lru_cache",
            "from collections import defaultdict",
            "import pprint",
            "#oo=list(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")",
            "# ko=list(\"abcdefghijklmnopqrstuvwxyz\")",
            "def sosuhante(n):",
            "    for k in range(2, int(math.sqrt(n))+1):",
            "        if n% k ==0:",
            "            return False",
            "    return True",
            "def cmb(n, r):",
            "    if n - r < r: r = n - r",
            "    if r == 0: return 1",
            "    if r == 1: return n",
            "    numerator = [n - r + k + 1 for k in range(r)]",
            "    denominator = [k + 1 for k in range(r)]",
            "    for p in range(2,r+1):",
            "        pivot = denominator[p - 1]",
            "        if pivot > 1:",
            "            offset = (n - r) % p",
            "            for k in range(p-1,r,p):",
            "                numerator[k - offset] /= pivot",
            "                denominator[k] /= pivot",
            "    result = 1",
            "    for k in range(r):",
            "        if numerator[k] > 1:",
            "            result *= int(numerator[k])",
            "    return result",
            "def kingaku(a,b,n):",
            "    keta=len(str(n))",
            "    return a*n+b*keta",
            "def my_index(l, x, default=False):",
            "    if x in l:",
            "        return l.index(x)",
            "    else:",
            "        return default",
            "#    h,w,a,b = map(int, input().split())",
            "#    c = [[0 for j in range(n)] for i in range(n)]",
            "def ret(a):",
            "    c=[None]*(len(a)-1)",
            "    if len(a)==1:",
            "        return a[0]",
            "    elif len(a)==0:",
            "        return 0",
            "    for i in range(1,len(a)):",
            "        c[i-1]=abs(a[i]-a[i-1])",
            "    return ret(c)",
            "def soinsubunkai(n):",
            "    a = []",
            "    i = 1",
            "    while i*i <= n:",
            "        if n % i == 0 and i!=1:",
            "            a.append(i)",
            "            n=n//i",
            "        if n% i !=0 or i==1:",
            "            i += 1",
            "    nokori=[n]",
            "    return a + nokori",
            "def make_divisors(n):",
            "    lower_divisors , upper_divisors = [], []",
            "    i = 1",
            "    while i*i <= n:",
            "        if n % i == 0:",
            "            lower_divisors.append(i)",
            "            if i != n // i:",
            "                upper_divisors.append(n//i)",
            "        i += 1",
            "    return lower_divisors + upper_divisors[::-1]",
            "def main():",
            "    n,m=map(int,input().split())",
            "    graph=[[] for _ in range(n+1)]",
            "    for i in range(m):",
            "        a,b,c=map(int,input().split())",
            "        graph[a].append(b)",
            "        graph[b].append(a)",
            "    stack=[]",
            "    visited=[0 for _ in range(n+1)]",
            "    zones=0",
            "    count=0",
            "    def DFS():",
            "        c=1",
            "        while True:",
            "            if len(stack)==0:",
            "                break",
            "            s=stack.pop()",
            "            if visited[s]==0:",
            "                for i in graph[s]:",
            "                    if visited[i]==0:",
            "                        stack.append(i)",
            "                visited[s]=1",
            "                c+=1",
            "            if len(stack)==0:",
            "                break",
            "        return c",
            "    for i in range(1,n+1):",
            "        if visited[i]==0:",
            "            visited[i]=1",
            "            for j in graph[i]:",
            "                stack.append(j)",
            "            if len(stack)>0:",
            "                count+=DFS()",
            "                zones += 1",
            "        else:",
            "            continue",
            "#    print(n,count,zones)",
            "    print(n-count+zones)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1
        ]
    },
    {
        "content": [
            "mod = 10 ** 9 + 7",
            "mod2 = 2**61+1",
            "from collections import deque",
            "import heapq",
            "from bisect import bisect_left, insort_left, bisect_right",
            "def iip(listed):",
            "    ret = [int(i) for i in input().split()]",
            "    if len(ret) == 1 and not listed:",
            "        return ret[0]",
            "    return ret",
            "def iip_ord():",
            "    return [ord(i) - ord(\"a\") for i in input()]",
            "def main():",
            "    ans = solve()",
            "    if ans is not None:",
            "        print(ans)",
            "class union_find():",
            "    def __init__(self, id):",
            "        self.parent = None",
            "        self.id = id",
            "    def root(self):",
            "        if not self.parent:",
            "            return self",
            "        else:",
            "            return self.parent.root()",
            "    def union(self, target):",
            "        sr = self.root().id",
            "        tr = target.root().id",
            "        if sr == tr:",
            "            return",
            "        elif sr > tr:",
            "            self.root().parent = target.root()",
            "        else:",
            "            target.root().parent = self.root()",
            "def solve():",
            "    N, M = iip(False)",
            "    uf = [union_find(i) for i in range(N)]",
            "    for i in range(M):",
            "        x, y, _ = iip(True)",
            "        uf[x-1].union(uf[y-1])",
            "    uf = set([i.root().id for i in uf])",
            "    #print(uf)",
            "    print(len(uf))",
            "#####################################################ライブラリ集ここから",
            "def split_print_space(s):",
            "    print(\" \".join([str(i) for i in s]))",
            "def split_print_enter(s):",
            "    print(\"\\n\".join([str(i) for i in s]))",
            "def koenai_saidai_x_index(sorted_list, n):",
            "    l = 0",
            "    r = len(sorted_list)",
            "    if len(sorted_list) == 0:",
            "        return False",
            "    if sorted_list[0] > n:",
            "        return False",
            "    while r - l > 1:",
            "        x = (l + r) // 2",
            "        if sorted_list[x] == n:",
            "            return x",
            "        elif sorted_list[x] > n:",
            "            r = x",
            "        else:",
            "            l = x",
            "    return l",
            "def searchsorted(sorted_list, n, side):",
            "    if side not in [\"right\", \"left\"]:",
            "        raise Exception(\"sideはrightかleftで指定してください\")",
            "    l = 0",
            "    r = len(sorted_list)",
            "    if n > sorted_list[-1]:",
            "        # print(sorted_list)",
            "        return len(sorted_list)",
            "    if n < sorted_list[0]:",
            "        return 0",
            "    while r - l > 1:",
            "        x = (l + r) // 2",
            "        if sorted_list[x] > n:",
            "            r = x",
            "        elif sorted_list[x] < n:",
            "            l = x",
            "        else:",
            "            if side == \"left\":",
            "                r = x",
            "            elif side == \"right\":",
            "                l = x",
            "    if side == \"left\":",
            "        if sorted_list[l] == n:",
            "            return r - 1",
            "        else:",
            "            return r",
            "    if side == \"right\":",
            "        if sorted_list[l] == n:",
            "            return l + 1",
            "        else:",
            "            return l",
            "def soinsuu_bunkai(n):",
            "    ret = []",
            "    for i in range(2, int(n ** 0.5) + 1):",
            "        while n % i == 0:",
            "            n //= i",
            "            ret.append(i)",
            "        if i > n:",
            "            break",
            "    if n != 1:",
            "        ret.append(n)",
            "    return ret",
            "def conbination(n, r, mod, test=False):",
            "    if n <= 0:",
            "        return 0",
            "    if r == 0:",
            "        return 1",
            "    if r < 0:",
            "        return 0",
            "    if r == 1:",
            "        return n",
            "    ret = 1",
            "    for i in range(n - r + 1, n + 1):",
            "        ret *= i",
            "        ret = ret % mod",
            "    bunbo = 1",
            "    for i in range(1, r + 1):",
            "        bunbo *= i",
            "        bunbo = bunbo % mod",
            "    ret = (ret * inv(bunbo, mod)) % mod",
            "    if test:",
            "        # print(f\"{n}C{r} = {ret}\")",
            "        pass",
            "    return ret",
            "def inv(n, mod):",
            "    return power(n, mod - 2)",
            "def power(n, p, mod_= mod):",
            "    if p == 0:",
            "        return 1",
            "    if p % 2 == 0:",
            "        return (power(n, p // 2, mod_) ** 2) % mod_",
            "    if p % 2 == 1:",
            "        return (n * power(n, p - 1, mod_)) % mod_",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#    Copyright 2016-2019 NetworkX developers.",
            "#    Copyright (C) 2004-2019 by",
            "#    Aric Hagberg <hagberg@lanl.gov>",
            "#    Dan Schult <dschult@colgate.edu>",
            "#    Pieter Swart <swart@lanl.gov>",
            "#    All rights reserved.",
            "#    BSD license.",
            "\"\"\"",
            "Union-find data structure.",
            "\"\"\"",
            "from networkx.utils import groups",
            "class UnionFind:",
            "    \"\"\"Union-find data structure.",
            "    Each unionFind instance X maintains a family of disjoint sets of",
            "    hashable objects, supporting the following two methods:",
            "    - X[item] returns a name for the set containing the given item.",
            "      Each set is named by an arbitrarily-chosen one of its members; as",
            "      long as the set remains unchanged it will keep the same name. If",
            "      the item is not yet part of a set in X, a new singleton set is",
            "      created for it.",
            "    - X.union(item1, item2, ...) merges the sets containing each item",
            "      into a single larger set.  If any item is not yet part of a set",
            "      in X, it is added to X as one of the members of the merged set.",
            "      Union-find data structure. Based on Josiah Carlson's code,",
            "      http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/215912",
            "      with significant additional changes by D. Eppstein.",
            "      http://www.ics.uci.edu/~eppstein/PADS/UnionFind.py",
            "    \"\"\"",
            "    def __init__(self, elements=None):",
            "        \"\"\"Create a new empty union-find structure.",
            "        If *elements* is an iterable, this structure will be initialized",
            "        with the discrete partition on the given set of elements.",
            "        \"\"\"",
            "        if elements is None:",
            "            elements = ()",
            "        self.parents = {}",
            "        self.weights = {}",
            "        for x in elements:",
            "            self.weights[x] = 1",
            "            self.parents[x] = x",
            "    def __getitem__(self, object):",
            "        \"\"\"Find and return the name of the set containing the object.\"\"\"",
            "        # check for previously unknown object",
            "        if object not in self.parents:",
            "            self.parents[object] = object",
            "            self.weights[object] = 1",
            "            return object",
            "        # find path of objects leading to the root",
            "        path = [object]",
            "        root = self.parents[object]",
            "        while root != path[-1]:",
            "            path.append(root)",
            "            root = self.parents[root]",
            "        # compress the path and return",
            "        for ancestor in path:",
            "            self.parents[ancestor] = root",
            "        return root",
            "    def __iter__(self):",
            "        \"\"\"Iterate through all items ever found or unioned by this structure.",
            "        \"\"\"",
            "        return iter(self.parents)",
            "    def to_sets(self):",
            "        \"\"\"Iterates over the sets stored in this structure.",
            "        For example::",
            "            >>> partition = UnionFind('xyz')",
            "            >>> sorted(map(sorted, partition.to_sets()))",
            "            [['x'], ['y'], ['z']]",
            "            >>> partition.union('x', 'y')",
            "            >>> sorted(map(sorted, partition.to_sets()))",
            "            [['x', 'y'], ['z']]",
            "        \"\"\"",
            "        # Ensure fully pruned paths",
            "        for x in self.parents.keys():",
            "            _ = self[x]  # Evaluated for side-effect only",
            "        # TODO In Python 3.3+, this should be `yield from ...`.",
            "        for block in groups(self.parents).values():",
            "            yield block",
            "    def union(self, *objects):",
            "        \"\"\"Find the sets containing the objects and merge them all.\"\"\"",
            "        roots = [self[x] for x in objects]",
            "        # Find the heaviest root according to its weight.",
            "        heaviest = max(roots, key=lambda r: self.weights[r])",
            "        for r in roots:",
            "            if r != heaviest:",
            "                self.weights[heaviest] += self.weights[r]",
            "                self.parents[r] = heaviest",
            "def main():",
            "    N, M = map(int, input().split())",
            "    XYZ = [list(map(int, input().split())) for _ in range(M)]",
            "    u = UnionFind(range(1, N + 1))",
            "    for x, y, z in XYZ:",
            "        u.union(x, y)",
            "    print(len(list(u.to_sets())))",
            "main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def isp():   return input().split()",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    m, k = mi()",
            "    if k >= 2 ** m:",
            "        print(-1)",
            "    elif m == 1:",
            "        if k == 0:",
            "            print('0 0 1 1')",
            "        else:",
            "            print(-1)",
            "    else:",
            "        left = [i for i in range(2**m) if i != k]",
            "        L = left + [k] + list(reversed(left)) + [k]",
            "        print(*L)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math, cmath",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import _heapify_max, _heappop_max, _siftdown_max",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    Num = Union[int, float]",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def isp():   return input().split()",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    # def _heappush_max(h, item): h.append(item); _siftdown_max(h, 0, len(h)-1)",
            "    red, green, blue, n = mi()",
            "    cnt = 0",
            "    for r in range(n // red + 1):",
            "        for g in range(n // green + 1):",
            "            if r * red + g * green > n:",
            "                break",
            "            res = n - (r * red + g * green)",
            "            if res % blue == 0:",
            "                cnt += 1",
            "    print(cnt)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math, cmath",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import _heapify_max, _heappop_max, _siftdown_max",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    Num = Union[int, float]",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def isp():   return input().split()",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    # def _heappush_max(h, item): h.append(item); _siftdown_max(h, 0, len(h)-1)",
            "    n = ii()",
            "    b_a, b_start, a_end = 0, 0, 0",
            "    ans = 0",
            "    for _ in range(n):",
            "        s = input()",
            "        ans += s.count('AB')",
            "        if s[0] == 'B' and s[-1] == 'A':",
            "            b_a += 1",
            "        elif s[0] == 'B':",
            "            b_start += 1",
            "        elif s[-1] == 'A':",
            "            a_end += 1",
            "    # print(b_a, b_start, a_end)",
            "    # m = min(b_start, a_end)",
            "    # ans += m",
            "    # b_start -= m",
            "    # a_end -= m",
            "    # if max(b_start, a_end) > 0:",
            "    #     ans += b_a",
            "    # else:",
            "    #     ans += max(b_a - 1, 0)",
            "    # print(ans)",
            "    if b_start and a_end:",
            "        if b_a:",
            "            ans += (b_a + 1)",
            "            b_start -= 1",
            "            a_end -= 1",
            "        ans += min(b_start, a_end)",
            "    elif b_start or a_end:",
            "        ans += b_a",
            "    else:",
            "        ans += max(b_a - 1, 0)",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math, cmath",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import _heapify_max, _heappop_max, _siftdown_max",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    Num = Union[int, float]",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def isp():   return input().split()",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    # def _heappush_max(h, item): h.append(item); _siftdown_max(h, 0, len(h)-1)",
            "    def enum_divisor(num: int) -> List[int]:",
            "        '''",
            "        O(√n) で約数列挙を行う",
            "        >>> enum_divisor(4)",
            "        [1, 2, 4]",
            "        >>> enum_divisor(19)",
            "        [1, 19]",
            "        >>> enum_divisor(100)",
            "        [1, 2, 4, 5, 10, 20, 25, 50, 100]",
            "        '''",
            "        if num < 1:",
            "            raise ValueError(f'enum_divisor(): argument should be >= 1. got {num}')",
            "        divisor_small = []",
            "        divisor_large = []",
            "        i = 1",
            "        while i ** 2 <= num:",
            "            if num % i == 0:",
            "                divisor_small.append(i)",
            "                if i != num // i:",
            "                    divisor_large.append(num // i)",
            "            i += 1",
            "        divisor_large.reverse()",
            "        return divisor_small + divisor_large",
            "    n = ii()",
            "    ans = 0",
            "    divisor = enum_divisor(n)",
            "    for num in divisor:",
            "        if num <= 2:",
            "            continue",
            "        r = n // num",
            "        m = num - 1",
            "        if 1 <= r <= m - 1:",
            "            ans += m",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# input()",
            "# int(input())",
            "# map(int, input().split())",
            "# list(map(int, input().split()))",
            "# list(map(int, list(input()))) # スペースがない数字リストを読み込み",
            "import math",
            "import fractions",
            "import sys",
            "import bisect",
            "import heapq  # 優先度付きキュー(最小値取り出し)",
            "import collections",
            "from collections import Counter",
            "from collections import deque",
            "import pprint",
            "import itertools",
            "sr = lambda: input()",
            "ir = lambda: int(sr())",
            "lr = lambda: list(map(int, sr().split()))",
            "\"\"\"nを素因数分解\"\"\"",
            "\"\"\"2以上の整数n => [[素因数, 指数], ...]の2次元リスト\"\"\"",
            "def factorization(n):",
            "    arr = []",
            "    temp = n",
            "    if n == 1:",
            "        return arr",
            "    for i in range(2, int(-(-n ** 0.5 // 1)) + 1):",
            "        if temp % i == 0:",
            "            cnt = 0",
            "            while temp % i == 0:",
            "                cnt += 1",
            "                temp //= i",
            "            arr.append([i, cnt])",
            "    if temp != 1:",
            "        arr.append([temp, 1])",
            "    if arr == []:",
            "        arr.append([n, 1])",
            "    return arr",
            "# a^n",
            "def power(a, n, mod):",
            "    x = 1",
            "    while n:",
            "        if n & 1:",
            "            x *= a % mod",
            "        n >>= 1",
            "        a *= a % mod",
            "    return x % mod",
            "# n*(n-1)*...*(l+1)*l",
            "def kaijo(n, l, mod):",
            "    if n == 0:",
            "        return 1",
            "    a = n",
            "    tmp = n - 1",
            "    while (tmp >= l):",
            "        a = a * tmp % mod",
            "        tmp -= 1",
            "    return a",
            "# Union Find",
            "class UnionFind():",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parents = [-1] * n",
            "    def find(self, x):",
            "        if self.parents[x] < 0:",
            "            return x",
            "        else:",
            "            self.parents[x] = self.find(self.parents[x])",
            "            return self.parents[x]",
            "    def union(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "        if x == y:",
            "            return",
            "        if self.parents[x] > self.parents[y]:",
            "            x, y = y, x",
            "        self.parents[x] += self.parents[y]",
            "        self.parents[y] = x",
            "    def size(self, x):",
            "        return -self.parents[self.find(x)]",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "    def members(self, x):",
            "        root = self.find(x)",
            "        return [i for i in range(self.n) if self.find(i) == root]",
            "    def roots(self):",
            "        return [i for i, x in enumerate(self.parents) if x < 0]",
            "    def group_count(self):",
            "        return len(self.roots())",
            "    def all_group_members(self):",
            "        return {r: self.members(r) for r in self.roots()}",
            "    def __str__(self):",
            "        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())",
            "# 約数生成",
            "def make_divisors(n):",
            "    divisors = []",
            "    for i in range(1, int(n**0.5)+1):",
            "        if n % i == 0:",
            "            divisors.append(i)",
            "            if i != n // i:",
            "                divisors.append(n//i)",
            "    divisors.sort()",
            "    return divisors",
            "inf = 10 ** 18",
            "mod = 10 ** 9 + 7",
            "h,w = lr()",
            "a = [list(sr()) for i in range(h)]",
            "ans = 0",
            "q = deque([])",
            "visited = [[False for i in range(w)] for j in range(h)]",
            "for i in range(h):",
            "    for j in range(w):",
            "        if a[i][j] == '#':",
            "            q.append([i,j])",
            "dir = [[1,0], [-1,0], [0,1], [0,-1]]",
            "while q:",
            "    neq = deque([])",
            "    while q:",
            "        y,x = q.popleft()",
            "        for dy,dx in dir:",
            "            ny,nx = y+dy,x+dx",
            "            if 0<=ny<h and 0<=nx<w and (not visited[ny][nx]) and a[ny][nx] == '.':",
            "                neq.append([ny,nx])",
            "                visited[ny][nx]  = True",
            "                a[ny][nx] = '#'",
            "    if neq:",
            "        ans+=1",
            "        q = neq",
            "    else:",
            "        break",
            "print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n = ii()",
            "    L = lmi()",
            "    gcd_before_dp = [L[0]] * n   # dp[i] = L[0] ... L[i] たちの gcd",
            "    gcd_after_dp = [L[-1]] * n    # dp[i] = L[i] ... L[n-1] たちの gcd",
            "    g = L[0]",
            "    for i in range(1, n):",
            "        g = gcd(g, L[i])",
            "        gcd_before_dp[i] = g",
            "    g = L[-1]",
            "    for i in range(n-2, -1, -1):",
            "        g = gcd(g, L[i])",
            "        gcd_after_dp[i] = g",
            "    ans = 0",
            "    for i in range(n):",
            "        # L[i] をスキップする。L[0]...L[i-1] の gcd と L[i+1]...L[n-1] の gcd がわかれば OK",
            "        if i == 0:",
            "            ans = max(ans, gcd_after_dp[i+1])",
            "        elif i == n - 1:",
            "            ans = max(ans, gcd_before_dp[i-1])",
            "        else:",
            "            ans = max(ans, gcd(gcd_before_dp[i-1], gcd_after_dp[i+1]))",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math, cmath",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import _heapify_max, _heappop_max, _siftdown_max",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    Num = Union[int, float]",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def isp():   return input().split()",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    # def _heappush_max(h, item): h.append(item); _siftdown_max(h, 0, len(h)-1)",
            "    n = ii()",
            "    s = input()",
            "    L = list(map(lambda x: 1 if x == '#' else 0, s))",
            "    black_accum_count = [0] * (n + 1)    # black_accum_count[i] = s[:i].count('#')",
            "    for i in range(n):",
            "        black_accum_count[i+1] = black_accum_count[i] + L[i]",
            "    # print(black_accum_count)",
            "    cnt = inf",
            "    for i in range(n+1):",
            "        # s[:i] までは白、s[i:] からは黒になる場合の変更個数",
            "        cnt = min(cnt, black_accum_count[i] + (n - i - (black_accum_count[n] - black_accum_count[i])))",
            "    print(cnt)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    a, b = mi()",
            "    ans = 0",
            "    def push():",
            "        nonlocal a, b, ans",
            "        if a > b:",
            "            ans += a",
            "            a -= 1",
            "        else:",
            "            ans += b",
            "            b -= 1",
            "    push()",
            "    push()",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n = ii()",
            "    H = lmi()",
            "    cnt = 0",
            "    current_max = -1",
            "    for height in H:",
            "        if height >= current_max:",
            "            cnt += 1",
            "            current_max = height",
            "    print(cnt)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# abc124_c.py",
            "# https://atcoder.jp/contests/abc124/tasks/abc124_c",
            "# C - Coloring Colorfully /",
            "# 実行時間制限: 2 sec / メモリ制限: 1024 MB",
            "# 配点 : 300点",
            "# 問題文",
            "# 左右一列に N枚のタイルが並んでおり、各タイルの初めの色は長さ N の文字列 Sで表されます。",
            "# 左から i番目のタイルは、S の i番目の文字が 0 のとき黒色で、1 のとき白色で塗られています。",
            "# あなたは、いくつかのタイルを黒色または白色に塗り替えることで、どの隣り合う 2枚のタイルも異なる色で塗られているようにしたいです。",
            "# 最小で何枚のタイルを塗り替えることで条件を満たすようにできるでしょうか。",
            "# 制約",
            "#     1≤|S|≤105",
            "#     Siは 0 または 1 である。",
            "# 入力",
            "# 入力は以下の形式で標準入力から与えられる。",
            "# S",
            "# 出力",
            "# 条件を満たすために塗り替えるタイルの枚数の最小値を出力せよ。",
            "# 入力例 1",
            "# 000",
            "# 出力例 1",
            "# 1",
            "# 中央のタイルを白色に塗り替えれば条件を達成できます。",
            "# 入力例 2",
            "# 10010010",
            "# 出力例 2",
            "# 3",
            "# 入力例 3",
            "# 0",
            "# 出力例 3",
            "# 0",
            "global FLAG_LOG",
            "FLAG_LOG = False",
            "def log(value):",
            "    # FLAG_LOG = True",
            "    # FLAG_LOG = False",
            "    if FLAG_LOG:",
            "        print(str(value))",
            "def calculation(lines):",
            "    line = lines[0]",
            "    # N = int(lines[0])",
            "    # values = list(map(int, lines[0].split()))",
            "    # values = list(map(int, lines[1].split()))",
            "    # values = list(map(int, lines[1].split()))",
            "    # values = list()",
            "    # for i in range(6):",
            "    #     values.append(int(lines[i]))",
            "    # valueses = list()",
            "    # for i in range(Q):",
            "    #     valueses.append(list(map(int, lines[i+1].split())))",
            "    result = 0",
            "    n_even_kuro = 0",
            "    n_even_shiro = 0",
            "    n_odd_kuro = 0",
            "    n_odd_shiro = 0",
            "    # まず観察",
            "    for i, char in enumerate(line):",
            "        if i % 2 == 0:",
            "            if char == '0':",
            "                n_even_kuro += 1",
            "            else:",
            "                n_even_shiro += 1",
            "        else:",
            "            if char == '0':",
            "                n_odd_kuro += 1",
            "            else:",
            "                n_odd_shiro += 1",
            "    log(n_even_kuro)",
            "    log(n_even_shiro)",
            "    log(n_odd_kuro)",
            "    log(n_odd_shiro)",
            "    # 偶数・奇数それぞれ、黒白どちらが多いかを判断",
            "    dif_even_kuro = n_even_kuro - n_even_shiro",
            "    dif_odd_kuro = n_odd_kuro - n_odd_shiro",
            "    # 偶数=黒/奇数=白 or 偶数=白/奇数=黒 を判断",
            "    if dif_even_kuro > dif_odd_kuro:",
            "        # 偶数=黒/奇数=白",
            "        result = n_even_shiro + n_odd_kuro",
            "    else:",
            "        # 偶数=白/奇数=黒",
            "        result = n_odd_shiro + n_even_kuro",
            "    return [result]",
            "# 引数を取得",
            "def get_input_lines(lines_count):",
            "    lines = list()",
            "    for _ in range(lines_count):",
            "        lines.append(input())",
            "    return lines",
            "# テストデータ",
            "def get_testdata(pattern):",
            "    if pattern == 1:",
            "        lines_input = ['000']",
            "        lines_export = [1]",
            "    if pattern == 2:",
            "        lines_input = ['10010010']",
            "        lines_export = [3]",
            "    if pattern == 3:",
            "        lines_input = ['0']",
            "        lines_export = [0]",
            "    return lines_input, lines_export",
            "# 動作モード判別",
            "def get_mode():",
            "    import sys",
            "    args = sys.argv",
            "    global FLAG_LOG",
            "    if len(args) == 1:",
            "        mode = 0",
            "        FLAG_LOG = False",
            "    else:",
            "        mode = int(args[1])",
            "        FLAG_LOG = True",
            "    return mode",
            "# 主処理",
            "def main():",
            "    import time",
            "    started = time.time()",
            "    mode = get_mode()",
            "    if mode == 0:",
            "        lines_input = get_input_lines(1)",
            "    else:",
            "        lines_input, lines_export = get_testdata(mode)",
            "    lines_result = calculation(lines_input)",
            "    for line_result in lines_result:",
            "        print(line_result)",
            "    # if mode > 0:",
            "    #     print(f'lines_input=[{lines_input}]')",
            "    #     print(f'lines_export=[{lines_export}]')",
            "    #     print(f'lines_result=[{lines_result}]')",
            "    #     if lines_result == lines_export:",
            "    #         print('OK')",
            "    #     else:",
            "    #         print('NG')",
            "    # finished = time.time()",
            "    # duration = finished - started",
            "    # print(f'duration=[{duration}]')",
            "# 起動処理",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "from collections import defaultdict, deque, Counter",
            "import math",
            "# import copy",
            "from bisect import bisect_left, bisect_right",
            "import heapq",
            "sys.setrecursionlimit(1000000)",
            "# input aliases",
            "input = sys.stdin.readline",
            "getS = lambda: input().strip()",
            "getN = lambda: int(input())",
            "getList = lambda: list(map(int, input().split()))",
            "getZList = lambda: [int(x) - 1 for x in input().split()]",
            "INF = 10 ** 20",
            "MOD = 10**9 + 7",
            "divide = lambda x: pow(x, MOD-2, MOD)",
            "def nck(n, k, kaijyo):",
            "    return (npk(n, k, kaijyo) * divide(kaijyo[k])) % MOD",
            "def npk(n, k, kaijyo):",
            "    if k == 0 or k == n:",
            "        return n % MOD",
            "    return (kaijyo[n] * divide(kaijyo[n-k])) % MOD",
            "def fact_and_inv(SIZE):",
            "    inv = [0] * SIZE  # inv[j] = j^{-1} mod MOD",
            "    fac = [0] * SIZE  # fac[j] = j! mod MOD",
            "    finv = [0] * SIZE  # finv[j] = (j!)^{-1} mod MOD",
            "    inv[1] = 1",
            "    fac[0] = fac[1] = 1",
            "    finv[0] = finv[1] = 1",
            "    for i in range(2, SIZE):",
            "        inv[i] = MOD - (MOD // i) * inv[MOD % i] % MOD",
            "        fac[i] = fac[i - 1] * i % MOD",
            "        finv[i] = finv[i - 1] * inv[i] % MOD",
            "    return fac, finv",
            "def kaijyo(n):",
            "    ret = [1]",
            "    for i in range(1, n + 1):",
            "        ret.append((ret[-1] * i)% MOD)",
            "    return ret",
            "def warshall_floyd(d, n):",
            "    #d[i][j]: iからjへの最短距離",
            "    for k in range(n):",
            "        for i in range(n):",
            "            for j in range(n):",
            "                d[i][j] = min(d[i][j],d[i][k] + d[k][j])",
            "    return d",
            "class TwoDimGrid:",
            "    # 2次元座標 -> 1次元",
            "    def __init__(self, h, w, wall=\"#\"):",
            "        self.h = h",
            "        self.w = w",
            "        self.size = (h+2) * (w+2)",
            "        self.wall = wall",
            "        self.get_grid()",
            "    def get_grid(self):",
            "        grid = [self.wall * (self.w + 2)]",
            "        for i in range(self.h):",
            "            grid.append(self.wall + getS() + self.wall)",
            "        grid.append(self.wall * (self.w + 2))",
            "        self.grid = grid",
            "    def pos(self, x, y):",
            "        return y * (self.w + 2) + x + 1",
            "    def search(self):",
            "        grid = self.grid",
            "        move = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
            "        move_eight = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]",
            "        ans = 0",
            "        for i in range(1, self.h + 1):",
            "            for j in range(1, self.w + 1):",
            "                pass # ここから何か書いてね",
            "def solve():",
            "    n, k = getList()",
            "    S = getS()",
            "    ren = []",
            "    if S.startswith(\"0\"):",
            "        ren.append(0)",
            "    ctmp = \"\"",
            "    ntmp = 0",
            "    for c in S:",
            "        if ctmp != \"\" and ctmp != c:",
            "            ren.append(ntmp)",
            "            ntmp = 1",
            "            ctmp = c",
            "        else:",
            "            ntmp += 1",
            "            ctmp = c",
            "    ren.append(ntmp)",
            "    if S.endswith(\"0\"):",
            "        ren.append(0)",
            "    # print(ren)",
            "    for i in range(len(ren) - 1):",
            "        ren[i+1] += ren[i]",
            "    if 2 * k + 1 >= len(ren):",
            "        print(ren[-1])",
            "        return",
            "    # print(ren)",
            "    off = 0",
            "    ans = 0",
            "    while True:",
            "        if off == 0:",
            "            ans = max(ans, ren[2 * (off + k)])",
            "        else:",
            "            ans = max(ans, ren[2 * (off + k)] - ren[2 * off - 1])",
            "        off += 1",
            "        if 2 * (off + k) >= len(ren):",
            "            print(ans)",
            "            return",
            "def main():",
            "    n = getN()",
            "    for _ in range(n):",
            "        solve()",
            "if __name__ == \"__main__\":",
            "    # main()",
            "    solve()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, k = mi()",
            "    s = input()",
            "    memo = [[], []]",
            "    if s[0] == '0':",
            "        memo[1].append(0)",
            "    for key, g in groupby(s):",
            "        memo[int(key)].append(len(list(g)))",
            "    if s[-1] == '0':",
            "        memo[1].append(0)",
            "    accum_zero_memo = [0]",
            "    for elm in memo[0]:",
            "        accum_zero_memo.append(accum_zero_memo[-1] + elm)",
            "    accum_one_memo = [0]",
            "    for elm in memo[1]:",
            "        accum_one_memo.append(accum_one_memo[-1] + elm)",
            "    # for elm in memo:",
            "    #     print(elm)",
            "    if k >= len(memo[0]):",
            "        # 全て 1 にできる",
            "        print(len(s))",
            "    else:",
            "        ans = 0",
            "        for i in range(len(memo[0]) - k + 1):",
            "            # sum(memo[0][i:i+k]) + sum(memo[1][i:i+k+1])",
            "            summation = (accum_zero_memo[i+k] - accum_zero_memo[i]) + (accum_one_memo[i+k+1] - accum_one_memo[i])",
            "            ans = max(ans, summation)",
            "        print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# abc123_b.py",
            "# https://atcoder.jp/contests/abc123/tasks/abc123_b",
            "# ★ RE:1",
            "# in2.txt",
            "# B - Five Dishes /",
            "# 実行時間制限: 2 sec / メモリ制限: 1024 MB",
            "# 配点: 200点",
            "# 問題文",
            "# AtCoder 料理店では、以下の 5つの料理が提供されています。ここで、「調理時間」は料理を注文してから客に届くまでの時間とします。",
            "#     ABC 丼： 調理時間 A分",
            "#     ARC カレー： 調理時間 B分",
            "#     AGC パスタ： 調理時間 C分",
            "#     APC ラーメン： 調理時間 D分",
            "#     ATC ハンバーグ： 調理時間 E分",
            "# また、この店には以下のような「注文のルール」があります。",
            "#     注文は、10の倍数の時刻 (時刻 0,10,20,30,...) にしかできない。",
            "#     一回の注文につき一つの料理しか注文できない。",
            "#     ある料理を注文したら、それが届くまで別の注文ができない。ただし、料理が届いたちょうどの時刻には注文ができる。",
            "# E869120 君は時刻 0に料理店に着きました。彼は 5 つの料理全てを注文します。最後の料理が届く最も早い時刻を求めてください。",
            "# ただし、料理を注文する順番は自由であり、時刻 0に注文することも可能とであるとします。",
            "# 制約",
            "#     A,B,C,D,Eは 1 以上 123以下の整数",
            "# 入力",
            "# 入力は以下の形式で標準入力から与えられる。",
            "# A",
            "# B",
            "# C",
            "# D",
            "# E",
            "# 出力",
            "# 最後の料理が届く最も早い時刻を整数で出力せよ。",
            "# 入力例 1",
            "# 29",
            "# 20",
            "# 7",
            "# 35",
            "# 120",
            "# 出力例 1",
            "# 215",
            "# ABC 丼→ARC カレー→AGC パスタ→ATC ハンバーグ→APC ラーメン の順に注文することにすると、各料理の最も早い注文時刻・届く時刻は以下の通りになります。",
            "#     時刻 0に ABC 丼を注文する。時刻 29に ABC 丼が届く。",
            "#     時刻 30に ARC カレーを注文する。時刻 50に ARC カレーが届く。",
            "#     時刻 50に AGC パスタを注文する。57に AGC パスタが届く。",
            "#     時刻 60に ATC ハンバーグを注文する。時刻 180に ATC ハンバーグが届く。",
            "#     時刻 180に APC ラーメンを注文する。時刻 215に APC ラーメンが届く。",
            "# これより早く最後の料理が届くような方法は存在しません。",
            "# 入力例 2",
            "# 101",
            "# 86",
            "# 119",
            "# 108",
            "# 57",
            "# 出力例 2",
            "# 481",
            "# AGC パスタ→ARC カレー→ATC ハンバーグ→APC ラーメン→ABC 丼の順に注文することにすると、各料理の最も早い注文時刻・届く時刻は以下の通りになります。",
            "#     時刻 0に AGC パスタを注文する。時刻 119に AGC パスタが届く。",
            "#     時刻 120に ARC カレーを注文する。時刻 206に ARC カレーが届く。",
            "#     時刻 210に ATC ハンバーグを注文する。時刻 267に ATC ハンバーグが届く。",
            "#     時刻 270に APC ラーメンを注文する。時刻 378に APC ラーメンが届く。",
            "#     時刻 380に ABC 丼を注文する。時刻 481に ABC 丼が届く。",
            "# これより早く最後の料理が届くような方法は存在しません。",
            "# 入力例 3",
            "# 123",
            "# 123",
            "# 123",
            "# 123",
            "# 123",
            "# 出力例 3",
            "# 643",
            "# これが入力される最大のケースです。",
            "global FLAG_LOG",
            "FLAG_LOG = False",
            "def log(value):",
            "    # FLAG_LOG = True",
            "    # FLAG_LOG = False",
            "    if FLAG_LOG:",
            "        print(str(value))",
            "def calculation(lines):",
            "    # line = lines[0]",
            "    # N = int(lines[0])",
            "    # N, Q = list(map(int, lines[0].split()))",
            "    # values = list(map(int, lines[1].split()))",
            "    # values = list(map(int, lines[1].split()))",
            "    values = list()",
            "    for i in range(5):",
            "        values.append(int(lines[i]))",
            "    # valueses = list()",
            "    # for i in range(Q):",
            "    #     valueses.append(list(map(int, lines[i+1].split())))",
            "    su = 0",
            "    amaris = list()",
            "    for value in values:",
            "        amari = value % 10",
            "        if amari > 0:",
            "            amaris.append(10-amari)",
            "    if amaris == []:",
            "        result = sum(values)",
            "    else:",
            "        result = sum(values) + sum(amaris) - max(amaris)",
            "    return [result]",
            "# 引数を取得",
            "def get_input_lines(lines_count):",
            "    lines = list()",
            "    for _ in range(lines_count):",
            "        lines.append(input())",
            "    return lines",
            "# テストデータ",
            "def get_testdata(pattern):",
            "    if pattern == 1:",
            "        lines_input = ['29', '20', '7', '35', '120']",
            "        lines_export = [215]",
            "    if pattern == 2:",
            "        lines_input = ['101', '86', '119', '108', '57']",
            "        lines_export = [481]",
            "    if pattern == 3:",
            "        lines_input = ['123', '123', '123', '123', '123']",
            "        lines_export = [643]",
            "    if pattern == -1:",
            "        lines_input = ['10', '10', '10', '10', '10']",
            "        lines_export = [50]",
            "    return lines_input, lines_export",
            "# 動作モード判別",
            "def get_mode():",
            "    import sys",
            "    args = sys.argv",
            "    global FLAG_LOG",
            "    if len(args) == 1:",
            "        mode = 0",
            "        FLAG_LOG = False",
            "    else:",
            "        mode = int(args[1])",
            "        FLAG_LOG = True",
            "    return mode",
            "# 主処理",
            "def main():",
            "    import time",
            "    started = time.time()",
            "    mode = get_mode()",
            "    if mode == 0:",
            "        lines_input = get_input_lines(5)",
            "    else:",
            "        lines_input, lines_export = get_testdata(mode)",
            "    lines_result = calculation(lines_input)",
            "    for line_result in lines_result:",
            "        print(line_result)",
            "    if FLAG_LOG:",
            "        log(f'lines_input=[{lines_input}]')",
            "        log(f'lines_export=[{lines_export}]')",
            "        log(f'lines_result=[{lines_result}]')",
            "        if lines_result == lines_export:",
            "            log('OK')",
            "        else:",
            "            log('NG')",
            "    finished = time.time()",
            "    duration = finished - started",
            "    log(f'duration=[{duration}]')",
            "# 起動処理",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# abc123_c.py",
            "# https://atcoder.jp/contests/abc123/tasks/abc123_c",
            "# C - Five Transportations /",
            "# 実行時間制限: 2 sec / メモリ制限: 1024 MB",
            "# 配点: 300点",
            "# 問題文",
            "# AtCoder 社は成長し、2028 年になってついに 6つの都市 (都市 1,2,3,4,5,6) からなる AtCoder 帝国を作りました！",
            "# AtCoder 帝国には 5つの交通機関があります。",
            "#     電車：都市 1から 2 まで 1 分で移動する。1 つの電車には A人まで乗ることができる。",
            "#     バス：都市 2から 3 まで 1 分で移動する。1 つのバスには B人まで乗ることができる。",
            "#     タクシー：都市 3から 4 まで 1 分で移動する。1 つのタクシーには C人まで乗ることができる。",
            "#     飛行機：都市 4から 5 まで 1 分で移動する。1 つの飛行機には D人まで乗ることができる。",
            "#     船：都市 5から 6 までを 1 分で移動する。1 つの船には E人まで乗ることができる。",
            "# それぞれの交通機関は、各整数時刻 (0,1,2,3,...) に、都市から出発します。",
            "# いま、N 人のグループが都市 1 におり、全員都市 6 まで移動したいです。全員が都市 6に到着するまでに最短で何分かかるでしょうか？",
            "# なお、乗り継ぎにかかる時間を考える必要はありません。",
            "# 制約",
            "#     1≤N,A,B,C,D,E≤1015",
            "#     入力中の値はすべて整数である。",
            "# 入力",
            "# 入力は以下の形式で標準入力から与えられる。",
            "# N",
            "# A",
            "# B",
            "# C",
            "# D",
            "# E",
            "# 出力",
            "# 全員が都市 6に移動するのに必要な最小の時間を分単位で出力せよ。",
            "# 入力例 1",
            "# 5",
            "# 3",
            "# 2",
            "# 4",
            "# 3",
            "# 5",
            "# 出力例 1",
            "# 7",
            "# 例えば、次のような移動方法が考えられます。",
            "# はじめ、次の画像のように、N=5人が都市 1にいます。",
            "# 1分後までに、3 人が都市 1 から都市 2 に電車で移動します。ここで、電車は一度に 3人までしか運べないことに注意してください。",
            "# 2分後までに、残り 2 人が都市 1 から都市 2 に電車で移動し、都市 2 にいた 3 人のうち 2 人がバスで都市 3 に移動します。",
            "# ここで、バスは一度に 2人までしか運べないことに注意してください。",
            "# 3分後までに、2 人が都市 2 から都市 3 にバスで移動し、2 人が都市 3 から都市 4にタクシーで移動します。",
            "# それ以降は、まだ都市 6に到着していない人が止まらずに移動し続けると、全員が 7 分で都市 6 に着くことができます。",
            "# また、6 分以内で全員が都市 6に着く方法はありません。",
            "# 入力例 2",
            "# 10",
            "# 123",
            "# 123",
            "# 123",
            "# 123",
            "# 123",
            "# 出力例 2",
            "# 5",
            "# どの交通機関も N=10人を 1 回で運ぶことができます。",
            "# したがって、全員が止まらずに移動し続ければ 5 分で都市 6に着くことができます。",
            "# 入力例 3",
            "# 10000000007",
            "# 2",
            "# 3",
            "# 5",
            "# 7",
            "# 11",
            "# 出力例 3",
            "# 5000000008",
            "# 入力・出力が 32ビット整数型に収まらない可能性があることに注意してください。",
            "def log(line):",
            "    if False:",
            "        print(line)",
            "def calculation(lines):",
            "    # line = lines[0]",
            "    # N = int(lines[0])",
            "    # N, Q = list(map(int, lines[0].split()))",
            "    # values = list(map(int, lines[1].split()))",
            "    # values = list(map(int, lines[1].split()))",
            "    values = list()",
            "    for i in range(6):",
            "        values.append(int(lines[i]))",
            "    # valueses = list()",
            "    # for i in range(Q):",
            "    #     valueses.append(list(map(int, lines[i+1].split())))",
            "    N, A, B, C, D, E = values",
            "    # ☆N回の状態遷移をループするバージョン。たぶん、8時間かかる。。。",
            "    # state = [N, 0, 0, 0, 0, 0]",
            "    # cnt = 0",
            "    # while True:",
            "    #     a, b, c, d, e, f = state",
            "    #     shift_a = min(a, A)",
            "    #     shift_b = min(b, B)",
            "    #     shift_c = min(c, C)",
            "    #     shift_d = min(d, D)",
            "    #     shift_e = min(e, E)",
            "    #     state = [a-shift_a, b+shift_a-shift_b, c+shift_b-shift_c, d+shift_c-shift_d, e+shift_d-shift_e, f+shift_e]",
            "    #     cnt += 1",
            "    #     if f+shift_e == N:",
            "    #         return [cnt]",
            "    # 解答を見ました・・・なるほど。",
            "    result = -(-N//min(values)) + 4",
            "    return [result]",
            "# 引数を取得",
            "def get_input_lines(lines_count):",
            "    lines = list()",
            "    for _ in range(lines_count):",
            "        lines.append(input())",
            "    return lines",
            "# テストデータ",
            "def get_testdata(pattern):",
            "    if pattern == 1:",
            "        lines_input = ['5', '3', '2', '4', '3', '5']",
            "        lines_export = [7]",
            "    if pattern == 2:",
            "        lines_input = ['10', '123', '123', '123', '123', '123']",
            "        lines_export = [5]",
            "    if pattern == 3:",
            "        lines_input = ['10000000007', '2', '3', '5', '7', '11']",
            "        lines_export = [5000000008]",
            "    return lines_input, lines_export",
            "# 動作モード判別",
            "def get_mode():",
            "    import sys",
            "    args = sys.argv",
            "    if len(args) == 1:",
            "        mode = 0",
            "    else:",
            "        mode = int(args[1])",
            "    return mode",
            "# 主処理",
            "def main():",
            "    import time",
            "    started = time.time()",
            "    mode = get_mode()",
            "    if mode == 0:",
            "        lines_input = get_input_lines(6)",
            "    else:",
            "        lines_input, lines_export = get_testdata(mode)",
            "    lines_result = calculation(lines_input)",
            "    for line_result in lines_result:",
            "        print(line_result)",
            "    # if mode > 0:",
            "    #     print(f'lines_input=[{lines_input}]')",
            "    #     print(f'lines_export=[{lines_export}]')",
            "    #     print(f'lines_result=[{lines_result}]')",
            "    #     if lines_result == lines_export:",
            "    #         print('OK')",
            "    #     else:",
            "    #         print('NG')",
            "    # finished = time.time()",
            "    # duration = finished - started",
            "    # print(f'duration=[{duration}]')",
            "# 起動処理",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def calc_1000_num(a, b, c):",
            "        return a + (10 ** 3) * b + (10 ** 6) * c",
            "    x, y, z, k = mi()",
            "    A = sorted(lmi(), reverse=True)",
            "    B = sorted(lmi(), reverse=True)",
            "    C = sorted(lmi(), reverse=True)",
            "    h = [(- (A[0]+B[0]+C[0]), [0, 0, 0])]",
            "    registered = set()",
            "    registered.add(calc_1000_num(0, 0, 0))",
            "    for _ in range(k):",
            "        minus_delicious, indices = heappop(h)",
            "        a, b, c = indices",
            "        print(- minus_delicious)",
            "        if a + 1 < x and calc_1000_num(a + 1, b, c) not in registered:",
            "            heappush(h, (- (A[a+1]+B[b]+C[c]), [a+1, b, c]))",
            "            registered.add(calc_1000_num(a + 1, b, c))",
            "        if b + 1 < y and calc_1000_num(a, b + 1, c) not in registered:",
            "            heappush(h, (- (A[a]+B[b+1]+C[c]), [a, b+1, c]))",
            "            registered.add(calc_1000_num(a, b + 1, c))",
            "        if c + 1 < z and calc_1000_num(a, b, c + 1) not in registered:",
            "            heappush(h, (- (A[a]+B[b]+C[c+1]), [a, b, c+1]))",
            "            registered.add(calc_1000_num(a, b, c + 1))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# abc122_b.py",
            "# https://atcoder.jp/contests/abc122/tasks/abc122_b",
            "# B - ATCoder /",
            "# 実行時間制限: 2 sec / メモリ制限: 1024 MB",
            "# 配点 : 200点",
            "# 問題文",
            "# 英大文字からなる文字列 Sが与えられます。Sの部分文字列 (注記を参照) であるような最も長い ACGT 文字列 の長さを求めてください。",
            "# ここで、ACGT 文字列とは A, C, G, T 以外の文字を含まない文字列です。",
            "# 注記",
            "# 文字列 Tの部分文字列とは、T の先頭と末尾から 0文字以上を取り去って得られる文字列です。",
            "# 例えば、ATCODER の部分文字列には TCO, AT, CODER, ATCODER, (空文字列) が含まれ、AC は含まれません。",
            "# 制約",
            "#     Sは長さ 1 以上 10以下の文字列である。",
            "#     Sの各文字は英大文字である。",
            "# 入力",
            "# 入力は以下の形式で標準入力から与えられる。",
            "# S",
            "# 出力",
            "# Sの部分文字列であるような最も長い ACGT 文字列の長さを出力せよ。",
            "# 入力例 1",
            "# ATCODER",
            "# 出力例 1",
            "# 3",
            "# ATCODER の部分文字列であるような ACGT 文字列のうち、最も長いものは ATC です。",
            "# 入力例 2",
            "# HATAGAYA",
            "# 出力例 2",
            "# 5",
            "# HATAGAYA の部分文字列であるような ACGT 文字列のうち、最も長いものは ATAGA です。",
            "# 入力例 3",
            "# SHINJUKU",
            "# 出力例 3",
            "# 0",
            "# SHINJUKU の部分文字列であるような ACGT 文字列のうち、最も長いものは (空文字列) です。",
            "def calculation(lines):",
            "    line = lines[0]",
            "    # N = int(lines[0])",
            "    # N, M = list(map(int, lines[0].split()))",
            "    # values = list(map(int, lines[1].split()))",
            "    # values = list(map(int, lines[1].split()))",
            "    # values = list()",
            "    # for i in range(N):",
            "    #     values.append(int(lines[i+1]))",
            "    # valueses = list()",
            "    # for i in range(N):",
            "    #     valueses.append(list(map(int, lines[i+1].split())))",
            "    result = 0",
            "    tmp = 0",
            "    # print(f'line=[{line}]')",
            "    for char in line:",
            "        # print(f'char=[{char}]')",
            "        if char == 'A':",
            "            flag = True",
            "        elif char == 'C':",
            "            flag = True",
            "        elif char == 'G':",
            "            flag = True",
            "        elif char == 'T':",
            "            flag = True",
            "        else:",
            "            flag = False",
            "        if flag:",
            "            tmp += 1",
            "            # print(f'result=[{result}], tmp=[{tmp}]')",
            "            if result < tmp:",
            "                result = tmp",
            "        else:",
            "            tmp = 0",
            "    return [result]",
            "# 引数を取得",
            "def get_input_lines(lines_count):",
            "    lines = list()",
            "    for _ in range(lines_count):",
            "        lines.append(input())",
            "    return lines",
            "# テストデータ",
            "def get_testdata(pattern):",
            "    if pattern == 1:",
            "        lines_input = ['ATCODER']",
            "        lines_export = [3]",
            "    if pattern == 2:",
            "        lines_input = ['HATAGAYA']",
            "        lines_export = [5]",
            "    if pattern == 3:",
            "        lines_input = ['SHINJUKU']",
            "        lines_export = [0]",
            "    return lines_input, lines_export",
            "# 動作モード判別",
            "def get_mode():",
            "    import sys",
            "    args = sys.argv",
            "    if len(args) == 1:",
            "        mode = 0",
            "    else:",
            "        mode = int(args[1])",
            "    return mode",
            "# 主処理",
            "def main():",
            "    import time",
            "    started = time.time()",
            "    mode = get_mode()",
            "    if mode == 0:",
            "        lines_input = get_input_lines(1)",
            "    else:",
            "        lines_input, lines_export = get_testdata(mode)",
            "    lines_result = calculation(lines_input)",
            "    for line_result in lines_result:",
            "        print(line_result)",
            "    # if mode > 0:",
            "    #     print(f'lines_input=[{lines_input}]')",
            "    #     print(f'lines_export=[{lines_export}]')",
            "    #     print(f'lines_result=[{lines_result}]')",
            "    #     if lines_result == lines_export:",
            "    #         print('OK')",
            "    #     else:",
            "    #         print('NG')",
            "    # finished = time.time()",
            "    # duration = finished - started",
            "    # print(f'duration=[{duration}]')",
            "# 起動処理",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def alpha_to_num(s):",
            "        \"\"\"",
            "        >>> alpha_to_num('AAA')",
            "        0",
            "        >>> alpha_to_num('AGC')",
            "        11",
            "        >>> alpha_to_num('CCC')",
            "        63",
            "        \"\"\"",
            "        assert(len(s) == 3)",
            "        d = {'A':0, 'T':1, 'G':2, 'C':3}",
            "        num = 0",
            "        for i in range(3):",
            "            num += pow(4, 2 - i) * d[s[i]]",
            "        return num",
            "    def num_to_alpha(num):",
            "        \"\"\"",
            "        >>> num_to_alpha(0)",
            "        'AAA'",
            "        >>> num_to_alpha(11)",
            "        'AGC'",
            "        >>> num_to_alpha(63)",
            "        'CCC'",
            "        \"\"\"",
            "        assert(0 <= num < 4 ** 3)",
            "        d = {0:'A', 1:'T', 2:'G', 3:'C'}",
            "        L = []",
            "        for i in range(2, -1, -1):",
            "            q = num // pow(4, i)",
            "            L.append(d[q])",
            "            num -= pow(4, i) * q",
            "        return ''.join(L)",
            "    def distribute(num, s, num_of_pattern, seq):",
            "        \"\"\"",
            "        最後の 3 文字が s (数字に直すと num) であるようなものに対し、末尾に A T G C を追加することを考える",
            "        valid pattern を数え上げ、seq の適切な位置にパターンを加算する",
            "        \"\"\"",
            "        for char in ['A', 'T', 'G', 'C']:",
            "            new_s = s[1:] + char",
            "            new_num = alpha_to_num(new_s)",
            "            if char == 'G':",
            "                if new_s == 'ACG':",
            "                    continue",
            "            elif char == 'C':",
            "                if s in ['AGT', 'AGG', 'ATG']:",
            "                    continue",
            "                if new_s in ['AGC', 'GAC']:",
            "                    continue",
            "            seq[new_num] = (seq[new_num] + num_of_pattern) % mod",
            "    n = ii()",
            "    # a:0, t:1, g:2, c:3 とする",
            "    # dp[i][num] = (i 文字で末尾の 4 進数表記が num となる適切な文字列の数)",
            "    dp = [[0] * (4 ** 3) for _ in range(n + 1)]",
            "    for num in range(4 ** 3):",
            "        dp[3][num] = 1 if num_to_alpha(num) not in ['AGC', 'ACG', 'GAC'] else 0",
            "    for i in range(3, n):",
            "        # dp[i] は既知。dp[i+1] に配る",
            "        for num in range(4 ** 3):",
            "            distribute(num, num_to_alpha(num), dp[i][num], dp[i+1])",
            "    print(sum(dp[n]) % mod)",
            "if __name__ == \"__main__\":",
            "    # import doctest",
            "    # doctest.testmod()",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1
        ]
    },
    {
        "content": [
            "n = int(input())",
            "if n == 3:",
            "    print(61)",
            "    exit()",
            "MOD = 10 ** 9 + 7",
            "# dp[i][i-1][i-2][i-3][i-4]",
            "dp = [[[[[0] * (4) for _ in range(4)] for i in range(4)] for i in range(4)] for i in range(n + 1)]",
            "to = {0:\"A\", 1:\"C\", 2:\"G\", 3:\"T\"}",
            "for i1 in range(4):",
            "    for i2 in range(4):",
            "        for i3 in range(4):",
            "            for i4 in range(4):",
            "                if \"AGC\" in to[i1] + to[i2] + to[i3] + to[i4]:",
            "                    continue",
            "                if \"ACG\" in to[i1] + to[i2] + to[i3] + to[i4]:",
            "                    continue",
            "                if \"GAC\" in to[i1] + to[i2] + to[i3] + to[i4]:",
            "                    continue",
            "                if \"AAGC\" in to[i1] + to[i2] + to[i3] + to[i4]:",
            "                    continue",
            "                if \"ACGC\" in to[i1] + to[i2] + to[i3] + to[i4]:",
            "                    continue",
            "                if \"AGGC\" in to[i1] + to[i2] + to[i3] + to[i4]:",
            "                    continue",
            "                if \"ATGC\" in to[i1] + to[i2] + to[i3] + to[i4]:",
            "                    continue",
            "                if \"AGAC\" in to[i1] + to[i2] + to[i3] + to[i4]:",
            "                    continue",
            "                if \"AGCC\" in to[i1] + to[i2] + to[i3] + to[i4]:",
            "                    continue",
            "                if \"AGGC\" in to[i1] + to[i2] + to[i3] + to[i4]:",
            "                    continue",
            "                if \"AGTC\" in to[i1] + to[i2] + to[i3] + to[i4]:",
            "                    continue",
            "                dp[4][i1][i2][i3][i4] = 1",
            "for i in range(4, n):",
            "    for i1 in range(4):",
            "        for i2 in range(4):",
            "            for i3 in range(4):",
            "                for i4 in range(4):",
            "                    if \"AGC\" in to[i1] + to[i2] + to[i3] + to[i4]:",
            "                        continue",
            "                    if \"ACG\" in to[i1] + to[i2] + to[i3] + to[i4]:",
            "                        continue",
            "                    if \"GAC\" in to[i1] + to[i2] + to[i3] + to[i4]:",
            "                        continue",
            "                    if \"AAGC\" in to[i1] + to[i2] + to[i3] + to[i4]:",
            "                        continue",
            "                    if \"ACGC\" in to[i1] + to[i2] + to[i3] + to[i4]:",
            "                        continue",
            "                    if \"AGGC\" in to[i1] + to[i2] + to[i3] + to[i4]:",
            "                        continue",
            "                    if \"ATGC\" in to[i1] + to[i2] + to[i3] + to[i4]:",
            "                        continue",
            "                    if \"AGAC\" in to[i1] + to[i2] + to[i3] + to[i4]:",
            "                        continue",
            "                    if \"AGCC\" in to[i1] + to[i2] + to[i3] + to[i4]:",
            "                        continue",
            "                    if \"AGGC\" in to[i1] + to[i2] + to[i3] + to[i4]:",
            "                        continue",
            "                    if \"AGTC\" in to[i1] + to[i2] + to[i3] + to[i4]:",
            "                        continue",
            "                    for j in range(4):",
            "                        dp[i + 1][i1][i2][i3][i4] += dp[i][i2][i3][i4][j]",
            "                        dp[i + 1][i1][i2][i3][i4] %= MOD",
            "ans = 0",
            "for i1 in range(4):",
            "    for i2 in range(4):",
            "        for i3 in range(4):",
            "            for i4 in range(4):",
            "                ans += dp[-1][i1][i2][i3][i4]",
            "                ans %= MOD",
            "print(ans % MOD)"
        ],
        "label": [
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2
        ]
    },
    {
        "content": [
            "# abc121_b.py",
            "# https://atcoder.jp/contests/abc121/tasks/abc121_b",
            "# B - Can you solve this? /",
            "# 実行時間制限: 2 sec / メモリ制限: 1024 MB",
            "# 配点 : 200点",
            "# 問題文",
            "# N個のソースコードがあり、i 個目のソースコードの特徴は Ai1,Ai2,...,AiM の M個の整数で表されます。",
            "# また、整数 B1,B2,...,BMと 整数 Cが与えられます。",
            "# Ai1B1+Ai2B2+...+AiMBM+C>0のときに限り、i個目のソースコードはこの問題に正答するソースコードです。",
            "# N個のソースコードのうち、この問題に正答するソースコードの個数を求めてください。",
            "# 制約",
            "#     入力は全て整数である。",
            "#     1≤N,M≤20",
            "#     −100≤Aij≤100",
            "#     −100≤Bi≤100",
            "#     −100≤C≤100",
            "# 入力",
            "# 入力は以下の形式で標準入力から与えられる。",
            "# N M C",
            "# B1 B2 ... BM",
            "# A11 A12 ... A1M",
            "# A21 A22 ... A2M",
            "# ⋮",
            "# AN1 AN2 ... ANM",
            "# 出力",
            "# N個のソースコードのうち、この問題に正答するソースコードの個数を出力せよ。",
            "# 入力例 1",
            "# 2 3 -10",
            "# 1 2 3",
            "# 3 2 1",
            "# 1 2 2",
            "# 出力例 1",
            "# 1",
            "# 以下のように 2個目のソースコードのみがこの問題に正答します。",
            "#     3×1+2×2+1×3+(−10)=0≤0なので 1個目のソースコードはこの問題に正答しません。",
            "#     1×1+2×2+2×3+(−10)=1>0なので 2個目のソースコードはこの問題に正答します。",
            "# 入力例 2",
            "# 5 2 -4",
            "# -2 5",
            "# 100 41",
            "# 100 40",
            "# -3 0",
            "# -6 -2",
            "# 18 -13",
            "# 出力例 2",
            "# 2",
            "# 入力例 3",
            "# 3 3 0",
            "# 100 -100 0",
            "# 0 100 100",
            "# 100 100 100",
            "# -100 100 100",
            "# 出力例 3",
            "# 0",
            "# 全て Wrong Answer です。あなたのソースコードは含めません。",
            "def calculation(lines):",
            "    # line = lines[0]",
            "    # N = int(lines[0])",
            "    N, M, C = list(map(int, lines[0].split()))",
            "    values_b = list(map(int, lines[1].split()))",
            "    # values = list(map(int, lines[1].split()))",
            "    # values = list()",
            "    # for i in range(N):",
            "    #     values.append(int(lines[i+1]))",
            "    valueses = list()",
            "    for i in range(N):",
            "        valueses.append(list(map(int, lines[i+2].split())))",
            "    cnt = 0",
            "    for values in valueses:",
            "        sm = C",
            "        for i in range(M):",
            "            sm += values_b[i] * values[i]",
            "        if sm > 0:",
            "            cnt += 1",
            "    return [cnt]",
            "# 引数を取得",
            "def get_input_lines():",
            "    line = input()",
            "    N, M, C = list(map(int, line.split()))",
            "    lines = list()",
            "    lines.append(line)",
            "    for _ in range(N+1):",
            "        lines.append(input())",
            "    return lines",
            "# テストデータ",
            "def get_testdata(pattern):",
            "    if pattern == 1:",
            "        lines_input = ['2 3 -10', '1 2 3', '3 2 1', '1 2 2']",
            "        lines_export = [1]",
            "    if pattern == 2:",
            "        lines_input = ['5 2 -4', '-2 5', '100 41', '100 40', '-3 0', '-6 -2', '18 -13']",
            "        lines_export = [2]",
            "    if pattern == 3:",
            "        lines_input = ['3 3 0', '100 -100 0', '0 100 100', '100 100 100', '-100 100 100']",
            "        lines_export = [0]",
            "    return lines_input, lines_export",
            "# 動作モード判別",
            "def get_mode():",
            "    import sys",
            "    args = sys.argv",
            "    if len(args) == 1:",
            "        mode = 0",
            "    else:",
            "        mode = int(args[1])",
            "    return mode",
            "# 主処理",
            "def main():",
            "    import time",
            "    started = time.time()",
            "    mode = get_mode()",
            "    if mode == 0:",
            "        lines_input = get_input_lines()",
            "    else:",
            "        lines_input, lines_export = get_testdata(mode)",
            "    lines_result = calculation(lines_input)",
            "    for line_result in lines_result:",
            "        print(line_result)",
            "    # if mode > 0:",
            "    #     print(f'lines_input=[{lines_input}]')",
            "    #     print(f'lines_export=[{lines_export}]')",
            "    #     print(f'lines_result=[{lines_result}]')",
            "    #     if lines_result == lines_export:",
            "    #         print('OK')",
            "    #     else:",
            "    #         print('NG')",
            "    # finished = time.time()",
            "    # duration = finished - started",
            "    # print(f'duration=[{duration}]')",
            "# 起動処理",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def calc_xor(num, digit):",
            "        '0 to num について、下の桁から順に xor を取った時の結果を buf に append して返す'",
            "        buf = [0] * digit",
            "        for i in range(len(bin(num)[2:])):",
            "            if i == 0:",
            "                blocks = (num + 1) // pow(2, i + 1)",
            "                buf[i] = blocks % 2",
            "            else:",
            "                res = (num + 1) % pow(2, i + 1)",
            "                buf[i] = max(res - pow(2, i), 0) % 2",
            "        # print(buf)",
            "        return buf",
            "    a, b = mi()",
            "    digit = len(bin(b)[2:])",
            "    f_a = calc_xor(a-1, digit) if a != 0 else [0] * digit",
            "    f_b = calc_xor(b, digit)",
            "    ans = 0",
            "    for i in range(digit):",
            "        ans += pow(2, i) * ((f_b[i] - f_a[i]) % 2)",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "sys.setrecursionlimit(10**7)",
            "def LI(): return [int(x) for x in sys.stdin.readline().split()]",
            "def LI_(): return [int(x) - 1 for x in sys.stdin.readline().split()]",
            "def LF(): return [float(x) for x in sys.stdin.readline().split()]",
            "def LS(): return sys.stdin.readline().split()",
            "def II(): return int(sys.stdin.readline())",
            "def SI(): return sys.stdin.readline().strip()",
            "def LILI(n): return [LI() for _ in range(n)]",
            "INF = 10 ** 18",
            "MOD = 10 ** 9 + 7",
            "'''",
            "独立なグラフがいくつかできていく。",
            "求めるもの：グラフ1にある頂点と2にある頂点の combinaton, 1と3のcombination,……2と3のcombination…… の総和を求めるのを繰り返す。",
            "union-findで行けそうだがN, Mどちらも10**5なので間に合わなさそう。",
            "最終的にはすべて独立となり、答えはnC2となる。",
            "ということで nC2 からはじめてどんどん union していけばいいのでは。",
            "union する2つのグループの頂点数の積を引いていけば良いのかな。",
            "'''",
            "import collections",
            "import itertools",
            "import operator",
            "class UnionFind:",
            "    def __init__(self, elems=None):",
            "        class KeyDict(dict):  # dict + キーがないときは dict[key] = key として key を返す。",
            "            def __missing__(self, key):",
            "                self[key] = key",
            "                return key",
            "        self.parent = KeyDict()  # キーがなければ孤立点→自身が key（parent[key]=key）",
            "        self.rank = collections.defaultdict(int)  # 木の高さ。デフォルトでは 0。経路圧縮すると本来は rank が下がるが、その効果は無視している。",
            "        self.size_ = collections.defaultdict(lambda: 1)  # 根に属する頂点の個数。根の値しか信用できない。",
            "        if elems is not None:",
            "            for elem in elems:",
            "                _, _ = self.parent[elem], self.rank[elem]",
            "    def find(self, x):  # あるキーの根を探す。",
            "        if self.parent[x] == x:",
            "            return x  # 自身が根なら自身を返す。",
            "        else:",
            "            self.parent[x] = self.find(self.parent[x])  # 再帰的に親を探して、すべて根に付け替える（経路圧縮）。",
            "            return self.parent[x]",
            "    def unite(self, x, y):",
            "        x = self.find(x)  # x の根を求める。",
            "        y = self.find(y)  # y の根を求める。",
            "        if x == y:  # もともと同一の木なら何もしない。",
            "            return",
            "        if self.rank[x] < self.rank[y]:  # rank （木の高さ）の低いほうを高いほうに繋げたい。",
            "            x, y = y, x",
            "        self.parent[y] = x  # x の親を y にする。",
            "        self.size_[x] += self.size_[y]",
            "        if self.rank[x] == self.rank[y]:  # 同じ高さの木だったら片方の rank を1つ上げておく。",
            "            self.rank[x] += 1",
            "    def are_same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "    def size(self, x):",
            "        return self.size_[self.find(x)]",
            "    def grouper(self):",
            "        roots = [(x, self.find(x_par)) for x, x_par in self.parent.items()]",
            "        root = operator.itemgetter(1)",
            "        for _, group in itertools.groupby(sorted(roots, key=root), root):",
            "            yield [x for x, _ in group]",
            "def main():",
            "    N, M = LI()",
            "    visited = [False]*(N+1)",
            "    uf = UnionFind()",
            "    ans_rev = [0]*(M+1)",
            "    ans_rev[0] = N * (N-1) // 2  # N_C_2",
            "    A_li, B_li = [], []",
            "    for i in range(0, M):",
            "        A, B = LI()",
            "        A_li.append(A)",
            "        B_li.append(B)",
            "    for i, (A, B) in enumerate(reversed(list(zip(A_li, B_li)))):",
            "        if not uf.are_same(A, B):",
            "            ans_rev[i+1] = ans_rev[i] - uf.size(A) * uf.size(B)",
            "        else:",
            "            ans_rev[i+1] = ans_rev[i]",
            "        uf.unite(A, B)",
            "    for i in reversed(ans_rev[:-1]):",
            "        print(i)",
            "main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    class UnionFindTree:",
            "        def __init__(self, num_of_elm):",
            "            self.n = num_of_elm",
            "            self.table = [i for i in range(self.n)]",
            "            self.rank = [0] * self.n",
            "            self.group_size = [1] * self.n",
            "            self.roots = set(i for i in range(self.n))",
            "        def _find_set(self, x):",
            "            '''",
            "            x の属するグループ番号を O(α(n)) で求める",
            "            '''",
            "            parent = self.table[x]",
            "            if x == parent:",
            "                return x",
            "            else:",
            "                root = self._find_set(parent)",
            "                # 経路圧縮",
            "                self.table[x] = root",
            "                return root",
            "        def is_same(self, x, y):",
            "            '''",
            "            x と y が同じグループに属するか O(α(n)) で判定する",
            "            '''",
            "            return self._find_set(x) == self._find_set(y)",
            "        def union(self, x, y):",
            "            '''",
            "            x と y の属するグループを O(α(n)) で統合する",
            "            '''",
            "            shallow_root = self._find_set(x)",
            "            deep_root = self._find_set(y)",
            "            if self.rank[shallow_root] > self.rank[deep_root]:",
            "                shallow_root, deep_root = deep_root, shallow_root",
            "            # そもそも同一グループだった時",
            "            if shallow_root == deep_root:",
            "                return False",
            "            # グループが異なるので union",
            "            else:",
            "                self.roots.remove(shallow_root)",
            "                self.table[shallow_root] = deep_root",
            "                self.group_size[deep_root] += self.group_size[shallow_root]",
            "                # 深さが等しかったときはつけ加えられた側の rank をインクリメントする",
            "                if self.rank[shallow_root] == self.rank[deep_root]:",
            "                    self.rank[deep_root] += 1",
            "                return True",
            "        def akin_num(self, x):",
            "            '''",
            "            x の属するグループのサイズを O(1) で計算する",
            "            '''",
            "            x_root = self._find_set(x)",
            "            return self.group_size[x_root]",
            "        def print_group_id(self):",
            "            print([self._find_set(x) for x in self.table])",
            "    n, m = mi()",
            "    query = [lmi_0() for _ in range(m)]",
            "    query.reverse()",
            "    ans = []",
            "    total_pairs = n * (n - 1) // 2",
            "    connected_pairs = 0",
            "    uf = UnionFindTree(n)",
            "    for i in range(m):",
            "        ans.append(total_pairs - connected_pairs)",
            "        group_a_size = uf.akin_num(query[i][0])",
            "        group_b_size = uf.akin_num(query[i][1])",
            "        result = uf.union(query[i][0], query[i][1])",
            "        if result:",
            "            # 異なるグループがマージされた",
            "            connected_pairs += group_a_size * group_b_size",
            "    for elm in reversed(ans):",
            "        print(elm)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "mod = 10 ** 9 + 7",
            "mod2 = 2 ** 61 + 1",
            "from collections import deque",
            "import heapq",
            "from bisect import bisect_left, insort_left, bisect_right",
            "_NUMINT_ALL = list(range(10))",
            "def main():",
            "    ans = solve()",
            "    if ans is True or ans is False:",
            "        YesNo(ans)",
            "    elif ans is not None:",
            "        print(ans)",
            "class UfNode():",
            "    def __init__(self, id):",
            "        self.parent = None",
            "        self.id = id",
            "        self._size = 1",
            "    @property",
            "    def size(self):",
            "        if not self.parent:",
            "            return self._size",
            "        else:",
            "            return self.root()._size",
            "    def root(self):",
            "        if not self.parent:",
            "            return self",
            "        else:",
            "            return self.parent.root()",
            "    def sizeup(self, n):",
            "        if not self.parent:",
            "            self._size += n",
            "        else:",
            "            self.root().sizeup(n)",
            "    def unite(self, target):",
            "        sr = self.root().id",
            "        tr = target.root().id",
            "        if sr == tr:",
            "            return False",
            "        elif sr > tr:",
            "            target.sizeup(self.size)",
            "            self.root().parent = target.root()",
            "        else:",
            "            self.sizeup(target.size)",
            "            target.root().parent = self.root()",
            "def solve():",
            "    N, M = iip(False)",
            "    AB = iipt(M)",
            "    AB.reverse()",
            "    nroot = {}",
            "    nodes = [UfNode(i) for i in range(N)]",
            "    benlist = [0]",
            "    cur = 0",
            "    for a, b in AB:",
            "        a -= 1",
            "        b -= 1",
            "        c1 = nodes[a].size",
            "        c2 = nodes[b].size",
            "        nodes[b].unite(nodes[a])",
            "        if c2 != nodes[b].size:",
            "            cur += c1*c2",
            "        benlist.append(cur)",
            "    t = benlist.pop()",
            "    benlist.reverse()",
            "    #print(benlist)",
            "    ans = [t - i for i in benlist]",
            "    split_print_enter(ans)",
            "#####################################################ライブラリ集ここから",
            "def kiriage_warizan(a, b):",
            "    return -(-a//b)",
            "def iip(listed=True):  # 数字のinputをlistで受け取る",
            "    d = input().split()",
            "    try:",
            "        ret = [int(i) for i in d]",
            "    except:",
            "        ret = [int(i) if i in _NUMINT_ALL else i for i in d]",
            "        if len(ret) == 1:",
            "            return ret[0]",
            "    if len(ret) == 1 and not listed:",
            "        return ret[0]",
            "    return ret",
            "def iipt(l, listed=False, num_only=True):  # 縦向きに並んでいるデータをリストに落とし込む(iip利用)",
            "    ret = []",
            "    for i in range(l):",
            "        ret.append(iip(listed=listed))",
            "    return ret",
            "def saidai_kouyakusuu(A):  # 最大公約数",
            "    l = len(A)",
            "    while True:",
            "        m = min(A)",
            "        mx = max(A)",
            "        if m == mx:",
            "            return m",
            "        for i in range(l):",
            "            if A[i] % m == 0:",
            "                A[i] = m",
            "            else:",
            "                A[i] %= m",
            "def make_graph_edge_flat(N):  # グラフ作成のための辺をリストで返す",
            "    ret = []",
            "    for i in range(N-1):",
            "        a, b, c = iip()",
            "        a -= 1",
            "        b -= 1",
            "        ret[a].append((b, c))",
            "        ret[b].append((a, c))",
            "    return ret",
            "def sort_tuples(l, index):  # タプルのリストを特定のインデックスでソートする",
            "    if isinstance(l, list):",
            "        l.sort(key=lambda x: x[index])",
            "        return l",
            "    else:",
            "        l = list(l)",
            "        return sorted(l, key=lambda x: x[index])",
            "def count_elements(l):  # リストの中身の個数を種類分けして辞書で返す",
            "    d = {}",
            "    for i in l:",
            "        if i in d:",
            "            d[i] += 1",
            "        else:",
            "            d[i] = 1",
            "    return d",
            "def safeget(l, index, default=\"exception\"):  # listの中身を取り出す時、listからはみ出たり",
            "    if index >= len(l):                      # マイナスインデックスになったりするのを防ぐ",
            "        if default == \"exception\":",
            "            raise Exception(\"\".join([\"safegetに不正な値 \", index, \"が渡されました。配列の長さは\", len(l), \"です\"]))",
            "        else:",
            "            return default",
            "    elif index < 0:",
            "        if default == \"exception\":",
            "            raise Exception(\"\".join([\"safegetに不正な値 \", index, \"が渡されました。負の値は許可されていません\"]))",
            "        else:",
            "            return default",
            "    else:",
            "        return l[index]",
            "def sortstr(s):  # 文字列をソートする",
            "    return \"\".join(sorted(s))",
            "def iip_ord(startcode=\"a\"):  # 文字列を数字の列に変換する(数字と文字は1:1対応)",
            "    if isinstance(startcode, str):",
            "        startcode = ord(startcode)",
            "    return [ord(i) - startcode for i in input()]",
            "def YesNo(s):  # TrueFalseや1, 0をYesNoに変換する",
            "    if s:",
            "        print(\"Yes\")",
            "    else:",
            "        print(\"No\")",
            "def fprint(s):  # リストを平たくしてprintする(二次元リストを見やすくしたりとか)",
            "    for i in s:",
            "        print(i)",
            "def bitall(N):  # ビット全探索用のインデックスを出力",
            "    ret = []",
            "    for i in range(2 ** N):",
            "        a = []",
            "        for j in range(N):",
            "            a.append(i % 2)",
            "            i //= 2",
            "        ret.append(a)",
            "    return ret",
            "def split_print_space(s):  # リストの中身をスペース区切りで出力する",
            "    print(\" \".join([str(i) for i in s]))",
            "def split_print_enter(s):  # リストの中身を改行区切りで出力する",
            "    print(\"\\n\".join([str(i) for i in s]))",
            "def soinsuu_bunkai(n):  # 素因数分解",
            "    ret = []",
            "    for i in range(2, int(n ** 0.5) + 1):",
            "        while n % i == 0:",
            "            n //= i",
            "            ret.append(i)",
            "        if i > n:",
            "            break",
            "    if n != 1:",
            "        ret.append(n)",
            "    return ret",
            "def conbination(n, r, mod, test=False):  # nCrをmodを使って計算する",
            "    if n <= 0:",
            "        return 0",
            "    if r == 0:",
            "        return 1",
            "    if r < 0:",
            "        return 0",
            "    if r == 1:",
            "        return n",
            "    ret = 1",
            "    for i in range(n - r + 1, n + 1):",
            "        ret *= i",
            "        ret = ret % mod",
            "    bunbo = 1",
            "    for i in range(1, r + 1):",
            "        bunbo *= i",
            "        bunbo = bunbo % mod",
            "    ret = (ret * inv(bunbo, mod)) % mod",
            "    if test:",
            "        # print(f\"{n}C{r} = {ret}\")",
            "        pass",
            "    return ret",
            "def inv(n, mod):  #  modnにおける逆元を計算",
            "    return power(n, mod - 2)",
            "def power(n, p, mod_=mod):  # 繰り返し二乗法でn**p % modを計算",
            "    if p == 0:",
            "        return 1",
            "    if p % 2 == 0:",
            "        return (power(n, p // 2, mod_) ** 2) % mod_",
            "    if p % 2 == 1:",
            "        return (n * power(n, p - 1, mod_)) % mod_",
            "def nibutan_func(func, target, left, right, side=\"left\"): # 関数を二分探索",
            "    l = left",
            "    r = right",
            "    while r-l > 1:",
            "        x = (l+r)//2",
            "        if func(x) == target:",
            "            return x",
            "        elif func(x) > target:",
            "            r = x",
            "        else:",
            "            l = x",
            "    if side == \"left\" or func(x) == target:",
            "        return l",
            "    else:",
            "        return r",
            "def nibutan_list(list_, target, side=\"left\"):  # リストを二分探索",
            "    if not isinstance(list_, list):",
            "        list_ = list(list_)",
            "    l = 0",
            "    r = len(list_)",
            "    while r-l > 1:",
            "        x = (l+r)//2",
            "        if list_[x] == target:",
            "            return x",
            "        elif list_[x] > target:",
            "            r = x",
            "        else:",
            "            l = x",
            "    if side == \"left\" or list_[x] == target:",
            "        return l",
            "    else:",
            "        return r",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "mod = 10 ** 9 + 7",
            "mod2 = 2 ** 61 + 1",
            "from collections import deque",
            "import heapq",
            "import time",
            "from bisect import bisect_left, insort_left, bisect_right",
            "import sys",
            "input = sys.stdin.readline",
            "_NUMINT_ALL = list(range(10))",
            "def main():",
            "    ans = solve()",
            "    if ans is True or ans is False:",
            "        YesNo(ans)",
            "    elif ans is not None:",
            "        print(ans)",
            "def solve():",
            "    N, M = iip(False)",
            "    AB = iipt(M)",
            "    AB.reverse()",
            "    uf = UfTree(N)",
            "    benlist = [0]",
            "    cur = 0",
            "    for a, b in AB:",
            "        a -= 1",
            "        b -= 1",
            "        c1 = uf.size(a)",
            "        c2 = uf.size(b)",
            "        uf.unite(a, b)",
            "        if c2 != uf.size(a):",
            "            cur += c1*c2",
            "        benlist.append(cur)",
            "    t = benlist.pop()",
            "    benlist.reverse()",
            "    #print(benlist)",
            "    ans = [t - i for i in benlist]",
            "    split_print_enter(ans)",
            "#####################################################ライブラリ集ここから",
            "def kiriage_warizan(a, b):",
            "    return -(-a//b)",
            "def iip(listed=True):  # 数字のinputをlistで受け取る",
            "    d = input().rstrip(\"\\n\").split()",
            "    try:",
            "        ret = [int(i) for i in d]",
            "    except:",
            "        ret = [int(i) if i in _NUMINT_ALL else i for i in d]",
            "        if len(ret) == 1:",
            "            return ret[0]",
            "    if len(ret) == 1 and not listed:",
            "        return ret[0]",
            "    return ret",
            "def iipt(l, listed=False, num_only=True):  # 縦向きに並んでいるデータをリストに落とし込む(iip利用)",
            "    ret = []",
            "    for i in range(l):",
            "        ret.append(iip(listed=listed))",
            "    return ret",
            "def saidai_kouyakusuu(A):  # 最大公約数",
            "    l = len(A)",
            "    while True:",
            "        m = min(A)",
            "        mx = max(A)",
            "        if m == mx:",
            "            return m",
            "        for i in range(l):",
            "            if A[i] % m == 0:",
            "                A[i] = m",
            "            else:",
            "                A[i] %= m",
            "def make_graph_edge_flat(N):  # グラフ作成のための辺をリストで返す",
            "    ret = []",
            "    for i in range(N-1):",
            "        a, b, c = iip()",
            "        a -= 1",
            "        b -= 1",
            "        ret[a].append((b, c))",
            "        ret[b].append((a, c))",
            "    return ret",
            "def sort_tuples(l, index):  # タプルのリストを特定のインデックスでソートする",
            "    if isinstance(l, list):",
            "        l.sort(key=lambda x: x[index])",
            "        return l",
            "    else:",
            "        l = list(l)",
            "        return sorted(l, key=lambda x: x[index])",
            "def count_elements(l):  # リストの中身の個数を種類分けして辞書で返す",
            "    d = {}",
            "    for i in l:",
            "        if i in d:",
            "            d[i] += 1",
            "        else:",
            "            d[i] = 1",
            "    return d",
            "def safeget(l, index, default=\"exception\"):  # listの中身を取り出す時、listからはみ出たり",
            "    if index >= len(l):                      # マイナスインデックスになったりするのを防ぐ",
            "        if default == \"exception\":",
            "            raise Exception(\"\".join([\"safegetに不正な値 \", index, \"が渡されました。配列の長さは\", len(l), \"です\"]))",
            "        else:",
            "            return default",
            "    elif index < 0:",
            "        if default == \"exception\":",
            "            raise Exception(\"\".join([\"safegetに不正な値 \", index, \"が渡されました。負の値は許可されていません\"]))",
            "        else:",
            "            return default",
            "    else:",
            "        return l[index]",
            "def sortstr(s):  # 文字列をソートする",
            "    return \"\".join(sorted(s))",
            "def iip_ord(startcode=\"a\"):  # 文字列を数字の列に変換する(数字と文字は1:1対応)",
            "    if isinstance(startcode, str):",
            "        startcode = ord(startcode)",
            "    return [ord(i) - startcode for i in input()]",
            "def YesNo(s):  # TrueFalseや1, 0をYesNoに変換する",
            "    if s:",
            "        print(\"Yes\")",
            "    else:",
            "        print(\"No\")",
            "def fprint(s):  # リストを平たくしてprintする(二次元リストを見やすくしたりとか)",
            "    for i in s:",
            "        print(i)",
            "def bitall(N):  # ビット全探索用のインデックスを出力",
            "    ret = []",
            "    for i in range(2 ** N):",
            "        a = []",
            "        for j in range(N):",
            "            a.append(i % 2)",
            "            i //= 2",
            "        ret.append(a)",
            "    return ret",
            "def split_print_space(s):  # リストの中身をスペース区切りで出力する",
            "    print(\" \".join([str(i) for i in s]))",
            "def split_print_enter(s):  # リストの中身を改行区切りで出力する",
            "    print(\"\\n\".join([str(i) for i in s]))",
            "def soinsuu_bunkai(n):  # 素因数分解",
            "    ret = []",
            "    for i in range(2, int(n ** 0.5) + 1):",
            "        while n % i == 0:",
            "            n //= i",
            "            ret.append(i)",
            "        if i > n:",
            "            break",
            "    if n != 1:",
            "        ret.append(n)",
            "    return ret",
            "def conbination(n, r, mod, test=False):  # nCrをmodを使って計算する",
            "    if n <= 0:",
            "        return 0",
            "    if r == 0:",
            "        return 1",
            "    if r < 0:",
            "        return 0",
            "    if r == 1:",
            "        return n",
            "    ret = 1",
            "    for i in range(n - r + 1, n + 1):",
            "        ret *= i",
            "        ret = ret % mod",
            "    bunbo = 1",
            "    for i in range(1, r + 1):",
            "        bunbo *= i",
            "        bunbo = bunbo % mod",
            "    ret = (ret * inv(bunbo, mod)) % mod",
            "    if test:",
            "        # print(f\"{n}C{r} = {ret}\")",
            "        pass",
            "    return ret",
            "def inv(n, mod):  #  modnにおける逆元を計算",
            "    return power(n, mod - 2)",
            "def power(n, p, mod_=mod):  # 繰り返し二乗法でn**p % modを計算",
            "    if p == 0:",
            "        return 1",
            "    if p % 2 == 0:",
            "        return (power(n, p // 2, mod_) ** 2) % mod_",
            "    if p % 2 == 1:",
            "        return (n * power(n, p - 1, mod_)) % mod_",
            "def nibutan_func(func, target, left, right, side=\"left\"): # 関数を二分探索",
            "    l = left",
            "    r = right",
            "    x = (l + r) // 2",
            "    while r-l > 1:",
            "        x = (l+r)//2",
            "        if func(x) == target:",
            "            return x",
            "        elif func(x) > target:",
            "            r = x",
            "        else:",
            "            l = x",
            "    if side == \"left\" or func(x) == target:",
            "        return l",
            "    else:",
            "        return r",
            "def nibutan_list(list_, target, side=\"left\"):  # リストを二分探索",
            "    if not isinstance(list_, list):",
            "        list_ = list(list_)",
            "    l = 0",
            "    r = len(list_)",
            "    x = (l + r) // 2",
            "    while r-l > 1:",
            "        x = (l+r)//2",
            "        if list_[x] == target:",
            "            return x",
            "        elif list_[x] > target:",
            "            r = x",
            "        else:",
            "            l = x",
            "    if side == \"left\" or list_[x] == target:",
            "        return l",
            "    else:",
            "        return r",
            "class UfTree():",
            "    def __init__(self, maxnum):",
            "        self.parent = list(range(maxnum))",
            "        self._size = [1] * maxnum",
            "        self.rank = [0] * maxnum",
            "    def size(self, a):",
            "        return self._size[self.root(a)]",
            "    def root(self, a):",
            "        rank = 0",
            "        cur = a",
            "        while True:",
            "            if self.parent[cur] == cur:",
            "                #for i in path: # 経路圧縮",
            "                #    self.parent[i] = cur",
            "                return cur",
            "            else:",
            "                self.parent[cur] = self.parent[self.parent[cur]]",
            "                cur = self.parent[cur]",
            "                rank += 1",
            "    def unite(self, a, b):",
            "        ra = self.root(a)",
            "        rb = self.root(b)",
            "        if ra == rb:",
            "            return self",
            "        self._size[ra] += self._size[rb]",
            "        self.parent[rb] = ra",
            "        return self",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# abc119_b.py",
            "# https://atcoder.jp/contests/abc119/tasks/abc119_b",
            "# B - Digital Gifts /",
            "# 実行時間制限: 2 sec / メモリ制限: 1024 MB",
            "# 配点 : 200点",
            "# 問題文",
            "# 高橋くんは N人の親戚からお年玉をもらいました。",
            "# N個の値 x1,x2,...,xN と N 個の文字列 u1,u2,...,uN が入力されます。",
            "# 各文字列 ui は JPY または BTC であり、xi と ui が i人目の親戚からのお年玉の内容を表します。",
            "# 例えば、x1=10000, u1= JPY であれば 1 人目の親戚からのお年玉は 10000 円であり、x2= 0.10000000,",
            "# u2= BTC であれば 2 人目の親戚からのお年玉は 0.1ビットコインです。",
            "# ビットコインを 1.0BTC あたり 380000.0円として換算すると、高橋くんがもらったお年玉は合計で何円に相当するでしょうか？",
            "# 制約",
            "#     2≤N≤10",
            "# ui=JPY または BTC",
            "# ui=JPY のとき xi は整数であり、1≤xi≤10^8",
            "# ui=BTC のとき xi は小数点以下の桁を 8 桁持つ小数であり、0.00000001≤xi≤100.00000000",
            "# 入力",
            "# 入力は以下の形式で標準入力から与えられる。",
            "# N",
            "# x1 u1",
            "# x2 u2",
            "# :",
            "# xN uN",
            "# 出力",
            "# 高橋くんが受け取ったお年玉が合計で Y円に相当するとき、値 Y(整数とは限らない) を出力せよ。",
            "# 出力は、ジャッジの出力との絶対誤差または相対誤差が 10−5以下のとき正解と判定される。",
            "# 入力例 1",
            "# 2",
            "# 10000 JPY",
            "# 0.10000000 BTC",
            "# 出力例 1",
            "# 48000.0",
            "# 1人目の親戚からのお年玉は 10000 円です。",
            "# 2 人目の親戚からのお年玉は 0.1 ビットコインであり、1 BTC あたり 380000.0 円として換算すると 38000.0 円となります。",
            "# これらの合計は 48000.0円です。",
            "# なお、48000、48000.1 などと出力しても正解と判定されます。",
            "# 入力例 2",
            "# 3",
            "# 100000000 JPY",
            "# 100.00000000 BTC",
            "# 0.00000001 BTC",
            "# 出力例 2",
            "# 138000000.0038",
            "# この場合、138001000、1.38e8 などと出力しても正解と判定されます。",
            "def calculation(lines):",
            "    # line = lines[0]",
            "    N = int(lines[0])",
            "    # N, M = list(map(int, lines[0].split()))",
            "    # values = list(map(int, lines[1].split()))",
            "    # values = list()",
            "    # for i in range(N):",
            "    #     values.append(int(lines[i+1]))",
            "    result = 0",
            "    for i in range(N):",
            "        line = lines[i+1]",
            "        if 'JPY' in line:",
            "            result += int(line.replace(' JPY', ''))",
            "        else:",
            "            result += float(line.replace(' BTC', ''))*380000.0",
            "    return [result]",
            "# 引数を取得",
            "def get_input_lines():",
            "    line = input()",
            "    N = int(line)",
            "    lines = list()",
            "    lines.append(line)",
            "    for _ in range(N):",
            "        lines.append(input())",
            "    return lines",
            "# テストデータ",
            "def get_testdata(pattern):",
            "    if pattern == 1:",
            "        lines_input = ['2', '10000 JPY', '0.10000000 BTC']",
            "        lines_export = [48000.0]",
            "    if pattern == 2:",
            "        lines_input = ['3', '100000000 JPY', '100.00000000 BTC', '0.00000001 BTC']",
            "        lines_export = [138000000.0038]",
            "    return lines_input, lines_export",
            "# 動作モード判別",
            "def get_mode():",
            "    import sys",
            "    args = sys.argv",
            "    if len(args) == 1:",
            "        mode = 0",
            "    else:",
            "        mode = int(args[1])",
            "    return mode",
            "# 主処理",
            "def main():",
            "    import time",
            "    started = time.time()",
            "    mode = get_mode()",
            "    if mode == 0:",
            "        lines_input = get_input_lines()",
            "    else:",
            "        lines_input, lines_export = get_testdata(mode)",
            "    lines_result = calculation(lines_input)",
            "    for line_result in lines_result:",
            "        print(line_result)",
            "    # if mode > 0:",
            "    #     print(f'lines_input=[{lines_input}]')",
            "    #     print(f'lines_export=[{lines_export}]')",
            "    #     print(f'lines_result=[{lines_result}]')",
            "    #     if lines_result == lines_export:",
            "    #         print('OK')",
            "    #     else:",
            "    #         print('NG')",
            "    # finished = time.time()",
            "    # duration = finished - started",
            "    # print(f'duration=[{duration}]')",
            "# 起動処理",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    ans = 0",
            "    n = ii()",
            "    for _ in range(n):",
            "        x, u = input().split()",
            "        x = float(x)",
            "        if u == 'JPY':",
            "            ans += x",
            "        else:",
            "            ans += 380000 * x",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# abc119_c.py",
            "# https://atcoder.jp/contests/abc119/tasks/abc119_c",
            "# C - Synthetic Kadomatsu /",
            "# 実行時間制限: 2 sec / メモリ制限: 1024 MB",
            "# 配点 : 300点",
            "# 問題文",
            "# あなたは N本の竹を持っています。これらの長さはそれぞれ l1,l2,...,lNです (単位: センチメートル)。",
            "# あなたの目的は、これらの竹のうち何本か (全部でもよい) を使い、長さが A,B,Cであるような 3本の竹を得ることです。",
            "# そのために、以下の三種類の魔法を任意の順に何度でも使うことができます。",
            "#     延長魔法: 1MP (マジックポイント) を消費し、1 本の竹を選んでその長さを 1増やす。",
            "#     短縮魔法: 1MP を消費し、1 本の長さ 2 以上の竹を選んでその長さを 1減らす。",
            "#     合成魔法: 10MP を消費し、2 本の竹を選んで接続し 1 本の竹とする。この新たな竹の長さは接続した 2本の竹の長さの合計に等しい。",
            "#     (以後、この竹に対してさらに魔法を使用することもできる。)",
            "# 目的を達成するには、最小でいくつの MP が必要でしょうか？",
            "# 制約",
            "#     3≤N≤8",
            "#     1≤C<B<A≤1000",
            "#     1≤li≤1000",
            "#     入力される値はすべて整数である。",
            "# 入力",
            "# 入力は以下の形式で標準入力から与えられる。",
            "# N A B C",
            "# l1",
            "# l2",
            "# :",
            "# lN",
            "# 出力",
            "# 目的の達成に必要な MP の最小量を出力せよ。",
            "# 入力例 1",
            "# 5 100 90 80",
            "# 98",
            "# 40",
            "# 30",
            "# 21",
            "# 80",
            "# 出力例 1",
            "# 23",
            "# 長さ 98,40,30,21,80の 5 本の竹から長さ 100,90,80 の 3 本の竹を得ようとしています。",
            "# 長さ 80 の竹ははじめから持っており、長さ 100,90 の竹は次のように魔法を使うと合計 23MP を消費することで得られ、これが最適です。",
            "#     長さ 98の竹に延長魔法を 2 回使い、長さ 100 の竹を得る。(消費 MP: 2)",
            "#     長さ 40,30の竹に合成魔法を使い、長さ 70 の竹を得る。(消費 MP: 10)",
            "#     長さ 21の竹に短縮魔法を 1 回使い、長さ 20 の竹を得る。(消費 MP: 1)",
            "#     手順 2. で得た長さ 70の竹と手順 3. で得た長さ 20 の竹に合成魔法を使い、長さ 90 の竹を得る。(消費 MP: 10)",
            "# 入力例 2",
            "# 8 100 90 80",
            "# 100",
            "# 100",
            "# 90",
            "# 90",
            "# 90",
            "# 80",
            "# 80",
            "# 80",
            "# 出力例 2",
            "# 0",
            "# 欲しい長さの竹をすでにすべて持っている場合、必要な MP は 0です。このように、必ずしもすべての竹を使う必要はありません。",
            "# 入力例 3",
            "# 8 1000 800 100",
            "# 300",
            "# 333",
            "# 400",
            "# 444",
            "# 500",
            "# 555",
            "# 600",
            "# 666",
            "# 出力例 3",
            "# 243",
            "def calculation(lines):",
            "    # line = lines[0]",
            "    # N = int(lines[0])",
            "    N, A, B, C = list(map(int, lines[0].split()))",
            "    # values = list(map(int, lines[1].split()))",
            "    values = list()",
            "    for i in range(N):",
            "        values.append(int(lines[i+1]))",
            "    patterns = get_patterns(N)",
            "    result = None",
            "    # print(patterns)",
            "    # patterns = ['01020003']",
            "    # patterns = ['01021003', '01020003', '31320113']",
            "    # patterns = ['32012100']",
            "    for pattern in patterns:",
            "        # print(f'pattern=[{pattern}]')",
            "        a = 0",
            "        b = 0",
            "        c = 0",
            "        mp = 0",
            "        for i, char in enumerate(pattern):",
            "            if char == '1':",
            "                if a > 0:",
            "                    mp += 10",
            "                a += values[i]",
            "            elif char == '2':",
            "                if b > 0:",
            "                    mp += 10",
            "                b += values[i]",
            "            elif char == '3':",
            "                if c > 0:",
            "                    mp += 10",
            "                c += values[i]",
            "        mp += abs(A-a) + abs(B-b) + abs(C-c)",
            "        # print(f'mp=[{mp}]')",
            "        if result is None:",
            "            result = mp",
            "        else:",
            "            if result > mp:",
            "                # print(f'pattern=[{pattern}], mp=[{mp}]')",
            "                result = mp",
            "    return [result]",
            "def get_patterns(n):",
            "    lst = ['0', '1', '2', '3']",
            "    _, patterns = get_patterns_internal(n-1, lst)",
            "    return [pattern for pattern in patterns if '1' in pattern and '2' in pattern and '3' in pattern]",
            "def get_patterns_internal(n, lst):",
            "    if n == 0:",
            "        return 0, lst",
            "    else:",
            "        ret = list()",
            "        for item in lst:",
            "            ret.append(item + '0')",
            "            ret.append(item + '1')",
            "            ret.append(item + '2')",
            "            ret.append(item + '3')",
            "        return get_patterns_internal(n-1, ret)",
            "# 引数を取得",
            "def get_input_lines():",
            "    line = input()",
            "    N, A, B, C = list(map(int, line.split()))",
            "    lines = list()",
            "    lines.append(line)",
            "    for _ in range(N):",
            "        lines.append(input())",
            "    return lines",
            "# テストデータ",
            "def get_testdata(pattern):",
            "    if pattern == 1:",
            "        lines_input = ['5 100 90 80', '98', '40', '30', '21', '80']",
            "        lines_export = [23]",
            "    if pattern == 2:",
            "        lines_input = ['8 100 90 80', '100', '100', '90', '90', '90', '80', '80', '80']",
            "        lines_export = [0]",
            "    if pattern == 3:",
            "        lines_input = ['8 1000 800 100', '300', '333', '400', '444', '500', '555', '600', '666']",
            "        lines_export = [243]",
            "    return lines_input, lines_export",
            "# 動作モード判別",
            "def get_mode():",
            "    import sys",
            "    args = sys.argv",
            "    if len(args) == 1:",
            "        mode = 0",
            "    else:",
            "        mode = int(args[1])",
            "    return mode",
            "# 主処理",
            "def main():",
            "    import time",
            "    started = time.time()",
            "    mode = get_mode()",
            "    if mode == 0:",
            "        lines_input = get_input_lines()",
            "    else:",
            "        lines_input, lines_export = get_testdata(mode)",
            "    lines_result = calculation(lines_input)",
            "    for line_result in lines_result:",
            "        print(line_result)",
            "    # if mode > 0:",
            "    #     print(f'lines_input=[{lines_input}]')",
            "    #     print(f'lines_export=[{lines_export}]')",
            "    #     print(f'lines_result=[{lines_result}]')",
            "    #     if lines_result == lines_export:",
            "    #         print('OK')",
            "    #     else:",
            "    #         print('NG')",
            "    # finished = time.time()",
            "    # duration = finished - started",
            "    # print(f'duration=[{duration}]')",
            "# 起動処理",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def calc_min_mp(L, a, b, c):",
            "        ans = inf",
            "        quaternary = product(range(4), repeat=n)",
            "        for pattern in quaternary:",
            "            if pattern.count(1) and pattern.count(2) and pattern.count(3):",
            "                needed_mp =  (n - pattern.count(0) - 3) * 10    # 合成魔法の使用回数",
            "                base_abc = [0, 0, 0]    # base_a, base_b, base_c",
            "                for i, num in enumerate(pattern):",
            "                    if num != 0:",
            "                        base_abc[num - 1] += L[i]",
            "                needed_mp += abs(a - base_abc[0]) + abs(b - base_abc[1]) + abs(c - base_abc[2])",
            "                ans = min(ans, needed_mp)",
            "        return ans",
            "    n, a, b, c = mi()",
            "    L = [ii() for _ in range(n)]",
            "    print(calc_min_mp(L, a, b, c))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    a, b, q = mi()",
            "    shrine = [ii() for _ in range(a)]",
            "    temple = [ii() for _ in range(b)]",
            "    query = [ii() for _ in range(q)]",
            "    shrine.sort()",
            "    temple.sort()",
            "    for x in query:",
            "        ans = inf",
            "        # print('')",
            "        # 右にのみ進む",
            "        if x <= shrine[-1] and x <= temple[-1]:",
            "            dist = max(abs(x - shrine[bisect_left(shrine, x)]), abs(x - temple[bisect_left(temple, x)]))",
            "            # print(dist)",
            "            ans = min(ans, dist)",
            "        # 左にのみ進む",
            "        if shrine[0] <= x and temple[0] <= x:",
            "            dist = max(abs(x - shrine[bisect_right(shrine, x) - 1]), abs(x - temple[bisect_right(temple, x) - 1]))",
            "            # print(dist)",
            "            ans = min(ans, dist)",
            "        # 右で神社、左で寺を見つける",
            "        if x <= shrine[-1] and temple[0] <= x:",
            "            a = abs(x - shrine[bisect_left(shrine, x)])",
            "            b = abs(x - temple[bisect_right(temple, x) - 1])",
            "            dist = a + b + min(a, b)",
            "            # print(dist)",
            "            ans = min(ans, dist)",
            "        # 右で寺、左で神社を見つける",
            "        if x <= temple[-1] and shrine[0] <= x:",
            "            a = abs(x - temple[bisect_left(temple, x)])",
            "            b = abs(x - shrine[bisect_right(shrine, x) - 1])",
            "            dist = a + b + min(a, b)",
            "            # print(dist)",
            "            ans = min(ans, dist)",
            "        # print('ans')",
            "        print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "from bisect import bisect_left,bisect_right",
            "import sys",
            "reader = (s.rstrip() for s in sys.stdin)",
            "input = reader.__next__",
            "A,B,Q = map(int,input().split())",
            "S = []",
            "T = []",
            "for i in range(A):",
            "    S.append(int(input()))",
            "for i in range(B):",
            "    T.append(int(input()))",
            "for i in range(Q):",
            "    x = int(input())",
            "    values = []",
            "    p1 = bisect_left(S,x)",
            "    if p1 == 0:",
            "        p2 = bisect_left(T,S[p1])",
            "        if p2 == 0:",
            "            values.append(abs(x-S[p1])+abs(S[p1]-T[p2]))",
            "        elif p2 == B:",
            "            values.append(abs(x-S[p1])+abs(S[p1]-T[p2-1]))",
            "        else:",
            "            values.append(abs(x-S[p1])+abs(S[p1]-T[p2]))",
            "            values.append(abs(x-S[p1])+abs(S[p1]-T[p2-1]))",
            "    elif p1 == A:",
            "        p1 -= 1",
            "        p2 = bisect_left(T,S[p1])",
            "        if p2 == 0:",
            "            values.append(abs(x-S[p1])+abs(S[p1]-T[p2]))",
            "        elif p2 == B:",
            "            values.append(abs(x-S[p1])+abs(S[p1]-T[p2-1]))",
            "        else:",
            "            values.append(abs(x-S[p1])+abs(S[p1]-T[p2]))",
            "            values.append(abs(x-S[p1])+abs(S[p1]-T[p2-1]))",
            "    else:",
            "        #-1",
            "        p1 -= 1",
            "        p2 = bisect_left(T,S[p1])",
            "        if p2 == 0:",
            "            values.append(abs(x-S[p1])+abs(S[p1]-T[p2]))",
            "        elif p2 == B:",
            "            values.append(abs(x-S[p1])+abs(S[p1]-T[p2-1]))",
            "        else:",
            "            values.append(abs(x-S[p1])+abs(S[p1]-T[p2]))",
            "            values.append(abs(x-S[p1])+abs(S[p1]-T[p2-1]))",
            "        p1 += 1",
            "        p2 = bisect_left(T,S[p1])",
            "        if p2 == 0:",
            "            values.append(abs(x-S[p1])+abs(S[p1]-T[p2]))",
            "        elif p2 == B:",
            "            values.append(abs(x-S[p1])+abs(S[p1]-T[p2-1]))",
            "        else:",
            "            values.append(abs(x-S[p1])+abs(S[p1]-T[p2]))",
            "            values.append(abs(x-S[p1])+abs(S[p1]-T[p2-1]))",
            "    p1 = bisect_left(T,x)",
            "    if p1 == 0:",
            "        p2 = bisect_left(S,T[p1])",
            "        if p2 == 0:",
            "            values.append(abs(x-T[p1])+abs(T[p1]-S[p2]))",
            "        elif p2 == A:",
            "            values.append(abs(x-T[p1])+abs(T[p1]-S[p2-1]))",
            "        else:",
            "            values.append(abs(x-T[p1])+abs(T[p1]-S[p2]))",
            "            values.append(abs(x-T[p1])+abs(T[p1]-S[p2-1]))",
            "    elif p1 == B:",
            "        p1 -= 1",
            "        p2 = bisect_left(S,T[p1])",
            "        if p2 == 0:",
            "            values.append(abs(x-T[p1])+abs(T[p1]-S[p2]))",
            "        elif p2 == A:",
            "            values.append(abs(x-T[p1])+abs(T[p1]-S[p2-1]))",
            "        else:",
            "            values.append(abs(x-T[p1])+abs(T[p1]-S[p2]))",
            "            values.append(abs(x-T[p1])+abs(T[p1]-S[p2-1]))",
            "    else:",
            "        #-1",
            "        p1 -= 1",
            "        p2 = bisect_left(S,T[p1])",
            "        if p2 == 0:",
            "            values.append(abs(x-T[p1])+abs(T[p1]-S[p2]))",
            "        elif p2 == A:",
            "            values.append(abs(x-T[p1])+abs(T[p1]-S[p2-1]))",
            "        else:",
            "            values.append(abs(x-T[p1])+abs(T[p1]-S[p2]))",
            "            values.append(abs(x-T[p1])+abs(T[p1]-S[p2-1]))",
            "        p1 += 1",
            "        p2 = bisect_left(S,T[p1])",
            "        if p2 == 0:",
            "            values.append(abs(x-T[p1])+abs(T[p1]-S[p2]))",
            "        elif p2 == A:",
            "            values.append(abs(x-T[p1])+abs(T[p1]-S[p2-1]))",
            "        else:",
            "            values.append(abs(x-T[p1])+abs(T[p1]-S[p2]))",
            "            values.append(abs(x-T[p1])+abs(T[p1]-S[p2-1]))",
            "    d = min(values)",
            "    print(d)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            2,
            2
        ]
    },
    {
        "content": [
            "# abc118_b.py",
            "# https://atcoder.jp/contests/abc118/tasks/abc118_b",
            "# B - Foods Loved by Everyone /",
            "# 実行時間制限: 2 sec / メモリ制限: 1024 MB",
            "# 配点 : 200点",
            "# 問題文",
            "# カツサンドくんはオムライスが好きです。",
            "# 他にも明太子や寿司、クリームブリュレやテンダーロインステーキなどが好きで、これらの食べ物は全て、誰もが好きだと信じています。",
            "# その仮説を証明するために、N人の人に M種類の食べ物について好きか嫌いかの調査を行いました。",
            "# 調査の結果、i番目の人は Ai1 番目, Ai2 番目, ..., AiKi番目の食べ物だけ好きだと答えました。",
            "# N人全ての人が好きだと答えた食べ物の種類数を求めてください。",
            "# 制約",
            "#     入力は全て整数である。",
            "#     1≤N,M≤30",
            "#     1≤Ki≤M",
            "#     1≤Aij≤M",
            "#     各 i(1≤i≤N) について Ai1,Ai2,...,AiKiは全て異なる。",
            "# 入力",
            "# 入力は以下の形式で標準入力から与えられる。",
            "# N M",
            "# K1 A11 A12 ... A1K1",
            "# K2 A21 A22 ... A2K2",
            "# :",
            "# KN AN1 AN2 ... ANKN",
            "# 出力",
            "# N人全ての人が好きだと答えた食べ物の種類数を出力せよ。",
            "# 入力例 1",
            "# 3 4",
            "# 2 1 3",
            "# 3 1 2 3",
            "# 2 3 2",
            "# 出力例 1",
            "# 1",
            "# 3人全員が好きだと答えた食べ物は 3 番目の食べ物だけなので 1を出力します。",
            "# 入力例 2",
            "# 5 5",
            "# 4 2 3 4 5",
            "# 4 1 3 4 5",
            "# 4 1 2 4 5",
            "# 4 1 2 3 5",
            "# 4 1 2 3 4",
            "# 出力例 2",
            "# 0",
            "# カツサンドくんの仮説は全く正しくありませんでした。",
            "# 入力例 3",
            "# 1 30",
            "# 3 5 10 30",
            "# 出力例 3",
            "# 3",
            "def calculation(lines):",
            "    # line = lines[0]",
            "    # N = int(lines[0])",
            "    N, M = list(map(int, lines[0].split()))",
            "    # values = list(map(int, lines[1].split()))",
            "    # values = list()",
            "    # for i in range(N):",
            "    #     values.append(int(lines[i+1]))",
            "    valueses = list()",
            "    for i in range(N):",
            "        valueses.append(list(map(int, lines[i+1].split())))",
            "    dic = dict()",
            "    for values in valueses:",
            "        for i in range(1, len(values)):",
            "            value = values[i]",
            "            if value not in dic.keys():",
            "                dic[value] = 1",
            "            else:",
            "                dic[value] += 1",
            "    result = 0",
            "    for key in dic:",
            "        if dic[key] == N:",
            "            result += 1",
            "    return [result]",
            "# 引数を取得",
            "def get_input_lines():",
            "    line = input()",
            "    N, M = list(map(int, line.split()))",
            "    lines = list()",
            "    lines.append(line)",
            "    for _ in range(N):",
            "        lines.append(input())",
            "    return lines",
            "# テストデータ",
            "def get_testdata(pattern):",
            "    if pattern == 1:",
            "        lines_input = ['3 4', '2 1 3', '3 1 2 3', '2 3 2']",
            "        lines_export = [1]",
            "    if pattern == 2:",
            "        lines_input = ['5 5', '4 2 3 4 5', '4 1 3 4 5', '4 1 2 4 5', '4 1 2 3 5', '4 1 2 3 4']",
            "        lines_export = [0]",
            "    if pattern == 3:",
            "        lines_input = ['1 30', '3 5 10 30']",
            "        lines_export = [3]",
            "    return lines_input, lines_export",
            "# 動作モード判別",
            "def get_mode():",
            "    import sys",
            "    args = sys.argv",
            "    if len(args) == 1:",
            "        mode = 0",
            "    else:",
            "        mode = int(args[1])",
            "    return mode",
            "# 主処理",
            "def main():",
            "    import time",
            "    started = time.time()",
            "    mode = get_mode()",
            "    if mode == 0:",
            "        lines_input = get_input_lines()",
            "    else:",
            "        lines_input, lines_export = get_testdata(mode)",
            "    lines_result = calculation(lines_input)",
            "    for line_result in lines_result:",
            "        print(line_result)",
            "    # if mode > 0:",
            "    #     print(f'lines_input=[{lines_input}]')",
            "    #     print(f'lines_export=[{lines_export}]')",
            "    #     print(f'lines_result=[{lines_result}]')",
            "    #     if lines_result == lines_export:",
            "    #         print('OK')",
            "    #     else:",
            "    #         print('NG')",
            "    # finished = time.time()",
            "    # duration = finished - started",
            "    # print(f'duration=[{duration}]')",
            "# 起動処理",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "N,M=map(int,input().split())",
            "A=list(map(int,input().split()))",
            "A.sort()",
            "if 1 in A:",
            "    if N%2==0:",
            "        print(\"1\"*(N//2))",
            "    else:",
            "        if 7 in A:",
            "            print(\"7\"+\"1\"*(N//2-1))",
            "        elif 5 in A:",
            "            print(\"5\"+\"1\"*(N//2-2))",
            "        elif 3 in A:",
            "            print(\"3\"+\"1\"*(N//2-2))",
            "        elif 2 in A:",
            "            print(\"2\"+\"1\"*(N//2-2))",
            "        else:",
            "            print(\"8\"+\"1\"*(N//2-3))",
            "elif 7 in A:",
            "    if N%3==0:",
            "        print(\"7\"*(N//3))",
            "    elif N%3==1:",
            "        if 4 in A:",
            "            print(\"7\"*(N//3-1)+\"4\")",
            "        elif 8 in A:",
            "            print(\"8\"+\"7\"*(N//3-2))",
            "        elif 5 in A:",
            "            print(\"7\"*(N//3-3)+\"55\")",
            "        elif 3 in A:",
            "            print(\"7\"*(N//3-3)+\"33\")",
            "        elif 2 in A:",
            "            print(\"7\"*(N//3-3)+\"22\")",
            "    else:",
            "        if 5 in A:",
            "            print(\"7\"*(N//3-1)+\"5\")",
            "        elif 3 in A:",
            "             print(\"7\"*(N//3-1)+\"3\")",
            "        elif 2 in A:",
            "            print(\"7\"*(N//3-1)+\"2\")",
            "        elif 4 in A:",
            "            print(\"7\"*(N//3-2)+\"44\")",
            "        elif 8 in A:",
            "            print(print(\"7\"*(N//3-4)+\"88\"))",
            "else:",
            "    B=[[] for i in range(0,10)]",
            "    for i in range(0,M):",
            "        if 2 in A:",
            "            B[5].append(2)",
            "        if 3 in A:",
            "            B[5].append(3)",
            "        if 4 in A:",
            "            B[4].append(4)",
            "        if 5 in A:",
            "            B[5].append(5)",
            "        if 6 in A:",
            "            B[6].append(6)",
            "        if 8 in A:",
            "            B[7].append(8)",
            "        if 9 in A:",
            "            B[6].append(9)",
            "    dp=['n' for i in range(0,max(10,N+1))]",
            "    for i in range(0,min(N+1,10)):",
            "        if i==2:",
            "            if 2 in A:",
            "                dp[5]='2'",
            "        if i==3:",
            "            if 3 in A:",
            "                dp[5]='3'",
            "        if i==4:",
            "            if 4 in A:",
            "                dp[4]='4'",
            "        if i==5:",
            "            if 5 in A:",
            "                dp[5]='5'",
            "        if i==6:",
            "            if 6 in A:",
            "                dp[6]='6'",
            "        if i==8:",
            "            if 8 in A:",
            "                dp[7]='8'",
            "        if i==9:",
            "            if 9 in A:",
            "                dp[6]='9'",
            "    if N>=6:",
            "        a='0'",
            "        b='0'",
            "        c='0'",
            "        if dp[6]=='n':",
            "            a=int(a)",
            "            b=int(b)",
            "            c=int(c)",
            "            x=max(a,b,c)",
            "            if x!=0:",
            "                dp[6]=str(x)",
            "        else:",
            "            a=int(a)",
            "            b=int(b)",
            "            c=int(c)",
            "            d=int(dp[6])",
            "            dp[6]=str(max(a,b,c,d))",
            "    if N>=7:",
            "        a='0'",
            "        b='0'",
            "        c='0'",
            "        d='0'",
            "        if dp[7]=='n':",
            "            a=int(a)",
            "            b=int(b)",
            "            c=int(c)",
            "            d=int(d)",
            "            x=max(a,b,c,d)",
            "            if x!=0:",
            "                dp[7]=str(x)",
            "        else:",
            "            a=int(a)",
            "            b=int(b)",
            "            c=int(c)",
            "            d=int(d)",
            "            e=int(dp[7])",
            "            dp[7]=str(max(e,a,b,c,d))",
            "    for i in range(8,N+1):",
            "        a='0'",
            "        b='0'",
            "        c='0'",
            "        d='0'",
            "        e='0'",
            "        f='0'",
            "        if B[4] and dp[i-4]!='n':",
            "            c='4'+dp[i-4]",
            "        if B[5] and dp[i-5]!='n':",
            "            d=str(max(B[5]))+dp[i-5]",
            "        if B[6] and dp[i-6]!='n':",
            "            e=str(max(B[6]))+dp[i-6]",
            "        if B[7] and dp[i-7]!='n':",
            "            f='8'+dp[i-7]",
            "        a=int(a)",
            "        b=int(b)",
            "        c=int(c)",
            "        d=int(d)",
            "        e=int(e)",
            "        f=int(f)",
            "        x=max(a,b,c,d,e,f)",
            "        if x==0:",
            "            dp[i]='n'",
            "        else:",
            "            dp[i]=str(x)",
            "    print(int(dp[N]))"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            1,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "from copy import copy, deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, m = mi()",
            "    A = lmi()",
            "    # A の前処理 (同じ必要本数なのに値が小さいやつらが入っていたら削除しておく)",
            "    if 6 in A and 9 in A:",
            "        A.remove(6)",
            "    if 2 in A and 5 in A:",
            "        A.remove(2)",
            "    if 3 in A and 5 in A:",
            "        A.remove(3)",
            "    if 2 in A and 3 in A:",
            "        A.remove(2)",
            "    # 各数字とマッチの必要本数の対応テーブル",
            "    num_to_match = {1:2, 2:5, 3:5, 4:4, 5:5, 6:6, 7:3, 8:7, 9:6}",
            "    match_to_num = dict()",
            "    for num in A:",
            "        match_to_num[num_to_match[num]] = num",
            "    needed_match = [num_to_match[num] for num in A]",
            "    # dp[i] = (指定された数字を使い i 本全部を使って作れる最大桁数, 使用数字のカウンタ)",
            "    dp = [[None, None] for _ in range(n + 1)]",
            "    dp[0][0] = 0",
            "    dp[0][1] = Counter()",
            "    def counter_gt(c1, c2):",
            "        # print(f\"{c1} {c2}\")",
            "        return sorted(tuple(c1.items()), key=lambda x: x[0], reverse=True) > sorted(tuple(c2.items()), key=lambda x: x[0], reverse=True)",
            "    for i in range(n + 1):",
            "        digit_max = 0",
            "        counter_memo = None",
            "        for match in needed_match:",
            "            if i - match >= 0 and dp[i - match][0] is not None:",
            "                tmp = copy(dp[i - match][1])",
            "                tmp[match_to_num[match]] += 1",
            "                if dp[i - match][0] + 1 > digit_max or (dp[i - match][0] + 1 == digit_max and counter_gt(tmp, counter_memo)):",
            "                    digit_max = dp[i - match][0] + 1",
            "                    counter_memo = copy(dp[i - match][1])",
            "                    counter_memo[match_to_num[match]] += 1",
            "        if digit_max != 0:",
            "            dp[i][0] = digit_max",
            "            dp[i][1] = counter_memo",
            "    # print('')",
            "    # for elm in dp:",
            "    #     print(elm)",
            "    char_array = [None] * dp[n][0]",
            "    cnt = 0",
            "    t = sorted(dp[n][1].items(), key=lambda x: x[0], reverse=True)",
            "    for k, v in t:",
            "        for i in range(v):",
            "            char_array[i + cnt] = str(k)",
            "        cnt += v",
            "    print(''.join(char_array))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "N,M=map(int,input().split())",
            "A=list(map(int,input().split()))",
            "A.sort()",
            "if 1 in A:",
            "    if N%2==0:",
            "        print(\"1\"*(N//2))",
            "    else:",
            "        if 7 in A:",
            "            print(\"7\"+\"1\"*(N//2-1))",
            "        elif 5 in A:",
            "            print(\"5\"+\"1\"*(N//2-2))",
            "        elif 3 in A:",
            "            print(\"3\"+\"1\"*(N//2-2))",
            "        elif 2 in A:",
            "            print(\"2\"+\"1\"*(N//2-2))",
            "        else:",
            "            print(\"8\"+\"1\"*(N//2-3))",
            "else:",
            "    B=[[] for i in range(0,10)]",
            "    for i in range(0,M):",
            "        if 2 in A:",
            "            B[5].append(2)",
            "        if 3 in A:",
            "            B[5].append(3)",
            "        if 4 in A:",
            "            B[4].append(4)",
            "        if 5 in A:",
            "            B[5].append(5)",
            "        if 6 in A:",
            "            B[6].append(6)",
            "        if 7 in A:",
            "            B[3].append(7)",
            "        if 8 in A:",
            "            B[7].append(8)",
            "        if 9 in A:",
            "            B[6].append(9)",
            "    dp=['n' for i in range(0,max(10,N+1))]",
            "    for i in range(0,min(N+1,10)):",
            "        if i==2:",
            "            if 2 in A:",
            "                dp[5]='2'",
            "        if i==3:",
            "            if 3 in A:",
            "                dp[5]='3'",
            "        if i==4:",
            "            if 4 in A:",
            "                dp[4]='4'",
            "        if i==5:",
            "            if 5 in A:",
            "                dp[5]='5'",
            "        if i==6:",
            "            if 6 in A:",
            "                dp[6]='6'",
            "        if i==7:",
            "            if 7 in A:",
            "                dp[3]='7'",
            "        if i==8:",
            "            if 8 in A:",
            "                dp[7]='8'",
            "        if i==9:",
            "            if 9 in A:",
            "                dp[6]='9'",
            "    if N>=6:",
            "        a='0'",
            "        b='0'",
            "        c='0'",
            "        if B[3]!=[]:",
            "            b='77'",
            "        if dp[6]=='n':",
            "            a=int(a)",
            "            b=int(b)",
            "            c=int(c)",
            "            x=max(a,b,c)",
            "            if x!=0:",
            "                dp[6]=str(x)",
            "        else:",
            "            a=int(a)",
            "            b=int(b)",
            "            c=int(c)",
            "            d=int(dp[6])",
            "            dp[6]=str(max(a,b,c,d))",
            "    if N>=7:",
            "        a='0'",
            "        b='0'",
            "        c='0'",
            "        d='0'",
            "        if B[3]!=[] and dp[4]!='n':",
            "            b='7'+dp[4]",
            "        if B[4]!=[] and dp[3]!='n':",
            "            c='47'",
            "        if dp[7]=='n':",
            "            a=int(a)",
            "            b=int(b)",
            "            c=int(c)",
            "            d=int(d)",
            "            x=max(a,b,c,d)",
            "            if x!=0:",
            "                dp[7]=str(x)",
            "        else:",
            "            a=int(a)",
            "            b=int(b)",
            "            c=int(c)",
            "            d=int(d)",
            "            e=int(dp[7])",
            "            dp[7]=str(max(e,a,b,c,d))",
            "    for i in range(8,N+1):",
            "        a='0'",
            "        b='0'",
            "        c='0'",
            "        d='0'",
            "        e='0'",
            "        f='0'",
            "        if B[3] and dp[i-3]!='n':",
            "            b='7'+dp[i-3]",
            "        if B[4] and dp[i-4]!='n':",
            "            c='4'+dp[i-4]",
            "        if B[5] and dp[i-5]!='n':",
            "            d=str(max(B[5]))+dp[i-5]",
            "        if B[6] and dp[i-6]!='n':",
            "            e=str(max(B[6]))+dp[i-6]",
            "        if B[7] and dp[i-7]!='n':",
            "            f='8'+dp[i-7]",
            "        a=int(a)",
            "        b=int(b)",
            "        c=int(c)",
            "        d=int(d)",
            "        e=int(e)",
            "        f=int(f)",
            "        x=max(a,b,c,d,e,f)",
            "        if x==0:",
            "            dp[i]='n'",
            "        else:",
            "            dp[i]=str(x)",
            "    print(int(dp[N]))"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, k = mi()",
            "    A = lmi()",
            "    max_digit_len = int(math.log(max(max(A), k), 2)) + 1",
            "    digit = [[0, 0] for _ in range(max_digit_len)]",
            "    for num in A:",
            "        bin_num_str = bin(num)[2:]",
            "        for i in range(max_digit_len):",
            "            if i < len(bin_num_str):",
            "                j = len(bin_num_str) - i - 1",
            "                digit[i][int(bin_num_str[j])] += 1    # [0] or [1] に加算",
            "            else:",
            "                digit[i][0] += 1    # [0] に加算",
            "    # print(digit)",
            "    def calc_max_xor_sum(digit, num, num_digit):",
            "        '下から num_digit 桁を自由に使い num 以下の数字を構成していい時、その桁の範囲での xor sum の最大値を返す'",
            "        if num_digit == 0:",
            "            return 0",
            "        # 自明なものは再帰処理をせずに高速化",
            "        if num >= pow(2, num_digit) - 1:",
            "            tmp = 0",
            "            for i in range(num_digit):",
            "                tmp += pow(2, i) * max(digit[i][0], digit[i][1])",
            "            return tmp",
            "        # num_digit の最大桁に 0 を立てる時 (num_digit - 1 桁以下の構成は自由)",
            "        pattern_0 = pow(2, num_digit - 1) * digit[num_digit - 1][1]    # 0 の相方は 1",
            "        pattern_0 += calc_max_xor_sum(digit, num, num_digit - 1)",
            "        # num_digit の最大桁に 1 を立てる時 (num_digit - 1 桁以下の構成に制約が入る)",
            "        if pow(2, num_digit - 1) > num:",
            "            pattern_1 = 0",
            "        else:",
            "            pattern_1 = pow(2, num_digit - 1) * digit[num_digit - 1][0]    # 1 の相方は 0",
            "            pattern_1 += calc_max_xor_sum(digit, num - pow(2, num_digit - 1), num_digit - 1)",
            "        # print(f\"{num} {num_digit} {pattern_0} {pattern_1}\")",
            "        return max(pattern_0, pattern_1)",
            "    k_digit_len = int(math.log(k, 2)) + 1 if k != 0 else 1",
            "    ans = 0",
            "    if k_digit_len < max_digit_len:",
            "        for i in range(k_digit_len, max_digit_len):",
            "            # 0 を立てなくてはならない",
            "            ans += pow(2, i) * digit[i][1]",
            "    # print(ans)",
            "    ans += calc_max_xor_sum(digit, k, k_digit_len)",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math, cmath",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import _heapify_max, _heappop_max, _siftdown_max",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    Num = Union[int, float]",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input():  return sys.stdin.readline().rstrip()",
            "    def ii():     return int(input())",
            "    def isp():    return input().split()",
            "    def mi():     return map(int, input().split())",
            "    def mi_0():   return map(lambda x: int(x)-1, input().split())",
            "    def lmi():    return list(map(int, input().split()))",
            "    def lmi_0():  return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():     return list(input())",
            "    def debug(x): print(x, file=sys.stderr)",
            "    # def _heappush_max(h, item): h.append(item); _siftdown_max(h, 0, len(h)-1)",
            "    n = ii()",
            "    a, b, c = input(), input(), input()",
            "    ans = 0",
            "    for i in range(n):",
            "        s = list(set((a[i], b[i], c[i])))",
            "        ans += len(s) - 1",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math, cmath",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import _heapify_max, _heappop_max, _siftdown_max",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    Num = Union[int, float]",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input():  return sys.stdin.readline().rstrip()",
            "    def ii():     return int(input())",
            "    def isp():    return input().split()",
            "    def mi():     return map(int, input().split())",
            "    def mi_0():   return map(lambda x: int(x)-1, input().split())",
            "    def lmi():    return list(map(int, input().split()))",
            "    def lmi_0():  return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():     return list(input())",
            "    def debug(x): print(x, file=sys.stderr)",
            "    # def _heappush_max(h, item): h.append(item); _siftdown_max(h, 0, len(h)-1)",
            "    n = ii()",
            "    L = [lmi() for _ in range(n)]",
            "    L.sort(key=lambda x: x[0] + x[1])",
            "    turn = True",
            "    takahashi, aoki = 0, 0",
            "    while L:",
            "        a, b = L.pop()",
            "        if turn:",
            "            takahashi += a",
            "        else:",
            "            aoki += b",
            "        turn = not turn",
            "    print(takahashi - aoki)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# abc116_c.py",
            "# https://atcoder.jp/contests/abc116/tasks/abc116_c",
            "# C - Grand Garden /",
            "# 実行時間制限: 2 sec / メモリ制限: 1024 MB",
            "# 配点 : 300点",
            "# 問題文",
            "# 花壇に N本の花が咲いており、それぞれ 1,2,......,N と番号が振られています。",
            "# 最初、全ての花の高さは 0 です。 数列 h={h1,h2,h3,......} が入力として与えられます。",
            "# 以下の「水やり」操作を繰り返すことで、すべての k(1≦k≦N) に対して花 k の高さを hkにしたいです。",
            "#     整数 l,rを指定する。l≦x≦r を満たすすべての x に対して、花 x の高さを 1高くする。",
            "# 条件を満たすための最小の「水やり」操作の回数を求めてください。",
            "# 制約",
            "#     1≦N≦100",
            "#     0≦hi≦100",
            "#     入力はすべて整数である。",
            "# 入力",
            "# 入力は以下の形式で標準入力から与えられます。",
            "# N",
            "# h1 h2 h3 ...... hN",
            "# 出力",
            "# 条件を満たすような最小の「水やり」操作の回数を出力してください。",
            "# 入力例 1",
            "# 4",
            "# 1 2 2 1",
            "# 出力例 1",
            "# 2",
            "# 「水やり」操作の回数は 2回が最小です。 以下が一つの例です。",
            "#     (l,r)=(1,3)の「水やり」操作を行う。",
            "#     (l,r)=(2,4)の「水やり」操作を行う。",
            "# 入力例 2",
            "# 5",
            "# 3 1 2 3 1",
            "# 出力例 2",
            "# 5",
            "# 入力例 3",
            "# 8",
            "# 4 23 75 0 23 96 50 100",
            "# 出力例 3",
            "# 221",
            "def calculation(lines):",
            "    # X = lines[0]",
            "    N = int(lines[0])",
            "    values = list(map(int, lines[1].split()))",
            "    # values = list()",
            "    # for i in range(N):",
            "    #     values.append(int(lines[i+1]))",
            "    result = get_cnt(values)",
            "    return [result]",
            "def get_cnt(values):",
            "    # print('----------------------------------------------')",
            "    # print(f'values=[{values}]')",
            "    ret = 0",
            "    mi = min(values)",
            "    # print(f'mi=[{mi}]')",
            "    ret += mi",
            "    values = [value - mi for value in values]",
            "    # print(f'values=[{values}]')",
            "    lst = None",
            "    for value in values:",
            "        # print(f'    value=[{value}], lst=[{lst}]')",
            "        if value != 0:",
            "            if lst is None:",
            "                lst = [value]",
            "            else:",
            "                lst.append(value)",
            "        else:",
            "            if lst is None:",
            "                pass",
            "            else:",
            "                ret += get_cnt(lst)",
            "                lst = None",
            "    if lst is not None:",
            "        ret += get_cnt(lst)",
            "    return ret",
            "def func_f(n):",
            "    if n % 2 == 0:",
            "        return int(n/2)",
            "    else:",
            "        return 3*n + 1",
            "# 引数を取得",
            "def get_input_lines(lines_count):",
            "    lines = list()",
            "    for _ in range(lines_count):",
            "        lines.append(input())",
            "    return lines",
            "# テストデータ",
            "def get_testdata(pattern):",
            "    if pattern == 1:",
            "        lines_input = ['4', '1 2 2 1']",
            "        lines_export = [2]",
            "    if pattern == 2:",
            "        lines_input = ['5', '3 1 2 3 1']",
            "        lines_export = [5]",
            "    if pattern == 3:",
            "        lines_input = ['8', '4 23 75 0 23 96 50 100']",
            "        lines_export = [221]",
            "    return lines_input, lines_export",
            "# 動作モード判別",
            "def get_mode():",
            "    import sys",
            "    args = sys.argv",
            "    if len(args) == 1:",
            "        mode = 0",
            "    else:",
            "        mode = int(args[1])",
            "    return mode",
            "# 主処理",
            "def main():",
            "    import time",
            "    started = time.time()",
            "    mode = get_mode()",
            "    if mode == 0:",
            "        lines_input = get_input_lines(2)",
            "    else:",
            "        lines_input, lines_export = get_testdata(mode)",
            "    lines_result = calculation(lines_input)",
            "    for line_result in lines_result:",
            "        print(line_result)",
            "    # if mode > 0:",
            "    #     print(f'lines_input=[{lines_input}]')",
            "    #     print(f'lines_export=[{lines_export}]')",
            "    #     print(f'lines_result=[{lines_result}]')",
            "    #     if lines_result == lines_export:",
            "    #         print('OK')",
            "    #     else:",
            "    #         print('NG')",
            "    # finished = time.time()",
            "    # duration = finished - started",
            "    # print(f'duration=[{duration}]')",
            "# 起動処理",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "readline = sys.stdin.readline",
            "MOD = 10 ** 9 + 7",
            "INF = float('INF')",
            "sys.setrecursionlimit(10 ** 5)",
            "import heapq",
            "class PriorityQueue:",
            "    class Reverse:",
            "        def __init__(self, val):",
            "            self.val = val",
            "        def __lt__(self, other):",
            "            return self.val > other.val",
            "        def __repr__(self):",
            "            return repr(self.val)",
            "    def __init__(self, x=None, desc=False):",
            "        if not x:",
            "            x = []",
            "        if desc:",
            "            for i in range(len(x)):",
            "                x[i] = self.Reverse(x[i])",
            "        self._desc = desc",
            "        self._container = x",
            "        heapq.heapify(self._container)",
            "    @property",
            "    def is_empty(self):",
            "        return not self._container",
            "    def pop(self):",
            "        if self._desc:",
            "            return heapq.heappop(self._container).val",
            "        else:",
            "            return heapq.heappop(self._container)",
            "    def push(self, item):",
            "        if self._desc:",
            "            heapq.heappush(self._container, self.Reverse(item))",
            "        else:",
            "            heapq.heappush(self._container, item)",
            "    def top(self):",
            "        if self._desc:",
            "            return self._container[0].val",
            "        else:",
            "            return self._container[0]",
            "    def sum(self):",
            "        return sum(self._container)",
            "    def __len__(self):",
            "        return len(self._container)",
            "def main():",
            "    from operator import itemgetter",
            "    n, k = list(map(int, readline().split()))",
            "    sushis_original = [list(map(int, readline().split())) for _ in range(n)]",
            "    sushis_original.sort(key=itemgetter(1))",
            "    sushis_original.sort(key=itemgetter(0))",
            "    new_type = 0",
            "    prev = -1",
            "    for i in range(n):",
            "        cur = sushis_original[i][0]",
            "        if prev != cur:",
            "            new_type += 1",
            "        if cur > new_type:",
            "            sushis_original[i][0] = new_type",
            "        prev = cur",
            "    type_num = sushis_original[-1][0]",
            "    sushis = {i: [] for i in range(1, type_num + 1)}",
            "    for sushi_type, val in sushis_original:",
            "        sushis[sushi_type].append(val)",
            "    eat_sushis = PriorityQueue()",
            "    rem_sushis = PriorityQueue(desc=True)",
            "    rem = k",
            "    if rem >= type_num:",
            "        for i in range(1, type_num + 1):",
            "            eat_sushis.push(sushis[i].pop())",
            "        rem -= type_num",
            "        for vals in sushis.values():",
            "            for val in vals:",
            "                rem_sushis.push(val)",
            "        for _ in range(rem):",
            "            eat_sushis.push(rem_sushis.pop())",
            "    else:",
            "        for i in range(1, type_num + 1):",
            "            eat_sushis.push(sushis[i].pop())",
            "        discard_num = type_num - k",
            "        for _ in range(discard_num):",
            "            eat_sushis.pop()",
            "        for vals in sushis.values():",
            "            for val in vals:",
            "                rem_sushis.push(val)",
            "    cur_type = min(k, type_num)",
            "    sub_next = 2 * cur_type - 1",
            "    while rem_sushis:",
            "        cur_val = eat_sushis.top()",
            "        new_val = rem_sushis.top()",
            "        diff = new_val - cur_val",
            "        if diff >= sub_next:",
            "            eat_sushis.pop()",
            "            eat_sushis.push(rem_sushis.pop())",
            "            cur_type -= 1",
            "            sub_next = 2 * cur_type - 1",
            "        else:",
            "            break",
            "    ans = cur_type ** 2 + eat_sushis.sum()",
            "    print(ans)",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            0,
            1,
            0,
            2,
            2,
            1,
            0,
            1,
            0,
            2,
            2,
            1,
            0,
            1,
            0,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            2,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "from pprint import pprint",
            "s = str(input())",
            "keyence_list = [[0,0] for _ in range(6)]",
            "#下記のリストを埋めていく",
            "#[[{keyenc},{e}],",
            "# [{keyen},{ce}],",
            "# [{keye},{nce}],",
            "# [{key},{ence}],",
            "# [{ke},{yence}],",
            "# [{k},{eyence}]]",
            "#前から探す",
            "i = 0",
            "if s[i] == \"k\":",
            "    if s[i+1] == \"e\":",
            "        if s[i+2] == \"y\":",
            "            if s[i+3] == \"e\":",
            "                if s[i+4] == \"n\":",
            "                    if s[i+5] == \"c\":",
            "                        if s[i+6] == \"e\":",
            "                            print(\"YES\")",
            "                            exit()",
            "                        else:",
            "                            keyence_list[0][0] = 1",
            "                    else:",
            "                        keyence_list[1][0] = 1",
            "                else:",
            "                    keyence_list[2][0] = 1",
            "            else:",
            "                keyence_list[3][0] = 1",
            "        else:",
            "            keyence_list[4][0] = 1",
            "    else:",
            "        keyence_list[5][0] = 1",
            "else:",
            "    pass",
            "#後ろから探す",
            "j = len(s)-1",
            "if s[j] == \"e\":",
            "    if s[j-1] == \"c\":",
            "        if s[j-2] == \"n\":",
            "            if s[j-3] == \"e\":",
            "                if s[j-4] == \"y\":",
            "                    if s[j-5] == \"e\":",
            "                        if s[j-6] == \"k\":",
            "                            print(\"YES\")",
            "                            exit()",
            "                        else:",
            "                            keyence_list[5][1] = 1",
            "                    else:",
            "                        keyence_list[4][1] = 1",
            "                else:",
            "                    keyence_list[3][1] = 1",
            "            else:",
            "                keyence_list[2][1] = 1",
            "        else:",
            "            keyence_list[1][1] = 1",
            "    else:",
            "        keyence_list[0][1] = 1",
            "else:",
            "    pass",
            "for k in range(6):",
            "    for l in range(k,6):",
            "        if keyence_list[k][0] == keyence_list[l][1] == 1:",
            "            print(\"YES\")",
            "            exit()",
            "print(\"NO\")",
            "exit()",
            "#問題の読み違え",
            "#一部分を削った文字列が\"keyence\"と一致しないといけない。（\"keyence\"を含む、ではない）",
            "#from pprint import pprint",
            "#",
            "#s = str(input())",
            "#",
            "#keyence_list = [[float(\"inf\"),-float(\"inf\")] for _ in range(6)]",
            "#",
            "#",
            "#",
            "##前から探す",
            "#for i in range(len(s)-6):",
            "#    if s[i] == \"k\":",
            "#        if s[i+1] == \"e\":",
            "#            if s[i+2] == \"y\":",
            "#                if s[i+3] == \"e\":",
            "#                    if s[i+4] == \"n\":",
            "#                        if s[i+5] == \"c\":",
            "#                            if s[i+6] == \"e\":",
            "#                                print(\"YES\")",
            "#                                exit()",
            "#                            else:",
            "#                                keyence_list[0][0] = min(keyence_list[0][0],i)",
            "#                        else:",
            "#                            keyence_list[1][0] = min(keyence_list[1][0],i)",
            "#                    else:",
            "#                        keyence_list[2][0] = min(keyence_list[2][0],i)",
            "#                else:",
            "#                    keyence_list[3][0] = min(keyence_list[3][0],i)",
            "#            else:",
            "#                keyence_list[4][0] = min(keyence_list[4][0],i)",
            "#        else:",
            "#            keyence_list[5][0] = min(keyence_list[5][0],i)",
            "#    else:",
            "#        pass",
            "#",
            "##後ろから探す",
            "#for j in range(len(s)-1,5,-1):",
            "#    if s[j] == \"e\":",
            "#        if s[j-1] == \"c\":",
            "#            if s[j-2] == \"n\":",
            "#                if s[j-3] == \"e\":",
            "#                    if s[j-4] == \"y\":",
            "#                        if s[j-5] == \"e\":",
            "#                            if s[j-6] == \"k\":",
            "#                                print(\"YES\")",
            "#                                exit()",
            "#                            else:",
            "#                                keyence_list[5][1] = max(keyence_list[0][1],j-5)",
            "#                        else:",
            "#                            keyence_list[4][1] = max(keyence_list[1][1],j-4)",
            "#                    else:",
            "#                        keyence_list[3][1] = max(keyence_list[2][1],j-3)",
            "#                else:",
            "#                    keyence_list[2][1] = max(keyence_list[3][1],j-2)",
            "#            else:",
            "#                keyence_list[1][1] = max(keyence_list[4][1],j-1)",
            "#        else:",
            "#            keyence_list[0][1] = max(keyence_list[5][1],j)",
            "#    else:",
            "#        pass",
            "#",
            "##pprint(keyence_list)",
            "#",
            "#",
            "#for k in range(6):",
            "#    for l in range(k,6):",
            "#        if keyence_list[k][0] <= keyence_list[l][1]:",
            "#            print(\"YES\")",
            "#            exit()",
            "#",
            "#print(\"NO\")",
            "#exit()",
            "#",
            "#",
            "#",
            "#",
            "#下記のリストを埋めていく",
            "#[[{keyenc},{e}],",
            "# [{keyen},{ce}],",
            "# [{keye},{nce}],",
            "# [{key},{ence}],",
            "# [{ke},{yence}],",
            "# [{k},{eyence}]]",
            "#",
            "# 0列目はsを前から走査し、1列目はsを後ろから走査",
            "# 0列目のset{}の中で最小のものと、1列目のset{}の中で最大のものの大小関係がおかしくなければTrue"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            2,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            2,
            1,
            2,
            2,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math, cmath",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import _heapify_max, _heappop_max, _siftdown_max",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    Num = Union[int, float]",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input():  return sys.stdin.readline().rstrip()",
            "    def ii():     return int(input())",
            "    def isp():    return input().split()",
            "    def mi():     return map(int, input().split())",
            "    def mi_0():   return map(lambda x: int(x)-1, input().split())",
            "    def lmi():    return list(map(int, input().split()))",
            "    def lmi_0():  return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():     return list(input())",
            "    def debug(x): print(x, file=sys.stderr)",
            "    # def _heappush_max(h, item): h.append(item); _siftdown_max(h, 0, len(h)-1)",
            "    n = ii()",
            "    a, b = mi()",
            "    L = lmi()",
            "    x, y, z = 0, 0, 0",
            "    for num in L:",
            "        if num <= a:",
            "            x += 1",
            "        elif num <= b:",
            "            y += 1",
            "        else:",
            "            z += 1",
            "    print(min(x, y, z))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "def main():",
            "    import sys",
            "    input = sys.stdin.readline",
            "    sys.setrecursionlimit(10**7)",
            "    from collections import Counter, deque",
            "    from collections import defaultdict",
            "    from itertools import combinations, permutations, accumulate, groupby, product",
            "    from bisect import bisect_left,bisect_right",
            "    from heapq import heapify, heappop, heappush",
            "    from math import floor, ceil,pi,factorial",
            "    from operator import itemgetter",
            "    def I(): return int(input().rstrip())",
            "    def MI(): return map(int, input().split())",
            "    def LI(): return list(map(int, input().split()))",
            "    def LI2(): return [int(input()) for i in range(n)]",
            "    def MXI(): return [[LI()]for i in range(n)]",
            "    def SI(): return input().rstrip()",
            "    def printns(x): print('\\n'.join(x))",
            "    def printni(x): print('\\n'.join(list(map(str,x))))",
            "    inf = 10**17",
            "    mod = 10**9 + 7",
            "    #https://note.nkmk.me/python-union-find/",
            "    class UnionFind():",
            "        def __init__(self, n):",
            "            self.n = n",
            "            self.parents = [-1] * n",
            "        def find(self, x):",
            "            if self.parents[x] < 0:",
            "                return x",
            "            else:",
            "                self.parents[x] = self.find(self.parents[x])",
            "                return self.parents[x]",
            "        def union(self, x, y):",
            "            x = self.find(x)",
            "            y = self.find(y)",
            "            if x == y:",
            "                return",
            "            if self.parents[x] > self.parents[y]:",
            "                x, y = y, x",
            "            self.parents[x] += self.parents[y]",
            "            self.parents[y] = x",
            "        def size(self, x):",
            "            return -self.parents[self.find(x)]",
            "        def same(self, x, y):",
            "            return self.find(x) == self.find(y)",
            "        def members(self, x):",
            "            root = self.find(x)",
            "            return [i for i in range(self.n) if self.find(i) == root]",
            "        def roots(self):",
            "            return [i for i, x in enumerate(self.parents) if x < 0]",
            "        def group_count(self):",
            "            return len(self.roots())",
            "        def all_group_members(self):",
            "            return {r: self.members(r) for r in self.roots()}",
            "        def __str__(self):",
            "            return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())",
            "    h,w=MI()",
            "    uf=UnionFind(h*w)",
            "    lis=[[0]*w for i in range(h)]",
            "    for i in range(h):",
            "        s=SI()",
            "        for j in range(w):",
            "            if s[j]==\"#\":",
            "                lis[i][j]=1",
            "    step=[[0,1],[0,-1],[-1,0],[1,0]]",
            "    for i in range(h):",
            "        for j in range(w):",
            "            for x,y in step:",
            "                if not (0<=i+x<h and 0<=j+y<w):",
            "                    continue",
            "                if lis[i][j]!=lis[i+x][j+y]:",
            "                    uf.union(w*i+j,w*(i+x)+(j+y))",
            "    ans=0",
            "    dic=defaultdict(lambda:[0,0])",
            "    for i in range(h):",
            "        for j in range(w):",
            "            dic[uf.find(w*i+j)][lis[i][j]==1]+=1",
            "    for p in dic.keys():",
            "        ans+=dic[p][0]*dic[p][1]",
            "    print(ans)",
            "if __name__==\"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            2,
            1,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "import sys",
            "sys.setrecursionlimit(10**7) #再帰関数の上限,10**5以上の場合python",
            "import math",
            "from copy import copy, deepcopy",
            "from copy import deepcopy as dcp",
            "from operator import itemgetter",
            "from bisect import bisect_left, bisect, bisect_right#2分探索",
            "#bisect_left(l,x), bisect(l,x)#aはソート済みである必要あり。aの中からx未満の要素数を返す。rightだと以下",
            "from collections import deque, defaultdict",
            "#deque(l), pop(), append(x), popleft(), appendleft(x)",
            "#q.rotate(n)で → にn回ローテート",
            "from collections import Counter#文字列を個数カウント辞書に、",
            "#S=Counter(l),S.most_common(x),S.keys(),S.values(),S.items()",
            "from itertools import accumulate,combinations,permutations,product#累積和",
            "#list(accumulate(l))",
            "from heapq import heapify,heappop,heappush",
            "#heapify(q),heappush(q,a),heappop(q) #q=heapify(q)としないこと、返り値はNone",
            "#import fractions#古いatcoderコンテストの場合GCDなどはここからimportする",
            "from functools import reduce,lru_cache#pypyでもうごく",
            "#@lru_cache(maxsize = None)#maxsizeは保存するデータ数の最大値、2**nが最も高効率",
            "from decimal import Decimal",
            "def input():",
            "    x=sys.stdin.readline()",
            "    return x[:-1] if x[-1]==\"\\n\" else x",
            "def printe(*x):print(\"## \",*x,file=sys.stderr)",
            "def printl(li): _=print(*li, sep=\"\\n\") if li else None",
            "def argsort(s, return_sorted=False):",
            "    inds=sorted(range(len(s)), key=lambda k: s[k])",
            "    if return_sorted: return inds, [s[i] for i in inds]",
            "    return inds",
            "def alp2num(c,cap=False): return ord(c)-97 if not cap else ord(c)-65",
            "def num2alp(i,cap=False): return chr(i+97) if not cap else chr(i+65)",
            "def matmat(A,B):",
            "    K,N,M=len(B),len(A),len(B[0])",
            "    return [[sum([(A[i][k]*B[k][j]) for k in range(K)]) for j in range(M)] for i in range(N)]",
            "def matvec(M,v):",
            "    N,size=len(v),len(M)",
            "    return [sum([M[i][j]*v[j] for j in range(N)]) for i in range(size)]",
            "def T(M):",
            "    n,m=len(M),len(M[0])",
            "    return [[M[j][i] for j in range(n)] for i in range(m)]",
            "class unionfind:#早いunionfind,class[i]のように要素指定すると親を得ることができる",
            "    def __init__(self, elements=None):#elementsで初期化",
            "        if elements is None:",
            "            elements = ()",
            "        self.parents = {}",
            "        self.weights = {}",
            "        for x in elements:",
            "            self.weights[x] = 1",
            "            self.parents[x] = x",
            "    def __getitem__(self, i):",
            "        # check for previously unknown i",
            "        if i not in self.parents:",
            "            self.parents[i] = i",
            "            self.weights[i] = 1",
            "            return i",
            "        path = [i]",
            "        root = self.parents[i]",
            "        while root != path[-1]:",
            "            path.append(root)",
            "            root = self.parents[root]",
            "        for ancestor in path:#縮約",
            "            self.parents[ancestor] = root",
            "        return root",
            "    def __iter__(self):#for parent in Class:",
            "        return iter(self.parents)",
            "    def union(self, *objects):#オブジェクトをすべて結合",
            "        roots = [self[x] for x in objects]",
            "        heaviest = max(roots, key=lambda r: self.weights[r])",
            "        for r in roots:",
            "            if r != heaviest:",
            "                self.weights[heaviest] += self.weights[r]",
            "                self.parents[r] = heaviest",
            "    def __len__(self):",
            "        return len(self.parents)",
            "def main():",
            "    mod = 1000000007",
            "    #w.sort(key=itemgetter(1),reverse=True)  #二個目の要素で降順並び替え",
            "    #N = int(input())",
            "    H,W = map(int, input().split())",
            "    #A = tuple(map(int, input().split())) #1行ベクトル",
            "    #L = tuple(int(input()) for i in range(N)) #改行ベクトル",
            "    S = tuple(input() for i in range(H)) #改行行列",
            "    uf=unionfind()",
            "    for i in range(H):",
            "        for j in range(W):",
            "            x=i*W+j",
            "            if i>0:",
            "                if S[i][j]!=S[i-1][j]:",
            "                    uf.union(x,(i-1)*W+j)",
            "            if j>0:",
            "                if S[i][j]!=S[i][j-1]:",
            "                    uf.union(x,i*W+j-1)",
            "    c=Counter()",
            "    ps=set()",
            "    for i in range(H*W):",
            "        p=uf[i]",
            "        ps.add(uf[i])",
            "        if S[i//W][i%W]==\"#\":",
            "            c[p*2]+=1",
            "        else:",
            "            c[p*2+1]+=1",
            "    ans=0",
            "    for p in ps:",
            "        ans+=c[p*2]*c[p*2+1]",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys,collections as cl,bisect as bs",
            "sys.setrecursionlimit(100000)",
            "mod = 10**9+7",
            "Max = sys.maxsize",
            "def l(): #intのlist",
            "    return list(map(int,input().split()))",
            "def m(): #複数文字",
            "    return map(int,input().split())",
            "def onem(): #Nとかの取得",
            "    return int(input())",
            "def s(x): #圧縮",
            "    a = []",
            "    aa = x[0]",
            "    su = 1",
            "    for i in range(len(x)-1):",
            "        if aa != x[i+1]:",
            "            a.append([aa,su])",
            "            aa = x[i+1]",
            "            su = 1",
            "        else:",
            "            su += 1",
            "    a.append([aa,su])",
            "    return a",
            "def jo(x): #listをスペースごとに分ける",
            "    return \" \".join(map(str,x))",
            "def max2(x): #他のときもどうように作成可能",
            "    return max(map(max,x))",
            "def In(x,a): #aがリスト(sorted)",
            "    k = bs.bisect_left(a,x)",
            "    if k != len(a) and a[k] ==  x:",
            "        return True",
            "    else:",
            "        return False",
            "import collections",
            "import itertools",
            "import operator",
            "class UnionFind:",
            "    def __init__(self, x):",
            "        class KeyDict(dict):",
            "            def __missing__(self, key):",
            "                self[key] = key",
            "                return key",
            "        self.parent = KeyDict()",
            "        self.rank = collections.defaultdict(int)",
            "        self.size = collections.defaultdict(lambda: 1)",
            "        if x is not None:",
            "            for elem in range(x+1):",
            "                _, _, _ = self.parent[elem], self.rank[elem],self.size[elem]",
            "    def find(self, x):",
            "        if self.parent[x] == x:",
            "            return x",
            "        else:",
            "            self.parent[x] = self.find(self.parent[x])",
            "            return self.parent[x]",
            "    def unite(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "        if not self.are_same(x,y):",
            "            xx = self.size[x]",
            "            yy = self.size[y]",
            "            if self.rank[x] < self.rank[y]:",
            "                self.parent[x] = y",
            "                self.size[y] += xx",
            "            else:",
            "                self.parent[y] = x",
            "                self.size[x] += yy",
            "        if self.rank[x] == self.rank[y]:",
            "            self.rank[x] += 1",
            "    def Size(self,x):",
            "        return self.size[self.find(x)]",
            "    def are_same(self, x, y):",
            "        '''print(x,y,self.find(x),self.find(y),self.find(x) == self.find(y))'''",
            "        return self.find(x) == self.find(y)",
            "    def grouper(self):",
            "        roots = [(x, self.find(x_par)) for x, x_par in self.parent.items()]",
            "        root = operator.itemgetter(1)",
            "        for _, group in itertools.groupby(sorted(roots, key=root), root):",
            "            yield [x for x, _ in group]",
            "h,w = m()",
            "uf = UnionFind(h*w-1)",
            "s = [list(input()) for i in range(h)]",
            "for i in range(h):",
            "    for j in range(w):",
            "        if i == h - 1 and j == w - 1:",
            "            continue",
            "        elif i == h - 1:",
            "            if s[i][j] != s[i][j+1]:",
            "                uf.unite(i*w + j,i*w + j+1)",
            "        elif j == w - 1:",
            "            if s[i][j] != s[i+1][j]:",
            "                uf.unite(i*w + j,(i+1)*w + j)",
            "        else:",
            "            if s[i][j] != s[i+1][j]:",
            "                uf.unite(i*w + j,(i+1)*w + j)",
            "            if s[i][j] != s[i][j+1]:",
            "                uf.unite(i*w + j,i*w + j+1)",
            "kkk = list(uf.grouper())",
            "ans = 0",
            "for i in range(len(kkk)):",
            "    black = 0",
            "    white = 0",
            "    for j in kkk[i]:",
            "        if s[j//w][j%w] == \".\":",
            "            white += 1",
            "        else:",
            "            black += 1",
            "    ans += black*white",
            "print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2
        ]
    },
    {
        "content": [
            "# -*- coding: utf-8 -*-",
            "import sys",
            "import math",
            "import os",
            "import itertools",
            "import string",
            "import heapq",
            "import _collections",
            "from collections import Counter",
            "from collections import defaultdict",
            "from functools import lru_cache",
            "import bisect",
            "import re",
            "import queue",
            "from decimal import *",
            "class Scanner():",
            "    @staticmethod",
            "    def int():",
            "        return int(sys.stdin.readline().rstrip())",
            "    @staticmethod",
            "    def string():",
            "        return sys.stdin.readline().rstrip()",
            "    @staticmethod",
            "    def map_int():",
            "        return [int(x) for x in Scanner.string().split()]",
            "    @staticmethod",
            "    def string_list(n):",
            "        return [Scanner.string() for i in range(n)]",
            "    @staticmethod",
            "    def int_list_list(n):",
            "        return [Scanner.map_int() for i in range(n)]",
            "    @staticmethod",
            "    def int_cols_list(n):",
            "        return [Scanner.int() for i in range(n)]",
            "class Math():",
            "    @staticmethod",
            "    def gcd(a, b):",
            "        if b == 0:",
            "            return a",
            "        return Math.gcd(b, a % b)",
            "    @staticmethod",
            "    def lcm(a, b):",
            "        return (a * b) // Math.gcd(a, b)",
            "    @staticmethod",
            "    def divisor(n):",
            "        res = []",
            "        i = 1",
            "        for i in range(1, int(n ** 0.5) + 1):",
            "            if n % i == 0:",
            "                res.append(i)",
            "                if i != n // i:",
            "                    res.append(n // i)",
            "        return res",
            "    @staticmethod",
            "    def round_up(a, b):",
            "        return -(-a // b)",
            "    @staticmethod",
            "    def is_prime(n):",
            "        if n < 2:",
            "            return False",
            "        if n == 2:",
            "            return True",
            "        if n % 2 == 0:",
            "            return False",
            "        d = int(n ** 0.5) + 1",
            "        for i in range(3, d + 1, 2):",
            "            if n % i == 0:",
            "                return False",
            "        return True",
            "def pop_count(x):",
            "    x = x - ((x >> 1) & 0x5555555555555555)",
            "    x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)",
            "    x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f",
            "    x = x + (x >> 8)",
            "    x = x + (x >> 16)",
            "    x = x + (x >> 32)",
            "    return x & 0x0000007f",
            "MOD = int(1e09) + 7",
            "INF = int(1e15)",
            "visited = None",
            "S = None",
            "H, W = None, None",
            "def bfs(x, y):",
            "    global visited",
            "    if visited[y][x]:",
            "        return 0",
            "    q = []",
            "    q.append((x, y))",
            "    black = 0",
            "    white = 0",
            "    while q != []:",
            "        x, y = q.pop()",
            "        DIR = [(-1, 0), (1, 0), (0, 1), (0, -1)]",
            "        for d in DIR:",
            "            nx, ny = x + d[0], y + d[1]",
            "            if 0 <= nx < W and 0 <= ny < H and S[y][x] != S[ny][nx] and not visited[ny][nx]:",
            "                visited[ny][nx] = True",
            "                if S[ny][nx] == '.':",
            "                    white += 1",
            "                else:",
            "                    black += 1",
            "                q.append((nx, ny))",
            "    return black * white",
            "def solve():",
            "    global H, W",
            "    global S",
            "    global visited",
            "    H, W = Scanner.map_int()",
            "    S = Scanner.string_list(H)",
            "    visited = [[False for _ in range(W)] for _ in range(H)]",
            "    ans = 0",
            "    for x in range(W):",
            "        for y in range(H):",
            "            ans += bfs(x, y)",
            "    print(ans)",
            "def main():",
            "    # sys.stdin = open(\"sample.txt\")",
            "    # print('YNEOS'[not solve()::2])",
            "    solve()",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "from collections import deque",
            "from collections import defaultdict",
            "H, W = map(int, input().split())",
            "chart = [input() for _ in range(H)]",
            "class UnionFind :",
            "    def __init__(self, size) :",
            "        \"\"\"",
            "        Parameters",
            "        ---",
            "        size : int",
            "            頂点数",
            "        \"\"\"",
            "        self.parent = list(range(size))",
            "        self.height = [0] * size",
            "        self.size = [1] * size",
            "        self.component = size",
            "    def root(self, index) :",
            "        \"\"\"",
            "        親のインデックスの取得",
            "        Parameters",
            "        ---",
            "        index : int",
            "            取得する頂点のインデックス",
            "        Returns",
            "        ---",
            "        rootIndex : int",
            "            指定した頂点の根のインデックス",
            "        \"\"\"",
            "        if self.parent[index] == index :  # 根の場合",
            "            return index",
            "        rootIndex = self.root(self.parent[index])  # 葉の場合親の根を取得",
            "        self.parent[index] = rootIndex  # 親の付け直し",
            "        return rootIndex",
            "    def union(self, index1, index2) :  # 結合",
            "        \"\"\"",
            "        木の結合",
            "        Parameters",
            "        ---",
            "        index1 : int",
            "        index2 : int",
            "            結合する頂点のインデックス",
            "        \"\"\"",
            "        root1 = self.root(index1)",
            "        root2 = self.root(index2)",
            "        if root1 == root2 :  # 連結されている場合",
            "            return",
            "        self.component -= 1  # 連結成分を減らす",
            "        if self.height[root1] < self.height[root2] :",
            "            self.parent[root1] = root2  # root2に結合",
            "            self.size[root2] += self.size[root1]",
            "        else :",
            "            self.parent[root2] = root1  # root1に結合",
            "            self.size[root1] += self.size[root2]",
            "            if self.height[root1] == self.height[root2] :",
            "                self.height[root1] += 1",
            "        return",
            "    def isSameRoot(self, index1, index2) :",
            "        \"\"\"",
            "        同じ木に属するかを判定する",
            "        Parameters",
            "        ---",
            "        index1 : int",
            "        index2 : int",
            "        Returns",
            "        ---",
            "        boolean",
            "        \"\"\"",
            "        return self.root(index1) == self.root(index2)",
            "    def sizeOfSameRoot(self, index) :",
            "        \"\"\"",
            "        指定した頂点の属する木の大きさを取得する",
            "        \"\"\"",
            "        return self.size[self.root(index)]",
            "    def getComponent(self) :",
            "        \"\"\"",
            "        連結成分数を取得する",
            "        \"\"\"",
            "        return self.component",
            "tree = UnionFind(H * W)",
            "visited = [[False] * W for _ in range(H)]",
            "def f(h, w):",
            "    return h * W + w",
            "def search(h, w):",
            "    que = deque([(h, w)])",
            "    while que:",
            "        nh, nw = que.popleft()",
            "        if visited[nh][nw]:",
            "            continue",
            "        visited[nh][nw] = True",
            "        tree.union(f(h, w), f(nh, nw))",
            "        if nh > 0 and chart[nh][nw] != chart[nh - 1][nw]:",
            "            que.append((nh - 1, nw))",
            "        if nh < H - 1 and chart[nh][nw] != chart[nh + 1][nw]:",
            "            que.append((nh + 1, nw))",
            "        if nw > 0 and chart[nh][nw] != chart[nh][nw - 1]:",
            "            que.append((nh, nw - 1))",
            "        if nw < W - 1 and chart[nh][nw] != chart[nh][nw + 1]:",
            "            que.append((nh, nw + 1))",
            "cntBW = defaultdict(lambda : [0, 0])",
            "for h in range(H):",
            "    for w in range(W):",
            "        if tree.root(f(h, w)) == f(h, w) and chart[h][w] == '#':",
            "            search(h, w)",
            "for h in range(H):",
            "    for w in range(W):",
            "        if chart[h][w] == '#':",
            "            cntBW[tree.root(f(h, w))][0] += 1",
            "        else:",
            "            cntBW[tree.root(f(h, w))][1] += 1",
            "ans = 0",
            "for black, white in cntBW.values():",
            "    ans += black * white",
            "print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            1,
            2,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math, cmath",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import _heapify_max, _heappop_max, _siftdown_max",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    Num = Union[int, float]",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input():  return sys.stdin.readline().rstrip()",
            "    def ii():     return int(input())",
            "    def isp():    return input().split()",
            "    def mi():     return map(int, input().split())",
            "    def mi_0():   return map(lambda x: int(x)-1, input().split())",
            "    def lmi():    return list(map(int, input().split()))",
            "    def lmi_0():  return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():     return list(input())",
            "    def debug(x): print(x, file=sys.stderr)",
            "    # def _heappush_max(h, item): h.append(item); _siftdown_max(h, 0, len(h)-1)",
            "    h, w = mi()",
            "    grid = []",
            "    B = 1",
            "    W = -1",
            "    for _ in range(h):",
            "        line = input()",
            "        grid.append(list(map(lambda x: B if x == '#' else W, line)))",
            "    visited = [[False] * w for _ in range(h)]",
            "    # debug(grid)",
            "    # debug(visited)",
            "    def bfs(p):",
            "        d = ((1, 0), (-1, 0), (0, 1), (0, -1))",
            "        black_cnt, white_cnt = 0, 0",
            "        q = deque()",
            "        q.append(p)",
            "        while q:",
            "            i, j = q.popleft()",
            "            if not visited[i][j]:",
            "                visited[i][j] = True",
            "                if grid[i][j] == B:",
            "                    black_cnt += 1",
            "                else:",
            "                    white_cnt += 1",
            "                for dx, dy in d:",
            "                    nx, ny = i + dx, j + dy",
            "                    if 0 <= nx < h and 0 <= ny < w and not visited[nx][ny] and grid[i][j] * grid[nx][ny] == -1:",
            "                        q.append((nx, ny))",
            "        return black_cnt, white_cnt",
            "    ans = 0",
            "    for i in range(h):",
            "        for j in range(w):",
            "            if grid[i][j] == B and not visited[i][j]:",
            "                black_cnt, white_cnt = bfs((i, j))",
            "                ans += black_cnt * white_cnt",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "from collections import defaultdict",
            "from heapq import heappush, heappop",
            "import sys",
            "sys.setrecursionlimit(10**6)",
            "input = sys.stdin.buffer.readline",
            "INF = 10 ** 9 + 1  # sys.maxsize # float(\"inf\")",
            "def debug(*x):",
            "    print(*x)",
            "def solve0(N, M, edges):",
            "    path = edges.copy()",
            "    exists = 1",
            "    for i in range(2, M + 1):",
            "        next_path = defaultdict(set)",
            "        for v1 in path:",
            "            for v2 in path[v1]:",
            "                if edges[v2]:",
            "                    next_path[v1].update(edges[v2])",
            "                    exists = i",
            "                    # debug(\": i, v1, next_path[v1]\", i, v1, next_path[v1])",
            "        if exists != i:",
            "            # no more pathes",
            "            break",
            "        path = next_path",
            "    return exists",
            "def solve(N, M, edges):",
            "    longest = {}",
            "    def get_longest(start):",
            "        if longest.get(start) != None:",
            "            return longest[start]",
            "        next_edges = edges.get(start)",
            "        if not next_edges:",
            "            ret = 0",
            "        else:",
            "            ret = max(get_longest(v) for v in edges[start]) + 1",
            "        longest[start] = ret",
            "        return ret",
            "    return max(get_longest(v) for v in edges)",
            "def solve(N, M, edges):",
            "    import numba",
            "    longest = [-1] * (N + 1)",
            "    def intlist(xs):",
            "        if xs:",
            "            return list(xs)",
            "        else:",
            "            return numba.typed.List()",
            "    edges = [intlist(edges[k]) for k in range(N + 1)]",
            "    @numba.njit",
            "    def get_longest(start, edges):",
            "        if longest[start] != -1:",
            "            return longest[start]",
            "        ret = 0",
            "        for v in edges[start]:",
            "            x = get_longest(v, edges) + 1",
            "            if x > ret:",
            "                ret = x",
            "        longest[start] = ret",
            "        return ret",
            "    ret = 0",
            "    for v in range(N + 1):",
            "        x = get_longest(v, edges)",
            "        if x > ret:",
            "            ret = x",
            "    return ret",
            "def solve(N, M, edges):",
            "    longest = [-1] * (N + 1)",
            "    for i in range(N + 1):",
            "        if not edges[i]:",
            "            longest[i] = 0",
            "    def get_longest(start):",
            "        next = edges[start]",
            "        for v in next:",
            "            if longest[v] == -1:",
            "                longest[v] = get_longest(v)",
            "        ret = max(longest[v] for v in next) + 1",
            "        return ret",
            "    for i in range(N + 1):",
            "        if longest[i] == -1:",
            "            longest[i] = get_longest(i)",
            "    return max(longest[v] for v in edges)",
            "T1 = \"\"\"",
            "4 5",
            "1 2",
            "1 3",
            "3 2",
            "2 4",
            "3 4",
            "\"\"\"",
            "T2 = \"\"\"",
            "6 3",
            "2 3",
            "4 5",
            "5 6",
            "\"\"\"",
            "T3 = \"\"\"",
            "5 8",
            "5 3",
            "2 3",
            "2 4",
            "5 2",
            "5 1",
            "1 4",
            "4 3",
            "1 3",
            "\"\"\"",
            "def main():",
            "    N, M = map(int, input().split())",
            "    edges = defaultdict(set)",
            "    for i in range(M):",
            "        v1, v2 = map(int, input().split())",
            "        edges[v1].add(v2)",
            "    print(solve(N, M, edges))",
            "def _test():",
            "    \"\"\"",
            "    # >>> as_input(T1)",
            "    # >>> main()",
            "    # 3",
            "    # >>> as_input(T2)",
            "    # >>> main()",
            "    # 2",
            "    >>> as_input(T3)",
            "    >>> main()",
            "    3",
            "    \"\"\"",
            "    import doctest",
            "    doctest.testmod()",
            "def as_input(s):",
            "    \"use in test, use given string as input file\"",
            "    import io",
            "    global read, input",
            "    f = io.StringIO(s.strip())",
            "    input = f.readline",
            "    read = f.read",
            "USE_NUMBA = False",
            "if (USE_NUMBA and sys.argv[-1] == 'ONLINE_JUDGE') or sys.argv[-1] == '-c':",
            "    print(\"compiling\")",
            "    from numba.pycc import CC",
            "    cc = CC('my_module')",
            "    cc.export('solve', solve.__doc__.strip().split()[0])(solve)",
            "    cc.compile()",
            "    exit()",
            "else:",
            "    input = sys.stdin.buffer.readline",
            "    read = sys.stdin.buffer.read",
            "    if (USE_NUMBA and sys.argv[-1] != '-p') or sys.argv[-1] == \"--numba\":",
            "        # -p: pure python mode",
            "        # if not -p, import compiled module",
            "        from my_module import solve  # pylint: disable=all",
            "    elif sys.argv[-1] == \"-t\":",
            "        _test()",
            "        sys.exit()",
            "    elif sys.argv[-1] != '-p' and len(sys.argv) == 2:",
            "        # input given as file",
            "        input_as_file = open(sys.argv[1])",
            "        input = input_as_file.buffer.readline",
            "        read = input_as_file.buffer.read",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "# vim: set fileencoding=utf-8",
            "# pylint: disable=unused-import, invalid-name, missing-docstring, bad-continuation",
            "\"\"\"Module docstring",
            "\"\"\"",
            "import functools",
            "import heapq",
            "import itertools",
            "import logging",
            "import math",
            "import random",
            "import string",
            "import sys",
            "from argparse import ArgumentParser",
            "from collections import defaultdict, deque",
            "from copy import deepcopy",
            "MODULO = pow(10, 9) + 7",
            "def solve_matrix(values, h, w):",
            "    dp = [[0] * (1 + w) for _ in range(1 + h)]",
            "    dp[1][1] = 1",
            "    for i in range(h):",
            "        for j in range(w):",
            "            if i + j != 0 and values[i][j] == \".\":",
            "                LOG.debug((i, j, values[i][j]))",
            "                dp[i + 1][j + 1] = (dp[i][j + 1] + dp[i + 1][j]) % MODULO",
            "    LOG.debug(\"\\n\".join(map(str, dp)))",
            "    return dp[h][w]",
            "def solve(values, h, w):",
            "    dp = [0] * w",
            "    dp[0] = 1",
            "    for i in range(h):",
            "        # LOG.debug((dp))",
            "        prev = dp.copy()",
            "        dp = [0] * w",
            "        for j in range(w):",
            "            # LOG.debug((i, j, values[i][j]))",
            "            if i + j == 0:",
            "                dp[j] = 1",
            "                continue",
            "            if values[i][j] == \"#\":",
            "                # LOG.debug((\"skipped\"))",
            "                continue",
            "            if j != 0:",
            "                dp[j] = (dp[j] + dp[j - 1]) % MODULO",
            "            dp[j] = (dp[j] + prev[j]) % MODULO",
            "    LOG.debug((dp))",
            "    return dp[w - 1]",
            "def do_job():",
            "    \"Do the work\"",
            "    LOG.debug(\"Start working\")",
            "    # first line is number of test cases",
            "    H, W = map(int, input().split())",
            "    values = []",
            "    for _ in range(H):",
            "        values.append(input())",
            "    # result = solve_matrix(values, H, W)",
            "    result = solve(values, H, W)",
            "    print(result)",
            "def configure_log():",
            "    \"Configure the log output\"",
            "    log_formatter = logging.Formatter(\"L%(lineno)d - \" \"%(message)s\")",
            "    handler = logging.StreamHandler(sys.stdout)",
            "    handler.setFormatter(log_formatter)",
            "    LOG.addHandler(handler)",
            "LOG = None",
            "# for interactive call: do not add multiple times the handler",
            "if not LOG:",
            "    LOG = logging.getLogger(\"template\")",
            "    configure_log()",
            "def main(argv=None):",
            "    \"Program wrapper.\"",
            "    if argv is None:",
            "        argv = sys.argv[1:]",
            "    parser = ArgumentParser()",
            "    parser.add_argument(",
            "        \"-v\",",
            "        \"--verbose\",",
            "        dest=\"verbose\",",
            "        action=\"store_true\",",
            "        default=False,",
            "        help=\"run as verbose mode\",",
            "    )",
            "    args = parser.parse_args(argv)",
            "    if args.verbose:",
            "        LOG.setLevel(logging.DEBUG)",
            "    do_job()",
            "    return 0",
            "if __name__ == \"__main__\":",
            "    import doctest",
            "    doctest.testmod()",
            "    sys.exit(main())",
            "class memoized:",
            "    \"\"\"Decorator that caches a function's return value each time it is called.",
            "    If called later with the same arguments, the cached value is returned, and",
            "    not re-evaluated.",
            "    \"\"\"",
            "    def __init__(self, func):",
            "        self.func = func",
            "        self.cache = {}",
            "    def __call__(self, *args):",
            "        try:",
            "            return self.cache[args]",
            "        except KeyError:",
            "            value = self.func(*args)",
            "            self.cache[args] = value",
            "            return value",
            "        except TypeError:",
            "            # uncachable -- for instance, passing a list as an argument.",
            "            # Better to not cache than to blow up entirely.",
            "            return self.func(*args)",
            "    def __repr__(self):",
            "        \"\"\"Return the function's docstring.\"\"\"",
            "        return self.func.__doc__",
            "    def __get__(self, obj, objtype):",
            "        \"\"\"Support instance methods.\"\"\"",
            "        return functools.partial(self.__call__, obj)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "# vim: set fileencoding=utf-8",
            "# pylint: disable=unused-import, invalid-name, missing-docstring, bad-continuation",
            "\"\"\"Module docstring",
            "\"\"\"",
            "import functools",
            "import heapq",
            "import itertools",
            "import logging",
            "import math",
            "import random",
            "import string",
            "import sys",
            "from argparse import ArgumentParser",
            "from collections import defaultdict, deque",
            "from copy import deepcopy",
            "def prob(i, values):",
            "    result = 1",
            "    idx = 0",
            "    for idx, v in enumerate(values):",
            "        i, rest = divmod(i, 2)",
            "        if rest == 1:",
            "            result *= v",
            "        else:",
            "            result *= 1 - v",
            "        idx += 1",
            "    return result",
            "def solve(values, nb):",
            "    LOG.debug((values))",
            "    dp = [[0] * (nb + 1) for _ in range(nb // 2 + 1)]",
            "    dp[0][0] = 1",
            "    for j in range(1, nb + 1):",
            "        dp[0][j] = dp[0][j - 1] * (1 - values[j - 1])",
            "    total = dp[0][-1]",
            "    for i in range(1, nb // 2 + 1):",
            "        for j in range(i, nb + 1):",
            "            dp[i][j] = (",
            "                dp[i - 1][j - 1] * values[j - 1] + (1 - values[j - 1]) * dp[i][j - 1]",
            "            )",
            "        total += dp[i][-1]",
            "    # LOG.debug((\"\\n\" + \"\\n\".join(map(str, dp))))",
            "    return 1 - total",
            "def do_job():",
            "    \"Do the work\"",
            "    LOG.debug(\"Start working\")",
            "    # first line is number of test cases",
            "    N = int(input())",
            "    values = list(map(float, input().split()))",
            "    # values = []",
            "    # for _ in range(N):",
            "    #     values.append(input().split())",
            "    result = solve(values, N)",
            "    # 6 digits float precision {:.6f} (6 is the default value)",
            "    print(\"{:.10g}\".format(result))",
            "def configure_log():",
            "    \"Configure the log output\"",
            "    log_formatter = logging.Formatter(\"L%(lineno)d - \" \"%(message)s\")",
            "    handler = logging.StreamHandler(sys.stdout)",
            "    handler.setFormatter(log_formatter)",
            "    LOG.addHandler(handler)",
            "LOG = None",
            "# for interactive call: do not add multiple times the handler",
            "if not LOG:",
            "    LOG = logging.getLogger(\"template\")",
            "    configure_log()",
            "def main(argv=None):",
            "    \"Program wrapper.\"",
            "    if argv is None:",
            "        argv = sys.argv[1:]",
            "    parser = ArgumentParser()",
            "    parser.add_argument(",
            "        \"-v\",",
            "        \"--verbose\",",
            "        dest=\"verbose\",",
            "        action=\"store_true\",",
            "        default=False,",
            "        help=\"run as verbose mode\",",
            "    )",
            "    args = parser.parse_args(argv)",
            "    if args.verbose:",
            "        LOG.setLevel(logging.DEBUG)",
            "    do_job()",
            "    return 0",
            "if __name__ == \"__main__\":",
            "    import doctest",
            "    doctest.testmod()",
            "    sys.exit(main())",
            "class memoized:",
            "    \"\"\"Decorator that caches a function's return value each time it is called.",
            "    If called later with the same arguments, the cached value is returned, and",
            "    not re-evaluated.",
            "    \"\"\"",
            "    def __init__(self, func):",
            "        self.func = func",
            "        self.cache = {}",
            "    def __call__(self, *args):",
            "        try:",
            "            return self.cache[args]",
            "        except KeyError:",
            "            value = self.func(*args)",
            "            self.cache[args] = value",
            "            return value",
            "        except TypeError:",
            "            # uncachable -- for instance, passing a list as an argument.",
            "            # Better to not cache than to blow up entirely.",
            "            return self.func(*args)",
            "    def __repr__(self):",
            "        \"\"\"Return the function's docstring.\"\"\"",
            "        return self.func.__doc__",
            "    def __get__(self, obj, objtype):",
            "        \"\"\"Support instance methods.\"\"\"",
            "        return functools.partial(self.__call__, obj)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "content": [
            "def wolne_mnozenie_wielomianu(wielomian1, wielomian2):",
            "    odp = [0.0] * (len(wielomian1) + len(wielomian2) - 1)",
            "    for i in range(len(wielomian1)):",
            "        for j in range(len(wielomian2)):",
            "            odp[i + j] += wielomian1[i] * wielomian2[j]",
            "    while len(odp) > 1 and odp[-1] == 0.0:",
            "        odp.pop()",
            "    return odp",
            "def wyrownaj(wielomian1, wielomian2):",
            "    if len(wielomian1) > len(wielomian2):",
            "        wielomian2 = wielomian2 + [0.0] * (len(wielomian1) - len(wielomian2))",
            "    if len(wielomian2) > len(wielomian1):",
            "        wielomian1 = wielomian1 + [0.0] * (len(wielomian2) - len(wielomian1))",
            "    return wielomian1, wielomian2",
            "def dodawanie_wielomianu(wielomian1, wielomian2):",
            "    wielomian1, wielomian2 = wyrownaj(wielomian1, wielomian2)",
            "    odp = [0.0] * len(wielomian2)",
            "    for i in range(len(wielomian1)):",
            "        odp[i] = wielomian1[i] + wielomian2[i]",
            "    while len(odp) > 1 and odp[-1] == 0.0:",
            "        odp.pop()",
            "    return odp",
            "def odejmowanie_wielomianu(wielomian1, wielomian2):",
            "    wielomian1, wielomian2 = wyrownaj(wielomian1, wielomian2)",
            "    odp = [0.0] * len(wielomian2)",
            "    for i in range(len(wielomian1)):",
            "        odp[i] = wielomian1[i] - wielomian2[i]",
            "    while len(odp) > 1 and odp[-1] == 0.0:",
            "        odp.pop()",
            "    return odp",
            "def szybkie_mnozenie_wielomianu(wielomian1, wielomian2):",
            "    wielomian1, wielomian2 = wyrownaj(wielomian1, wielomian2)",
            "    if len(wielomian1) < 3:",
            "        return wolne_mnozenie_wielomianu(wielomian1, wielomian2)",
            "    k = len(wielomian1) // 2",
            "    a = wielomian1[k:]",
            "    b = wielomian1[:k]",
            "    c = wielomian2[k:]",
            "    d = wielomian2[:k]",
            "    ac = szybkie_mnozenie_wielomianu(a, c)",
            "    bd = szybkie_mnozenie_wielomianu(b, d)",
            "    w = szybkie_mnozenie_wielomianu(dodawanie_wielomianu(a, b), dodawanie_wielomianu(c, d))",
            "    w_ac_bd = odejmowanie_wielomianu(w, dodawanie_wielomianu(ac, bd))",
            "    ac = [0.0] * 2 * k + ac",
            "    w_ac_bd = [0.0] * k + w_ac_bd",
            "    odp = dodawanie_wielomianu(ac, dodawanie_wielomianu(bd, w_ac_bd))",
            "    while len(odp) > 1 and odp[-1] == 0.0:",
            "        odp.pop()",
            "    return odp",
            "def wczytaj_liste():",
            "    wczytana_lista = input()",
            "    lista_znakow = wczytana_lista.split()",
            "    ostateczna_lista = []",
            "    for element in lista_znakow:",
            "        ostateczna_lista.append(int(element))",
            "    return ostateczna_lista",
            "def wczytaj_rzeczywiste():",
            "    wczytana_lista = input()",
            "    lista_znakow = wczytana_lista.split()",
            "    ostateczna_lista = []",
            "    for element in lista_znakow:",
            "        ostateczna_lista.append(float(element))",
            "    return ostateczna_lista",
            "def wymnoz_duzo_wielomianow(wielomiany):",
            "    if len(wielomiany) == 1:",
            "        return wielomiany[0]",
            "    k = (len(wielomiany) + 1) // 2",
            "    lewo = wymnoz_duzo_wielomianow(wielomiany[:k])",
            "    prawo = wymnoz_duzo_wielomianow(wielomiany[k:])",
            "    return szybkie_mnozenie_wielomianu(lewo, prawo)",
            "def rzuc_grosza_wiedzminowi_natychmiast():",
            "    N = wczytaj_liste()[0]",
            "    prawdopodopienstwa = wczytaj_rzeczywiste()",
            "    rzuty = []",
            "    for moneta in prawdopodopienstwa:",
            "        rzut = [1 - moneta, moneta]",
            "        rzuty.append(rzut)",
            "    po_rzutach = wymnoz_duzo_wielomianow(rzuty)",
            "    odp = sum(po_rzutach[N//2+1:])",
            "    print(odp)",
            "rzuc_grosza_wiedzminowi_natychmiast()"
        ],
        "label": [
            2,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            2,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "# vim: set fileencoding=utf-8",
            "# pylint: disable=unused-import, invalid-name, missing-docstring, bad-continuation",
            "\"\"\"Module docstring",
            "\"\"\"",
            "import functools",
            "import heapq",
            "import itertools",
            "import logging",
            "import math",
            "import random",
            "import string",
            "import sys",
            "from argparse import ArgumentParser",
            "from collections import defaultdict, deque",
            "from copy import deepcopy",
            "def solve_me(values, k):",
            "    dp = [0 for _ in range(k)]",
            "    # 1 is 1st player",
            "    dp[k - 1] = 1",
            "    for _ in range(k // min(values)):",
            "        prev = dp.copy()",
            "        # dp[i] which players can have i stones at round (1 first, 2 second, 3 both)",
            "        dp = [0 for _ in range(k)]",
            "        for a in values:",
            "            LOG.debug((a))",
            "            for i in range(a, k):",
            "                # LOG.debug((\"i\", i, \"prev[i]\", prev[i]))",
            "                # 1st player is there",
            "                if prev[i] & 1 == 1:",
            "                    # LOG.debug((\"player 1\", i - a))",
            "                    dp[i - a] |= 2",
            "                # 2nd player is there",
            "                if prev[i] & 2 == 2:",
            "                    # LOG.debug((\"player 2\", i - a))",
            "                    dp[i - a] |= 1",
            "        LOG.debug((dp))",
            "        if dp[0] > 0:",
            "            return dp[0] & 2",
            "    assert False, dp",
            "    return None",
            "def solve(values, k):",
            "    # dp[i] True if the first player wins if there are i stones remaining",
            "    dp = [False for _ in range(k + 1)]",
            "    for stones in range(k + 1):",
            "        for a in values:",
            "            if stones < a:",
            "                continue",
            "            if not dp[stones - a]:",
            "                dp[stones] = True",
            "        LOG.debug((dp))",
            "    return dp[k]",
            "def do_job():",
            "    \"Do the work\"",
            "    LOG.debug(\"Start working\")",
            "    # first line is number of test cases",
            "    N, K = list(map(int, input().split()))",
            "    values = list(map(int, input().split()))",
            "    assert len(values) == N",
            "    result = solve(values, K)",
            "    print(\"First\" if result else \"Second\")",
            "def configure_log():",
            "    \"Configure the log output\"",
            "    log_formatter = logging.Formatter(\"L%(lineno)d - \" \"%(message)s\")",
            "    handler = logging.StreamHandler(sys.stdout)",
            "    handler.setFormatter(log_formatter)",
            "    LOG.addHandler(handler)",
            "LOG = None",
            "# for interactive call: do not add multiple times the handler",
            "if not LOG:",
            "    LOG = logging.getLogger(\"template\")",
            "    configure_log()",
            "def main(argv=None):",
            "    \"Program wrapper.\"",
            "    if argv is None:",
            "        argv = sys.argv[1:]",
            "    parser = ArgumentParser()",
            "    parser.add_argument(",
            "        \"-v\",",
            "        \"--verbose\",",
            "        dest=\"verbose\",",
            "        action=\"store_true\",",
            "        default=False,",
            "        help=\"run as verbose mode\",",
            "    )",
            "    args = parser.parse_args(argv)",
            "    if args.verbose:",
            "        LOG.setLevel(logging.DEBUG)",
            "    do_job()",
            "    return 0",
            "if __name__ == \"__main__\":",
            "    import doctest",
            "    doctest.testmod()",
            "    sys.exit(main())",
            "class memoized:",
            "    \"\"\"Decorator that caches a function's return value each time it is called.",
            "    If called later with the same arguments, the cached value is returned, and",
            "    not re-evaluated.",
            "    \"\"\"",
            "    def __init__(self, func):",
            "        self.func = func",
            "        self.cache = {}",
            "    def __call__(self, *args):",
            "        try:",
            "            return self.cache[args]",
            "        except KeyError:",
            "            value = self.func(*args)",
            "            self.cache[args] = value",
            "            return value",
            "        except TypeError:",
            "            # uncachable -- for instance, passing a list as an argument.",
            "            # Better to not cache than to blow up entirely.",
            "            return self.func(*args)",
            "    def __repr__(self):",
            "        \"\"\"Return the function's docstring.\"\"\"",
            "        return self.func.__doc__",
            "    def __get__(self, obj, objtype):",
            "        \"\"\"Support instance methods.\"\"\"",
            "        return functools.partial(self.__call__, obj)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def isp():   return input().split()",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, h, w = mi()",
            "    cnt = 0",
            "    for _ in range(n):",
            "        a, b = mi()",
            "        if a >= h and b >= w:",
            "            cnt += 1",
            "    print(cnt)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, x = mi()",
            "    def calc_patty(level, num):",
            "        '''",
            "        level バーガーを下から num 枚食べる時に何枚パティを食べられるか計算し返す",
            "        '''",
            "        # 全部食べる時",
            "        if pow(2, level + 2) - 3 == num:",
            "            return pow(2, level + 1) - 1",
            "        # 部分的に食べる時",
            "        if num == 1:",
            "            return 0",
            "        elif num <= pow(2, level + 1) - 2:",
            "            return calc_patty(level - 1, num - 1)",
            "        elif num == pow(2, level + 1) - 1:",
            "            return 1 + calc_patty(level - 1, num - 2)",
            "        elif num <=  pow(2, level + 2) - 4:",
            "            return calc_patty(level-1, pow(2, level+1)-3) + 1 + calc_patty(level-1, num - (pow(2, level + 1) - 1))",
            "        else:",
            "            raise RuntimeError",
            "    print(calc_patty(n, x))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "class Prime:",
            "    # https://qiita.com/daikw/items/f48d6ac374255763463d",
            "    seed_primes = [",
            "        2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,",
            "        71, 73, 79, 83, 89, 97",
            "    ]",
            "    def is_prime(self, n):",
            "        \"\"\"",
            "        prime test (hybrid)",
            "        see also: https://qiita.com/gushwell/items/ff9ed83ba55350aaa369",
            "        :param n:",
            "        :return: boolean",
            "        \"\"\"",
            "        is_prime_common = self.is_prime_common(n)",
            "        if is_prime_common is not None:",
            "            return is_prime_common",
            "        if n < 2000000:",
            "            return self.is_prime_brute_force(n)",
            "        else:",
            "            return self.is_prime_miller_rabin(n)",
            "    def is_prime_common(self, n):",
            "        if n == 1: return False",
            "        if n in Prime.seed_primes: return True",
            "        if any(map(lambda x: n % x == 0, self.seed_primes)): return False",
            "    def is_prime_brute_force(self, n):",
            "        \"\"\"",
            "        brute force prime test",
            "        use with is_prime_common if you want to skip seed_primes",
            "        :param n:",
            "        :return: boolean",
            "        \"\"\"",
            "        for k in range(2, int(math.sqrt(n)) + 1):",
            "            if n % k == 0:",
            "                return False",
            "        return True",
            "    def is_prime_miller_rabin(self, n):",
            "        \"\"\"",
            "        miller rabin prime test",
            "        use with is_prime_common if you want to skip seed_primes",
            "        see also",
            "            algorithm: https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test",
            "            implementation: https://qiita.com/srtk86/items/609737d50c9ef5f5dc59",
            "            improvement: https://qiita.com/gushwell/items/ff9ed83ba55350aaa369",
            "        :param n:",
            "        :return: boolean",
            "        \"\"\"",
            "        d = n - 1",
            "        while d & 1 == 0:",
            "            d >>= 1",
            "        # use one of these lines / upper is more efficient.",
            "        witnesses = self.get_witnesses(n)",
            "        # witnesses = [random.randint(1, n - 1) for _ in range(100)]",
            "        for w in witnesses:",
            "            y = pow(w, d, n)",
            "            while d != n - 1 and y != 1 and y != n - 1:",
            "                y = (y * y) % n",
            "                d <<= 1",
            "            if y != n - 1 and d & 1 == 0:",
            "                return False",
            "        return True",
            "    def get_witnesses(self, num):",
            "        def _get_range(num):",
            "            if num < 2047:",
            "                return 1",
            "            if num < 1373653:",
            "                return 2",
            "            if num < 25326001:",
            "                return 3",
            "            if num < 3215031751:",
            "                return 4",
            "            if num < 2152302898747:",
            "                return 5",
            "            if num < 3474749660383:",
            "                return 6",
            "            if num < 341550071728321:",
            "                return 7",
            "            if num < 3825123056546413051:",
            "                return 9",
            "            return 12",
            "        return self.seed_primes[:_get_range(num)]",
            "    def gcd(self, a, b):",
            "        if a < b:",
            "            return self.gcd(b, a)",
            "        if b == 0:",
            "            return a",
            "        while b:",
            "            a, b = b, a % b",
            "        return a",
            "    @staticmethod",
            "    def f(x, n, seed):",
            "        \"\"\"",
            "        pseudo prime generator",
            "        :param x:",
            "        :param n:",
            "        :param seed:",
            "        :return: pseudo prime",
            "        \"\"\"",
            "        p = Prime.seed_primes[seed % len(Prime.seed_primes)]",
            "        return (p * x + seed) % n",
            "    def find_factor(self, n, seed=1):",
            "        \"\"\"",
            "        find one of factor of n",
            "        this function is based to Pollard's rho algorithm",
            "        see also",
            "            algorithm: https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm",
            "            implementation: https://qiita.com/gushwell/items/561afde2e00bf3380c98",
            "        :param n:",
            "        :param seed:",
            "        :return: factor",
            "        \"\"\"",
            "        if self.is_prime(n):",
            "            return n",
            "        x, y, d = 2, 2, 1",
            "        count = 0",
            "        while d == 1:",
            "            count += 1",
            "            x = self.f(x, n, seed)",
            "            y = self.f(self.f(y, n, seed), n, seed)",
            "            d = self.gcd(abs(x - y), n)",
            "        if d == n:",
            "            return self.find_factor(n, seed + 1)",
            "        return self.find_factor(d)",
            "    def find_factors(self, n):",
            "        primes = {}",
            "        if self.is_prime(n):",
            "            primes[n] = 1",
            "            return primes",
            "        while n > 1:",
            "            factor = self.find_factor(n)",
            "            primes.setdefault(factor, 0)",
            "            primes[factor] += 1",
            "            n //= factor",
            "        return primes",
            "import collections",
            "N = int(input())",
            "c = collections.defaultdict(int)",
            "for i in range(1, N + 1):",
            "    factors = Prime().find_factors(i)",
            "    for k, v in factors.items():",
            "        c[k] += v",
            "d = c.values()",
            "#3*5*5=3*25=5*15=75",
            "#a^b*c^dの約数は(b+1)*(d+1)個",
            "n75 = sum(i >= 74 for i in d)",
            "n25 = sum(i >= 24 for i in d)",
            "n15 = sum(i >= 14 for i in d)",
            "n5 = sum(i >= 4 for i in d)",
            "n3 = sum(i >= 2 for i in d)",
            "ans = n5 * (n5 - 1) * (n3 - 2) // 2",
            "ans += n25 * (n3 - 1)",
            "ans += n15 * (n5 - 1)",
            "ans += n75",
            "print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    class Eratos:",
            "        def __init__(self, num):",
            "            '''",
            "            O(nlglgn) で num までの素数判定テーブルを作る",
            "            >>> e = Eratos(10)",
            "            >>> e.table",
            "            [False, False, True, True, False, True, False, True, False, False, False]",
            "            '''",
            "            assert(num >= 1)",
            "            self.table_max = num",
            "            # self.table[i] は i が素数かどうかを示す (bool)",
            "            self.table = [False if i == 0 or i == 1 else True for i in range(num+1)]",
            "            for i in range(2, int(math.sqrt(num)) + 1):",
            "                if self.table[i]:",
            "                    for j in range(i ** 2, num + 1, i):    # i**2 からスタートすることで定数倍高速化できる",
            "                        self.table[j] = False",
            "        def is_prime(self, num):",
            "            '''",
            "            O(1) で素数判定を行う",
            "            >>> e = Eratos(100)",
            "            >>> [i for i in range(1, 101) if e.is_prime(i)]",
            "            [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]",
            "            '''",
            "            assert(num >= 1)",
            "            if num > self.table_max:",
            "                raise ValueError('Eratos.is_prime(): exceed table_max({}). got {}'.format(self.table_max, num))",
            "            return self.table[num]",
            "        def prime_factorize(self, num):",
            "            '''",
            "            O(√n) で素因数分解を行う",
            "            >>> e = Eratos(10000)",
            "            >>> e.prime_factorize(6552)",
            "            {2: 3, 3: 2, 7: 1, 13: 1}",
            "            '''",
            "            assert(num >= 1)",
            "            if int(math.sqrt(num)) > self.table_max:",
            "                raise ValueError('Eratos.prime_factorize(): exceed prime table size. got {}'.format(num))",
            "            # 素因数分解の結果を記録する辞書",
            "            factorized_dict = dict()",
            "            candidate_prime_numbers = [i for i in range(2, int(math.sqrt(num)) + 1) if self.is_prime(i)]",
            "            # n について、√n 以下の素数で割り続けると最後には 1 or 素数となる",
            "            # 背理法を考えれば自明 (残された数が √n より上の素数の積であると仮定。これは自明に n を超えるため矛盾)",
            "            for p in candidate_prime_numbers:",
            "                if num == 1:    # これ以上調査は無意味",
            "                    break",
            "                if num % p == 0:",
            "                    cnt = 0",
            "                    while num % p == 0:",
            "                        num //= p",
            "                        cnt += 1",
            "                    factorized_dict[p] = cnt",
            "            if num != 1:",
            "                factorized_dict[num] = 1",
            "            return factorized_dict",
            "        def enum_divisor(self, num):",
            "            '''",
            "            O(√n) で約数列挙を行う",
            "            >>> e = Eratos(10000)",
            "            >>> e.enum_divisor(4)",
            "            [1, 2, 4]",
            "            >>> e.enum_divisor(19)",
            "            [1, 19]",
            "            >>> e.enum_divisor(100)",
            "            [1, 2, 4, 5, 10, 20, 25, 50, 100]",
            "            '''",
            "            divisor_small = []",
            "            divisor_large = []",
            "            for i in range(1, int(math.sqrt(num)) + 1):",
            "                if num % i == 0:",
            "                    divisor_small.append(i)",
            "                    if i != num // i:",
            "                        divisor_large.append(num // i)",
            "            divisor_large.reverse()",
            "            return divisor_small + divisor_large",
            "    n = ii()",
            "    e = Eratos(n)",
            "    c = Counter()",
            "    for i in range(2, n + 1):",
            "        c += Counter(e.prime_factorize(i))",
            "    # print(c)",
            "    gt_74_candidate = 0",
            "    gt_24_candidate = 0",
            "    gt_14_candidate = 0",
            "    gt_4_candidate = 0",
            "    gt_2_candidate = 0",
            "    for _, v in c.items():",
            "        if v >= 2:",
            "            gt_2_candidate += 1",
            "        if v >= 4:",
            "            gt_4_candidate += 1",
            "        if v >= 14:",
            "            gt_14_candidate += 1",
            "        if v >= 24:",
            "            gt_24_candidate += 1",
            "        if v >= 74:",
            "            gt_74_candidate += 1",
            "    def calc_3_5_5(a, b):",
            "        if a >= 3 and b >= 2:",
            "            # bC2 * (a - 2)",
            "            return (b * (b-1) // 2) * (a - 2)",
            "        else:",
            "            return 0",
            "    def calc_5_15(a, b):",
            "        if a >= 2 and b >= 1:",
            "            # bC1 * (a - 1)",
            "            return b * (a - 1)",
            "        else:",
            "            return 0",
            "    def calc_3_25(a, b):",
            "        if a >= 2 and b >= 1:",
            "            # bC1 * (a - 1)",
            "            return b * (a - 1)",
            "        else:",
            "            return 0",
            "    def calc_75(a):",
            "        if a >= 1:",
            "            return a",
            "        else:",
            "            return 0",
            "    def calc_all_75_num(gt_2_candidate, gt_4_candidate, gt_14_candidate, gt_24_candidate, gt_74_candidate):",
            "        ans = 0",
            "        ans += calc_3_5_5(gt_2_candidate, gt_4_candidate)",
            "        # print(ans)",
            "        ans += calc_5_15(gt_4_candidate, gt_14_candidate)",
            "        # print(ans)",
            "        ans += calc_3_25(gt_2_candidate, gt_24_candidate)",
            "        # print(ans)",
            "        ans += calc_75(gt_74_candidate)",
            "        # print(ans)",
            "        return ans",
            "    print(calc_all_75_num(gt_2_candidate, gt_4_candidate, gt_14_candidate, gt_24_candidate, gt_74_candidate))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            2,
            2,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "# -*- coding: utf-8 -*-",
            "import sys",
            "import math",
            "import os",
            "import itertools",
            "import string",
            "import heapq",
            "import _collections",
            "from collections import Counter",
            "from collections import defaultdict",
            "from functools import lru_cache",
            "import bisect",
            "import re",
            "import queue",
            "from decimal import *",
            "class Scanner():",
            "    @staticmethod",
            "    def int():",
            "        return int(sys.stdin.readline().rstrip())",
            "    @staticmethod",
            "    def string():",
            "        return sys.stdin.readline().rstrip()",
            "    @staticmethod",
            "    def map_int():",
            "        return [int(x) for x in Scanner.string().split()]",
            "    @staticmethod",
            "    def string_list(n):",
            "        return [Scanner.string() for i in range(n)]",
            "    @staticmethod",
            "    def int_list_list(n):",
            "        return [Scanner.map_int() for i in range(n)]",
            "    @staticmethod",
            "    def int_cols_list(n):",
            "        return [Scanner.int() for i in range(n)]",
            "class Math():",
            "    @staticmethod",
            "    def gcd(a, b):",
            "        if b == 0:",
            "            return a",
            "        return Math.gcd(b, a % b)",
            "    @staticmethod",
            "    def lcm(a, b):",
            "        return (a * b) // Math.gcd(a, b)",
            "    @staticmethod",
            "    def divisor(n):",
            "        res = []",
            "        i = 1",
            "        for i in range(1, int(n ** 0.5) + 1):",
            "            if n % i == 0:",
            "                res.append(i)",
            "                if i != n // i:",
            "                    res.append(n // i)",
            "        return res",
            "    @staticmethod",
            "    def round_up(a, b):",
            "        return -(-a // b)",
            "    @staticmethod",
            "    def is_prime(n):",
            "        if n < 2:",
            "            return False",
            "        if n == 2:",
            "            return True",
            "        if n % 2 == 0:",
            "            return False",
            "        d = int(n ** 0.5) + 1",
            "        for i in range(3, d + 1, 2):",
            "            if n % i == 0:",
            "                return False",
            "        return True",
            "def pop_count(x):",
            "    x = x - ((x >> 1) & 0x5555555555555555)",
            "    x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)",
            "    x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f",
            "    x = x + (x >> 8)",
            "    x = x + (x >> 16)",
            "    x = x + (x >> 32)",
            "    return x & 0x0000007f",
            "MOD = int(1e09) + 7",
            "INF = int(1e15)",
            "def pm(X):",
            "    res = {}",
            "    for i in range(2, int(X ** 0.5) + 1):",
            "        if X % i == 0:",
            "            res[i] = 0",
            "            while X % i == 0:",
            "                X //= i",
            "                res[i] += 1",
            "    if X > 1:",
            "        res[X] = 1",
            "    return res",
            "def solve():",
            "    N = Scanner.int()",
            "    # N!の素因数分解",
            "    M = defaultdict(int)",
            "    for i in range(2, N + 1):",
            "        tmp = i",
            "        for j in range(2, int(i ** 0.5) + 1):",
            "            while tmp % j == 0:",
            "                M[j] += 1",
            "                tmp //= j",
            "        if tmp > 1:",
            "            M[tmp] += 1",
            "    ans = 0",
            "    # 75",
            "    for p in range(2, N+1):",
            "        if M[p] >= 74:",
            "            ans += 1",
            "    # 3 * 25",
            "    # 5 * 25",
            "    for p in range(2, N + 1):",
            "        for q in range(2, N+1):",
            "            if p == q:",
            "                continue",
            "            if M[p] >= 2 and M[q] >= 24:",
            "                ans += 1",
            "            if M[p] >= 4 and M[q] >= 14:",
            "                ans += 1",
            "    # 5 * 5 * 3",
            "    for p in range(2, N+1):",
            "        for q in range(p + 1, N + 1):",
            "            for r in range(2, N + 1):",
            "                if p == r:",
            "                    continue",
            "                if q == r:",
            "                    continue",
            "                if M[p] >= 4 and M[q] >= 4 and M[r] >= 2:",
            "                    ans += 1",
            "    print(ans)",
            "def main():",
            "    # sys.stdin = open(\"sample.txt\")",
            "    solve()",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# -*- coding: utf-8 -*-",
            "import sys",
            "import math",
            "import os",
            "import itertools",
            "import string",
            "import heapq",
            "import _collections",
            "from collections import Counter",
            "from collections import defaultdict",
            "from functools import lru_cache",
            "import bisect",
            "import re",
            "import queue",
            "from decimal import *",
            "class Scanner():",
            "    @staticmethod",
            "    def int():",
            "        return int(sys.stdin.readline().rstrip())",
            "    @staticmethod",
            "    def string():",
            "        return sys.stdin.readline().rstrip()",
            "    @staticmethod",
            "    def map_int():",
            "        return [int(x) for x in Scanner.string().split()]",
            "    @staticmethod",
            "    def string_list(n):",
            "        return [Scanner.string() for i in range(n)]",
            "    @staticmethod",
            "    def int_list_list(n):",
            "        return [Scanner.map_int() for i in range(n)]",
            "    @staticmethod",
            "    def int_cols_list(n):",
            "        return [Scanner.int() for i in range(n)]",
            "class Math():",
            "    @staticmethod",
            "    def gcd(a, b):",
            "        if b == 0:",
            "            return a",
            "        return Math.gcd(b, a % b)",
            "    @staticmethod",
            "    def lcm(a, b):",
            "        return (a * b) // Math.gcd(a, b)",
            "    @staticmethod",
            "    def divisor(n):",
            "        res = []",
            "        i = 1",
            "        for i in range(1, int(n ** 0.5) + 1):",
            "            if n % i == 0:",
            "                res.append(i)",
            "                if i != n // i:",
            "                    res.append(n // i)",
            "        return res",
            "    @staticmethod",
            "    def round_up(a, b):",
            "        return -(-a // b)",
            "    @staticmethod",
            "    def is_prime(n):",
            "        if n < 2:",
            "            return False",
            "        if n == 2:",
            "            return True",
            "        if n % 2 == 0:",
            "            return False",
            "        d = int(n ** 0.5) + 1",
            "        for i in range(3, d + 1, 2):",
            "            if n % i == 0:",
            "                return False",
            "        return True",
            "def pop_count(x):",
            "    x = x - ((x >> 1) & 0x5555555555555555)",
            "    x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)",
            "    x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f",
            "    x = x + (x >> 8)",
            "    x = x + (x >> 16)",
            "    x = x + (x >> 32)",
            "    return x & 0x0000007f",
            "MOD = int(1e09) + 7",
            "INF = int(1e15)",
            "def solve():",
            "    H, W, K = Scanner.map_int()",
            "    L = []",
            "    for i in range(1 << (W - 1)):",
            "        l = [False for _ in range(W - 1)]",
            "        for j in range(W-1):",
            "            if i >> j & 1:",
            "                l[j] = True",
            "        for j in range(W - 2):",
            "            if l[j] and l[j + 1]:",
            "                break",
            "        else:",
            "            L.append(l)",
            "    m = [[0 for _ in range(W)]for _ in range(W)]",
            "    if W == 1:",
            "        m[0][0] = 1",
            "    else:",
            "        for l in L:",
            "            for w in range(W):",
            "                k = w",
            "                if w < W - 1 and l[w]:",
            "                    k = k + 1",
            "                elif w - 1 >= 0 and l[w - 1]:",
            "                    k = k - 1",
            "                m[w][k] += 1",
            "    dp = [[0 for _ in range(W)]for _ in range(H + 1)]",
            "    dp[0][0] = 1",
            "    for h in range(H):",
            "        for w in range(W):",
            "            for i in range(W):",
            "                dp[h + 1][w] += m[w][i] * dp[h][i]",
            "                dp[h + 1][w] %= MOD",
            "    print(dp[H][K - 1])",
            "def main():",
            "    # sys.stdin = open(\"sample.txt\")",
            "    solve()",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#",
            "# 　　  ⋀_⋀",
            "#　　  (･ω･)",
            "# .／ Ｕ ∽ Ｕ＼",
            "#  │＊　合　＊│",
            "#  │＊　格　＊│",
            "#  │＊　祈　＊│",
            "#  │＊　願　＊│",
            "#  │＊　　　＊│",
            "#      ￣",
            "#",
            "import sys",
            "sys.setrecursionlimit(10**6)",
            "input=sys.stdin.readline",
            "from math import floor,ceil,sqrt,factorial,hypot,log #log2ないｙｐ",
            "from heapq import heappop, heappush, heappushpop",
            "from collections import Counter,defaultdict,deque",
            "from itertools import accumulate,permutations,combinations,product,combinations_with_replacement",
            "from bisect import bisect_left,bisect_right",
            "from copy import deepcopy",
            "inf=float('inf')",
            "mod = 10**9+7",
            "def pprint(*A):",
            "    for a in A:     print(*a,sep='\\n')",
            "def INT_(n): return int(n)-1",
            "def MI(): return map(int,input().split())",
            "def MF(): return map(float, input().split())",
            "def MI_(): return map(INT_,input().split())",
            "def LI(): return list(MI())",
            "def LI_(): return [int(x) - 1 for x in input().split()]",
            "def LF(): return list(MF())",
            "def LIN(n:int): return [I() for _ in range(n)]",
            "def LLIN(n: int): return [LI() for _ in range(n)]",
            "def LLIN_(n: int): return [LI_() for _ in range(n)]",
            "def LLI(): return [list(map(int, l.split() )) for l in input()]",
            "def I(): return int(input())",
            "def F(): return float(input())",
            "def ST(): return input().replace('\\n', '')",
            "#mint",
            "class ModInt:",
            "    def __init__(self, x):",
            "        self.x = x % mod",
            "    def __str__(self):",
            "        return str(self.x)",
            "    __repr__ = __str__",
            "    def __add__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(self.x + other.x)",
            "        else:",
            "            return ModInt(self.x + other)",
            "    __radd__ = __add__",
            "    def __sub__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(self.x - other.x)",
            "        else:",
            "            return ModInt(self.x - other)",
            "    def __rsub__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(other.x - self.x)",
            "        else:",
            "            return ModInt(other - self.x)",
            "    def __mul__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(self.x * other.x)",
            "        else:",
            "            return ModInt(self.x * other)",
            "    __rmul__ = __mul__",
            "    def __truediv__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(self.x * pow(other.x, mod-2,mod))",
            "        else:",
            "            return ModInt(self.x * pow(other, mod - 2, mod))",
            "    def __rtruediv(self, other):",
            "        if isinstance(other, self):",
            "            return ModInt(other * pow(self.x, mod - 2, mod))",
            "        else:",
            "            return ModInt(other.x * pow(self.x, mod - 2, mod))",
            "    def __pow__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(pow(self.x, other.x, mod))",
            "        else:",
            "            return ModInt(pow(self.x, other, mod))",
            "    def __rpow__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(pow(other.x, self.x, mod))",
            "        else:",
            "            return ModInt(pow(other, self.x, mod))",
            "def main():",
            "    H,W,K = MI()",
            "    K-=1",
            "    dp = [[ModInt(0)]*W for _ in range(H+1)]",
            "    dp[0][0] = ModInt(1)",
            "    max_bit = 1<<(W-1)",
            "    for h in range(H):",
            "        for mask in range(max_bit):",
            "            before = 0",
            "            ng = False",
            "            for i in range(W):",
            "                if before&(mask>>i):",
            "                    ng = True",
            "                    break",
            "                before = mask>>i&1",
            "            if ng:",
            "                continue",
            "            for i in range(W):",
            "                if 1&mask>>i:",
            "                    dp[h+1][i]+=dp[h][i+1]",
            "                    dp[h+1][i+1]+=dp[h][i]",
            "                elif i==0 or not 1&mask>>(i-1):",
            "                    dp[h+1][i]+=dp[h][i]",
            "    print(dp[-1][K])",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def isp():   return input().split()",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def simu(a, b, k):",
            "        turn = True",
            "        while k > 0:",
            "            # print(a, b, k)",
            "            if turn:",
            "                tmp = a//2",
            "                a = tmp",
            "                b += tmp",
            "            else:",
            "                tmp = b//2",
            "                b = tmp",
            "                a += tmp",
            "            k -= 1",
            "            turn = not turn",
            "        return a, b",
            "    a, b, k = mi()",
            "    x, y = simu(a, b, k)",
            "    print(f\"{x} {y}\")",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def isp():   return input().split()",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def calc_max_diff(seq):",
            "        n = len(seq)",
            "        total = 0",
            "        min_diff = inf",
            "        for i in range(1, n):",
            "            diff = abs(seq[i] - seq[i-1])",
            "            total += diff",
            "            min_diff = min(min_diff, diff)",
            "        diff = abs(seq[0] - seq[-1])",
            "        total += diff",
            "        min_diff = min(min_diff, diff)",
            "        return total - min_diff",
            "    n = ii()",
            "    L = [ii() for _ in range(n)]",
            "    L.sort()",
            "    dq = deque(L)",
            "    large_small = []",
            "    while dq:",
            "        # print(dq)",
            "        large_small.append(dq.pop())",
            "        if dq:",
            "            large_small.append(dq.popleft())",
            "    dq = deque(L)",
            "    small_large = []",
            "    while dq:",
            "        small_large.append(dq.popleft())",
            "        if dq:",
            "            small_large.append(dq.pop())",
            "    a = calc_max_diff(large_small)",
            "    b = calc_max_diff(small_large)",
            "    # print(a, b)",
            "    print(max(a, b))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def isp():   return input().split()",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def check_k(n):",
            "        for k in range(2, 10**3):",
            "            if k * (k-1) > 2 * n:",
            "                return -1",
            "            if k * (k-1) == 2 * n:",
            "                return k",
            "    n = ii()",
            "    k = check_k(n)",
            "    if k == -1:",
            "        print('No')",
            "    else:",
            "        print('Yes')",
            "        print(k)",
            "        num = 0",
            "        groups = [[] for _ in range(k)]",
            "        for pattern in combinations(range(k), r=2):",
            "            num += 1",
            "            a, b = pattern",
            "            groups[a].append(num)",
            "            groups[b].append(num)",
            "        for g in groups:",
            "            print(2 * n // k, end=' ')",
            "            print(*g, sep=' ')",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# input()",
            "# int(input())",
            "# map(int, input().split())",
            "# list(map(int, input().split()))",
            "# list(map(int, list(input()))) # スペースがない数字リストを読み込み",
            "import math",
            "import fractions",
            "import sys",
            "import bisect",
            "import heapq  # 優先度付きキュー(最小値取り出し)",
            "import collections",
            "from collections import Counter",
            "from collections import deque",
            "import pprint",
            "import itertools",
            "sr = lambda: input()",
            "ir = lambda: int(sr())",
            "lr = lambda: list(map(int, sr().split()))",
            "\"\"\"nを素因数分解\"\"\"",
            "\"\"\"2以上の整数n => [[素因数, 指数], ...]の2次元リスト\"\"\"",
            "def factorization(n):",
            "    arr = []",
            "    temp = n",
            "    if n == 1:",
            "        return arr",
            "    for i in range(2, int(-(-n ** 0.5 // 1)) + 1):",
            "        if temp % i == 0:",
            "            cnt = 0",
            "            while temp % i == 0:",
            "                cnt += 1",
            "                temp //= i",
            "            arr.append([i, cnt])",
            "    if temp != 1:",
            "        arr.append([temp, 1])",
            "    if arr == []:",
            "        arr.append([n, 1])",
            "    return arr",
            "# a^n",
            "def power(a, n, mod):",
            "    x = 1",
            "    while n:",
            "        if n & 1:",
            "            x *= a % mod",
            "        n >>= 1",
            "        a *= a % mod",
            "    return x % mod",
            "# n*(n-1)*...*(l+1)*l",
            "def kaijo(n, l, mod):",
            "    if n == 0:",
            "        return 1",
            "    a = n",
            "    tmp = n - 1",
            "    while (tmp >= l):",
            "        a = a * tmp % mod",
            "        tmp -= 1",
            "    return a",
            "# Union Find",
            "class UnionFind():",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parents = [-1] * n",
            "    def find(self, x):",
            "        if self.parents[x] < 0:",
            "            return x",
            "        else:",
            "            self.parents[x] = self.find(self.parents[x])",
            "            return self.parents[x]",
            "    def union(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "        if x == y:",
            "            return",
            "        if self.parents[x] > self.parents[y]:",
            "            x, y = y, x",
            "        self.parents[x] += self.parents[y]",
            "        self.parents[y] = x",
            "    def size(self, x):",
            "        return -self.parents[self.find(x)]",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "    def members(self, x):",
            "        root = self.find(x)",
            "        return [i for i in range(self.n) if self.find(i) == root]",
            "    def roots(self):",
            "        return [i for i, x in enumerate(self.parents) if x < 0]",
            "    def group_count(self):",
            "        return len(self.roots())",
            "    def all_group_members(self):",
            "        return {r: self.members(r) for r in self.roots()}",
            "    def __str__(self):",
            "        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())",
            "# 約数生成",
            "def make_divisors(n):",
            "    divisors = []",
            "    for i in range(1, int(n**0.5)+1):",
            "        if n % i == 0:",
            "            divisors.append(i)",
            "            if i != n // i:",
            "                divisors.append(n//i)",
            "    divisors.sort()",
            "    return divisors",
            "inf = 10 ** 18",
            "mod = 10 ** 9 + 7",
            "n = ir()",
            "xyh = [lr() for i in range(n)]",
            "xyh.sort(key=lambda x:x[2],reverse=True)",
            "for i in range(0,101):",
            "    for j in range(0,101):",
            "        H = abs(xyh[0][0]-i)+abs(xyh[0][1]-j)+xyh[0][2]",
            "        flag = True",
            "        for k in range(1,n):",
            "            h = abs(xyh[k][0]-i)+abs(xyh[k][1]-j)+xyh[k][2]",
            "            if not ((h>H and xyh[k][2]==0) or h==H):",
            "                flag = False",
            "                break",
            "        if flag:",
            "            print(i,j,H)",
            "            sys.exit()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "content": [
            "# abc112_c.py",
            "# https://atcoder.jp/contests/abc112/tasks/abc112_c",
            "# C - Pyramid /",
            "# 実行時間制限: 3 sec / メモリ制限: 1024 MB",
            "# 配点: 300点",
            "# 問題文",
            "# 古代すぬけ国では, AtCoder 社長「高橋君」の権威を高めるために, ピラミッドが建てられていた.",
            "# ピラミッドには 中心座標 (CX,CY)と 高さ H が定まっており, 座標 (X,Y) の高度は max(H−|X−CX|−|Y−CY|,0)であった.",
            "# 探検家の青木君は, このピラミッドの中心座標と高さを求めるために調査を行った. その結果, 次のような情報が得られた.",
            "#     CX,CYは 0 以上 100 以下の整数で, H は 1以上の整数であった.",
            "#     上記と別に N個の情報が得られた. そのうち i 個目の情報は, 「座標 (xi,yi) の高度は hiである」",
            "# この情報は, ピラミッドの中心座標と高さを特定するのに十分であった. 情報を手掛かりに, これらの値を求めなさい.",
            "# 制約",
            "#     Nは 1 以上 100以下の整数",
            "#     xi, yi は 0 以上 100以下の整数",
            "#     hiは 0 以上 109以下の整数",
            "#     N個の座標 (x1,y1),(x2,y2),(x3,y3),...,(xN,yN)はすべて異なる",
            "#     ピラミッドの中心座標と高さをちょうど 1つに特定することができる",
            "# 入力",
            "# 入力は以下の形式で標準入力から与えられる.",
            "# N",
            "# x1 y1 h1",
            "# x2 y2 h2",
            "# x3 y3 h3",
            "# :",
            "# xN yN hN",
            "# 出力",
            "# 特定した中心座標と高さを表す整数 CX,CY,Hを空白区切りで, 1 行に出力しなさい.",
            "# 入力例 1",
            "# 4",
            "# 2 3 5",
            "# 2 1 5",
            "# 1 2 5",
            "# 3 2 5",
            "# 出力例 1",
            "# 2 2 6",
            "# この場合, 中心座標は (2,2), 高さは 6と特定することができる.",
            "# 入力例 2",
            "# 2",
            "# 0 0 100",
            "# 1 1 98",
            "# 出力例 2",
            "# 0 0 100",
            "# この場合, 中心座標は (0,0), 高さは 100 と特定することができる.",
            "# CX,CY が 0 以上 100以下の整数であると分かっていることに注意せよ.",
            "# 入力例 3",
            "# 3",
            "# 99 1 191",
            "# 100 1 192",
            "# 99 0 192",
            "# 出力例 3",
            "# 100 0 193",
            "# この場合, 中心座標は (100,0), 高さは 193 と特定することができる.",
            "def calculation(lines):",
            "    N = int(lines[0])",
            "    # N, T = list(map(int, lines[0].split()))",
            "    # n = lines[0]",
            "    points = list()",
            "    highest = 0",
            "    for i in range(1, N+1):",
            "        point = list(map(int, lines[i].split()))",
            "        # print(point)",
            "        points.append(point)",
            "        if highest < point[2]:",
            "            highest = point[2]",
            "        # print(f'points=[{points}]')",
            "    for x in range(101):",
            "        for y in range(101):",
            "            for h in range(highest, highest+200):",
            "                # print(f'x=[{x}], y=[{y}], h=[{h}]')",
            "                flag = True",
            "                for point in points:",
            "                    # print(f'point=[{point}]')",
            "                    calc_h = max(h - abs(point[0]-x) - abs(point[1]-y), 0)",
            "                    if point[2] != calc_h:",
            "                        flag = False",
            "                        break",
            "                if flag:",
            "                    result = str(x) + ' ' + str(y) + ' ' + str(h)",
            "                    return [result]",
            "# 引数を取得",
            "def get_input_lines():",
            "    line = input()",
            "    N = int(line)",
            "    lines = list()",
            "    lines.append(line)",
            "    for _ in range(N):",
            "        lines.append(input())",
            "    return lines",
            "# テストデータ",
            "def get_testdata(pattern):",
            "    if pattern == 1:",
            "        lines_input = ['4', '2 3 5', '2 1 5', '1 2 5', '3 2 5']",
            "        lines_export = ['2 2 6']",
            "    if pattern == 2:",
            "        lines_input = ['2', '0 0 100', '1 1 98']",
            "        lines_export = ['0 0 100']",
            "    if pattern == 3:",
            "        lines_input = ['3', '99 1 191', '100 1 192', '99 0 192']",
            "        lines_export = ['100 0 193']",
            "    return lines_input, lines_export",
            "# 動作モード判別",
            "def get_mode():",
            "    import sys",
            "    args = sys.argv",
            "    if len(args) == 1:",
            "        mode = 0",
            "    else:",
            "        mode = int(args[1])",
            "    return mode",
            "# 主処理",
            "def main():",
            "    import time",
            "    started = time.time()",
            "    mode = get_mode()",
            "    if mode == 0:",
            "        lines_input = get_input_lines()",
            "    else:",
            "        lines_input, lines_export = get_testdata(mode)",
            "    lines_result = calculation(lines_input)",
            "    for line_result in lines_result:",
            "        print(line_result)",
            "    # if mode > 0:",
            "    #     print(f'lines_input=[{lines_input}]')",
            "    #     print(f'lines_export=[{lines_export}]')",
            "    #     print(f'lines_result=[{lines_result}]')",
            "    #     if lines_result == lines_export:",
            "    #         print('OK')",
            "    #     else:",
            "    #         print('NG')",
            "    # finished = time.time()",
            "    # duration = finished - started",
            "    # print(f'duration=[{duration}]')",
            "# 起動処理",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, m, x, y = mi()",
            "    X = lmi()",
            "    Y = lmi()",
            "    if max(X) < min(Y):",
            "        for p in range(max(X) + 1, min(Y) + 1):",
            "            if x < p <= y:",
            "                print('No War')",
            "                exit()",
            "    print('War')",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    s = input()",
            "    t = input()",
            "    s_first_appeared = dict()",
            "    s_replaced = [i for i in range(len(s))]",
            "    for i, char in enumerate(s):",
            "        if char not in s_first_appeared:",
            "            s_first_appeared[char] = i",
            "        else:",
            "            s_replaced[i] = s_first_appeared[char]",
            "    t_first_appeared = dict()",
            "    t_replaced = [i for i in range(len(t))]",
            "    for i, char in enumerate(t):",
            "        if char not in t_first_appeared:",
            "            t_first_appeared[char] = i",
            "        else:",
            "            t_replaced[i] = t_first_appeared[char]",
            "    print('Yes') if s_replaced == t_replaced else print('No')",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    class Eratos:",
            "        def __init__(self, num):",
            "            assert(num >= 1)",
            "            self.table_max = num",
            "            # self.table[i] は i が素数かどうかを示す (bool)",
            "            self.table = [False if i == 0 or i == 1 else True for i in range(num+1)]",
            "            for i in range(2, int(math.sqrt(num)) + 1):",
            "                if self.table[i]:",
            "                    for j in range(i ** 2, num + 1, i):    # i**2 からスタートすることで定数倍高速化できる",
            "                        self.table[j] = False",
            "            # self.table_max 以下の素数を列挙したリスト",
            "            self.prime_numbers = [2] if self.table_max >= 2 else []",
            "            for i in range(3, self.table_max + 1, 2):",
            "                if self.table[i]:",
            "                    self.prime_numbers.append(i)",
            "        def is_prime(self, num):",
            "            \"\"\"",
            "            >>> e = Eratos(100)",
            "            >>> [i for i in range(1, 101) if e.is_prime(i)]",
            "            [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]",
            "            \"\"\"",
            "            assert(num >= 1)",
            "            if num > self.table_max:",
            "                raise ValueError('Eratos.is_prime(): exceed table_max({}). got {}'.format(self.table_max, num))",
            "            return self.table[num]",
            "        def prime_factorize(self, num):",
            "            \"\"\"",
            "            >>> e = Eratos(10000)",
            "            >>> e.prime_factorize(6552)",
            "            {2: 3, 3: 2, 7: 1, 13: 1}",
            "            \"\"\"",
            "            assert(num >= 1)",
            "            if int(math.sqrt(num)) > self.table_max:",
            "                raise ValueError('Eratos.prime_factorize(): exceed prime table size. got {}'.format(num))",
            "            factorized_dict = dict()    # 素因数分解の結果を記録する辞書",
            "            candidate_prime_numbers = [i for i in range(2, int(math.sqrt(num)) + 1) if self.is_prime(i)]",
            "            # n について、√n 以下の素数で割り続けると最後には 1 or 素数となる",
            "            # 背理法を考えれば自明 (残された数が √n より上の素数の積であると仮定。これは自明に n を超えるため矛盾)",
            "            for p in candidate_prime_numbers:",
            "                # これ以上調査は無意味",
            "                if num == 1:",
            "                    break",
            "                while num % p == 0:",
            "                    num //= p",
            "                    try:",
            "                        factorized_dict[p]",
            "                    except KeyError:",
            "                        factorized_dict[p] = 0",
            "                    finally:",
            "                        factorized_dict[p] += 1",
            "            if num != 1:",
            "                factorized_dict[num] = 1",
            "            return factorized_dict",
            "    n, m = mi()",
            "    eratos = Eratos(max(int(math.sqrt(m)), n))",
            "    d = eratos.prime_factorize(m)",
            "    # print(d)",
            "    FACT = [1] * (n + int(math.log2(m)) + 1)",
            "    for i in range(2, n + int(math.log2(m)) + 1):",
            "        FACT[i] = (FACT[i-1] * i) % mod",
            "    def comb(n, r, m):",
            "        numerator = FACT[n]",
            "        denominator = pow(FACT[n-r] * FACT[r], m - 2, m)",
            "        return (numerator * denominator) % m",
            "    ans = 1",
            "    for _, k in d.items():",
            "        ans = (ans * comb(k + n - 1, k, mod)) % mod",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "MOD = 1000000007  # type: int",
            "def solve(N: int, M: int):",
            "    factors = {}",
            "    m = M",
            "    for i in range(2, int(M**0.5)+1):",
            "        while m % i == 0:",
            "            factors[i] = factors.get(i, 0) + 1",
            "            m //= i",
            "    else:",
            "        if m != 1:",
            "            factors[m] = 1",
            "    mf = ModFactorial(MOD)",
            "    ans = 1",
            "    for c in factors.values():",
            "        ans = ans * mf.combination(c+N-1, c) % MOD",
            "    return ans",
            "# Generated by 1.1.6 https://github.com/kyuridenamida/atcoder-tools",
            "def main():",
            "    def iterate_tokens():",
            "        for line in sys.stdin:",
            "            for word in line.split():",
            "                yield word",
            "    tokens = iterate_tokens()",
            "    N = int(next(tokens))  # type: int",
            "    M = int(next(tokens))  # type: int",
            "    print(solve(N, M))",
            "def test():",
            "    import doctest",
            "    doctest.testmod()",
            "def mod_range(mod, start, stop=None, step=1):",
            "    if stop == None:",
            "        stop = start",
            "        start = 0",
            "    return map(lambda i: i % mod, range(start, stop, step))",
            "def mod_inv(mod, n):",
            "    '''",
            "    >>> mod_inv(3, 2)",
            "    2",
            "    >>> mod_inv(1000000007, 2)",
            "    500000004",
            "    '''",
            "    return pow(n, mod-2, mod)",
            "def mod_permutation(mod, n, r):",
            "    '''",
            "    >>> mod_permutation(1000000007, 10, 2)",
            "    90",
            "    >>> mod_permutation(7, 10, 2)",
            "    6",
            "    '''",
            "    m = 1",
            "    for i in mod_range(mod, n-r+1, n+1):",
            "        m = (m * i) % mod",
            "    return m",
            "def mod_factorial(mod, n):",
            "    '''",
            "    >>> mod_factorial(1000000007, 10)",
            "    3628800",
            "    >>> mod_factorial(7, 6)",
            "    6",
            "    '''",
            "    return mod_permutation(mod, n, n)",
            "def mod_combination(mod, n, r):",
            "    '''",
            "    >>> mod_combination(1000000007, 10, 2)",
            "    45",
            "    >>> mod_combination(7, 10, 2)",
            "    3",
            "    '''",
            "    return mod_permutation(mod, n, r) * mod_inv(mod, mod_factorial(mod, r)) % mod",
            "class ModFactorial:",
            "    def __init__(self, mod, size=1):",
            "        '''",
            "        >>> ModFactorial(7, 7)",
            "        Traceback (most recent call last):",
            "        ...",
            "        AssertionError",
            "        '''",
            "        assert mod > size",
            "        self._mod = mod",
            "        self._init_factorials(size)",
            "    def _mod_range(self, start, stop=None, step=1):",
            "        return mod_range(self._mod, start, stop, step)",
            "    def _mod_inv(self, n):",
            "        return mod_inv(self._mod, n)",
            "    def _init_factorials(self, size):",
            "        '''",
            "        >>> mf1 = ModFactorial(1000000007)",
            "        >>> mf2 = ModFactorial(1000000007, 10)",
            "        >>> mf1.factorial(10) == mf2.factorial(10)",
            "        True",
            "        '''",
            "        self._factorials = [1] * size",
            "        n = 1 # リストの参照は遅いので減らす",
            "        for i, m in enumerate(self._mod_range(1, size), 1):",
            "            n = (n * m) % self._mod",
            "            self._factorials[i] = n",
            "    def _append_factorials(self, n):",
            "        for m in map(lambda i: i % self._mod, range(len(self._factorials), n+1)):",
            "            self._factorials.append((self._factorials[-1] * m) % self._mod)",
            "    def factorial(self, n):",
            "        '''",
            "        >>> ModFactorial(1000000007).factorial(10)",
            "        3628800",
            "        >>> ModFactorial(7).factorial(6)",
            "        6",
            "        >>> ModFactorial(7).factorial(7)",
            "        Traceback (most recent call last):",
            "        ...",
            "        AssertionError",
            "        '''",
            "        assert n < self._mod",
            "        if len(self._factorials) <= n:",
            "            self._append_factorials(n)",
            "        return self._factorials[n]",
            "    def factorial_inv(self, n):",
            "        '''",
            "        >>> MOD = 1000000007",
            "        >>> mf = ModFactorial(MOD)",
            "        >>> mf.factorial_inv(10)",
            "        283194722",
            "        >>> mf.factorial_inv(10) * mf.factorial(10) % MOD",
            "        1",
            "        >>> MOD = 7",
            "        >>> mf = ModFactorial(MOD)",
            "        >>> mf.factorial_inv(6)",
            "        6",
            "        >>> mf.factorial_inv(6) * mf.factorial(6) % MOD",
            "        1",
            "        '''",
            "        return self._mod_inv(self.factorial(n))",
            "    def permutation(self, n, r):",
            "        '''",
            "        >>> ModFactorial(1000000007).permutation(10, 2)",
            "        90",
            "        '''",
            "        return self.factorial(n) * self.factorial_inv(n-r) % self._mod",
            "    def combination(self, n, r):",
            "        '''",
            "        >>> ModFactorial(1000000007).combination(10, 2)",
            "        45",
            "        '''",
            "        return self.permutation(n, r) * self.factorial_inv(r) % self._mod",
            "if __name__ == '__main__':",
            "    #test()",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1
        ]
    },
    {
        "content": [
            "# Complexity: O(sqrt(N))",
            "def factor(n):",
            "    res = []",
            "    last = -1",
            "    i = 2",
            "    while i ** 2 <= n:",
            "        while n % i == 0:",
            "            if i != last:",
            "                res.append([i,1])",
            "                last = i",
            "            else:",
            "                res[-1][1] += 1",
            "            n //= i",
            "        i += 1",
            "    if n != 1:",
            "        res.append([n,1])",
            "    return res",
            "# Complexity: O(logN)(pow,floordiv)",
            "# A//B (mod P) is available only if (MOD is prime AND gcd(B,P)==1)",
            "MOD = 10**9+7",
            "class mint:",
            "    def __init__(self, x):",
            "        self.x = x % MOD if isinstance(x, int) else int(x) % MOD",
            "    def __str__(self):",
            "        return str(self.x)",
            "    __repr__ = __str__",
            "    def __iadd__(self, other):",
            "        self.x += other.x if isinstance(other, mint) else other",
            "        self.x -= MOD if self.x >= MOD else 0",
            "        return self",
            "    def __isub__(self, other):",
            "        self.x += MOD-other.x if isinstance(other, mint) else MOD-other",
            "        self.x -= MOD if self.x >= MOD else 0",
            "        return self",
            "    def __imul__(self, other):",
            "        self.x *= other.x if isinstance(other, mint) else other",
            "        self.x %= MOD",
            "        return self",
            "    def __add__(self, other):",
            "        return (",
            "            mint(self.x + other.x) if isinstance(other, mint) else",
            "            mint(self.x + other)",
            "        )",
            "    def __sub__(self, other):",
            "        return (",
            "            mint(self.x - other.x) if isinstance(other, mint) else",
            "            mint(self.x - other)",
            "        )",
            "    def __mul__(self, other):",
            "        return (",
            "            mint(self.x * other.x) if isinstance(other, mint) else",
            "            mint(self.x * other)",
            "        )",
            "    def __floordiv__(self, other):",
            "        return (",
            "            mint(",
            "                self.x * pow(other.x, MOD - 2, MOD)",
            "            ) if isinstance(other, mint) else",
            "            mint(self.x * pow(other, MOD - 2, MOD))",
            "        )",
            "    def __pow__(self, other):",
            "        return (",
            "            mint(pow(self.x, other.x, MOD)) if isinstance(other, mint) else",
            "            mint(pow(self.x, other, MOD))",
            "        )",
            "    __radd__ = __add__",
            "    def __rsub__(self, other):",
            "        return (",
            "            mint(other.x - self.x) if isinstance(other, mint) else",
            "            mint(other - self.x)",
            "        )",
            "    __rmul__ = __mul__",
            "    def __rfloordiv__(self, other):",
            "        return (",
            "            mint(",
            "                other.x * pow(self.x, MOD - 2, MOD)",
            "            ) if isinstance(other, mint) else",
            "            mint(other * pow(self.x, MOD - 2, MOD))",
            "        )",
            "    def __rpow__(self, other):",
            "        return (",
            "            mint(pow(other.x, self.x, MOD)) if isinstance(other, mint) else",
            "            mint(pow(other, self.x, MOD))",
            "        )",
            "class Comb():",
            "    # class <mint> should be imported",
            "    def __init__(self, n):",
            "        self.n = n",
            "        fact = [0]*(n+1) # 1-indexed",
            "        ifact = [0]*(n+1) # 逆元",
            "        fact[0] = mint(1)",
            "        for i in range(1, n+1):",
            "            fact[i] = fact[i-1]*i",
            "        ifact[-1] = pow(fact[-1], MOD-2)",
            "        for i in range(n, 0, -1):",
            "            ifact[i-1] = ifact[i]*i",
            "        self.fact = fact",
            "        self.ifact = ifact",
            "    def calc(self, n, k):",
            "        if k<0 or k>n:",
            "            return 0",
            "        return self.fact[n]*self.ifact[k]*self.ifact[n-k]",
            "n, m = map(int, input().split())",
            "cb=Comb(200005)",
            "f=factor(m)",
            "ans=mint(1)",
            "for p,cnt in f:",
            "    ans*=cb.calc(cnt+n-1,cnt)",
            "print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            2,
            1,
            1,
            1,
            2,
            1,
            1,
            1,
            2,
            1,
            1,
            1,
            2,
            1,
            0,
            0,
            1,
            2,
            1,
            0,
            0,
            1,
            2,
            1,
            0,
            0,
            1,
            2,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            2,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "#",
            "# 　　  ⋀_⋀",
            "#　　  (･ω･)",
            "# .／ Ｕ ∽ Ｕ＼",
            "#  │＊　合　＊│",
            "#  │＊　格　＊│",
            "#  │＊　祈　＊│",
            "#  │＊　願　＊│",
            "#  │＊　　　＊│",
            "#      ￣",
            "#",
            "import sys",
            "sys.setrecursionlimit(10**6)",
            "input=sys.stdin.readline",
            "from math import floor,ceil,sqrt,factorial,hypot,log #log2ないｙｐ",
            "from heapq import heappop, heappush, heappushpop",
            "from collections import Counter,defaultdict,deque",
            "from itertools import accumulate,permutations,combinations,product,combinations_with_replacement",
            "from bisect import bisect_left,bisect_right",
            "from copy import deepcopy",
            "inf=float('inf')",
            "mod = 10**9+7",
            "def pprint(*A):",
            "    for a in A:     print(*a,sep='\\n')",
            "def INT_(n): return int(n)-1",
            "def MI(): return map(int,input().split())",
            "def MF(): return map(float, input().split())",
            "def MI_(): return map(INT_,input().split())",
            "def LI(): return list(MI())",
            "def LI_(): return [int(x) - 1 for x in input().split()]",
            "def LF(): return list(MF())",
            "def LIN(n:int): return [I() for _ in range(n)]",
            "def LLIN(n: int): return [LI() for _ in range(n)]",
            "def LLIN_(n: int): return [LI_() for _ in range(n)]",
            "def LLI(): return [list(map(int, l.split() )) for l in input()]",
            "def I(): return int(input())",
            "def F(): return float(input())",
            "def ST(): return input().replace('\\n', '')",
            "# 素因数分解",
            "def prime_factorization(n):",
            "    fact=[]",
            "    for i in range(2, int(sqrt(n)) + 1):",
            "        while n % i == 0:",
            "            n //= i",
            "            fact.append(i)",
            "    if n!=1:",
            "        fact.append(n)",
            "    return fact",
            "#mint",
            "class ModInt:",
            "    def __init__(self, x):",
            "        self.x = x % mod",
            "    def __str__(self):",
            "        return str(self.x)",
            "    __repr__ = __str__",
            "    def __add__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(self.x + other.x)",
            "        else:",
            "            return ModInt(self.x + other)",
            "    __radd__ = __add__",
            "    def __sub__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(self.x - other.x)",
            "        else:",
            "            return ModInt(self.x - other)",
            "    def __rsub__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(other.x - self.x)",
            "        else:",
            "            return ModInt(other - self.x)",
            "    def __mul__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(self.x * other.x)",
            "        else:",
            "            return ModInt(self.x * other)",
            "    __rmul__ = __mul__",
            "    def __truediv__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(self.x * pow(other.x, mod-2,mod))",
            "        else:",
            "            return ModInt(self.x * pow(other, mod - 2, mod))",
            "    def __rtruediv(self, other):",
            "        if isinstance(other, self):",
            "            return ModInt(other * pow(self.x, mod - 2, mod))",
            "        else:",
            "            return ModInt(other.x * pow(self.x, mod - 2, mod))",
            "    def __pow__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(pow(self.x, other.x, mod))",
            "        else:",
            "            return ModInt(pow(self.x, other, mod))",
            "    def __rpow__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(pow(other.x, self.x, mod))",
            "        else:",
            "            return ModInt(pow(other, self.x, mod))",
            "class BigCombination(object):",
            "    def __init__(self, mod: int=10**9+7, max_n: int=10**6):",
            "        fac, inv=[1], []",
            "        fac_append, inv_append=fac.append, inv.append",
            "        for i in range(1, max_n+1):",
            "            fac_append(fac[-1] * i % mod)",
            "        inv_append(pow(fac[-1], mod-2, mod))",
            "        for i in range(max_n, 0, -1):",
            "            inv_append(inv[-1] * i % mod)",
            "        self.mod, self.factorial, self.inverse=mod, fac, inv[::-1]",
            "    def get_combination(self, n, r):",
            "        if n < r:",
            "            return 0",
            "        return self.factorial[n] * self.inverse[r] * self.inverse[n-r] % self.mod",
            "    def get_permutation(self, n, r):",
            "        if n < r:",
            "            return 0",
            "        return self.factorial[n] * self.inverse[n-r] % self.mod",
            "def main():",
            "    N,M = MI()",
            "    prime = prime_factorization(M)",
            "    ans = ModInt(1)",
            "    B = BigCombination()",
            "    for p in prime:",
            "        cnt = 0",
            "        while M%p == 0:",
            "            M//=p",
            "            cnt += 1",
            "        ans *= B.get_combination(N+cnt-1, N-1)",
            "    print(ans)",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#",
            "# 　　  ⋀_⋀",
            "#　　  (･ω･)",
            "# .／ Ｕ ∽ Ｕ＼",
            "#  │＊　合　＊│",
            "#  │＊　格　＊│",
            "#  │＊　祈　＊│",
            "#  │＊　願　＊│",
            "#  │＊　　　＊│",
            "#      ￣",
            "#",
            "import sys",
            "sys.setrecursionlimit(10**6)",
            "input=sys.stdin.readline",
            "from math import floor,sqrt,factorial,hypot,log #log2ないｙｐ",
            "from heapq import heappop, heappush, heappushpop",
            "from collections import Counter,defaultdict,deque",
            "from itertools import accumulate,permutations,combinations,product,combinations_with_replacement",
            "from bisect import bisect_left,bisect_right",
            "from copy import deepcopy",
            "from fractions import gcd",
            "from random import randint",
            "def ceil(a,b): return (a+b-1)//b",
            "inf=float('inf')",
            "mod = 10**9+7",
            "def pprint(*A):",
            "    for a in A:     print(*a,sep='\\n')",
            "def INT_(n): return int(n)-1",
            "def MI(): return map(int,input().split())",
            "def MF(): return map(float, input().split())",
            "def MI_(): return map(INT_,input().split())",
            "def LI(): return list(MI())",
            "def LI_(): return [int(x) - 1 for x in input().split()]",
            "def LF(): return list(MF())",
            "def LIN(n:int): return [I() for _ in range(n)]",
            "def LLIN(n: int): return [LI() for _ in range(n)]",
            "def LLIN_(n: int): return [LI_() for _ in range(n)]",
            "def LLI(): return [list(map(int, l.split() )) for l in input()]",
            "def I(): return int(input())",
            "def F(): return float(input())",
            "def ST(): return input().replace('\\n', '')",
            "# 約数列挙",
            "def find_divisor(n):",
            "    divisors=[]",
            "    for i in range(1, int(sqrt(n)) + 1):",
            "        if n % i == 0:",
            "            divisors.append(i)",
            "            if i*i!=n:",
            "                divisors.append(n // i)",
            "    return divisors",
            "# 素因数分解",
            "def prime_factorization(n):",
            "    fact=defaultdict(int)",
            "    for i in range(2, int(sqrt(n)) + 1):",
            "        while n % i == 0:",
            "            n //= i",
            "            fact[i]+=1",
            "    if n!=1:",
            "        fact[n]+=1",
            "    return fact",
            "#mint",
            "class ModInt:",
            "    def __init__(self, x):",
            "        self.x = x % mod",
            "    def __str__(self):",
            "        return str(self.x)",
            "    __repr__ = __str__",
            "    def __add__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(self.x + other.x)",
            "        else:",
            "            return ModInt(self.x + other)",
            "    __radd__ = __add__",
            "    def __sub__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(self.x - other.x)",
            "        else:",
            "            return ModInt(self.x - other)",
            "    def __rsub__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(other.x - self.x)",
            "        else:",
            "            return ModInt(other - self.x)",
            "    def __mul__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(self.x * other.x)",
            "        else:",
            "            return ModInt(self.x * other)",
            "    __rmul__ = __mul__",
            "    def __truediv__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(self.x * pow(other.x, mod-2,mod))",
            "        else:",
            "            return ModInt(self.x * pow(other, mod - 2, mod))",
            "    def __rtruediv(self, other):",
            "        if isinstance(other, self):",
            "            return ModInt(other * pow(self.x, mod - 2, mod))",
            "        else:",
            "            return ModInt(other.x * pow(self.x, mod - 2, mod))",
            "    def __pow__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(pow(self.x, other.x, mod))",
            "        else:",
            "            return ModInt(pow(self.x, other, mod))",
            "    def __rpow__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(pow(other.x, self.x, mod))",
            "        else:",
            "            return ModInt(pow(other, self.x, mod))",
            "class BigCombination(object):",
            "    def __init__(self, mod: int=10**9+7, max_n: int=10**6):",
            "        fac, inv=[1], []",
            "        fac_append, inv_append=fac.append, inv.append",
            "        for i in range(1, max_n+1):",
            "            fac_append(fac[-1] * i % mod)",
            "        inv_append(pow(fac[-1], mod-2, mod))",
            "        for i in range(max_n, 0, -1):",
            "            inv_append(inv[-1] * i % mod)",
            "        self.mod, self.factorial, self.inverse=mod, fac, inv[::-1]",
            "    def get_combination(self, n, r):",
            "        if n < r:",
            "            return 0",
            "        return self.factorial[n] * self.inverse[r] * self.inverse[n-r] % self.mod",
            "    def get_permutation(self, n, r):",
            "        if n < r:",
            "            return 0",
            "        return self.factorial[n] * self.inverse[n-r] % self.mod",
            "def main():",
            "    N,M=MI()",
            "    ans = ModInt(1)",
            "    B=BigCombination()",
            "    for p,v in prime_factorization(M).items():",
            "        ans *= B.get_combination(v+N-1,v)",
            "    print(ans)",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#a module for any prime implication",
            "import random",
            "def primesbelow(N):",
            "    # http://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188",
            "    #\"\"\" Input N>=6, Returns a list of primes, 2 <= p < N \"\"\"",
            "    correction = N % 6 > 1",
            "    N = {0:N, 1:N-1, 2:N+4, 3:N+3, 4:N+2, 5:N+1}[N%6]",
            "    sieve = [True] * (N // 3)",
            "    sieve[0] = False",
            "    for i in range(int(N ** .5) // 3 + 1):",
            "        if sieve[i]:",
            "            k = (3 * i + 1) | 1",
            "            sieve[k*k // 3::2*k] = [False] * ((N//6 - (k*k)//6 - 1)//k + 1)",
            "            sieve[(k*k + 4*k - 2*k*(i%2)) // 3::2*k] = [False] * ((N // 6 - (k*k + 4*k - 2*k*(i%2))//6 - 1) // k + 1)",
            "    return [2, 3] + [(3 * i + 1) | 1 for i in range(1, N//3 - correction) if sieve[i]]",
            "smallprimeset = set(primesbelow(100000))",
            "_smallprimeset = 100000",
            "def isprime(n, precision=7):",
            "    # http://en.wikipedia.org/wiki/Miller-Rabin_primality_test#Algorithm_and_running_time",
            "    if n < 1:",
            "        raise ValueError(\"Out of bounds, first argument must be > 0\")",
            "    elif n <= 3:",
            "        return n >= 2",
            "    elif n % 2 == 0:",
            "        return False",
            "    elif n < _smallprimeset:",
            "        return n in smallprimeset",
            "    d = n - 1",
            "    s = 0",
            "    while d % 2 == 0:",
            "        d //= 2",
            "        s += 1",
            "    for repeat in range(precision):",
            "        a = random.randrange(2, n - 2)",
            "        x = pow(a, d, n)",
            "        if x == 1 or x == n - 1: continue",
            "        for r in range(s - 1):",
            "            x = pow(x, 2, n)",
            "            if x == 1: return False",
            "            if x == n - 1: break",
            "        else: return False",
            "    return True",
            "# https://comeoncodeon.wordpress.com/2010/09/18/pollard-rho-brent-integer-factorization/",
            "def pollard_brent(n):",
            "    if n % 2 == 0: return 2",
            "    if n % 3 == 0: return 3",
            "    y, c, m = random.randint(1, n-1), random.randint(1, n-1), random.randint(1, n-1)",
            "    g, r, q = 1, 1, 1",
            "    while g == 1:",
            "        x = y",
            "        for i in range(r):",
            "            y = (pow(y, 2, n) + c) % n",
            "        k = 0",
            "        while k < r and g==1:",
            "            ys = y",
            "            for i in range(min(m, r-k)):",
            "                y = (pow(y, 2, n) + c) % n",
            "                q = q * abs(x-y) % n",
            "            g = gcd(q, n)",
            "            k += m",
            "        r *= 2",
            "    if g == n:",
            "        while True:",
            "            ys = (pow(ys, 2, n) + c) % n",
            "            g = gcd(abs(x - ys), n)",
            "            if g > 1:",
            "                break",
            "    return g",
            "smallprimes = primesbelow(1000) # might seem low, but 1000*1000 = 1000000, so this will fully factor every composite < 1000000",
            "def primefactors(n, sort=False):",
            "    factors = []",
            "    for checker in smallprimes:",
            "        while n % checker == 0:",
            "            factors.append(checker)",
            "            n //= checker",
            "        if checker > n: break",
            "    if n < 2: return factors",
            "    while n > 1:",
            "        if isprime(n):",
            "            factors.append(n)",
            "            break",
            "        factor = pollard_brent(n) # trial division did not fully factor, switch to pollard-brent",
            "        factors.extend(primefactors(factor)) # recurse to factor the not necessarily prime factor returned by pollard-brent",
            "        n //= factor",
            "    if sort: factors.sort()",
            "    return factors",
            "def factorization(n):",
            "    factors = {}",
            "    for p1 in primefactors(n):",
            "        try:",
            "            factors[p1] += 1",
            "        except KeyError:",
            "            factors[p1] = 1",
            "    return factors",
            "def gcd(a, b):",
            "    if a == b: return a",
            "    while b > 0: a, b = b, a % b",
            "    return a",
            "N=1000000007",
            "def c(n,r):",
            "    a=1",
            "    b=1",
            "    for i in range(n,n-r,-1):",
            "        a=(a*i)%N",
            "    for i in range(1,r+1):",
            "        b=(b*i)%N",
            "    binv=pow(b,N-2,N)",
            "    return (a*binv)%N",
            "n,m=map(int,input().strip().split(\" \"))",
            "d=factorization(m)",
            "ans=1",
            "for i in d.values():",
            "    ans=(ans*c(i+n-1,n-1))%N",
            "print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2
        ]
    },
    {
        "content": [
            "import sys",
            "import heapq",
            "import re",
            "from itertools import permutations",
            "from bisect import bisect_left, bisect_right",
            "from collections import Counter, deque",
            "from fractions import gcd",
            "from math import factorial, sqrt, ceil",
            "from functools import lru_cache, reduce",
            "INF = 1 << 60",
            "MOD = 1000000007",
            "sys.setrecursionlimit(10 ** 7)",
            "# UnionFind",
            "class UnionFind():",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parents = [-1] * n",
            "    def find(self, x):",
            "        if self.parents[x] < 0:",
            "            return x",
            "        else:",
            "            self.parents[x] = self.find(self.parents[x])",
            "            return self.parents[x]",
            "    def union(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "        if x == y:",
            "            return",
            "        if self.parents[x] > self.parents[y]:",
            "            x, y = y, x",
            "        self.parents[x] += self.parents[y]",
            "        self.parents[y] = x",
            "    def size(self, x):",
            "        return -self.parents[self.find(x)]",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "    def members(self, x):",
            "        root = self.find(x)",
            "        return [i for i in range(self.n) if self.find(i) == root]",
            "    def roots(self):",
            "        return [i for i, x in enumerate(self.parents) if x < 0]",
            "    def group_count(self):",
            "        return len(self.roots())",
            "    def all_group_members(self):",
            "        return {r: self.members(r) for r in self.roots()}",
            "    def __str__(self):",
            "        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())",
            "def is_prime(n):",
            "    if n == 1:",
            "        return False",
            "    for i in range(2,int(n**0.5)+1):",
            "        if n % i == 0:",
            "            return False",
            "    return True",
            "# ワーシャルフロイド (任意の2頂点の対に対して最短経路を求める)",
            "# 計算量n^3 (nは頂点の数)",
            "def warshall_floyd(d, n):",
            "    #d[i][j]: iからjへの最短距離",
            "    for k in range(n):",
            "        for i in range(n):",
            "            for j in range(n):",
            "                d[i][j] = min(d[i][j],d[i][k] + d[k][j])",
            "    return d",
            "# ダイクストラ",
            "def dijkstra_heap(s, edge, n):",
            "    #始点sから各頂点への最短距離",
            "    d = [10**20] * n",
            "    used = [True] * n #True:未確定",
            "    d[s] = 0",
            "    used[s] = False",
            "    edgelist = []",
            "    for a,b in edge[s]:",
            "        heapq.heappush(edgelist,a*(10**6)+b)",
            "    while len(edgelist):",
            "        minedge = heapq.heappop(edgelist)",
            "        #まだ使われてない頂点の中から最小の距離のものを探す",
            "        if not used[minedge%(10**6)]:",
            "            continue",
            "        v = minedge%(10**6)",
            "        d[v] = minedge//(10**6)",
            "        used[v] = False",
            "        for e in edge[v]:",
            "            if used[e[1]]:",
            "                heapq.heappush(edgelist,(e[0]+d[v])*(10**6)+e[1])",
            "    return d",
            "# 素因数分解",
            "def factorization(n):",
            "    arr = []",
            "    temp = n",
            "    for i in range(2, int(-(-n**0.5//1))+1):",
            "        if temp%i==0:",
            "            cnt=0",
            "            while temp%i==0:",
            "                cnt+=1",
            "                temp //= i",
            "            arr.append([i, cnt])",
            "    if temp!=1:",
            "        arr.append([temp, 1])",
            "    if arr==[]:",
            "        arr.append([n, 1])",
            "    return arr",
            "# 2数の最小公倍数",
            "def lcm(x, y):",
            "    return (x * y) // gcd(x, y)",
            "# リストの要素の最小公倍数",
            "def lcm_list(numbers):",
            "    return reduce(lcm, numbers, 1)",
            "# リストの要素の最大公約数",
            "def gcd_list(numbers):",
            "    return reduce(gcd, numbers)",
            "# 素数判定",
            "# limit以下の素数を列挙",
            "def eratosthenes(limit):",
            "    A = [i for i in range(2, limit+1)]",
            "    P = []",
            "    while True:",
            "        prime = min(A)",
            "        if prime > sqrt(limit):",
            "            break",
            "        P.append(prime)",
            "        i = 0",
            "        while i < len(A):",
            "            if A[i] % prime == 0:",
            "                A.pop(i)",
            "                continue",
            "            i += 1",
            "    for a in A:",
            "        P.append(a)",
            "    return P",
            "# 同じものを含む順列",
            "def permutation_with_duplicates(L):",
            "    if L == []:",
            "        return [[]]",
            "    else:",
            "        ret = []",
            "        # set（集合）型で重複を削除、ソート",
            "        S = sorted(set(L))",
            "        for i in S:",
            "            data = L[:]",
            "            data.remove(i)",
            "            for j in permutation_with_duplicates(data):",
            "                ret.append([i] + j)",
            "        return ret",
            "# ここから書き始める",
            "h, w = map(int, input().split())",
            "a = [list(map(int, input().split())) for i in range(h)]",
            "n = 0",
            "ans = []",
            "for i in range(h):",
            "    for j in range(w):",
            "        if a[i][j] % 2 == 0:",
            "            continue",
            "        if i < h - 1:",
            "            n += 1",
            "            ans.append([i + 1, j + 1, i + 2, j + 1])",
            "            a[i][j] -= 1",
            "            a[i + 1][j] += 1",
            "        elif j < w - 1:",
            "            n += 1",
            "            ans.append([i + 1, j + 1, i + 1, j + 2])",
            "            a[i][j] -= 1",
            "            a[i][j + 1] += 1",
            "# print(a)",
            "print(n)",
            "for i in range(n):",
            "    print(*ans[i])"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            1,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# abc107_b.py",
            "# https://atcoder.jp/contests/abc107/tasks/abc107_b",
            "# B - Grid Compression /",
            "# 実行時間制限: 2 sec / メモリ制限: 1024 MB",
            "# 配点 : 200点",
            "# 問題文",
            "# 縦 H行、横 W 列のマス目があります。 上から i 行目、左から j 列目のマスを (i,j) と表します。",
            "# 各マスは白または黒です。 マス目の配色は、H 行 W 列の行列 (ai,j) によって与えられます。",
            "# ai,j が . ならばマス (i,j) は白であり、ai,j が # ならばマス (i,j)は黒です。",
            "# すぬけ君はこのマス目を圧縮しようとしています。 そのために、白いマスのみからなる行または列が存在する間、次の操作を繰り返し行います。",
            "#     操作: 白いマスのみからなる行または列をひとつ任意に選び、その行または列を取り除いて空白を詰める。",
            "# 各操作でどの行または列を選ぶかによらず、最終的なマス目は一意に定まることが示せます。 最終的なマス目を求めてください。",
            "# 制約",
            "#     1≤H,W≤100",
            "#     ai,jは . または # である。",
            "#     マス目全体で少なくともひとつは黒いマスが存在する。",
            "# 入力",
            "# 入力は以下の形式で標準入力から与えられる。",
            "# H W",
            "# a1,1...a1,W",
            "# :",
            "# aH,1...aH,W",
            "# 出力",
            "# 最終的なマス目を、入力と同様のフォーマットで出力せよ。 ただし、行数および列数は省くこと。 詳しくはサンプルを参照せよ。",
            "# 入力例 1",
            "# 4 4",
            "# ##.#",
            "# ....",
            "# ##.#",
            "# .#.#",
            "# 出力例 1",
            "# ###",
            "# ###",
            "# .##",
            "# 元のマス目における第 2行および第 3列がそれぞれ取り除かれます。",
            "# 入力例 2",
            "# 3 3",
            "# #..",
            "# .#.",
            "# ..#",
            "# 出力例 2",
            "# #..",
            "# .#.",
            "# ..#",
            "# 白いマスのみからなる行または列が存在しないので、操作は行われません。",
            "# 入力例 3",
            "# 4 5",
            "# .....",
            "# .....",
            "# ..#..",
            "# .....",
            "# 出力例 3",
            "# #",
            "# 入力例 4",
            "# 7 6",
            "# ......",
            "# ....#.",
            "# .#....",
            "# ..#...",
            "# ..#...",
            "# ......",
            "# .#..#.",
            "# 出力例 4",
            "# ..#",
            "# #..",
            "# .#.",
            "# .#.",
            "# #.#",
            "def calculation(lines):",
            "    N, W = list(map(int, lines[0].split()))",
            "    masus = list()",
            "    for i in range(N):",
            "        line = lines[i+1]",
            "        if line != '.'*W:",
            "            masus.append(line)",
            "    for w in range(W):",
            "        flag = True",
            "        for masu in masus:",
            "            if masu[w] == '#':",
            "                flag = False",
            "        if flag:",
            "            for i in range(len(masus)):",
            "                masus[i] = masus[i][:w] + ' ' + masus[i][w+1:]",
            "    for i in range(len(masus)):",
            "        masus[i] = masus[i].replace(' ', '')",
            "    return masus",
            "# 引数を取得",
            "def get_input_lines():",
            "    line = input()",
            "    H, W = list(map(int, line.split()))",
            "    lines = list()",
            "    lines.append(line)",
            "    for _ in range(H):",
            "        lines.append(input())",
            "    return lines",
            "# テストデータ",
            "def get_testdata(pattern):",
            "    if pattern == 1:",
            "        lines_input = ['4 4', '##.#', '....', '##.#', '.#.#']",
            "        lines_export = ['###', '###', '.##']",
            "    if pattern == 2:",
            "        lines_input = ['3 3', '#..', '.#.', '..#']",
            "        lines_export = ['#..', '.#.', '..#']",
            "    if pattern == 3:",
            "        lines_input = ['4 5', '.....', '.....', '..#..', '.....']",
            "        lines_export = ['#']",
            "    if pattern == 4:",
            "        lines_input = ['7 6', '......', '....#.', '.#....', '..#...', '..#...', '......', '.#..#.']",
            "        lines_export = ['..#', '#..', '.#.', '.#.', '#.#']",
            "    return lines_input, lines_export",
            "# 動作モード判別",
            "def get_mode():",
            "    import sys",
            "    args = sys.argv",
            "    if len(args) == 1:",
            "        mode = 0",
            "    else:",
            "        mode = int(args[1])",
            "    return mode",
            "# 主処理",
            "def main():",
            "    mode = get_mode()",
            "    if mode == 0:",
            "        lines_input = get_input_lines()",
            "    else:",
            "        lines_input, lines_export = get_testdata(mode)",
            "    lines_result = calculation(lines_input)",
            "    for line_result in lines_result:",
            "        print(line_result)",
            "    # if mode > 0:",
            "    #     print(f'lines_input=[{lines_input}]')",
            "    #     print(f'lines_export=[{lines_export}]')",
            "    #     print(f'lines_result=[{lines_result}]')",
            "    #     if lines_result == lines_export:",
            "    #         print('OK')",
            "    #     else:",
            "    #         print('NG')",
            "# 起動処理",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, k = mi()",
            "    L = lmi()",
            "    ans = 2 ** 64 - 1",
            "    for i in range(n - (k - 1)):",
            "        if L[i+k-1] <= 0:",
            "            cost = abs(L[i])",
            "        elif L[i] >= 0:",
            "            cost = L[i+k-1]",
            "        else:",
            "            cost = L[i+k-1] - L[i] + min(abs(L[i]), L[i+k-1])",
            "        ans = min(ans, cost)",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, m, q = mi()",
            "    intervals = []",
            "    for _ in range(m):",
            "        l, r = mi()",
            "        intervals.append((l - 1, r))",
            "    intervals.sort(key=itemgetter(1))",
            "    commands = []",
            "    for _ in range(q):",
            "        a, b = mi()",
            "        commands.append((a - 1, b))",
            "    # completely_included[i] = ([0:i] で完全に含んでいる区間数)",
            "    completely_included = [0] * (n + 1)",
            "    for _, right in intervals:",
            "        completely_included[right] += 1",
            "    prev = 0",
            "    for i in range(1, n + 1):",
            "        completely_included[i] += prev",
            "        prev = completely_included[i]",
            "    # print(completely_included)",
            "    # across_num[r][l] = (0:right に含まれるインターバルのうち、left を内部に含むようなインターバルの個数)",
            "    across_num = [[0] * (n + 1) for _ in range(n + 1)]",
            "    for left, right in intervals:",
            "        if right - left >= 2:",
            "            for i in range(right, n + 1):",
            "                across_num[i][left + 1] += 1",
            "                across_num[i][right] -= 1",
            "    for i in range(1, n + 1):",
            "        prev = 0",
            "        for j in range(1, n + 1):",
            "            across_num[i][j] += prev",
            "            prev = across_num[i][j]",
            "    def calc_included_intervals(left, right):",
            "        return completely_included[right] - completely_included[left] - across_num[right][left]",
            "    for l, r in commands:",
            "        print(calc_included_intervals(l, r))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, m, q = mi()",
            "    train = [lmi() for _ in range(m)]",
            "    query = [lmi() for _ in range(q)]",
            "    \"\"\"",
            "    電車の運行区間のうち開始地点を x 座標で、終着地点を y 座標で表し二次元座標で管理する",
            "    [i, j] 区間内で運行する電車は 0 <= x <= i, 0 <= y <= j の長方形区間内の全ての電車である",
            "    \"\"\"",
            "    coordinate = [[0] * (n + 1) for _ in range(n + 1)]",
            "    for start, end in train:",
            "        coordinate[start][end] += 1",
            "    # for line in coordinate:",
            "    #     print(*line)",
            "    # print(\"\")",
            "    # 二次元累積和に",
            "    for i in range(n):",
            "        for j in range(n):",
            "            coordinate[i+1][j+1] += coordinate[i][j+1] + coordinate[i+1][j] - coordinate[i][j]",
            "    # for line in coordinate:",
            "    #     print(*line)",
            "    # print(\"\")",
            "    # 各クエリに O(1) で答えられる！",
            "    for l, r in query:",
            "        print(coordinate[r][r] - coordinate[l-1][r] - coordinate[r][l-1] + coordinate[l-1][l-1])",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def calc_covered_k(num):",
            "        \"\"\"",
            "        abs(num) > 0 の時 -> num が -2 進数表記で k + 1 桁で表現される場合 k を返す ([k] に 1 が立つことを表す)",
            "        \"\"\"",
            "        assert(num != 0)",
            "        if num > 0:",
            "            return (math.ceil(math.log(3 * num + 1, 4)) - 1) * 2",
            "        else:",
            "            return (math.ceil(math.log(3 / 2 * abs(num) + 1, 4)) - 1) * 2 + 1",
            "    n = ii()",
            "    if n == 0:",
            "        print(0)",
            "    else:",
            "        k = calc_covered_k(n)",
            "        ans = ['0'] * (k + 1)    # あとで反転する",
            "        ans[k] = '1'",
            "        n -= pow(-2, k)",
            "        while n != 0:",
            "            k = calc_covered_k(n)",
            "            ans[k] = '1'",
            "            n -= pow(-2, k)",
            "        print(''.join(reversed(ans)))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, m = mi()",
            "    L = list(map(lambda x: int(x) % m, input().split()))",
            "    # accum[i] -> (sum(L[0:i]) % m)",
            "    # accum[j] - accum[i] (j > i) -> (sum(L[i:j]) % m)",
            "    accum = [0] + list(accumulate(L, lambda x, y: (x + y) % m))",
            "    # print(accum)",
            "    # accum[i] = accum[j] なる i < j の組み合わせの個数が答え",
            "    ans = 0",
            "    for _, duplicate_num in Counter(accum).items():",
            "        ans += duplicate_num * (duplicate_num - 1) // 2",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#",
            "# 　　  ⋀_⋀",
            "#　　  (･ω･)",
            "# .／ Ｕ ∽ Ｕ＼",
            "#  │＊　合　＊│",
            "#  │＊　格　＊│",
            "#  │＊　祈　＊│",
            "#  │＊　願　＊│",
            "#  │＊　　　＊│",
            "#      ￣",
            "#",
            "import sys",
            "sys.setrecursionlimit(10**6)",
            "input=sys.stdin.readline",
            "from math import floor,ceil,sqrt,factorial,hypot,log #log2ないｙｐ",
            "from heapq import heappop, heappush, heappushpop",
            "from collections import Counter,defaultdict,deque",
            "from itertools import accumulate,permutations,combinations,product,combinations_with_replacement",
            "from bisect import bisect_left,bisect_right",
            "from copy import deepcopy",
            "inf=float('inf')",
            "mod = 10**9+7",
            "def pprint(*A):",
            "    for a in A:     print(*a,sep='\\n')",
            "def INT_(n): return int(n)-1",
            "def MI(): return map(int,input().split())",
            "def MF(): return map(float, input().split())",
            "def MI_(): return map(INT_,input().split())",
            "def LI(): return list(MI())",
            "def LI_(): return [int(x) - 1 for x in input().split()]",
            "def LF(): return list(MF())",
            "def LIN(n:int): return [I() for _ in range(n)]",
            "def LLIN(n: int): return [LI() for _ in range(n)]",
            "def LLIN_(n: int): return [LI_() for _ in range(n)]",
            "def LLI(): return [list(map(int, l.split() )) for l in input()]",
            "def I(): return int(input())",
            "def F(): return float(input())",
            "def ST(): return input().replace('\\n', '')",
            "#mint",
            "class ModInt:",
            "    def __init__(self, x):",
            "        self.x = x % mod",
            "    def __str__(self):",
            "        return str(self.x)",
            "    __repr__ = __str__",
            "    def __add__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(self.x + other.x)",
            "        else:",
            "            return ModInt(self.x + other)",
            "    __radd__ = __add__",
            "    def __sub__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(self.x - other.x)",
            "        else:",
            "            return ModInt(self.x - other)",
            "    def __rsub__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(other.x - self.x)",
            "        else:",
            "            return ModInt(other - self.x)",
            "    def __mul__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(self.x * other.x)",
            "        else:",
            "            return ModInt(self.x * other)",
            "    __rmul__ = __mul__",
            "    def __truediv__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(self.x * pow(other.x, mod-2,mod))",
            "        else:",
            "            return ModInt(self.x * pow(other, mod - 2, mod))",
            "    def __rtruediv(self, other):",
            "        if isinstance(other, self):",
            "            return ModInt(other * pow(self.x, mod - 2, mod))",
            "        else:",
            "            return ModInt(other.x * pow(self.x, mod - 2, mod))",
            "    def __pow__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(pow(self.x, other.x, mod))",
            "        else:",
            "            return ModInt(pow(self.x, other, mod))",
            "    def __rpow__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(pow(other.x, self.x, mod))",
            "        else:",
            "            return ModInt(pow(other, self.x, mod))",
            "def main():",
            "    S=ST()",
            "    N=len(S)",
            "    dp = [[ModInt(0)]*4 for _ in range(N)] #dp[i][j]:=i番目までで、ABCのj文字目まで完成している場合の数",
            "    dp[0][0]+=1",
            "    for i,s in enumerate(S):",
            "        if i==0:",
            "            if s in \"A?\":",
            "                dp[0][1]+=1",
            "                if s == \"?\":",
            "                    dp[0][0]*=3",
            "            continue",
            "        for j in range(4):",
            "            if s==\"?\":",
            "                dp[i][j]=3*dp[i-1][j]",
            "            else:",
            "                dp[i][j]=dp[i-1][j]",
            "        if s==\"A\":",
            "            dp[i][1]+=dp[i-1][0]",
            "        elif s==\"B\":",
            "            dp[i][2]+=dp[i-1][1]",
            "        elif s==\"C\":",
            "            dp[i][3]+=dp[i-1][2]",
            "        else:",
            "            dp[i][1]+=dp[i-1][0]",
            "            dp[i][2]+=dp[i-1][1]",
            "            dp[i][3]+=dp[i-1][2]",
            "    print(dp[-1][-1])",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "from copy import copy, deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    # n, m = mi()",
            "    # edge = set()",
            "    # for _ in range(m):",
            "    #     a, b = mi_0()",
            "    #     edge.add((a, b - 1))",
            "    # cnt = 0",
            "    # while edge:",
            "    #     accum = [0] * n",
            "    #     for start, end in edge:",
            "    #         accum[start] += 1",
            "    #         accum[end + 1] -= 1",
            "    #     prev = 0",
            "    #     covered_edge_max = 0    # 現時点で残されているインターバルについて最もかぶっているようなポイントを探す。その被っているインターバルの個数",
            "    #     point_x = 0    # そのポイントの座標",
            "    #     for i in range(n):",
            "    #         accum[i] += prev",
            "    #         prev = accum[i]",
            "    #         if accum[i] > covered_edge_max:",
            "    #             covered_edge_max = accum[i]",
            "    #             point_x = i",
            "    #     # print(accum)",
            "    #     cnt += 1",
            "    #     tmp = copy(edge)",
            "    #     for elm in edge:",
            "    #         start, end = elm",
            "    #         if start <= point_x <= end:",
            "    #             tmp.remove(elm)",
            "    #     edge = tmp",
            "    #     print(edge)",
            "    # print(cnt)",
            "    \"\"\"",
            "    橋を [x_left, x_left + 1) の整数座標区間と考える",
            "    (0-index で) 頂点 i から j へ行けなくする = [i, j) の整数座標区間とかぶるような橋を選択する",
            "    全ての要望 m 個について [i, j) の整数座標区間を用意し、それらと最も被っているような橋を選択 -> 削除 & それにより条件が満たされた整数座標区間も削除...",
            "    を貪欲で行えれば行ける気がしたが嘘貪欲 (半分くらい WA)、TLE",
            "    \"\"\"",
            "    n, m = mi()",
            "    edge = []",
            "    for _ in range(m):",
            "        a, b = mi()",
            "        edge.append((a, b - 1))",
            "    edge.sort(key=itemgetter(0))",
            "    cnt = 0",
            "    # (未カウントの) これまでの整数座標区間をカバーできる区間をメモする",
            "    prev_left = n + 1",
            "    prev_right = n",
            "    for start, end in edge:",
            "        if start > prev_right:",
            "            cnt += 1",
            "            prev_left = start",
            "            prev_right = end",
            "        # 包含 or ずれているパターン",
            "        else:",
            "            prev_left = start",
            "            prev_right = min(prev_right, end)",
            "    # edge さえあれば必ず +1 されて欲しい (最後に区間が余るので)",
            "    if prev_left <= prev_right:",
            "        cnt += 1",
            "    print(cnt)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math, cmath",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import _heapify_max, _heappop_max, _siftdown_max",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    Num = Union[int, float]",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input():  return sys.stdin.readline().rstrip()",
            "    def ii():     return int(input())",
            "    def isp():    return input().split()",
            "    def mi():     return map(int, input().split())",
            "    def mi_0():   return map(lambda x: int(x)-1, input().split())",
            "    def lmi():    return list(map(int, input().split()))",
            "    def lmi_0():  return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():     return list(input())",
            "    def debug(x): print(x, file=sys.stderr)",
            "    # def _heappush_max(h, item): h.append(item); _siftdown_max(h, 0, len(h)-1)",
            "    n, m, d = mi()",
            "    if d != 0:",
            "        print((m - 1) * (ｎ - d) * 2 / (n ** 2))",
            "    else:",
            "        print((m - 1) * (n - d) / (n ** 2))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, k = mi()",
            "    L = lmi()",
            "    L.sort()",
            "    minimum = L[0]",
            "    cnt = 0",
            "    for i in range(n):",
            "        if L[i] == minimum:",
            "            cnt += 1",
            "    print(math.ceil((n - cnt) / (k - 1)))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "N,M=map(int,input().split())",
            "if M==0:",
            "  print(0)",
            "  sys.exit(0)",
            "xyzlist=[]",
            "for i in range(N):",
            "  x,y,z=map(int,input().split())",
            "  xyzlist.append((x,y,z))",
            "#print(xyzlist)",
            "selected_list1=[False]*N",
            "pt_list=[0,0,0]",
            "for _ in range(M):",
            "  max_ind=-1",
            "  max_point=-10**20",
            "  for i in range(N):",
            "    if selected_list1[i]:",
            "      continue",
            "    x,y,z=xyzlist[i]",
            "    point=abs(pt_list[0]+x)-abs(pt_list[0])+abs(pt_list[1]+y)-abs(pt_list[1])+abs(pt_list[2]+z)-abs(pt_list[2])",
            "    if max_point<point:",
            "      max_ind=i",
            "      max_point=point",
            "  #print(max_ind+1,xyzlist[max_ind])",
            "  selected_list1[max_ind]=True",
            "  mx,my,mz=xyzlist[max_ind]",
            "  pt_list=[pt_list[0]+mx,pt_list[1]+my,pt_list[2]+mz]",
            "  #print(pt_list)",
            "#print(selected_list1)",
            "#print(pt_list)",
            "answer1=0",
            "for i in range(3):",
            "  answer1+=abs(pt_list[i])",
            "#print(answer1)",
            "maxabs_ind=[-1,-1,-1]",
            "maxabs=[-1,-1,-1]",
            "for i in range(N):",
            "  x,y,z=xyzlist[i]",
            "  if abs(x)>maxabs[0]:",
            "    maxabs_ind[0]=i",
            "    maxabs[0]=abs(x)",
            "  if abs(y)>maxabs[1]:",
            "    maxabs_ind[1]=i",
            "    maxabs[1]=abs(y)",
            "  if abs(z)>maxabs[2]:",
            "    maxabs_ind[2]=i",
            "    maxabs[2]=abs(z)",
            "#print(maxabs_ind)",
            "selected_list2=[False]*N",
            "selected_list2[maxabs_ind[0]]=True",
            "pt_list=list(xyzlist[maxabs_ind[0]])",
            "#print(pt_list)",
            "for _ in range(M-1):",
            "  max_ind=-1",
            "  max_point=-10**20",
            "  for i in range(N):",
            "    if selected_list2[i]:",
            "      continue",
            "    x,y,z=xyzlist[i]",
            "    point=abs(pt_list[0]+x)-abs(pt_list[0])+abs(pt_list[1]+y)-abs(pt_list[1])+abs(pt_list[2]+z)-abs(pt_list[2])",
            "    if max_point<point:",
            "      max_ind=i",
            "      max_point=point",
            "  #print(max_ind+1,xyzlist[max_ind])",
            "  selected_list2[max_ind]=True",
            "  mx,my,mz=xyzlist[max_ind]",
            "  pt_list=[pt_list[0]+mx,pt_list[1]+my,pt_list[2]+mz]",
            "  #print(pt_list)",
            "#print(selected_list2)",
            "#print(pt_list)",
            "answer2=0",
            "for i in range(3):",
            "  answer2+=abs(pt_list[i])",
            "#print(answer2)",
            "selected_list3=[False]*N",
            "selected_list3[maxabs_ind[1]]=True",
            "pt_list=list(xyzlist[maxabs_ind[1]])",
            "#print(pt_list)",
            "for _ in range(M-1):",
            "  max_ind=-1",
            "  max_point=-10**20",
            "  for i in range(N):",
            "    if selected_list3[i]:",
            "      continue",
            "    x,y,z=xyzlist[i]",
            "    point=abs(pt_list[0]+x)-abs(pt_list[0])+abs(pt_list[1]+y)-abs(pt_list[1])+abs(pt_list[2]+z)-abs(pt_list[2])",
            "    if max_point<point:",
            "      max_ind=i",
            "      max_point=point",
            "  #print(max_ind+1,xyzlist[max_ind])",
            "  selected_list3[max_ind]=True",
            "  mx,my,mz=xyzlist[max_ind]",
            "  pt_list=[pt_list[0]+mx,pt_list[1]+my,pt_list[2]+mz]",
            "  #print(pt_list)",
            "#print(selected_list3)",
            "#print(pt_list)",
            "answer3=0",
            "for i in range(3):",
            "  answer3+=abs(pt_list[i])",
            "#print(answer3)",
            "selected_list4=[False]*N",
            "selected_list4[maxabs_ind[2]]=True",
            "pt_list=list(xyzlist[maxabs_ind[2]])",
            "#print(pt_list)",
            "for _ in range(M-1):",
            "  max_ind=-1",
            "  max_point=-10**20",
            "  for i in range(N):",
            "    if selected_list4[i]:",
            "      continue",
            "    x,y,z=xyzlist[i]",
            "    point=abs(pt_list[0]+x)-abs(pt_list[0])+abs(pt_list[1]+y)-abs(pt_list[1])+abs(pt_list[2]+z)-abs(pt_list[2])",
            "    if max_point<point:",
            "      max_ind=i",
            "      max_point=point",
            "  #print(max_ind+1,xyzlist[max_ind])",
            "  selected_list4[max_ind]=True",
            "  mx,my,mz=xyzlist[max_ind]",
            "  pt_list=[pt_list[0]+mx,pt_list[1]+my,pt_list[2]+mz]",
            "  #print(pt_list)",
            "#print(selected_list3)",
            "#print(pt_list)",
            "answer4=0",
            "for i in range(3):",
            "  answer4+=abs(pt_list[i])",
            "#print(answer4)",
            "#print(answer1,answer2,answer3,answer4)",
            "print(max(answer1,answer2,answer3,answer4))"
        ],
        "label": [
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "# input()",
            "# int(input())",
            "# map(int, input().split())",
            "# list(map(int, input().split()))",
            "# list(map(int, list(input()))) # スペースがない数字リストを読み込み",
            "import math",
            "import fractions",
            "import sys",
            "import bisect",
            "import heapq  # 優先度付きキュー(最小値取り出し)",
            "import collections",
            "from collections import Counter",
            "from collections import deque",
            "import pprint",
            "import itertools",
            "sr = lambda: input()",
            "ir = lambda: int(sr())",
            "lr = lambda: list(map(int, sr().split()))",
            "\"\"\"nを素因数分解\"\"\"",
            "\"\"\"2以上の整数n => [[素因数, 指数], ...]の2次元リスト\"\"\"",
            "def factorization(n):",
            "    arr = []",
            "    temp = n",
            "    if n == 1:",
            "        return arr",
            "    for i in range(2, int(-(-n ** 0.5 // 1)) + 1):",
            "        if temp % i == 0:",
            "            cnt = 0",
            "            while temp % i == 0:",
            "                cnt += 1",
            "                temp //= i",
            "            arr.append([i, cnt])",
            "    if temp != 1:",
            "        arr.append([temp, 1])",
            "    if arr == []:",
            "        arr.append([n, 1])",
            "    return arr",
            "# a^n",
            "def power(a, n, mod):",
            "    x = 1",
            "    while n:",
            "        if n & 1:",
            "            x *= a % mod",
            "        n >>= 1",
            "        a *= a % mod",
            "    return x % mod",
            "# n*(n-1)*...*(l+1)*l",
            "def kaijo(n, l, mod):",
            "    if n == 0:",
            "        return 1",
            "    a = n",
            "    tmp = n - 1",
            "    while (tmp >= l):",
            "        a = a * tmp % mod",
            "        tmp -= 1",
            "    return a",
            "# Union Find",
            "class UnionFind():",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parents = [-1] * n",
            "    def find(self, x):",
            "        if self.parents[x] < 0:",
            "            return x",
            "        else:",
            "            self.parents[x] = self.find(self.parents[x])",
            "            return self.parents[x]",
            "    def union(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "        if x == y:",
            "            return",
            "        if self.parents[x] > self.parents[y]:",
            "            x, y = y, x",
            "        self.parents[x] += self.parents[y]",
            "        self.parents[y] = x",
            "    def size(self, x):",
            "        return -self.parents[self.find(x)]",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "    def members(self, x):",
            "        root = self.find(x)",
            "        return [i for i in range(self.n) if self.find(i) == root]",
            "    def roots(self):",
            "        return [i for i, x in enumerate(self.parents) if x < 0]",
            "    def group_count(self):",
            "        return len(self.roots())",
            "    def all_group_members(self):",
            "        return {r: self.members(r) for r in self.roots()}",
            "    def __str__(self):",
            "        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())",
            "# 約数生成",
            "def make_divisors(n):",
            "    divisors = []",
            "    for i in range(1, int(n**0.5)+1):",
            "        if n % i == 0:",
            "            divisors.append(i)",
            "            if i != n // i:",
            "                divisors.append(n//i)",
            "    divisors.sort()",
            "    return divisors",
            "inf = 10 ** 18",
            "mod = 10 ** 9 + 7",
            "n,m = lr()",
            "xyz = [lr() for i in range(n)]",
            "ans = -inf",
            "for i in range(2**3):",
            "    tmp = [0 for i in range(n)]",
            "    for j in range(3):",
            "        if (i >> j) & 1:",
            "            for k in range(n):",
            "                tmp[k] += xyz[k][j]",
            "        else:",
            "            for k in range(n):",
            "                tmp[k] -= xyz[k][j]",
            "    tmp.sort(reverse=True)",
            "    ans = max(sum(tmp[:m]),ans)",
            "print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def div_n(divisor, num):",
            "        \"\"\"",
            "        >>> div_n(9, 9**2)",
            "        2",
            "        >>> div_n(9, 9**2-1)",
            "        1",
            "        \"\"\"",
            "        candidate = int(math.log(num, divisor))",
            "        if pow(divisor,(candidate+1)) == num:",
            "            return candidate+1",
            "        else:",
            "            return candidate",
            "    n = ii()",
            "    dp = [i for i in range(n+1)]",
            "    for i in range(6, n+1):",
            "        # print(i)",
            "        dp[i] = min(dp[i], dp[i - pow(6, div_n(6,i))] + 1, dp[i - pow(9, div_n(9,i))] + 1)",
            "    # print(dp)",
            "    print(dp[n])",
            "if __name__ == \"__main__\":",
            "    # import doctest",
            "    # doctest.testmod()",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1
        ]
    },
    {
        "content": [
            "# -*- coding: utf-8 -*-",
            "import sys",
            "import math",
            "import os",
            "import itertools",
            "import string",
            "import heapq",
            "import _collections",
            "from collections import Counter",
            "from collections import defaultdict",
            "from functools import lru_cache",
            "import bisect",
            "import re",
            "import queue",
            "class Scanner():",
            "    @staticmethod",
            "    def int():",
            "        return int(sys.stdin.readline().rstrip())",
            "    @staticmethod",
            "    def string():",
            "        return sys.stdin.readline().rstrip()",
            "    @staticmethod",
            "    def map_int():",
            "        return [int(x) for x in Scanner.string().split()]",
            "    @staticmethod",
            "    def string_list(n):",
            "        return [input() for i in range(n)]",
            "    @staticmethod",
            "    def int_list_list(n):",
            "        return [Scanner.map_int() for i in range(n)]",
            "    @staticmethod",
            "    def int_cols_list(n):",
            "        return [int(input()) for i in range(n)]",
            "class Math():",
            "    @staticmethod",
            "    def gcd(a, b):",
            "        if b == 0:",
            "            return a",
            "        return Math.gcd(b, a % b)",
            "    @staticmethod",
            "    def lcm(a, b):",
            "        return (a * b) // Math.gcd(a, b)",
            "    @staticmethod",
            "    def roundUp(a, b):",
            "        return -(-a // b)",
            "    @staticmethod",
            "    def toUpperMultiple(a, x):",
            "        return Math.roundUp(a, x) * x",
            "    @staticmethod",
            "    def toLowerMultiple(a, x):",
            "        return (a // x) * x",
            "    @staticmethod",
            "    def nearPow2(n):",
            "        if n <= 0:",
            "            return 0",
            "        if n & (n - 1) == 0:",
            "            return n",
            "        ret = 1",
            "        while(n > 0):",
            "            ret <<= 1",
            "            n >>= 1",
            "        return ret",
            "    @staticmethod",
            "    def sign(n):",
            "        if n == 0:",
            "            return 0",
            "        if n < 0:",
            "            return -1",
            "        return 1",
            "    @staticmethod",
            "    def isPrime(n):",
            "        if n < 2:",
            "            return False",
            "        if n == 2:",
            "            return True",
            "        if n % 2 == 0:",
            "            return False",
            "        d = int(n ** 0.5) + 1",
            "        for i in range(3, d + 1, 2):",
            "            if n % i == 0:",
            "                return False",
            "        return True",
            "class PriorityQueue:",
            "    def __init__(self, l=[]):",
            "        self.__q = l",
            "        heapq.heapify(self.__q)",
            "        return",
            "    def push(self, n):",
            "        heapq.heappush(self.__q, n)",
            "        return",
            "    def pop(self):",
            "        return heapq.heappop(self.__q)",
            "sys.setrecursionlimit(1000000)",
            "MOD = int(1e09) + 7",
            "INF = int(1e30)",
            "def main():",
            "    # sys.stdin = open(\"Sample.txt\")",
            "    N, C = Scanner.map_int()",
            "    D = Scanner.int_list_list(C)",
            "    colors = Scanner.int_list_list(N)",
            "    for i in range(N):",
            "        for j in range(N):",
            "            colors[i][j] -= 1",
            "    T = [[0 for _ in range(C)] for _ in range(3)]",
            "    for h in range(N):",
            "        for w in range(N):",
            "            T[(h+w) % 3][colors[h][w]] += 1",
            "    ans = INF",
            "    for a in range(C):",
            "        for b in range(C):",
            "            for c in range(C):",
            "                if a == b or a == c or b == c:",
            "                    continue",
            "                now = 0",
            "                for d in range(C):",
            "                    now += T[0][d] * D[d][a]",
            "                    now += T[1][d] * D[d][b]",
            "                    now += T[2][d] * D[d][c]",
            "                ans = min(ans, now)",
            "    print(ans)",
            "    return",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, c = mi()",
            "    color_cost = [lmi() for _ in range(c)]    # color x -> color y (0 to c-1 表現) にかかる擦ろtは color_cost[x][y]",
            "    # color_cost = np.zeros((c, c), dtype=\"int16\")",
            "    # for i in range(c):",
            "    #     tmp = lmi()",
            "    #     for j in range(c):",
            "    #         color_cost[i, j] = tmp[j]",
            "    group = [[] for _ in range(3)]    # 0-index で i+j%3=0, 1, 2 となるやつら",
            "    for i in range(n):",
            "        tmp = lmi_0()    # color を 0 to c-1 表現に",
            "        # print(tmp)",
            "        for j in range(n):",
            "            group[(i+j)%3].append(tmp[j])",
            "    zero, one, two = group",
            "    # O(n^2) で前処理",
            "    zero_cnt, one_cnt, two_cnt = map(lambda x: Counter(x), group)",
            "    ans = 10**15",
            "    # O(30*29*28) (= O(2*10^4)) * O(C)",
            "    for color_zero, color_one, color_two in permutations(range(c), r=3):",
            "        cost = 0",
            "        for col, v in zero_cnt.items():",
            "            cost += v * color_cost[col][color_zero]",
            "        for col, v in one_cnt.items():",
            "            cost += v * color_cost[col][color_one]",
            "        for col, v in two_cnt.items():",
            "            cost += v * color_cost[col][color_two]",
            "        ans = min(ans, cost)",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()",
            "\"\"\"",
            "O(10^7) だけど通らないっぽい <- 勘違い O(30*29*28* n) ではなく O(30*29*28* n * n) なので O(6*10^9)",
            "辞書化の前処理で O(30*29*28 * c) = O(10**5) に",
            "\"\"\""
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "from heapq import heappush,heappop,heapify",
            "from collections import deque,defaultdict,Counter",
            "import itertools",
            "from functools import *",
            "from itertools import permutations,combinations,groupby",
            "import sys",
            "import bisect",
            "import string",
            "import math",
            "import time",
            "import random",
            "def Golf():",
            "    *a,=map(int,open(0))",
            "def S_():",
            "    return input()",
            "def IS():",
            "    return input().split()",
            "def LS():",
            "    return [i for i in input().split()]",
            "def I():",
            "    return int(input())",
            "def MI():",
            "    return map(int,input().split())",
            "def LI():",
            "    return [int(i) for i in input().split()]",
            "def LI_():",
            "    return [int(i)-1 for i in input().split()]",
            "def NI(n):",
            "    return [int(input()) for i in range(n)]",
            "def NI_(n):",
            "    return [int(input())-1 for i in range(n)]",
            "def StoI():",
            "    return [ord(i)-97 for i in input()]",
            "def ItoS(nn):",
            "    return chr(nn+97)",
            "def LtoS(ls):",
            "    return ''.join([chr(i+97) for i in ls])",
            "def GI(V,E,Directed=False,index=0):",
            "    org_inp=[]",
            "    g=[[] for i in range(n)]",
            "    for i in range(E):",
            "        inp=LI()",
            "        org_inp.append(inp)",
            "        if index==0:",
            "            inp[0]-=1",
            "            inp[1]-=1",
            "        if len(inp)==2:",
            "            a,b=inp",
            "            g[a].append(b)",
            "            if not Directed:",
            "                g[b].append(a)",
            "        elif len(inp)==3:",
            "            a,b,c=inp",
            "            aa=(inp[0],inp[2])",
            "            bb=(inp[1],inp[2])",
            "            g[a].append(bb)",
            "            if not Directed:",
            "                g[b].append(aa)",
            "    return g,org_inp",
            "def GGI(h,w,search=None,replacement_of_found='.',mp_def={'#':1,'.':0}):",
            "#h,w,g,sg=GGI(h,w,search=['S','G'],replacement_of_found='.',mp_def={'#':1,'.':0}) # sample usage",
            "    mp=[1]*(w+2)",
            "    found={}",
            "    for i in range(h):",
            "        s=input()",
            "        for char in search:",
            "            if char in s:",
            "                found[char]=((i+1)*(w+2)+s.index(char)+1)",
            "                mp_def[char]=mp_def[replacement_of_found]",
            "        mp+=[1]+[mp_def[j] for j in s]+[1]",
            "    mp+=[1]*(w+2)",
            "    return h+2,w+2,mp,found",
            "def bit_combination(k,n=2):",
            "    rt=[]",
            "    for tb in range(n**k):",
            "        s=[tb//(n**bt)%n for bt in range(k)]",
            "        rt+=[s]",
            "    return rt",
            "def show(*inp,end='\\n'):",
            "    if show_flg:",
            "        print(*inp,end=end)",
            "YN=['YES','NO']",
            "mo=10**9+7",
            "inf=float('inf')",
            "l_alp=string.ascii_lowercase",
            "u_alp=string.ascii_uppercase",
            "ts=time.time()",
            "#sys.setrecursionlimit(10**7)",
            "input=lambda: sys.stdin.readline().rstrip()",
            "def ran_input():",
            "    import random",
            "    n=random.randint(4,16)",
            "    rmin,rmax=1,10",
            "    a=[random.randint(rmin,rmax) for _ in range(n)]",
            "    return n,a",
            "show_flg=False",
            "show_flg=True",
            "ans=inf",
            "n,c=LI()",
            "d=[defaultdict(int)for i in' '*3]",
            "f=[]",
            "for i in range(c):",
            "    f+=[LI()]",
            "for i in range(n):",
            "    x=LI()",
            "    for j in range(n):",
            "        d[(i+j)%3][x[j]-1]+=1",
            "for i in range(c):",
            "    for j in range(c):",
            "        for k in range(c):",
            "            if len(set([i,j,k]))<3:",
            "                continue",
            "            tmp=0",
            "            for col,cnt in d[0].items():",
            "                tmp+=f[col][i]*cnt",
            "            for col,cnt in d[1].items():",
            "                tmp+=f[col][j]*cnt",
            "            for col,cnt in d[2].items():",
            "                tmp+=f[col][k]*cnt",
            "            ans=min(ans,tmp)",
            "print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            1,
            1,
            0,
            0,
            1,
            2,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            1,
            0,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    # inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n = ii()",
            "    L = lmi()",
            "    digit = len(bin(max(L))[2:])",
            "    bin_L = [(bin(elm)[2:]).zfill(digit) for elm in L]",
            "    # print(bin_L)",
            "    counter = [[0] * n for _ in range(digit)]",
            "    for d in range(digit):",
            "        accum = 0",
            "        for i in range(n):",
            "            if bin_L[i][d] == '1':",
            "                accum += 1",
            "            counter[d][i] = accum",
            "    # import pprint",
            "    # pprint.pprint(counter)",
            "    ans = 0",
            "    j = 0",
            "    for i in range(n):",
            "        target_list = [counter[d][i] if bin_L[i][d] == '1' else counter[d][i] + 1 for d in range(digit)]",
            "        while j < n:",
            "            if not all([counter[d][j] <= target_list[d] for d in range(digit)]):",
            "                break",
            "            j += 1",
            "        ans += (j - i)",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    s = input()",
            "    k = ii()",
            "    n = len(s)",
            "    d = defaultdict(list)",
            "    for i in range(n):",
            "        d[s[i]].append(i)",
            "    L = list(set([s[i:j] for i in range(n) for j in range(i+1, min(n+1, i+6))]))",
            "    print(nsmallest(k, L)[-1])    # O(n)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    class UnionFindTree:",
            "        def __init__(self, num_of_elm):",
            "            '''",
            "            0 ... num_of_elem - 1 まで数字で表される (0-index) グループを管理する union find tree を作成する (O(n))",
            "            '''",
            "            self.n = num_of_elm",
            "            self.table = [i for i in range(self.n)]    # table[ind] は ind の親の index を表す。ind == table[ind] の時そのグループの root である。",
            "            self.rank = [0] * self.n    # root となる ind について rank[ind] はその木の深さを表す。それ以外の ind については意味を持たない。",
            "            self.group_size = [1] * self.n    # root となる ind について group_size[ind] はそのグループに属するメンバの個数を表す。それ以外の ind については意味を持たない。",
            "        def _find_set(self, x):",
            "            '''",
            "            x の属するグループ番号を O(α(n)) で求める",
            "            '''",
            "            parent = self.table[x]",
            "            if x == parent:",
            "                return x",
            "            else:",
            "                root = self._find_set(parent)",
            "                # 経路圧縮",
            "                self.table[x] = root",
            "                return root",
            "        def is_same(self, x, y):",
            "            '''",
            "            x と y が同じグループに属するか O(α(n)) で判定する",
            "            '''",
            "            return self._find_set(x) == self._find_set(y)",
            "        def union(self, x, y):",
            "            '''",
            "            x と y の属するグループを O(α(n)) で統合する",
            "            '''",
            "            shallow_root = self._find_set(x)",
            "            deep_root = self._find_set(y)",
            "            if self.rank[shallow_root] > self.rank[deep_root]:",
            "                shallow_root, deep_root = deep_root, shallow_root",
            "            # そもそも同一グループだった時",
            "            if shallow_root == deep_root:",
            "                return False",
            "            # グループが異なるので union",
            "            else:",
            "                self.table[shallow_root] = deep_root",
            "                self.group_size[deep_root] += self.group_size[shallow_root]",
            "                # 深さが等しかったときはつけ加えられた側の rank をインクリメントする",
            "                if self.rank[shallow_root] == self.rank[deep_root]:",
            "                    self.rank[deep_root] += 1",
            "                return True",
            "        def akin_num(self, x):",
            "            '''",
            "            x の属するグループのサイズを O(1) で計算する",
            "            '''",
            "            x_root = self._find_set(x)",
            "            return self.group_size[x_root]",
            "        def print_group_id(self):",
            "            print([self._find_set(x) for x in self.table])",
            "    n, m = mi()",
            "    P = lmi_0()",
            "    uf = UnionFindTree(n)",
            "    for _ in range(m):",
            "        x, y = mi_0()",
            "        uf.union(x, y)",
            "    # 任意に swap 可能な P の index たちをまとめる",
            "    groups = [[] for _ in range(n)]",
            "    for i in range(n):",
            "        groups[uf._find_set(i)].append(i)",
            "    cnt = 0",
            "    for g in groups:",
            "        indices = [P[ind] for ind in g]",
            "        ind_set = set(indices)",
            "        for ind in g:",
            "            if ind in ind_set:",
            "                cnt += 1",
            "    print(cnt)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "from __future__ import print_function",
            "# import numpy as np",
            "# import numpypy as np",
            "import sys",
            "input = sys.stdin.readline",
            "def eprint(*args, **kwargs):",
            "    print(*args, file=sys.stderr, **kwargs)",
            "    return",
            "import math",
            "import string",
            "import fractions",
            "from fractions import Fraction",
            "from fractions import gcd",
            "def lcm(n,m):",
            "    return int(n*m/gcd(n,m))",
            "import re",
            "import array",
            "import copy",
            "import functools",
            "import operator",
            "import collections",
            "import itertools",
            "import bisect",
            "import heapq",
            "from heapq import heappush",
            "from heapq import heappop",
            "from heapq import heappushpop",
            "from heapq import heapify",
            "from heapq import heapreplace",
            "from queue import PriorityQueue as pq",
            "def reduce(p, q):",
            "    common = fractions.gcd(p, q)",
            "    return (p//common , q//common )",
            "# from itertools import accumulate",
            "# from collections import deque",
            "import random",
            "class UnionFind():",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parents = [-1] * n",
            "    def find(self, x):",
            "        if self.parents[x] < 0:",
            "            return x",
            "        else:",
            "            self.parents[x] = self.find(self.parents[x])",
            "            return self.parents[x]",
            "    def union(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "        if x == y:",
            "            return",
            "        if self.parents[x] > self.parents[y]:",
            "            x, y = y, x",
            "        self.parents[x] += self.parents[y]",
            "        self.parents[y] = x",
            "    def size(self, x):",
            "        return -self.parents[self.find(x)]",
            "    def same(self, x, y):       # 2つのデータxとyが同じ木に属するならtrue，そうでなければfalseを返す",
            "        return self.find(x) == self.find(y)",
            "    def members(self, x):",
            "        root = self.find(x)",
            "        return [i for i in range(self.n) if self.find(i) == root]",
            "    def roots(self):",
            "        return [i for i, x in enumerate(self.parents) if x < 0]",
            "    def group_count(self):",
            "        return len(self.roots())",
            "    def all_group_members(self):",
            "        return {r: self.members(r) for r in self.roots()}",
            "    def __str__(self):",
            "        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())",
            "def main():",
            "    n_len_of_seq, m_num_of_pairs = map(int, input().split())",
            "    union_find_forest = UnionFind(n_len_of_seq) # 数列の長さだけの木からなるunion_find森を作る",
            "    p_seq  = list(map(int, input().split()))",
            "    p_seq = [p_seq[i] - 1 for i in range(len(p_seq))]",
            "    # eprint(\"union_find_forest\")",
            "    # eprint(union_find_forest)",
            "    # eprint()",
            "    for index in range(m_num_of_pairs): # loop for each element (pair) in pairs",
            "        x_pair,y_pair = map(int, input().split())",
            "        x_pair-=1",
            "        y_pair-=1",
            "        union_find_forest.union( x_pair , y_pair) # x_pair-1の木とy_pair-1の木を併合する",
            "        # eprint(union_find_forest)",
            "        # eprint()",
            "    cnt=0",
            "    for i in range(n_len_of_seq): # loop for p_seq (sequence of integeres)",
            "        if union_find_forest.same(i, p_seq[i]): # 例えばp_seqのindex==3であるところ(p_seqの4番目)(値は4であって欲しい)について，うにふぁい森の中で4とp_seq[3](の値)が同じ木に属していれば，それらを交換できる(何回でもペア交換は適用できるからね)(連結成分のなかは自由自在に入れ替えられる)．",
            "            # やっぱバグるので全部 0 based index に直しました",
            "            cnt+=1",
            "    print(cnt)",
            "    # p_seq = list(map(int, input().split()))",
            "    # pairs=[[0,0] for _ in range(m_num_of_pairs)]",
            "    # # eprint(pairs)",
            "    # for index_pairs in range(m_num_of_pairs):",
            "    #     pairs[index_pairs][0] , pairs[index_pairs][1] = map(int, input().split())",
            "    #     # eprint(index_pairs)",
            "    #     # eprint(pairs[index_pairs])",
            "    #     # eprint(pairs)",
            "    # eprint(pairs)",
            "    return",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    import math",
            "    class Eratos:",
            "        def __init__(self, num):",
            "            '''",
            "            O(nlglgn) で num までの素数判定テーブルを作る",
            "            >>> e = Eratos(10)",
            "            >>> e.table",
            "            [False, False, True, True, False, True, False, True, False, False, False]",
            "            '''",
            "            assert(num >= 1)",
            "            self.table_max = num",
            "            # self.table[i] は i が素数かどうかを示す (bool)",
            "            self.table = [False if i == 0 or i == 1 else True for i in range(num+1)]",
            "            for i in range(2, int(math.sqrt(num)) + 1):",
            "                if self.table[i]:",
            "                    for j in range(i ** 2, num + 1, i):    # i**2 からスタートすることで定数倍高速化できる",
            "                        self.table[j] = False",
            "        def is_prime(self, num):",
            "            '''",
            "            O(1) で素数判定を行う",
            "            >>> e = Eratos(100)",
            "            >>> [i for i in range(1, 101) if e.is_prime(i)]",
            "            [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]",
            "            '''",
            "            assert(num >= 1)",
            "            if num > self.table_max:",
            "                raise ValueError('Eratos.is_prime(): exceed table_max({}). got {}'.format(self.table_max, num))",
            "            return self.table[num]",
            "        def prime_factorize(self, num):",
            "            '''",
            "            O(√n) で素因数分解を行う",
            "            >>> e = Eratos(10000)",
            "            >>> e.prime_factorize(6552)",
            "            {2: 3, 3: 2, 7: 1, 13: 1}",
            "            '''",
            "            assert(num >= 1)",
            "            if int(math.sqrt(num)) > self.table_max:",
            "                raise ValueError('Eratos.prime_factorize(): exceed prime table size. got {}'.format(num))",
            "            # 素因数分解の結果を記録する辞書",
            "            factorized_dict = dict()",
            "            candidate_prime_numbers = [i for i in range(2, int(math.sqrt(num)) + 1) if self.is_prime(i)]",
            "            # n について、√n 以下の素数で割り続けると最後には 1 or 素数となる",
            "            # 背理法を考えれば自明 (残された数が √n より上の素数の積であると仮定。これは自明に n を超えるため矛盾)",
            "            for p in candidate_prime_numbers:",
            "                if num == 1:    # これ以上調査は無意味",
            "                    break",
            "                if num % p == 0:",
            "                    cnt = 0",
            "                    while num % p == 0:",
            "                        num //= p",
            "                        cnt += 1",
            "                    factorized_dict[p] = cnt",
            "            if num != 1:",
            "                factorized_dict[num] = 1",
            "            return factorized_dict",
            "        def enum_divisor(self, num):",
            "            '''",
            "            O(√n) で約数列挙を行う",
            "            >>> e = Eratos(10000)",
            "            >>> e.enum_divisor(4)",
            "            [1, 2, 4]",
            "            >>> e.enum_divisor(19)",
            "            [1, 19]",
            "            >>> e.enum_divisor(100)",
            "            [1, 2, 4, 5, 10, 20, 25, 50, 100]",
            "            '''",
            "            divisor_small = []",
            "            divisor_large = []",
            "            for i in range(1, int(math.sqrt(num)) + 1):",
            "                if num % i == 0:",
            "                    divisor_small.append(i)",
            "                    if i != num // i:",
            "                        divisor_large.append(num // i)",
            "            divisor_large.reverse()",
            "            return divisor_small + divisor_large",
            "    def satisfy_composite(eratos, p, possible_four_sum):",
            "        # print(f\"{p} {possible_four_sum}\")",
            "        for elm in possible_four_sum:",
            "            if eratos.is_prime(elm + p):",
            "                return False",
            "        return True",
            "    n = ii()",
            "    eratos = Eratos(55555 * 5)",
            "    prime_list = [i for i in range(17, 55556) if eratos.is_prime(i)]",
            "    ans = list(filter(lambda x: x%5==1, prime_list))[:n]",
            "    print(*ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#W, H, x, y, r = map(int, input().split())",
            "def main():",
            "    a, b, c, x, y = map(int, input().split())",
            "    min_sum = 100000 * 5000 + 100000 * 5000 + 200000 * 5000",
            "    if a == c and b == c :",
            "        min_sum = a * x + b * y",
            "    elif a  < c and b < c  or a  == c and b  < c or a < c and b  == c :",
            "        min_sum = a * x + b * y",
            "    elif a  > c and b  > c or a  == c and b  > c or a  > c and b  == c  :",
            "        if x >= y :",
            "            min_sum = y * 2 * c",
            "            if a > c * 2:",
            "                min_sum = min_sum + (x - y) * c * 2",
            "            else:",
            "                min_sum = min_sum + (x - y ) * a",
            "        else:",
            "            min_sum = x * 2 * c",
            "            if b > c * 2:",
            "                min_sum = min_sum + (y - x) * c * 2",
            "            else:",
            "                min_sum = min_sum + (y - x ) * b",
            "    elif a < c and b > c:",
            "        if c - a > b - c : #むだ",
            "            min_sum = a * x + b * y",
            "        else:",
            "            if x >= y :",
            "                min_sum = (x-y)* a + y * c * 2",
            "            else:",
            "                min_sum = (y-x)* b + x * c * 2",
            "    elif a > c and b < c:",
            "        if c - b > a - c   : #むだ",
            "            min_sum = a * x + b * y",
            "        else:",
            "            if x >= y :",
            "                min_sum = (x-y)* a + y * c * 2",
            "            else:",
            "                min_sum = (y-x)* b + x * c * 2",
            "    else:",
            "        for i in range(0, x+1):",
            "            for j in range(0, y+1):",
            "                if min_sum > a * i + b * j + max(x-i, y-j) * c * 2:",
            "                    min_sum =a * i + b * j + max(x-i, y-j) * c * 2",
            "    print(min_sum)",
            "main()",
            "# if a >= c and b <= c :",
            "#     sum = x * c * 2",
            "#     if x <= y :",
            "#         sum = sum + ( y - x ) * b",
            "# else:",
            "#     sum = y * c * 2",
            "#     if x >= y :",
            "#         sum = sum + ( x - y ) * a",
            "# if b > c * 2 :",
            "    #     b_price = c",
            "    #",
            "    # input_array_list = []",
            "    #",
            "    # while True:",
            "    #     input_array = input().split()",
            "    #     if input_array[0] == \"0\" and input_array[1] == \"0\":",
            "    #         break",
            "    #     else:",
            "    #         input_array_list.append(input_array)",
            "    #",
            "    # for item in input_array_list:",
            "    #     n = int(item[0])",
            "    #     k_sum = int(item[1])",
            "    #",
            "    #     count = 0",
            "    #     for i in range(1,n + 1- 2):",
            "    #         for j in range(i+1, n + 1 - 1):",
            "    #             for k in range (j+1, n+ 1):",
            "    #                 if i + j + k == k_sum :",
            "    #                     count = count + 1",
            "    #     print(count)",
            "    #",
            "    # for item in input_array_list:",
            "    #     if item[1] == \"+\":",
            "    #         print(str(int(item[0])+int(item[2])))",
            "    #     elif item[1] ==\"-\":",
            "    #         print(str(int(item[0])-int(item[2])))",
            "    #     elif item[1] == \"/\":",
            "    #         print(str(int(item[0])//int(item[2])))",
            "    #     elif item[1] == \"*\":",
            "    #         print(str(int(item[0])*int(item[2])))",
            "    #",
            "# import sympy as sp",
            "# input_list = []",
            "# a,b,c = map(int, input().split())",
            "# divisors = sp.divisors(c)",
            "#",
            "# count = 0",
            "#",
            "# for divisor in divisors:",
            "#     if a <= divisor and divisor <= b:",
            "#         count = count + 1",
            "# print(count)",
            "#",
            "# while True:",
            "#     pair_str = input().split()",
            "#     pair_int = [int(s) for s in pair_str]",
            "#     if pair_int[0] == 0 and pair_int[1] == 0 :",
            "#         break",
            "#     else:",
            "#         input_list.append(pair_int)",
            "#",
            "# for pair_int in input_list:",
            "#     if pair_int[0] <= pair_int[1]:",
            "#         print(\"{} {}\".format(pair_int[0], pair_int[1]))",
            "#     else:",
            "#         print(\"{} {}\".format(pair_int[1], pair_int[0]))",
            "#for i in range(10000):",
            "#    print(\"Hello World\")",
            "#a = input().split()",
            "#a_int = [int(s) for s in a]",
            "#a_sorted = sorted(a_int)",
            "#print(' '.join(map(str, a_sorted)))"
        ],
        "label": [
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, c = mi()",
            "    place = []",
            "    inv_place = []",
            "    value = []",
            "    for _ in range(n):",
            "        x, v = mi()",
            "        place.append(x)",
            "        inv_place.append(c - x)",
            "        value.append(v)",
            "    accum_val = list(accumulate(value))",
            "    counter_accum_val = list(reversed(list(accumulate(reversed(value)))))",
            "    clockwise = [[] for _ in range(n)]",
            "    counter_clockwise = [[] for _ in range(n)]",
            "    for i in range(n):",
            "        clockwise[i] = [accum_val[i] - place[i], accum_val[i] - 2 * place[i]]",
            "        counter_clockwise[i]= [counter_accum_val[i] - inv_place[i], counter_accum_val[i] - 2 * inv_place[i]]",
            "    # import pprint",
            "    # print(clockwise)",
            "    # print(counter_clockwise)",
            "    # print('')",
            "    # 時計回りのみ -> clockwise の [0] の max",
            "    # 反時計回りのみ -> counter_clockwise の [0] の max",
            "    max_memo = - inf",
            "    max_memo_clock_0 = [0] * n",
            "    for i in range(n):",
            "        max_memo = max(max_memo, clockwise[i][0])",
            "        max_memo_clock_0[i] = max_memo",
            "    max_memo = - inf",
            "    max_memo_counter_clock_0 = [0] * n",
            "    for i in range(n-1, -1, -1):",
            "        max_memo = max(max_memo, counter_clockwise[i][0])",
            "        max_memo_counter_clock_0[i] = max_memo",
            "    # print(max_memo_clock_0)",
            "    # print(max_memo_counter_clock_0)",
            "    ans = max(max(max_memo_clock_0), max(max_memo_counter_clock_0), 0)",
            "    # print(ans)",
            "    for i in range(n-1, 0, -1):",
            "        ans = max(ans, counter_clockwise[i][1] + max_memo_clock_0[i-1])",
            "    for i in range(n-1):",
            "        ans = max(ans, clockwise[i][1] + max_memo_counter_clock_0[i+1])",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "###############################################################################",
            "from sys import stdout",
            "from bisect import bisect_left as binl",
            "from copy import copy, deepcopy",
            "from collections import defaultdict",
            "mod = 1",
            "def intin():",
            "    input_tuple = input().split()",
            "    if len(input_tuple) <= 1:",
            "        return int(input_tuple[0])",
            "    return tuple(map(int, input_tuple))",
            "def intina():",
            "    return [int(i) for i in input().split()]",
            "def intinl(count):",
            "    return [intin() for _ in range(count)]",
            "def modadd(x, y):",
            "    global mod",
            "    return (x + y) % mod",
            "def modmlt(x, y):",
            "    global mod",
            "    return (x * y) % mod",
            "def lcm(x, y):",
            "    while y != 0:",
            "        z = x % y",
            "        x = y",
            "        y = z",
            "    return x",
            "def combination(x, y):",
            "    assert(x >= y)",
            "    if y > x // 2:",
            "        y = x - y",
            "    ret = 1",
            "    for i in range(0, y):",
            "        j = x - i",
            "        i = i + 1",
            "        ret = ret * j",
            "        ret = ret // i",
            "    return ret",
            "def get_divisors(x):",
            "    retlist = []",
            "    for i in range(1, int(x**0.5) + 3):",
            "        if x % i == 0:",
            "            retlist.append(i)",
            "            retlist.append(x // i)",
            "    return retlist",
            "def get_factors(x):",
            "    retlist = []",
            "    for i in range(2, int(x**0.5) + 3):",
            "        while x % i == 0:",
            "            retlist.append(i)",
            "            x = x // i",
            "    retlist.append(x)",
            "    return retlist",
            "def make_linklist(xylist):",
            "    linklist = {}",
            "    for a, b in xylist:",
            "        linklist.setdefault(a, [])",
            "        linklist.setdefault(b, [])",
            "        linklist[a].append(b)",
            "        linklist[b].append(a)",
            "    return linklist",
            "def calc_longest_distance(linklist, v=1):",
            "    distance_list = {}",
            "    distance_count = 0",
            "    distance = 0",
            "    vlist_previous = []",
            "    vlist = [v]",
            "    nodecount = len(linklist)",
            "    while distance_count < nodecount:",
            "        vlist_next = []",
            "        for v in vlist:",
            "            distance_list[v] = distance",
            "            distance_count += 1",
            "            vlist_next.extend(linklist[v])",
            "        distance += 1",
            "        vlist_to_del = vlist_previous",
            "        vlist_previous = vlist",
            "        vlist = list(set(vlist_next) - set(vlist_to_del))",
            "    max_distance = -1",
            "    max_v = None",
            "    for v, distance in distance_list.items():",
            "        if distance > max_distance:",
            "            max_distance = distance",
            "            max_v = v",
            "    return (max_distance, max_v)",
            "def calc_tree_diameter(linklist, v=1):",
            "    _, u = calc_longest_distance(linklist, v)",
            "    distance, _ = calc_longest_distance(linklist, u)",
            "    return distance",
            "class UnionFind:",
            "    def __init__(self, n):",
            "        self.parent = [i for i in range(n)]",
            "    def root(self, i):",
            "        if self.parent[i] == i:",
            "            return i",
            "        self.parent[i] = self.root(self.parent[i])",
            "        return self.parent[i]",
            "    def unite(self, i, j):",
            "        rooti = self.root(i)",
            "        rootj = self.root(j)",
            "        if rooti == rootj:",
            "            return",
            "        if rooti < rootj:",
            "            self.parent[rootj] = rooti",
            "        else:",
            "            self.parent[rooti] = rootj",
            "    def same(self, i, j):",
            "        return self.root(i) == self.root(j)",
            "###############################################################################",
            "def main():",
            "    n, c = intin()",
            "    xvlist = [(0, 0)]",
            "    xvlist.extend(intinl(n))",
            "    xvlist.append((c, 0))",
            "    leftrt = {-1: 0}",
            "    leftmax = {-1: 0}",
            "    rightrt = {-1: 0}",
            "    rightmax = {-1: 0}",
            "    leftxsum = 0",
            "    leftvsum = 0",
            "    rightxsum = 0",
            "    rightvsum = 0",
            "    for i in range(n + 1):",
            "        leftx, leftv = xvlist[i]",
            "        rightx, rightv = xvlist[n-i+1]",
            "        leftxsum = leftx",
            "        leftvsum += leftv",
            "        rightxsum = c - rightx",
            "        rightvsum += rightv",
            "        leftrt[i] = max(leftrt[i-1], leftvsum - leftxsum * 2)",
            "        leftmax[i] = max(leftmax[i-1], leftvsum - leftxsum)",
            "        rightrt[i] = max(rightrt[i-1], rightvsum - rightxsum * 2)",
            "        rightmax[i] = max(rightrt[i-1], rightvsum - rightxsum)",
            "    ans = 0",
            "    for i in range(n + 1):",
            "        ans = max(ans, leftrt[i] + rightmax[n-i])",
            "        ans = max(ans, rightrt[i] + leftmax[n-i])",
            "    print(ans)",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# -*- coding: utf-8 -*-",
            "import bisect",
            "import heapq",
            "import math",
            "import random",
            "from collections import Counter, defaultdict, deque",
            "from decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal",
            "from fractions import Fraction",
            "from functools import lru_cache, reduce",
            "from itertools import combinations, combinations_with_replacement, product, permutations, accumulate",
            "from operator import add, mul, sub, itemgetter, attrgetter",
            "import sys",
            "# sys.setrecursionlimit(10**6)",
            "# readline = sys.stdin.buffer.readline",
            "readline = sys.stdin.readline",
            "INF = 2**62-1",
            "def read_int():",
            "    return int(readline())",
            "def read_int_n():",
            "    return list(map(int, readline().split()))",
            "def read_float():",
            "    return float(readline())",
            "def read_float_n():",
            "    return list(map(float, readline().split()))",
            "def read_str():",
            "    return readline().strip()",
            "def read_str_n():",
            "    return readline().strip().split()",
            "def ep(*args):",
            "    print(*args, file=sys.stderr)",
            "def mt(f):",
            "    import time",
            "    def wrap(*args, **kwargs):",
            "        s = time.perf_counter()",
            "        ret = f(*args, **kwargs)",
            "        e = time.perf_counter()",
            "        ep(e - s, 'sec')",
            "        return ret",
            "    return wrap",
            "class SegmentTree:",
            "    def __init__(self, array, operator, identity_element):",
            "        _len = len(array)",
            "        self.__op = operator",
            "        self.__size = 1 << (_len - 1).bit_length()",
            "        self.__tree = [identity_element] * self.__size + \\",
            "            array + [identity_element] * (self.__size - _len)",
            "        self.__ie = identity_element",
            "        for i in range(self.__size - 1, 0, -1):",
            "            self.__tree[i] = operator(",
            "                self.__tree[i * 2], self.__tree[i * 2 + 1])",
            "    def update(self, i, v):",
            "        i += self.__size",
            "        self.__tree[i] = v",
            "        while i:",
            "            i //= 2",
            "            self.__tree[i] = self.__op(",
            "                self.__tree[i * 2], self.__tree[i * 2 + 1])",
            "    def query(self, l, r):",
            "        \"\"\"[l, r)",
            "        \"\"\"",
            "        l += self.__size",
            "        r += self.__size",
            "        ret = self.__ie",
            "        while l < r:",
            "            if l & 1:",
            "                ret = self.__op(ret, self.__tree[l])",
            "                l += 1",
            "            if r & 1:",
            "                r -= 1",
            "                ret = self.__op(ret, self.__tree[r])",
            "            l //= 2",
            "            r //= 2",
            "        return ret",
            "    def __getitem__(self, key):",
            "        return self.__tree[key + self.__size]",
            "@mt",
            "def slv(N, C, XV):",
            "    XV.sort()",
            "    ans = 0",
            "    sf = [(0, 0)]",
            "    stf = SegmentTree([-INF]*N, max, -INF)",
            "    c = 0",
            "    for i, (x, v) in enumerate(XV):",
            "        v = sf[-1][0]+v-(x-c)",
            "        sf.append((v, x))",
            "        stf.update(i, v)",
            "        c = x",
            "    str_ = SegmentTree([-INF]*N, max, -INF)",
            "    sr = [(0, 0)]",
            "    c = 0",
            "    for i, (x, v) in enumerate(reversed(XV)):",
            "        x = C - x",
            "        v = sr[-1][0]+v-(x-c)",
            "        sr.append((v, x))",
            "        str_.update(i, v)",
            "        c = x",
            "    ans = 0",
            "    for i in range(N+1):",
            "        t = sf[i][0] + max(0, str_.query(0, N-i) - sf[i][1])",
            "        ans = max(ans, t)",
            "        t = sr[i][0] + max(0, stf.query(0, N-i) - sr[i][1])",
            "        ans = max(ans, t)",
            "    return ans",
            "def main():",
            "    N, C = read_int_n()",
            "    XV = [read_int_n() for _ in range(N)]",
            "    print(slv(N, C, XV))",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n = ii()",
            "    L = lmi()",
            "    sorted_l = sorted(L)",
            "    left_pivot = sorted_l[n//2 - 1]",
            "    right_pivot = sorted_l[n//2]",
            "    if left_pivot == right_pivot:",
            "        for _ in range(n):",
            "            print(left_pivot)",
            "    else:",
            "        for elm in L:",
            "            print(right_pivot) if elm <= left_pivot else print(left_pivot)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n = ii()",
            "    L = lmi()",
            "    L.sort()",
            "    a = L[-1]",
            "    b = -1",
            "    min_diff_between_half_a = inf",
            "    for elm in L:",
            "        if min_diff_between_half_a > abs(elm - a/2):",
            "            min_diff_between_half_a = abs(elm - a/2)",
            "            b = elm",
            "    print(\"{} {}\".format(a, b))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    a, b, k = mi()",
            "    for i in range(a, min(b, a+k)):",
            "        print(i)",
            "    for j in range(max(min(b, a+k), b-k+1), b+1):",
            "        print(j)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n = ii()",
            "    d, x = mi()",
            "    L = [ii() for _ in range(n)]",
            "    cnt = x",
            "    for elm in L:",
            "        cnt += 1 + (d - 1) // elm",
            "    print(cnt)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n = ii()",
            "    L = lmi()",
            "    L = [0] + L + [0]",
            "    default = sum([abs(L[i] - L[i-1]) for i in range(1, n+2)])",
            "    for i in range(1, n+1):",
            "        if L[i-1] <= L[i] <= L[i+1] or L[i-1] >= L[i] >= L[i+1]:",
            "            print(default)",
            "        elif L[i] >= L[i-1] and L[i] >= L[i+1]:",
            "            print(default - 2 * (L[i] - max(L[i-1], L[i+1])))",
            "        else:",
            "            print(default - 2 *  (min(L[i+1], L[i-1]) - L[i]))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def increase_symbol(seq, sym, num):",
            "        for i in range(1, 48, 2):",
            "            for j in range(1, 98, 2):",
            "                if num > 0:",
            "                    seq[i][j] = sym",
            "                    num -= 1",
            "                else:",
            "                    return",
            "    a, b = mi()",
            "    upper = [['#'] * 99 for _ in range(49)]",
            "    lower = [['.'] * 99 for _ in range(49)]",
            "    increase_symbol(upper, '.', a - 1)",
            "    increase_symbol(lower, '#', b - 1)",
            "    grid = upper + lower",
            "    print(\"98 99\")",
            "    for line in grid:",
            "        print(''.join(line))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "###############################################################################",
            "from sys import stdout",
            "from bisect import bisect_left as binl",
            "from copy import copy, deepcopy",
            "from collections import defaultdict",
            "mod = 1",
            "def intin():",
            "    input_tuple = input().split()",
            "    if len(input_tuple) <= 1:",
            "        return int(input_tuple[0])",
            "    return tuple(map(int, input_tuple))",
            "def intina():",
            "    return [int(i) for i in input().split()]",
            "def intinl(count):",
            "    return [intin() for _ in range(count)]",
            "def modadd(x, y):",
            "    global mod",
            "    return (x + y) % mod",
            "def modmlt(x, y):",
            "    global mod",
            "    return (x * y) % mod",
            "def lcm(x, y):",
            "    while y != 0:",
            "        z = x % y",
            "        x = y",
            "        y = z",
            "    return x",
            "def combination(x, y):",
            "    assert(x >= y)",
            "    if y > x // 2:",
            "        y = x - y",
            "    ret = 1",
            "    for i in range(0, y):",
            "        j = x - i",
            "        i = i + 1",
            "        ret = ret * j",
            "        ret = ret // i",
            "    return ret",
            "def get_divisors(x):",
            "    retlist = []",
            "    for i in range(1, int(x**0.5) + 3):",
            "        if x % i == 0:",
            "            retlist.append(i)",
            "            retlist.append(x // i)",
            "    return retlist",
            "def get_factors(x):",
            "    retlist = []",
            "    for i in range(2, int(x**0.5) + 3):",
            "        while x % i == 0:",
            "            retlist.append(i)",
            "            x = x // i",
            "    retlist.append(x)",
            "    return retlist",
            "def make_linklist(xylist):",
            "    linklist = {}",
            "    for a, b in xylist:",
            "        linklist.setdefault(a, [])",
            "        linklist.setdefault(b, [])",
            "        linklist[a].append(b)",
            "        linklist[b].append(a)",
            "    return linklist",
            "def calc_longest_distance(linklist, v=1):",
            "    distance_list = {}",
            "    distance_count = 0",
            "    distance = 0",
            "    vlist_previous = []",
            "    vlist = [v]",
            "    nodecount = len(linklist)",
            "    while distance_count < nodecount:",
            "        vlist_next = []",
            "        for v in vlist:",
            "            distance_list[v] = distance",
            "            distance_count += 1",
            "            vlist_next.extend(linklist[v])",
            "        distance += 1",
            "        vlist_to_del = vlist_previous",
            "        vlist_previous = vlist",
            "        vlist = list(set(vlist_next) - set(vlist_to_del))",
            "    max_distance = -1",
            "    max_v = None",
            "    for v, distance in distance_list.items():",
            "        if distance > max_distance:",
            "            max_distance = distance",
            "            max_v = v",
            "    return (max_distance, max_v)",
            "def calc_tree_diameter(linklist, v=1):",
            "    _, u = calc_longest_distance(linklist, v)",
            "    distance, _ = calc_longest_distance(linklist, u)",
            "    return distance",
            "class UnionFind:",
            "    def __init__(self, n):",
            "        self.parent = [i for i in range(n)]",
            "    def root(self, i):",
            "        if self.parent[i] == i:",
            "            return i",
            "        self.parent[i] = self.root(self.parent[i])",
            "        return self.parent[i]",
            "    def unite(self, i, j):",
            "        rooti = self.root(i)",
            "        rootj = self.root(j)",
            "        if rooti == rootj:",
            "            return",
            "        if rooti < rootj:",
            "            self.parent[rootj] = rooti",
            "        else:",
            "            self.parent[rooti] = rootj",
            "    def same(self, i, j):",
            "        return self.root(i) == self.root(j)",
            "###############################################################################",
            "def main():",
            "    a, b = intin()",
            "    if a < b:",
            "        dot = '#'",
            "        wide = '.'",
            "    else:",
            "        dot = '.'",
            "        wide = '#'",
            "    print('38 100')",
            "    print(dot * 100)",
            "    print(('%s%s' % (dot, wide)) * 50)",
            "    mincount = min(a, b) - 1",
            "    for i in range(12):",
            "        lline = ''",
            "        for j in range(50):",
            "            if mincount == 0:",
            "                lline += '%s%s' % (wide, wide)",
            "            elif i & 1:",
            "                lline += '%s%s' % (dot, wide)",
            "                mincount -= 1",
            "            else:",
            "                lline += '%s%s' % (wide, dot)",
            "                mincount -= 1",
            "        print(lline)",
            "    dotcount = abs(a - b)",
            "    for i in range(12):",
            "        print(wide * 100)",
            "        lline = ''",
            "        for j in range(50):",
            "            if dotcount == 0:",
            "                lline += '%s%s' % (wide, wide)",
            "            else:",
            "                lline += '%s%s' % (wide, dot)",
            "                dotcount -= 1",
            "        print(lline)",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys, re",
            "from collections import deque, defaultdict, Counter",
            "from math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians",
            "from itertools import accumulate, permutations, combinations, product, groupby, combinations_with_replacement",
            "from operator import itemgetter, mul",
            "from copy import deepcopy",
            "from string import ascii_lowercase, ascii_uppercase, digits",
            "from bisect import bisect, bisect_left",
            "from fractions import gcd",
            "from heapq import heappush, heappop",
            "from functools import reduce",
            "def input(): return sys.stdin.readline().strip()",
            "def INT(): return int(input())",
            "def MAP(): return map(int, input().split())",
            "def LIST(): return list(map(int, input().split()))",
            "def ZIP(n): return zip(*(MAP() for _ in range(n)))",
            "sys.setrecursionlimit(10 ** 9)",
            "INF = float('inf')",
            "mod = 10 ** 9 + 7",
            "from collections import deque",
            "class HopcroftKarp:",
            "    def __init__(self, N0, N1):",
            "        self.N0 = N0",
            "        self.N1 = N1",
            "        self.N = N = 2+N0+N1",
            "        self.G = [[] for i in range(N)]",
            "        for i in range(N0):",
            "            forward = [2+i, 1, None]",
            "            forward[2] = backward = [0, 0, forward]",
            "            self.G[0].append(forward)",
            "            self.G[2+i].append(backward)",
            "        self.backwards = bs = []",
            "        for i in range(N1):",
            "            forward = [1, 1, None]",
            "            forward[2] = backward = [2+N0+i, 0, forward]",
            "            bs.append(backward)",
            "            self.G[2+N0+i].append(forward)",
            "            self.G[1].append(backward)",
            "    def add_edge(self, fr, to):",
            "        #assert 0 <= fr < self.N0",
            "        #assert 0 <= to < self.N1",
            "        v0 = 2 + fr",
            "        v1 = 2 + self.N0 + to",
            "        forward = [v1, 1, None]",
            "        forward[2] = backward = [v0, 0, forward]",
            "        self.G[v0].append(forward)",
            "        self.G[v1].append(backward)",
            "    def bfs(self):",
            "        G = self.G",
            "        level = [None]*self.N",
            "        deq = deque([0])",
            "        level[0] = 0",
            "        while deq:",
            "            v = deq.popleft()",
            "            lv = level[v] + 1",
            "            for w, cap, _ in G[v]:",
            "                if cap and level[w] is None:",
            "                    level[w] = lv",
            "                    deq.append(w)",
            "        self.level = level",
            "        return level[1] is not None",
            "    def dfs(self, v, t):",
            "        if v == t:",
            "            return 1",
            "        level = self.level",
            "        for e in self.it[v]:",
            "            w, cap, rev = e",
            "            if cap and level[v] < level[w] and self.dfs(w, t):",
            "                e[1] = 0",
            "                rev[1] = 1",
            "                return 1",
            "        return 0",
            "    def flow(self):",
            "        flow = 0",
            "        G = self.G",
            "        bfs = self.bfs; dfs = self.dfs",
            "        while bfs():",
            "            *self.it, = map(iter, G)",
            "            while dfs(0, 1):",
            "                flow += 1",
            "        return flow",
            "    def matching(self):",
            "        return [cap for _, cap, _ in self.backwards]",
            "N = INT()",
            "hk = HopcroftKarp(N, N)",
            "ab = [LIST() for _ in range(N)]",
            "cd = [LIST() for _ in range(N)]",
            "for i, (a, b) in enumerate(ab):",
            "    for j, (c, d) in enumerate(cd):",
            "        if a < c and b < d:",
            "            hk.add_edge(i, j)",
            "print(hk.flow())"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            2,
            2
        ]
    },
    {
        "content": [
            "# https://atcoder.jp/contests/abc091/tasks/arc092_a",
            "import sys",
            "input = sys.stdin.readline",
            "from collections import deque",
            "class MaxFlow:",
            "    class Edge:",
            "        def __init__(self, to, cap, rev):",
            "            \"\"\"",
            "            :param to:  終点ノード",
            "            :param cap: 残された容量",
            "            :param rev: 遂になる逆向きのエッジ（ノード to の rev 番目のエッジ）",
            "            \"\"\"",
            "            self.to, self.cap, self.rev = to, cap, rev",
            "    def __init__(self, node_size, inf):",
            "        self._node = node_size",
            "        self._inf = inf",
            "        self._level = [-1] * self._node",
            "        self._iter = [0] * self._node",
            "        self._graph = [[] for _ in range(self._node)]",
            "    def add_edge(self, from_, to, cap):",
            "        self._graph[from_].append(self.Edge(to, cap, len(self._graph[to])))",
            "        self._graph[to].append(self.Edge(from_, 0, len(self._graph[from_]) - 1))",
            "    def bfs(self, start):",
            "        \"\"\"",
            "        _level: 未訪問の場合は -1, 訪問済みの場合は start からの最短距離（正容量のエッジのみを使った経路の中での）",
            "        \"\"\"",
            "        self._level = [-1] * self._node",
            "        next_set = deque()",
            "        self._level[start] = 0",
            "        next_set.append(start)",
            "        while next_set:",
            "            cur_vertex = next_set.popleft()",
            "            for edge in self._graph[cur_vertex]:",
            "                if self._level[edge.to] < 0 < edge.cap:",
            "                    self._level[edge.to] = self._level[cur_vertex] + 1",
            "                    next_set.append(edge.to)",
            "    def dfs(self, cur_vertex, end_vertex, flow):",
            "        if cur_vertex == end_vertex:",
            "            return flow",
            "        while self._iter[cur_vertex] < len(self._graph[cur_vertex]):",
            "            edge = self._graph[cur_vertex][self._iter[cur_vertex]]",
            "            if edge.cap > 0 and self._level[cur_vertex] < self._level[edge.to]:",
            "                flowed = self.dfs(edge.to, end_vertex, min(flow, edge.cap))",
            "                if flowed > 0:",
            "                    edge.cap -= flowed",
            "                    self._graph[edge.to][edge.rev].cap += flowed",
            "                    return flowed",
            "            self._iter[cur_vertex] += 1",
            "        return 0",
            "    def solve(self, source, sink):",
            "        flow = 0",
            "        while True:",
            "            self.bfs(source)",
            "            if self._level[sink] < 0:",
            "                \"\"\" sinkへの最短距離が -1 ⇒ sink にたどり着けない ⇒ 増加路が存在しないため探索終了\"\"\"",
            "                return flow",
            "            self._iter = [0] * self._node",
            "            while True:",
            "                f = self.dfs(source, sink, self._inf)",
            "                if f == 0:",
            "                    break",
            "                flow += f",
            "class Dinic:",
            "    def __init__(self, len_X, len_Y):",
            "        \"\"\"",
            "        soursの位置 = 0",
            "        sinkの位置  = len_X + len_Y + 1",
            "        capacity   = 1",
            "        の最大フロー問題",
            "        \"\"\"",
            "        self.len_X, self.len_Y = len_X, len_Y",
            "        self.mf = MaxFlow(self.len_X + self.len_Y + 2, min(self.len_X, self.len_Y))",
            "        for i in range(self.len_X):",
            "            \"\"\" sours から部分集合Xへの各点に capacity=1 の流れを作る \"\"\"",
            "            self.mf.add_edge(0, i + 1, 1)",
            "        for i in range(self.len_Y):",
            "            \"\"\" 部分集合Yへの各点からsinkへの capacity=1 の流れを作る \"\"\"",
            "            self.mf.add_edge(self.len_X + i + 1, self.len_X + self.len_Y + 1, 1)",
            "    def add_edge(self, from_, to):",
            "        \"\"\"",
            "        :param from_: 部分集合Xの頂点　（1,...,len_X）",
            "        :param to:    部分集合Yの頂点　（len_X + 1,...,len_X + 1 + len_Y）",
            "        \"\"\"",
            "        self.mf.add_edge(from_ + 1, to + self.len_X + 1, 1)",
            "    def solve(self):",
            "        return self.mf.solve(0, self.len_X + self.len_Y + 1)",
            "#####################################################################################",
            "N = int(input())",
            "X = []",
            "Y = []",
            "for i in range(N):",
            "    X.append([int(i) for i in input().split()])",
            "for i in range(N):",
            "    Y.append([int(i) for i in input().split()])",
            "dinic = Dinic(len(X), len(Y))",
            "for i in range(len(X)):",
            "    for j in range(N):",
            "        if X[i][0] < Y[j][0] and X[i][1] < Y[j][1]:",
            "            dinic.add_edge(i,j)",
            "print(dinic.solve())"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "#####################################################################################################",
            "##### 最大二部マッチング問題",
            "#####################################################################################################",
            "\"\"\"",
            "参考（コード）",
            "https://kopricky.github.io/code/For_Python/bipartite_matching.html",
            "参考（最大フロー問題）",
            "http://nw.tsuda.ac.jp/class/algoC/c9.html",
            "https://ikatakos.com/pot/programming_algorithm/graph_theory/maximum_flow",
            "http://vartkw.hatenablog.com/entry/2016/12/02/002703",
            "参考（計算量）",
            "https://ta1sa.hatenablog.com/entry/2020/04/13/123802",
            "https://cp-algorithms.com/graph/dinic.html",
            "ベンチマーク",
            "http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_7_A&lang=ja",
            "https://atcoder.jp/contests/abc091/submissions/14937663",
            "\"\"\"",
            "import sys",
            "input = sys.stdin.readline",
            "from collections import deque",
            "class MaxFlow:",
            "    class Edge:",
            "        def __init__(self, to, cap, rev):",
            "            \"\"\"",
            "            :param to:  終点ノード",
            "            :param cap: 残された容量",
            "            :param rev: 遂になる逆向きのエッジ（ノード to の rev 番目のエッジ）",
            "            \"\"\"",
            "            self.to, self.cap, self.rev = to, cap, rev",
            "    def __init__(self, node_size, inf):",
            "        self._node = node_size",
            "        self._inf = inf",
            "        self._level = [-1] * self._node",
            "        self._iter = [0] * self._node",
            "        self._graph = [[] for _ in range(self._node)]",
            "    def add_edge(self, from_, to, cap):",
            "        self._graph[from_].append(self.Edge(to, cap, len(self._graph[to])))",
            "        self._graph[to].append(self.Edge(from_, 0, len(self._graph[from_]) - 1))",
            "    def bfs(self, start):",
            "        \"\"\"",
            "        概要: 流れる方向を大雑把に決める（※ ループ２回目以降は逆流辺の cap が正になるので逆流も可能になり、流れる方向に選択肢が出てくる。）",
            "        入力: cap",
            "        出力: level[v]            (※ start から v への（cap > 0 の辺のみを使った場合の）最短距離。経路が無い場合は -1)",
            "        備考1: 最初は適当に見つかった最短経路から始めるが、ループが進むにつれて徐々に条件のきつい cap が入力として与えられるようになり、",
            "              最終的に遠回りの経路も全て考慮した結果が得られる。",
            "        備考2: level[sink]（最短経路長）が単調増加であるため、ステップ数 O(V) で探索が終了する。",
            "        \"\"\"",
            "        self._level = [-1] * self._node",
            "        next_set = deque()",
            "        self._level[start] = 0",
            "        next_set.append(start)",
            "        while next_set:",
            "            current = next_set.popleft()",
            "            for edge in self._graph[current]:",
            "                \"\"\" current vertex から進める候補が _graph[current] に格納されている。ここでは逆流辺（edge.rev）は考慮しない。\"\"\"",
            "                if self._level[edge.to] < 0 < edge.cap:",
            "                    self._level[edge.to] = self._level[current] + 1",
            "                    next_set.append(edge.to)",
            "    def dfs(self, start, end, flow):",
            "        \"\"\"",
            "        概要: bfsで大雑把に決めた方向に実際に水を流してみて本当に流れるかを調べる。",
            "        入力: level           （※ bfs で決めた方向）",
            "        出力: cap, flowed",
            "        内部変数: iter          (※ 探索済みかどうかをメモ)",
            "        備考1: bfs で先に方向を決めたおかげで、ここのステップが効率化される。 O(EV)",
            "        \"\"\"",
            "        if start == end:",
            "            return flow",
            "        while self._iter[start] < len(self._graph[start]):",
            "            edge = self._graph[start][self._iter[start]]",
            "            if edge.cap > 0 and self._level[start] < self._level[edge.to]:",
            "                \"\"\" 二つ目の条件が bfs からの入力である水流の方向に対応 \"\"\"",
            "                flowed = self.dfs(edge.to, end, min(flow, edge.cap))",
            "                if flowed > 0:",
            "                    \"\"\" 水流を流すと、正方向のcapは減って、逆方向のcapは増える \"\"\"",
            "                    edge.cap -= flowed",
            "                    self._graph[edge.to][edge.rev].cap += flowed",
            "                    return flowed",
            "            self._iter[start] += 1",
            "        return 0",
            "    def solve(self, source, sink):",
            "        flow = 0",
            "        while True:",
            "            self.bfs(source)",
            "            if self._level[sink] < 0:",
            "                \"\"\" sinkへの最短距離が -1 ⇒ sink にたどり着けない ⇒ 増加路が存在しないため探索終了\"\"\"",
            "                return flow",
            "            self._iter = [0] * self._node",
            "            while True:",
            "                f = self.dfs(source, sink, self._inf)",
            "                if f == 0:",
            "                    break",
            "                flow += f",
            "class Dinic:",
            "    def __init__(self, len_X, len_Y):",
            "        \"\"\"",
            "        soursの位置 = 0",
            "        sinkの位置  = len_X + len_Y + 1",
            "        capacity   = 1",
            "        の最大フロー問題",
            "        \"\"\"",
            "        self.len_X, self.len_Y = len_X, len_Y",
            "        self.mf = MaxFlow(self.len_X + self.len_Y + 2, min(self.len_X, self.len_Y))",
            "        for i in range(self.len_X):",
            "            \"\"\" sours から部分集合Xへの各点に capacity=1 の流れを作る \"\"\"",
            "            self.mf.add_edge(0, i + 1, 1)",
            "        for i in range(self.len_Y):",
            "            \"\"\" 部分集合Yへの各点からsinkへの capacity=1 の流れを作る \"\"\"",
            "            self.mf.add_edge(self.len_X + i + 1, self.len_X + self.len_Y + 1, 1)",
            "    def add_edge(self, from_, to):",
            "        \"\"\"",
            "        :param from_: 部分集合Xの頂点　（1,...,len_X）",
            "        :param to:    部分集合Yの頂点　（len_X + 1,...,len_X + len_Y）",
            "        \"\"\"",
            "        self.mf.add_edge(from_ + 1, to + self.len_X + 1, 1)",
            "    def solve(self):",
            "        return self.mf.solve(0, self.len_X + self.len_Y + 1)",
            "#####################################################################################",
            "N = int(input())",
            "X = []",
            "Y = []",
            "for i in range(N):",
            "    X.append([int(i) for i in input().split()])",
            "for i in range(N):",
            "    Y.append([int(i) for i in input().split()])",
            "dinic = Dinic(len(X), len(Y))",
            "for i in range(len(X)):",
            "    for j in range(N):",
            "        if X[i][0] < Y[j][0] and X[i][1] < Y[j][1]:",
            "            dinic.add_edge(i,j)",
            "print(dinic.solve())"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    class Edge:",
            "        def __init__(self, here, to, weight, rev_edge):",
            "            self.here = here",
            "            self.to = to",
            "            self.weight = weight",
            "            self.rev_edge = rev_edge    # 逆辺への参照",
            "    def bipartite_max_matching(adj_list):",
            "        \"\"\"",
            "        偶数ノードと奇数ノードで二部グラフが構成されているとする",
            "        偶数ノードから奇数ノードへ向かう辺を集めた隣接リストが渡されるので、超入口と出口を追加し、辺を接続し、逆辺も Edge クラスで張った形の隣接リストを作成。",
            "        最大流を求めて最大マッチングを計算する",
            "        \"\"\"",
            "        n = len(adj_list)",
            "        adj = [[] for _ in range(n+2)]",
            "        # 順辺、逆辺をはる",
            "        for i, elm in enumerate(adj_list):",
            "            for j in elm:",
            "                # 0-index のノードを 1-index 風に変更",
            "                # どちらのエッジからも逆辺への参照を行えるようにしておく",
            "                forward = Edge(i+1, j+1, 1, None)",
            "                backward = Edge(j+1, i+1, 0, forward)",
            "                forward.rev_edge = backward",
            "                adj[i+1].append(forward)",
            "                adj[j+1].append(backward)",
            "        # 超入口、出口を作成し辺をはる",
            "        start_ind = 0",
            "        for i in range(0, n, 2):",
            "            # 0-index のノードを 1-index 風に変更",
            "            forward = Edge(start_ind, i+1, 1, None)",
            "            backward = Edge(i+1, start_ind, 0, forward)",
            "            forward.rev_edge = backward",
            "            adj[start_ind].append(forward)",
            "            adj[i+1].append(backward)",
            "        goal_ind = n + 1",
            "        for i in range(1, n, 2):",
            "            # 0-index のノードを 1-index 風に変更",
            "            forward = Edge(i+1, goal_ind, 1, None)",
            "            backward = Edge(goal_ind, i+1, 0, forward)",
            "            forward.rev_edge = backward",
            "            adj[i+1].append(forward)",
            "            adj[goal_ind].append(backward)",
            "        # import pprint",
            "        # pprint.pprint(adj)",
            "        def dfs():",
            "            path = [Edge(None, start_ind, None, None)]    # 擬似エッジ",
            "            visited = [False] * (n+2)",
            "            visited[start_ind] = 0",
            "            while path:",
            "                previous_e = path[-1]",
            "                u = previous_e.to",
            "                visited[u] = True",
            "                if u == goal_ind:",
            "                    return path[1:]    # 最初の擬似エッジを取り除く",
            "                for e in adj[u]:",
            "                    if not visited[e.to] and e.weight > 0:",
            "                        path.append(e)",
            "                        break",
            "                else:",
            "                    path.pop()",
            "        def update_flow(path):",
            "            maximum_flow = float('inf')",
            "            for e in path:",
            "                maximum_flow = min(maximum_flow, e.weight)",
            "            for e in path:",
            "                e.weight -= maximum_flow    # エッジクラスは参照で渡されているので adj にも変更が反映される",
            "                e.rev_edge.weight += maximum_flow    # どれくらい押し戻せるかが更新される",
            "            return maximum_flow",
            "        # main loop",
            "        flow = 0",
            "        while True:",
            "            # for e in adj:",
            "            #     print(e)",
            "            p = dfs()",
            "            if not p:",
            "                return flow",
            "            else:",
            "                flow += update_flow(p)",
            "                # print(f\"path: {list(map(lambda x: x.to - 1, p))[:-1]}, current flow: {flow}\")",
            "    n = ii()",
            "    red = [lmi() for _ in range(n)]  # 0, 2, 4, 6, ...",
            "    blue = [lmi() for _ in range(n)]  # 1, 3, 5, 7, ...",
            "    # 二部グラフ",
            "    adj = [[] for _ in range(2*n)]",
            "    for i in range(n):",
            "        for j in range(n):",
            "            if red[i][0] < blue[j][0] and red[i][1] < blue[j][1]:",
            "                adj[i*2].append(j*2+1)",
            "    # import pprint",
            "    # pprint.pprint(adj)",
            "    print(bipartite_max_matching(adj))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "from collections import deque",
            "class MaxFlow:",
            "    class Edge:",
            "        def __init__(self, to, cap, rev):",
            "            self.to, self.cap, self.rev = to, cap, rev",
            "    def __init__(self, node_size, inf):",
            "        self._node = node_size",
            "        self._inf = inf",
            "        self._level = [-1] * self._node",
            "        self._iter = [0] * self._node",
            "        self._graph = [[] for _ in range(self._node)]",
            "    def add_edge(self, from_, to, cap):",
            "        self._graph[from_].append(self.Edge(to, cap, len(self._graph[to])))",
            "        self._graph[to].append(self.Edge(from_, 0, len(self._graph[from_]) - 1))",
            "    def bfs(self, start):",
            "        self._level = [-1] * self._node",
            "        que = deque()",
            "        self._level[start] = 0",
            "        que.append(start)",
            "        while que:",
            "            cur_vertex = que.popleft()",
            "            for e in self._graph[cur_vertex]:",
            "                if self._level[e.to] < 0 < e.cap:",
            "                    self._level[e.to] = self._level[cur_vertex] + 1",
            "                    que.append(e.to)",
            "    def dfs(self, cur_vertex, end_vertex, flow):",
            "        if cur_vertex == end_vertex:",
            "            return flow",
            "        while self._iter[cur_vertex] < len(self._graph[cur_vertex]):",
            "            e = self._graph[cur_vertex][self._iter[cur_vertex]]",
            "            if e.cap > 0 and self._level[cur_vertex] < self._level[e.to]:",
            "                flowed = self.dfs(e.to, end_vertex, min(flow, e.cap))",
            "                if flowed > 0:",
            "                    e.cap -= flowed",
            "                    self._graph[e.to][e.rev].cap += flowed",
            "                    return flowed",
            "            self._iter[cur_vertex] += 1",
            "        return 0",
            "    def solve(self, source, sink):",
            "        flow = 0",
            "        while True:",
            "            self.bfs(source)",
            "            if self._level[sink] < 0:",
            "                return flow",
            "            self._iter = [0] * self._node",
            "            while True:",
            "                f = self.dfs(source, sink, self._inf)",
            "                if f == 0:",
            "                    break",
            "                flow += f",
            "class BipartiteMatching:",
            "    def __init__(self, size1, size2):",
            "        self._u_size, self._v_size = size1, size2",
            "        self.mf = MaxFlow(self._u_size + self._v_size + 2, min(self._u_size, self._v_size))",
            "        for i in range(self._u_size):",
            "            self.mf.add_edge(0, i + 1, 1)",
            "        for i in range(self._v_size):",
            "            self.mf.add_edge(self._u_size + i + 1, self._u_size + self._v_size + 1, 1)",
            "    def add_edge(self, from_, to):",
            "        self.mf.add_edge(from_ + 1, to + self._u_size + 1, 1)",
            "    def solve(self):",
            "        return self.mf.solve(0, self._u_size + self._v_size + 1)",
            "#####################################################################################",
            "N = int(input())",
            "X = []",
            "Y = []",
            "for i in range(N):",
            "    X.append([int(i) for i in input().split()])",
            "for i in range(N):",
            "    Y.append([int(i) for i in input().split()])",
            "dinic = BipartiteMatching(len(X), len(Y))",
            "for i in range(len(X)):",
            "    for j in range(N):",
            "        if X[i][0] < Y[j][0] and X[i][1] < Y[j][1]:",
            "            dinic.add_edge(i,j)",
            "print(dinic.solve())"
        ],
        "label": [
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "from collections import deque",
            "class Dinic:",
            "    def __init__(self, N0, N1):",
            "        self.N0 = N0",
            "        self.N1 = N1",
            "        self.N = N = 2+N0+N1",
            "        self.G = [[] for i in range(N)]",
            "        for i in range(N0):",
            "            forward = [2+i, 1, None]",
            "            forward[2] = backward = [0, 0, forward]",
            "            self.G[0].append(forward)",
            "            self.G[2+i].append(backward)",
            "        self.backwards = bs = []",
            "        for i in range(N1):",
            "            forward = [1, 1, None]",
            "            forward[2] = backward = [2+N0+i, 0, forward]",
            "            bs.append(backward)",
            "            self.G[2+N0+i].append(forward)",
            "            self.G[1].append(backward)",
            "    def add_edge(self, fr, to):",
            "        #assert 0 <= fr < self.N0",
            "        #assert 0 <= to < self.N1",
            "        v0 = 2 + fr",
            "        v1 = 2 + self.N0 + to",
            "        forward = [v1, 1, None]",
            "        forward[2] = backward = [v0, 0, forward]",
            "        self.G[v0].append(forward)",
            "        self.G[v1].append(backward)",
            "    def bfs(self):",
            "        G = self.G",
            "        level = [None]*self.N",
            "        deq = deque([0])",
            "        level[0] = 0",
            "        while deq:",
            "            v = deq.popleft()",
            "            lv = level[v] + 1",
            "            for w, cap, _ in G[v]:",
            "                if cap and level[w] is None:",
            "                    level[w] = lv",
            "                    deq.append(w)",
            "        self.level = level",
            "        return level[1] is not None",
            "    def dfs(self, v, t):",
            "        if v == t:",
            "            return 1",
            "        level = self.level",
            "        for e in self.it[v]:",
            "            w, cap, rev = e",
            "            if cap and level[v] < level[w] and self.dfs(w, t):",
            "                e[1] = 0",
            "                rev[1] = 1",
            "                return 1",
            "        return 0",
            "    def flow(self):",
            "        flow = 0",
            "        while self.bfs():",
            "            *self.it, = map(iter, self.G)",
            "            while self.dfs(0, 1):",
            "                flow += 1",
            "        return flow",
            "    def matching(self):",
            "        return [cap for _, cap, _ in self.backwards]",
            "#####################################################################################",
            "N = int(input())",
            "s = []",
            "ss = []",
            "for i in range(N):",
            "    s.append([int(i) for i in input().split()])",
            "for i in range(N):",
            "    ss.append([int(i) for i in input().split()])",
            "pair = []",
            "for i in range(len(s)):",
            "    right = []",
            "    for j in range(N):",
            "        if s[j][0] < ss[i][0] and s[j][1] < ss[i][1]:",
            "            right.append(j)",
            "    pair.append(right)",
            "# print(pair)",
            "#####################################################################################",
            "# 頂点の組u,vと辺の重みc（今回は1）からグラフ作って最大流で解くFOOOOOOOOOOOOOOOOO",
            "V = len(pair) + N + 2  # (sとt追加)",
            "dinic = Dinic(V, V)",
            "for i in range(len(pair)):  # 始点s（番号0）から青い点(1から最大len(pair))への辺",
            "    u, v, c = 0, i + 1, 1",
            "    dinic.add_edge(u, v)",
            "for i in range(N):  # 赤い点（len(pair)+1から最大len(pair)+n）から終点t（番号V-1）への辺",
            "    u, v, c = i + len(pair) + 1, V - 1, 1",
            "    dinic.add_edge(u, v)",
            "for i in range(len(pair)):  # 青い点（番号1から最大len(pair)に振り直し）から　赤い点（番号1～100に振り直し）への辺",
            "    for j in range(len(pair[i])):",
            "        node1, node2 = i + 1, pair[i][j] + len(pair) + 1",
            "        u, v, c = node1, node2, 1",
            "        dinic.add_edge(u, v)",
            "print(dinic.flow() - 2)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            2,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def check_palindrome(s):",
            "        n = len(s)",
            "        for i in range(n//2):",
            "            if s[i] != s[n-1-i]:",
            "                return False",
            "        return True",
            "    a, b = mi()",
            "    cnt = 0",
            "    for i in range(a, b+1):",
            "        s_i = str(i)",
            "        if check_palindrome(s_i):",
            "            cnt += 1",
            "    print(cnt)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, m = mi()",
            "    if n == 1 and m == 1:",
            "        print(1)",
            "    elif n == 1:",
            "        print(m - 2)",
            "    elif m == 1:",
            "        print(n - 2)",
            "    else:",
            "        print((n - 2) * (m - 2))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def make_chain(res, seq):",
            "        num = res",
            "        prev = number_to_point[num]",
            "        num += d",
            "        while num < h * w:",
            "            current = number_to_point[num]",
            "            dist = abs(current[0] - prev[0]) + abs(current[1] - prev[1])",
            "            seq.append(dist)",
            "            num += d",
            "            prev = current",
            "    h, w, d = mi()",
            "    grid = [lmi_0() for _ in range(h)]    # 0 to h*w-1",
            "    q = ii()",
            "    query = [lmi_0() for _ in range(q)]",
            "    number_to_point = dict()",
            "    for i in range(h):",
            "        for j in range(w):",
            "            number_to_point[grid[i][j]] = (i, j)",
            "    chain = [[0] for _ in range(d)]    # chain[i] = (num%d == i なる数字について順にジャンプしていく時のコスト)",
            "    for i in range(d):",
            "        make_chain(i, chain[i])",
            "    # print(chain)",
            "    accum_chain = [list(accumulate(elm)) for elm in chain]",
            "    for l, r in query:",
            "        assert (l % d == r % d)",
            "        res = l % d",
            "        a = l // d",
            "        b = r // d",
            "        print(accum_chain[res][b] - accum_chain[res][a])",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# input()",
            "# int(input())",
            "# map(int, input().split())",
            "# list(map(int, input().split()))",
            "# list(map(int, list(input()))) # スペースがない数字リストを読み込み",
            "import math",
            "import fractions",
            "import sys",
            "import bisect",
            "import heapq  # 優先度付きキュー(最小値取り出し)",
            "import collections",
            "from collections import Counter",
            "from collections import deque",
            "import pprint",
            "import itertools",
            "sr = lambda: input()",
            "ir = lambda: int(sr())",
            "lr = lambda: list(map(int, sr().split()))",
            "\"\"\"nを素因数分解\"\"\"",
            "\"\"\"2以上の整数n => [[素因数, 指数], ...]の2次元リスト\"\"\"",
            "def factorization(n):",
            "    arr = []",
            "    temp = n",
            "    if n == 1:",
            "        return arr",
            "    for i in range(2, int(-(-n ** 0.5 // 1)) + 1):",
            "        if temp % i == 0:",
            "            cnt = 0",
            "            while temp % i == 0:",
            "                cnt += 1",
            "                temp //= i",
            "            arr.append([i, cnt])",
            "    if temp != 1:",
            "        arr.append([temp, 1])",
            "    if arr == []:",
            "        arr.append([n, 1])",
            "    return arr",
            "# a^n",
            "def power(a, n, mod):",
            "    x = 1",
            "    while n:",
            "        if n & 1:",
            "            x *= a % mod",
            "        n >>= 1",
            "        a *= a % mod",
            "    return x % mod",
            "# n*(n-1)*...*(l+1)*l",
            "def kaijo(n, l, mod):",
            "    if n == 0:",
            "        return 1",
            "    a = n",
            "    tmp = n - 1",
            "    while (tmp >= l):",
            "        a = a * tmp % mod",
            "        tmp -= 1",
            "    return a",
            "# Union Find",
            "class UnionFind():",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parents = [-1] * n",
            "    def find(self, x):",
            "        if self.parents[x] < 0:",
            "            return x",
            "        else:",
            "            self.parents[x] = self.find(self.parents[x])",
            "            return self.parents[x]",
            "    def union(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "        if x == y:",
            "            return",
            "        if self.parents[x] > self.parents[y]:",
            "            x, y = y, x",
            "        self.parents[x] += self.parents[y]",
            "        self.parents[y] = x",
            "    def size(self, x):",
            "        return -self.parents[self.find(x)]",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "    def members(self, x):",
            "        root = self.find(x)",
            "        return [i for i in range(self.n) if self.find(i) == root]",
            "    def roots(self):",
            "        return [i for i, x in enumerate(self.parents) if x < 0]",
            "    def group_count(self):",
            "        return len(self.roots())",
            "    def all_group_members(self):",
            "        return {r: self.members(r) for r in self.roots()}",
            "    def __str__(self):",
            "        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())",
            "# 約数生成",
            "def make_divisors(n):",
            "    divisors = []",
            "    for i in range(1, int(n**0.5)+1):",
            "        if n % i == 0:",
            "            divisors.append(i)",
            "            if i != n // i:",
            "                divisors.append(n//i)",
            "    divisors.sort()",
            "    return divisors",
            "inf = 10 ** 18",
            "mod = 10 ** 9 + 7",
            "h,w,d = lr()",
            "a = [lr() for i in range(h)]",
            "dic = [[0,0] for i in range(h*w)]",
            "dic1 = [[0] for i in range(d)]",
            "for i in range(h):",
            "    for j in range(w):",
            "        dic[a[i][j]-1] = [i,j]",
            "for j in range(d):",
            "    pre = dic[j]",
            "    for k in range(j,h*w,d):",
            "        cost = abs(pre[0] - dic[k][0])+abs(pre[1] - dic[k][1])",
            "        dic1[j].append(dic1[j][-1]+cost)",
            "        pre = dic[k]",
            "q = ir()",
            "for t in range(q):",
            "    l,r = lr()",
            "    l-=1",
            "    r-=1",
            "    next = (r-l)//d",
            "    start = l%d",
            "    left = l//d+1",
            "    print(dic1[start][left+next]-dic1[start][left])"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            2,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "content": [
            "\"\"\"",
            "Maze class.",
            "cf. WarpableMaze class.",
            "\"\"\"",
            "import sys",
            "from collections import deque",
            "from typing import List, Tuple",
            "class Maze:",
            "    __slots__ = [\"height\", \"width\", \"wall\", \"sentinel\", \"unsearched\", \"dist\"]",
            "    def __init__(",
            "        self, height: int, width: int, grid: List[bytes], wall: str = \"#\",",
            "    ) -> None:",
            "        self.height = height + 2",
            "        self.width = width + 2",
            "        self.wall = -1",
            "        self.sentinel = -2",
            "        self.unsearched = 1 << 30",
            "        self.dist = self._convert_grid_to_dist(grid, wall)",
            "    def _convert_grid_to_dist(self, grid: List[bytes], wall) -> List[int]:",
            "        \"\"\"Convert a 2D grid to a 1D dist.\"\"\"",
            "        dist = [self.sentinel] * self.height * self.width",
            "        i = self.width",
            "        for row in grid:",
            "            for c in row.decode():",
            "                i += 1",
            "                dist[i] = self.wall if c == wall else self.unsearched",
            "            i += 2",
            "        return dist",
            "    def _flatten_coordinate(self, x: int, y: int) -> int:",
            "        \"\"\"Flatten 2D coordinate values.",
            "        Values of a coordinate must be 1-origin.",
            "        \"\"\"",
            "        return self.width * x + y",
            "    def bfs(",
            "        self,",
            "        start_2d: Tuple[int, int],",
            "        goal_2d: Tuple[int, int],",
            "        updates_dist: bool = False,",
            "    ) -> int:",
            "        \"\"\"BFS to compute the distance from start to goal.",
            "        Values of start_2d and goal_2d must be 1-origin.",
            "        \"\"\"",
            "        start = self._flatten_coordinate(*start_2d)",
            "        goal = self._flatten_coordinate(*goal_2d)",
            "        moves = (-self.width, self.width, -1, 1)",
            "        dist = self.dist[:]",
            "        dist[start] = 0",
            "        queue = deque([start])",
            "        while queue:",
            "            x = queue.popleft()",
            "            cur_dist = dist[x]",
            "            if x == goal:",
            "                break",
            "            for dx in moves:",
            "                nx = x + dx",
            "                if dist[nx] == self.unsearched:",
            "                    dist[nx] = cur_dist + 1",
            "                    queue.append(nx)",
            "        if updates_dist:",
            "            self.dist = dist",
            "        return dist[goal] if dist[goal] != self.unsearched else self.wall",
            "    def debug(self) -> None:",
            "        \"\"\"Show debugging information.\"\"\"",
            "        def convert(n: int) -> str:",
            "            if n == self.sentinel:",
            "                return \"†\"",
            "            elif n == self.wall:",
            "                return \"#\"",
            "            return \".\"",
            "        print(f\"<DEBUG>\\nheight={self.height}, width={self.width}\\n\", file=sys.stderr)",
            "        for row in zip(*[iter(self.dist)] * self.width):",
            "            print(*map(convert, row), file=sys.stderr)",
            "class BreakableMaze(Maze):",
            "    def __init__(self, height: int, width: int, grid: List[bytes], wall: str = \"#\"):",
            "        self.start = -1",
            "        self.goal = -1",
            "        super().__init__(height, width, grid, wall)",
            "    def _convert_grid_to_dist(self, grid: List[bytes], wall) -> List[int]:",
            "        \"\"\"Convert a 2D grid to a 1D dist.\"\"\"",
            "        dist = [self.sentinel] * self.height * self.width",
            "        i = self.width",
            "        for row in grid:",
            "            for c in row.decode():",
            "                i += 1",
            "                dist[i] = self.wall if c == wall else self.unsearched",
            "                if c == \"s\":",
            "                    self.start = i",
            "                elif c == \"g\":",
            "                    self.goal = i",
            "            i += 2",
            "        return dist",
            "    def breakable_bfs(self, updates_dist: bool = False) -> int:",
            "        \"\"\"BFS to compute the distance from start to goal.",
            "        \"\"\"",
            "        moves = (-self.width, self.width, -1, 1)",
            "        dist = self.dist[:]",
            "        dist[self.start] = 0",
            "        queue = deque([self.start])",
            "        while queue:",
            "            x = queue.popleft()",
            "            cur_dist = dist[x]",
            "            if x == self.goal or cur_dist > 2:",
            "                break",
            "            for dx in moves:",
            "                nx = x + dx",
            "                if dist[nx] == self.unsearched:",
            "                    dist[nx] = cur_dist",
            "                    queue.appendleft(nx)",
            "                elif dist[nx] == self.wall:",
            "                    dist[nx] = cur_dist + 1",
            "                    queue.append(nx)",
            "        if updates_dist:",
            "            self.dist = dist",
            "        return dist[self.goal]",
            "def abc007_c():",
            "    # https://atcoder.jp/contests/abc007/tasks/abc007_3",
            "    read = sys.stdin.buffer.read",
            "    readline = sys.stdin.buffer.readline",
            "    R, C = map(int, readline().split())",
            "    (*start,) = map(int, readline().split())",
            "    (*goal,) = map(int, readline().split())",
            "    (*S,) = read().split()",
            "    maze = Maze(R, C, S)",
            "    print(maze.bfs(start, goal))",
            "def abc088_d():",
            "    # https://atcoder.jp/contests/abc088/tasks/abc088_d",
            "    read = sys.stdin.buffer.read",
            "    readline = sys.stdin.buffer.readline",
            "    H, W = map(int, readline().split())",
            "    (*S,) = read().split()",
            "    maze = Maze(H, W, S)",
            "    dist = maze.bfs((1, 1), (H, W))",
            "    if dist != -1:",
            "        res = H * W - sum((row.decode()).count(\"#\") for row in S) - dist - 1",
            "        print(res)",
            "    else:",
            "        print(-1)",
            "def arc005_c():",
            "    # https://atcoder.jp/contests/arc005/tasks/arc005_3",
            "    read = sys.stdin.buffer.read",
            "    readline = sys.stdin.buffer.readline",
            "    H, W = map(int, readline().split())",
            "    (*C,) = read().split()",
            "    maze = BreakableMaze(H, W, C)",
            "    print(\"YES\" if maze.breakable_bfs() <= 2 else \"NO\")",
            "if __name__ == \"__main__\":",
            "    # abc007_c()  # https://atcoder.jp/contests/abc007/tasks/abc007_3",
            "    abc088_d()  # https://atcoder.jp/contests/abc088/tasks/abc088_d",
            "    # arc005_c()  # https://atcoder.jp/contests/arc005/tasks/arc005_3"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1
        ]
    },
    {
        "content": [
            "from collections import deque",
            "from heapq import heapify,heappop,heappush,heappushpop",
            "from copy import copy,deepcopy",
            "from itertools import product,permutations,combinations,combinations_with_replacement",
            "from collections import defaultdict,Counter",
            "from bisect import bisect_left,bisect_right",
            "from math import gcd,ceil,floor,factorial",
            "# from fractions import gcd",
            "from functools import reduce",
            "from pprint import pprint",
            "from statistics import mean,median,mode",
            "INF = float(\"inf\")",
            "def mycol(data,col):",
            "    return [ row[col] for row in data ]",
            "def mysort(data,col,reverse_flag):",
            "    data.sort(key=lambda x:x[col],reverse=reverse_flag)",
            "    return data",
            "def mymax(data):",
            "    M = -1*float(\"inf\")",
            "    for i in range(len(data)):",
            "        m = max(data[i])",
            "        M = max(M,m)",
            "    return M",
            "def mymin(data):",
            "    m = float(\"inf\")",
            "    for i in range(len(data)):",
            "        M = min(data[i])",
            "        m = min(m,M)",
            "    return m",
            "def mycount(ls,x):",
            "    # lsはソート済みであること",
            "    l = bisect_left(ls,x)",
            "    r = bisect_right(ls,x)",
            "    return (r-l)",
            "def myoutput(ls,space=True):",
            "    if space:",
            "        if len(ls)==0:",
            "            print(\" \")",
            "        elif type(ls[0])==str:",
            "            print(\" \".join(ls))",
            "        elif type(ls[0])==int:",
            "            print(\" \".join(map(str,ls)))",
            "        else:",
            "            print(\"Output Error\")",
            "    else:",
            "        if len(ls)==0:",
            "            print(\"\")",
            "        elif type(ls[0])==str:",
            "            print(\"\".join(ls))",
            "        elif type(ls[0])==int:",
            "            print(\"\".join(map(str,ls)))",
            "        else:",
            "            print(\"Output Error\")",
            "def I():",
            "    return int(input())",
            "def MI():",
            "    return map(int,input().split())",
            "def RI():",
            "    return list(map(int,input().split()))",
            "def CI(n):",
            "    return [ int(input()) for _ in range(n) ]",
            "def LI(n):",
            "    return [ list(map(int,input().split())) for _ in range(n) ]",
            "def S():",
            "    return input()",
            "def MS():",
            "    return input().split()",
            "def RS():",
            "    return list(input())",
            "def CS(n):",
            "    return [ input() for _ in range(n) ]",
            "def LS(n):",
            "    return [ list(input()) for _ in range(n) ]",
            "# ddict = defaultdict(lambda: 0)",
            "# ddict = defaultdict(lambda: 1)",
            "# ddict = defaultdict(lambda: int())",
            "# ddict = defaultdict(lambda: list())",
            "# ddict = defaultdict(lambda: float())",
            "h,w = MI()",
            "maze = LS(h)",
            "sy = 1",
            "sx = 1",
            "gy = h",
            "gx = w",
            "sy -= 1",
            "sx -= 1",
            "gy -= 1",
            "gx -= 1",
            "d = [ [INF]*w for _ in range(h) ]",
            "def bfs(sy,sx,gy,gx):",
            "    q = deque()",
            "    q.append([sy,sx])",
            "    d[sy][sx] = 0",
            "    while q:",
            "        y,x = q.popleft()",
            "        if y==gy and x==gx:",
            "            break",
            "        else:",
            "            for j,i in ([1,0],[0,-1],[-1,0],[0,1]):",
            "                ny = y + j",
            "                nx = x + i",
            "                if nx==-1 or ny==-1 or nx==w or ny==h:",
            "                    pass",
            "                elif maze[ny][nx]==\"#\":",
            "                    pass",
            "                elif d[ny][nx]!=INF:",
            "                    pass",
            "                else:",
            "                    q.append([ny,nx])",
            "                    d[ny][nx] = d[y][x] + 1",
            "    return d[gy][gx]",
            "count = 0",
            "for i in range(h):",
            "    c = maze[i].count('.')",
            "    count += c",
            "d = bfs(sy,sx,gy,gx)",
            "# print(f'd={d}')",
            "if d==INF:",
            "    print('-1')",
            "else:",
            "    print(count-2-(d-1))"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            2,
            1
        ]
    },
    {
        "content": [
            "\"\"\"",
            "Maze class.",
            "cf. WarpableMaze class.",
            "\"\"\"",
            "import sys",
            "from collections import deque",
            "from typing import List, Tuple",
            "class Maze:",
            "    __slots__ = [",
            "        \"height\",",
            "        \"width\",",
            "        \"road\",",
            "        \"wall\",",
            "        \"is_unsearched\",",
            "        \"is_unreachable\",",
            "        \"dist\",",
            "    ]",
            "    def __init__(",
            "        self,",
            "        height: int,",
            "        width: int,",
            "        grid: List[bytes],",
            "        *,",
            "        road: str = \".\",",
            "        wall: str = \"#\",",
            "        is_unsearched: int = 1 << 30,",
            "        is_unreachable: int = -1,",
            "    ) -> None:",
            "        self.height = height + 2",
            "        self.width = width + 2",
            "        self.road = road",
            "        self.wall = wall",
            "        self.is_unsearched = is_unsearched",
            "        self.is_unreachable = is_unreachable",
            "        self.dist = self._convert_grid_to_dist(grid)",
            "    def _convert_grid_to_dist(self, grid: List[bytes]) -> List[int]:",
            "        \"\"\"Convert a 2D grid to a 1D dist.\"\"\"",
            "        dist = [self.is_unreachable] * self.height * self.width",
            "        i = self.width",
            "        for row in grid:",
            "            for c in row.decode():",
            "                i += 1",
            "                if c == self.road:",
            "                    dist[i] = self.is_unsearched",
            "            i += 2",
            "        return dist",
            "    def _flatten_coordinate(self, x: int, y: int) -> int:",
            "        \"\"\"Flatten 2D coordinate values.",
            "        Values of a coordinate must be 1-origin.",
            "        \"\"\"",
            "        return self.width * x + y",
            "    def bfs(",
            "        self,",
            "        start_2d: Tuple[int, int],",
            "        goal_2d: Tuple[int, int],",
            "        updates_dist: bool = False,",
            "    ) -> int:",
            "        \"\"\"BFS to compute the distance from start to goal.",
            "        Values of start_2d and goal_2d must be 1-origin.",
            "        \"\"\"",
            "        start = self._flatten_coordinate(*start_2d)",
            "        goal = self._flatten_coordinate(*goal_2d)",
            "        moves = (-self.width, self.width, -1, 1)",
            "        dist = self.dist[:]",
            "        dist[start] = 0",
            "        queue = deque([start])",
            "        while queue:",
            "            x = queue.popleft()",
            "            cur_dist = dist[x]",
            "            if x == goal:",
            "                break",
            "            for dx in moves:",
            "                nx = x + dx",
            "                if dist[nx] == self.is_unsearched:",
            "                    dist[nx] = cur_dist + 1",
            "                    queue.append(nx)",
            "        if updates_dist:",
            "            self.dist = dist",
            "        return dist[goal] if dist[goal] != self.is_unsearched else self.is_unreachable",
            "    def debug(self) -> None:",
            "        \"\"\"Show debugging information.\"\"\"",
            "        print(",
            "            f\"<DEBUG>\\n\"",
            "            f\"height={self.height}, width={self.width}\\n\"",
            "            f\"is_unsearched={self.is_unsearched}, is_unreachable={self.is_unreachable}\",",
            "            file=sys.stderr,",
            "        )",
            "        convert = lambda x: self.road if x != self.is_unreachable else self.wall",
            "        for row in zip(*[iter(self.dist)] * self.width):",
            "            print(*map(convert, row), file=sys.stderr)",
            "def abc007_c():",
            "    # https://atcoder.jp/contests/abc007/tasks/abc007_3",
            "    read = sys.stdin.buffer.read",
            "    readline = sys.stdin.buffer.readline",
            "    R, C = map(int, readline().split())",
            "    (*start,) = map(int, readline().split())",
            "    (*goal,) = map(int, readline().split())",
            "    (*S,) = read().split()",
            "    maze = Maze(R, C, S)",
            "    print(maze.bfs(start, goal))",
            "def abc088_d():",
            "    # https://atcoder.jp/contests/abc088/tasks/abc088_d",
            "    read = sys.stdin.buffer.read",
            "    readline = sys.stdin.buffer.readline",
            "    H, W = map(int, readline().split())",
            "    (*S,) = read().split()",
            "    maze = Maze(H, W, S)",
            "    dist = maze.bfs((1, 1), (H, W))",
            "    if dist != -1:",
            "        res = H * W - sum((row.decode()).count(\"#\") for row in S) - dist - 1",
            "        print(res)",
            "    else:",
            "        print(-1)",
            "if __name__ == \"__main__\":",
            "    # abc007_c()",
            "    abc088_d()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def no_contradict_p(info):",
            "        visited = [False] * n",
            "        dist_list = [None] * n",
            "        def bfs_and_check_no_contradict(start):",
            "            dist_list[start] = 0",
            "            q = deque([start])",
            "            while q:",
            "                u = q.popleft()",
            "                if not visited[u]:",
            "                    visited[u] = True",
            "                    for v, dist in info[u]:",
            "                        if dist_list[v] is None:",
            "                            dist_list[v] = dist_list[u] + dist",
            "                        elif dist_list[v] != dist_list[u] + dist:",
            "                            return False",
            "                    for v, dist in info[u]:",
            "                        if not visited[v]:",
            "                            q.append(v)",
            "            return True",
            "        for i in range(n):",
            "            if not visited[i]:",
            "                if not bfs_and_check_no_contradict(i):",
            "                    return False",
            "        return True",
            "    n, m = mi()",
            "    info = [[] for _ in range(n)]",
            "    for _ in range(m):",
            "        l, r, dist = mi_0()",
            "        dist += 1",
            "        info[l].append((r, dist))",
            "        info[r].append((l, -dist))",
            "    print('Yes') if no_contradict_p(info) else print('No')",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "from sys import stdin",
            "def main():",
            "    from collections import deque",
            "    _in = [_.rstrip() for _ in stdin.readlines()]",
            "    N, M = list(map(int,_in[0].split(' ')))  # type:list(int)",
            "    if M == 0:",
            "        TF = 'Yes'",
            "    else:",
            "        L_R_D_arr = deque([])",
            "        for i in range(M):",
            "            _ = list(map(int,_in[i+1].split(' ')))  # type:list(int)",
            "            L_R_D_arr.append(_)",
            "        # vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv",
            "        iter_ = [float('inf')]*(N+1)",
            "        iter_[L_R_D_arr[0][0]] = 0",
            "        TF = 'No'",
            "        rot_cnt = 0",
            "        while len(L_R_D_arr)>0:",
            "            if rot_cnt > len(L_R_D_arr):",
            "                iter_ = [float('inf')]*(N+1)",
            "                iter_[L_R_D_arr[0][0]] = 0",
            "            else:",
            "                L, R, D = L_R_D_arr[0]",
            "                if iter_[L] == float('inf'):",
            "                    if iter_[R] == float('inf'):",
            "                        L_R_D_arr.rotate(-1)",
            "                        rot_cnt += 1",
            "                    else:",
            "                        iter_[L] = iter_[R]-D",
            "                        L_R_D_arr.popleft()",
            "                        rot_cnt = 0",
            "                else:",
            "                    rot_cnt = 0",
            "                    if iter_[R] == float('inf'):",
            "                        iter_[R] = iter_[L]+D",
            "                        L_R_D_arr.popleft()",
            "                    elif iter_[R] == iter_[L]+D:",
            "                        L_R_D_arr.popleft()",
            "                    else:",
            "                        break",
            "        else:",
            "            TF = 'Yes'",
            "        # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",
            "    print(TF)",
            "# 重み付きUnion-Find木",
            "class Weighted_Union_Find():",
            "    def __init__(self, N=1, SUM_UNITY=0):",
            "        self.par  = [i for i in range(N)]  # 親ノード",
            "        self.rank = [0] * N                # ランク",
            "        self.diff_weight = [SUM_UNITY] * N",
            "    # 経路圧縮",
            "    def root(self, x):",
            "        if self.par[x] == x:",
            "            return x",
            "        else:",
            "            r = self.root(self.par[x])",
            "            self.diff_weight[x] += self.diff_weight[self.par[x]]",
            "            self.par[x] = r",
            "            return r",
            "    # 経路圧縮＋重みを返す",
            "    def weight(self, x):",
            "        self.root(x)",
            "        return self.diff_weight[x]",
            "    # xとyが同じグループに属するか判定",
            "    def issame(self, x, y):",
            "        return self.root(x) == self.root(y)",
            "    # xとyの属するグループを1つにまとめる",
            "    def merge(self, x, y, w):",
            "        w = w + self.weight(x) - self.weight(y)",
            "        x = self.root(x)",
            "        y = self.root(y)",
            "        if x == y:",
            "            return False",
            "        else:",
            "            if self.rank[x] < self.rank[y]:",
            "                x, y = y, x",
            "                w = -w",
            "            elif self.rank[x] == self.rank[y]:",
            "                self.rank[x] += 1",
            "            self.par[y] = x",
            "            self.diff_weight[y] = w",
            "            return True",
            "    # xとyが同じグループにいるとき、xとyの重みの差を返す",
            "    def diff(self,x,y):",
            "        return self.weight(y) - self.weight(x)",
            "if __name__ == \"__main__\":",
            "    _in = [_.rstrip() for _ in stdin.readlines()]",
            "    N, M = list(map(int,_in[0].split(' ')))  # type:list(int)",
            "    if M == 0:",
            "        TF = 'Yes'",
            "    else:",
            "        L_R_D_arr = []",
            "        for i in range(M):",
            "            _ = list(map(int,_in[i+1].split(' ')))  # type:list(int)",
            "            L_R_D_arr.append(_)",
            "        # vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv",
            "        TF = 'No'",
            "        wuf = Weighted_Union_Find(N)",
            "        for L,R,D in L_R_D_arr:",
            "            L -= 1",
            "            R -= 1",
            "            if wuf.issame(L,R):",
            "                diff = wuf.diff(L,R)",
            "                if diff != D:",
            "                    break",
            "            else:",
            "                wuf.merge(L,R,D)",
            "        else:",
            "            TF = 'Yes'",
            "        # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",
            "    print(TF)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            2
        ]
    },
    {
        "content": [
            "import sys",
            "def input(): return sys.stdin.readline().strip()",
            "class WeightedUnionFind():",
            "    \"\"\"",
            "    https://qiita.com/drken/items/cce6fc5c579051e64fab",
            "    UnionFindTreeに親ノードへ向かう辺の重みを追加したもの。",
            "    これによりノードx, yがpath-connectedな場合にその間の符号付き距離をO(logN)で取得できる。",
            "    ただしこれは「有向辺」であることに注意。",
            "    というのも距離の導出は各ノードから根ノードまでの距離を取ってその差分で求めているため、",
            "    無向辺の場合はLCAを求めないといけない。そしてUnionFindでは経路圧縮のせいでLCAを求めるのは不可能。",
            "    \"\"\"",
            "    def __init__(self, n):",
            "        \"\"\"",
            "        要素数をnとして、各ノードを0,1,...,(n-1)の番号で管理する。",
            "        parentsは各ノードの属する木の根を表す。",
            "        ただし根ノードのparentには(その木のノード数)*(-1)を格納する。",
            "        diff_weightは各ノードから親ノードへ向かう辺の重みを格納する。",
            "        根ノードに格納する重みは0とする。",
            "        \"\"\"",
            "        self.n = n",
            "        self.parents = [-1] * n",
            "        self.diff_weight = [0] * n",
            "    def find(self, x):",
            "        \"\"\"",
            "        xの属する木の根を返す。",
            "        このとき同時に経路圧縮して、探索途中のノードを全て根に繋ぎ直す。",
            "        \"\"\"",
            "        if self.parents[x] < 0:",
            "            return x",
            "        else:",
            "            edge_weight = self.diff_weight[x]",
            "            prev_parent = self.parents[x]",
            "            self.parents[x] = self.find(self.parents[x])",
            "            self.diff_weight[x] = self.diff_weight[prev_parent] + edge_weight",
            "            return self.parents[x]",
            "    def union(self, x, y, w):",
            "        \"\"\"",
            "        xからyへ重みwの辺を繋ぐ。",
            "        既にx, yがpath-connectedな場合はFalseを返す。",
            "        そうでなければTrueを返す。",
            "        \"\"\"",
            "        rx = self.find(x)",
            "        ry = self.find(y)",
            "        w += self.diff_weight[y] - self.diff_weight[x]",
            "        w *= -1 # 内部処理的にはfind(y) -> find(x)へ辺を繋ぐ",
            "        if rx == ry:",
            "            return False",
            "        if self.parents[rx] > self.parents[ry]:",
            "            rx, ry = ry, rx # xの方が木のサイズが大きいようにする",
            "            w *= -1 # それに応じて結ぶ辺の向きも反転させる",
            "        self.parents[rx] += self.parents[ry]",
            "        self.parents[ry] = rx",
            "        self.diff_weight[ry] = w",
            "        return True",
            "    def weight(self, x):",
            "        \"\"\"",
            "        xからxの属する木の根ノードまでの重みを求める",
            "        \"\"\"",
            "        _ = self.find(x)",
            "        return self.diff_weight[x]",
            "    def diff(self, x, y):",
            "        \"\"\"",
            "        xからyへ向かうのにかかる重みを求める",
            "        \"\"\"",
            "        return self.weight(x) - self.weight(y)",
            "    def size(self, x):",
            "        \"\"\"",
            "        xの属する木の要素数を返す",
            "        根の親を要素数の(-1)倍で定めておいたおかげでO(1)で取得可能",
            "        \"\"\"",
            "        return -self.parents[self.find(x)]",
            "    def same(self, x, y):",
            "        \"\"\"",
            "        xとyがpath-connectedかを判定する",
            "        \"\"\"",
            "        return self.find(x) == self.find(y)",
            "    def members(self, x):",
            "        \"\"\"",
            "        xの属する木の要素を列挙する",
            "        \"\"\"",
            "        root = self.find(x)",
            "        return [i for i in range(self.n) if self.find(i) == root]",
            "    def roots(self):",
            "        \"\"\"",
            "        連結成分の代表元のリストを返す",
            "        \"\"\"",
            "        return [i for i, x in enumerate(self.parents) if x < 0]",
            "    def group_count(self):",
            "        \"\"\"",
            "        連結成分の個数を返す",
            "        \"\"\"",
            "        return len(self.roots())",
            "    def all_group_members(self):",
            "         \"\"\"",
            "         連結成分およびそれぞれの代表元をまとめた辞書を返す",
            "         代表元がキーになってる",
            "         \"\"\"",
            "         return {r: self.members(r) for r in self.roots()}",
            "    def __str__(self):",
            "        \"\"\"",
            "        連結成分およびその代表元を出力",
            "        \"\"\"",
            "        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())",
            "def main():",
            "    N, M = map(int, input().split())",
            "    tree = WeightedUnionFind(N)",
            "    for _ in range(M):",
            "        l, r, d = map(int, input().split())",
            "        l, r = l-1, r-1",
            "        if tree.same(l, r):",
            "            dist = tree.diff(l, r)",
            "            if d != dist:",
            "                print(\"No\")",
            "                return",
            "        else:",
            "            tree.union(l, r, d)",
            "    print(\"Yes\")",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "class Coodinate (object):",
            "    \"\"\"Coodinate object",
            "    This class contains infomation about the coodinates.",
            "    Each instance can have up to 3-dimensional(x,y,z) space coodinates.",
            "    params",
            "    ------------------------------",
            "    x : int or floot ,default 0",
            "    y : int or floot ,default 0",
            "    z : int or floot ,default 0",
            "    This class have following methods.",
            "    ------------------------------",
            "    distance : Calculate the straight-line distance between 2 points in Euclidean space.",
            "    midpoint : Calculate the midpoint(halfway) between 2 points.",
            "    manhattan_distance : Calculate the distance between 2 points that is sum of the absolute values their Cartesian coordinates.",
            "    \"\"\"",
            "    def __init__(self,x=0,y=0,z=0):",
            "        self.x=x",
            "        self.y=y",
            "        self.z=z",
            "    def __str__(self):",
            "        if self.z==0:",
            "            if self.y==0:",
            "                return \"( {} )\".format(self.x)",
            "            else :",
            "                return \"( {} , {} )\".format(self.x,self.y)",
            "        else:",
            "            return \"( {} , {} , {} )\".format(self.x,self.y,self.z)",
            "    def distance(self,other):",
            "        \"\"\"Calculate the straight-line distance between 2 points in Euclidean space.",
            "        params",
            "        ----------",
            "        self : Coodinate object",
            "        other : Coodinate object",
            "        return",
            "        ----------",
            "        distance : floot",
            "        \"\"\"",
            "        x_diff_sq=(self.x-other.x)**2",
            "        y_diff_sq=(self.y-other.y)**2",
            "        z_diff_sq=(self.z-other.z)**2",
            "        return (x_diff_sq + y_diff_sq +z_diff_sq)**0.5",
            "    def midpoint(self,other):",
            "        \"\"\"Calculate the midpoint(halfway) between 2 points.",
            "        params",
            "        ----------",
            "        self : Coodinate object",
            "        other : Coodinate object",
            "        return",
            "        ----------",
            "        midpoint : tupul",
            "        \"\"\"",
            "        x_midpoint=(self.x+other.x)/2",
            "        y_midpoint=(self.y+other.y)/2",
            "        z_midpoint=(self.z+other.z)/2",
            "        if self.z == other.z ==0 :",
            "            if self.y == other.y==0:",
            "                return(x_midpoint)",
            "            else:",
            "                return(x_midpoint,y_midpoint)",
            "        return(x_midpoint,y_midpoint,z_midpoint)",
            "    def manhattan_distance(self,other):",
            "        \"\"\"Calculate the distance between 2 points that is sum of the absolute values their Cartesian coordinates.",
            "        params",
            "        ----------",
            "        self : Coodinate object",
            "        other : Coodinate object",
            "        return",
            "        ----------",
            "        manhattan_distance : floot",
            "        \"\"\"",
            "        x_diff_abs=abs(self.x - other.x)",
            "        y_diff_abs=abs(self.y - other.y)",
            "        z_diff_abs=abs(self.z - other.z)",
            "        return(x_diff_abs + y_diff_abs + z_diff_abs)",
            "# AtCoder Beginner Contest 086",
            "# C - Traveling",
            "N=int(input())",
            "T=0",
            "now=Coodinate()",
            "for i in range (N):",
            "    t, x, y =map(int,input().split())",
            "    time =t-T",
            "    location = Coodinate(x,y)",
            "    destination = Coodinate.manhattan_distance(location,now)",
            "    if time >= destination and time%2==destination%2:",
            "        T=t",
            "        now=location",
            "    else :",
            "        print(\"No\")",
            "        exit()",
            "print(\"Yes\")"
        ],
        "label": [
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            2,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def calc_min_attack(A, B, h):",
            "        n = len(A)",
            "        max_a_memo, max_a_ind = -1, -1",
            "        for i in range(n):",
            "            if A[i] > max_a_memo:",
            "                max_a_memo, max_a_ind = A[i], i",
            "        throw_off_damage = sorted([B[i] for i in range(n) if B[i] >= max_a_memo])",
            "        cnt = 0",
            "        if sum(throw_off_damage) >= h:",
            "            # 投げつけまくるだけ",
            "            while h > 0:",
            "                h -= throw_off_damage.pop()",
            "                cnt += 1",
            "            return cnt",
            "        else:",
            "            cnt += len(throw_off_damage)",
            "            h -= sum(throw_off_damage)",
            "            assert(h > 0)",
            "            return cnt + ((h + max_a_memo - 1) // max_a_memo)",
            "    n, h = mi()",
            "    A = []",
            "    B = []",
            "    for _ in range(n):",
            "        a, b = mi()",
            "        A.append(a)",
            "        B.append(b)",
            "    print(calc_min_attack(A, B, h))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "import math",
            "import copy",
            "import heapq",
            "from functools import cmp_to_key",
            "from bisect import bisect_left, bisect_right",
            "from collections import defaultdict, deque, Counter",
            "# sys.setrecursionlimit(1000000)",
            "# input aliases",
            "input = sys.stdin.readline",
            "getS = lambda: input().strip()",
            "getN = lambda: int(input())",
            "getList = lambda: list(map(int, input().split()))",
            "getZList = lambda: [int(x) - 1 for x in input().split()]",
            "INF = float(\"inf\")",
            "MOD = 10**9 + 7",
            "divide = lambda x: pow(x, MOD-2, MOD)",
            "def nck(n, k, kaijyo):",
            "    return (npk(n, k, kaijyo) * divide(kaijyo[k])) % MOD",
            "def npk(n, k, kaijyo):",
            "    if k == 0 or k == n:",
            "        return n % MOD",
            "    return (kaijyo[n] * divide(kaijyo[n-k])) % MOD",
            "def fact_and_inv(SIZE):",
            "    inv = [0] * SIZE  # inv[j] = j^{-1} mod MOD",
            "    fac = [0] * SIZE  # fac[j] = j! mod MOD",
            "    finv = [0] * SIZE  # finv[j] = (j!)^{-1} mod MOD",
            "    inv[1] = 1",
            "    fac[0] = fac[1] = 1",
            "    finv[0] = finv[1] = 1",
            "    for i in range(2, SIZE):",
            "        inv[i] = MOD - (MOD // i) * inv[MOD % i] % MOD",
            "        fac[i] = fac[i - 1] * i % MOD",
            "        finv[i] = finv[i - 1] * inv[i] % MOD",
            "    return fac, finv",
            "def renritsu(A, Y):",
            "    # example 2x + y = 3, x + 3y = 4",
            "    # A = [[2,1], [1,3]])",
            "    # Y = [[3],[4]] または [3,4]",
            "    A = np.matrix(A)",
            "    Y = np.matrix(Y)",
            "    Y = np.reshape(Y, (-1, 1))",
            "    X = np.linalg.solve(A, Y)",
            "    # [1.0, 1.0]",
            "    return X.flatten().tolist()[0]",
            "class TwoDimGrid:",
            "    # 2次元座標 -> 1次元",
            "    def __init__(self, h, w, wall=\"#\"):",
            "        self.h = h",
            "        self.w = w",
            "        self.size = (h+2) * (w+2)",
            "        self.wall = wall",
            "        self.get_grid()",
            "        # self.init_cost()",
            "    def get_grid(self):",
            "        grid = [self.wall * (self.w + 2)]",
            "        for i in range(self.h):",
            "            grid.append(self.wall + getS() + self.wall)",
            "        grid.append(self.wall * (self.w + 2))",
            "        self.grid = grid",
            "    def init_cost(self):",
            "        self.cost = [INF] * self.size",
            "    def pos(self, x, y):",
            "        # 壁も含めて0-indexed 元々の座標だけ考えると1-indexed",
            "        return y * (self.w + 2) + x",
            "    def getgrid(self, x, y):",
            "        return self.grid[y][x]",
            "    def get(self, x, y):",
            "        return self.cost[self.pos(x, y)]",
            "    def set(self, x, y, v):",
            "        self.cost[self.pos(x, y)] = v",
            "        return",
            "    def show(self):",
            "        for i in range(self.h+2):",
            "            print(self.cost[(self.w + 2) * i:(self.w + 2) * (i+1)])",
            "    def showsome(self, tgt):",
            "        for t in tgt:",
            "            print(t)",
            "        return",
            "    def showsomejoin(self, tgt):",
            "        for t in tgt:",
            "            print(\"\".join(t))",
            "        return",
            "    def search(self):",
            "        grid = self.grid",
            "        move = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
            "        move_eight = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]",
            "        # for i in range(1, self.h+1):",
            "        #     for j in range(1, self.w+1):",
            "        #         cx, cy = j, i",
            "        #         for dx, dy in move_eight:",
            "        #             nx, ny = dx + cx, dy + cy",
            "def sosu(n):",
            "    so = [1 for i in range(n+1)]",
            "    so[0], so[1] = 0, 0",
            "    for i in range(2, n+1):",
            "        if so[i]:",
            "            for j in range(2, n//i):",
            "                so[i * j] = 0",
            "    return so",
            "def solve():",
            "    # n, k = getList()",
            "    # nums = getList()",
            "    so = sosu(200000)",
            "    ok = [0 for i in range(200000)]",
            "    for i in range(1, 200000):",
            "        if i % 2:",
            "            if so[i] and so[int((i+1) // 2)]:",
            "                ok[i] = 1",
            "    for i in range(1, 200000):",
            "        ok[i] += ok[i-1]",
            "    # print(so)",
            "    # print(ok)",
            "    q = getN()",
            "    for i in range(q):",
            "        l, r = getList()",
            "        print(ok[r] - ok[l-1])",
            "def main():",
            "    n = getN()",
            "    for _ in range(n):",
            "        solve()",
            "    return",
            "if __name__ == \"__main__\":",
            "    # main()",
            "    solve()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            2,
            1,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    a, b, c, d = mi()",
            "    if a + b > c + d:",
            "        print('Left')",
            "    elif a + b == c + d:",
            "        print('Balanced')",
            "    else:",
            "        print('Right')",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import math",
            "#import sys",
            "#input = sys.stdin.readline",
            "def make_divisors(n):",
            "    divisors = []",
            "    for i in range(1, int(n**0.5)+1):",
            "        if n % i == 0:",
            "            divisors.append(i)",
            "            if i != n // i:",
            "                divisors.append(n//i)",
            "    # divisors.sort()",
            "    return divisors",
            "def ValueToBits(x,digit):",
            "    res = [0 for i in range(digit)]",
            "    now = x",
            "    for i in range(digit):",
            "        res[i]=now%2",
            "        now = now >> 1",
            "    return res",
            "def BitsToValue(arr):",
            "    n = len(arr)",
            "    ans = 0",
            "    for i in range(n):",
            "        ans+= arr[i] * 2**i",
            "    return ans",
            "def ZipArray(a):",
            "    aa = [[a[i],i]for i in range(n)]",
            "    aa.sort(key = lambda x : x[0])",
            "    for i in range(n):",
            "        aa[i][0]=i+1",
            "    aa.sort(key = lambda x : x[1])",
            "    b=[aa[i][0] for i in range(len(a))]",
            "    return b",
            "def ValueToArray10(x, digit):",
            "    ans = [0 for i in range(digit)]",
            "    now = x",
            "    for i in range(digit):",
            "        ans[digit-i-1] = now%10",
            "        now = now //10",
            "    return ans",
            "def Zeros(a,b):",
            "    if(b<=-1):",
            "        return [0 for i in range(a)]",
            "    else:",
            "        return [[0 for i in range(b)] for i in range(a)]",
            "def AddV2(v,w):",
            "    return [v[0]+w[0],v[1]+w[1]]",
            "dir4 = [[1,0],[0,1],[-1,0],[0,-1]]",
            "def clamp(x,y,z):",
            "    return max(y,min(z,x))",
            "class Bit:",
            "    def __init__(self, n):",
            "        self.size = n",
            "        self.tree = [0] * (n + 1)",
            "    def sum(self, i):",
            "        s = 0",
            "        while i > 0:",
            "            s += self.tree[i]",
            "            i -= i & -i",
            "        return s",
            "    def add(self, i, x):",
            "        while i <= self.size:",
            "            self.tree[i] += x",
            "            i += i & -i",
            "#",
            "def Zaatsu(a):",
            "    a.sort()",
            "    now = a[0][0]",
            "    od = 0",
            "    for i in range(n):",
            "        if(now==a[i][0]):",
            "            a[i][0]=od",
            "        else:",
            "            now = a[i][0]",
            "            od+=1",
            "            a[i][0] = od",
            "    a.sort(key = lambda x : x[1])",
            "    return a",
            "class UnionFind:",
            "    def __init__(self, n):",
            "        self.par = [i for i in range(n+1)]",
            "        self.rank = [0] * (n+1)",
            "    # 検索",
            "    def find(self, x):",
            "        if self.par[x] == x:",
            "            return x",
            "        else:",
            "            self.par[x] = self.find(self.par[x])",
            "            return self.par[x]",
            "    # 併合",
            "    def union(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "        if self.rank[x] < self.rank[y]:",
            "            self.par[x] = y",
            "        else:",
            "            self.par[y] = x",
            "            if self.rank[x] == self.rank[y]:",
            "                self.rank[x] += 1",
            "    # 同じ集合に属するか判定",
            "    def same_check(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "'''",
            "def cmb(n, r, p):",
            "    if (r < 0) or (n < r):",
            "        return 0",
            "    r = min(r, n - r)",
            "    return fact[n] * factinv[r] * factinv[n-r] % p",
            "p = 2",
            "N = 10 ** 6 + 2",
            "fact = [1, 1]  # fact[n] = (n! mod p)",
            "factinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)",
            "inv = [0, 1]  # factinv 計算用",
            "for i in range(2, N + 1):",
            "    fact.append((fact[-1] * i) % p)",
            "    inv.append((-inv[p % i] * (p // i)) % p)",
            "    factinv.append((factinv[-1] * inv[-1]) % p)",
            "'''",
            "def rl(x):",
            "    return range(len(x))",
            "# a = list(map(int, input().split()))",
            "#################################################",
            "#################################################",
            "#################################################",
            "#################################################",
            "#31-",
            "s = input()",
            "x,y = list(map(int, input().split()))",
            "now = 0",
            "right = 0",
            "while(True):",
            "    if(len(s)==now):",
            "        break",
            "    if(s[now]=='T'):",
            "        break",
            "    right+=1",
            "    now+=1",
            "#",
            "x -= right",
            "chain = 0",
            "xy = 0",
            "seg = [[],[]]",
            "while(True):",
            "    if(len(s)==now):",
            "        break",
            "    if(s[now]=='T'):",
            "        if(chain>0):",
            "            seg[xy].append(chain)",
            "            chain=0",
            "        xy = 1-xy",
            "    else:",
            "        chain+=1",
            "    now+=1",
            "if(chain>0):",
            "    seg[xy].append(chain)",
            "#print(seg,x,y)",
            "n = len(seg[0])",
            "m = sum(seg[0])",
            "if(abs(x)>m):",
            "    print(\"No\")",
            "    exit()",
            "dp=[[0 for i in range(m+1)] for i in range(n+1)]",
            "dp[0][0]=1",
            "for i in range(n):",
            "    nowlen = seg[0][i]",
            "    for j in range(m+1):",
            "        if(dp[i][j]==1):",
            "            if(j+nowlen<=m):",
            "                dp[i+1][j+nowlen]=1",
            "            if(j-nowlen>=0):",
            "                dp[i+1][j-nowlen]=1",
            "#print(dp)",
            "if(dp[-1][abs(x)]==0):",
            "    print(\"No\")",
            "    exit()",
            "n = len(seg[1])",
            "m = sum(seg[1])",
            "if(abs(y)>m):",
            "    print(\"No\")",
            "    exit()",
            "dp=[[0 for i in range(m+1)] for i in range(n+1)]",
            "dp[0][0]=1",
            "for i in range(n):",
            "    nowlen = seg[1][i]",
            "    for j in range(m+1):",
            "        if(dp[i][j]==1):",
            "            if(j+nowlen<=m):",
            "                dp[i+1][j+nowlen]=1",
            "            if(j-nowlen>=0):",
            "                dp[i+1][j-nowlen]=1",
            "#print(dp)",
            "if(dp[-1][abs(y)]==0):",
            "    print(\"No\")",
            "    exit()",
            "print(\"Yes\")"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            0,
            1,
            0,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            2,
            2
        ]
    },
    {
        "content": [
            "import sys",
            "import math",
            "import copy",
            "import random",
            "from heapq import heappush, heappop, heapify",
            "from functools import cmp_to_key",
            "from bisect import bisect_left, bisect_right",
            "from collections import defaultdict, deque, Counter",
            "# sys.setrecursionlimit(1000000)",
            "# input aliases",
            "input = sys.stdin.readline",
            "getS = lambda: input().strip()",
            "getN = lambda: int(input())",
            "getList = lambda: list(map(int, input().split()))",
            "getZList = lambda: [int(x) - 1 for x in input().split()]",
            "INF = float(\"inf\")",
            "MOD = 10**9 + 7",
            "divide = lambda x: pow(x, MOD-2, MOD)",
            "def nck(n, k, kaijyo):",
            "    return (npk(n, k, kaijyo) * divide(kaijyo[k])) % MOD",
            "def npk(n, k, kaijyo):",
            "    if k == 0 or k == n:",
            "        return n % MOD",
            "    return (kaijyo[n] * divide(kaijyo[n-k])) % MOD",
            "def fact_and_inv(SIZE):",
            "    inv = [0] * SIZE  # inv[j] = j^{-1} mod MOD",
            "    fac = [0] * SIZE  # fac[j] = j! mod MOD",
            "    finv = [0] * SIZE  # finv[j] = (j!)^{-1} mod MOD",
            "    inv[1] = 1",
            "    fac[0] = fac[1] = 1",
            "    finv[0] = finv[1] = 1",
            "    for i in range(2, SIZE):",
            "        inv[i] = MOD - (MOD // i) * inv[MOD % i] % MOD",
            "        fac[i] = fac[i - 1] * i % MOD",
            "        finv[i] = finv[i - 1] * inv[i] % MOD",
            "    return fac, finv",
            "def renritsu(A, Y):",
            "    # example 2x + y = 3, x + 3y = 4",
            "    # A = [[2,1], [1,3]])",
            "    # Y = [[3],[4]] または [3,4]",
            "    A = np.matrix(A)",
            "    Y = np.matrix(Y)",
            "    Y = np.reshape(Y, (-1, 1))",
            "    X = np.linalg.solve(A, Y)",
            "    # [1.0, 1.0]",
            "    return X.flatten().tolist()[0]",
            "class TwoDimGrid:",
            "    # 2次元座標 -> 1次元",
            "    def __init__(self, h, w, wall=\"#\"):",
            "        self.h = h",
            "        self.w = w",
            "        self.size = (h+2) * (w+2)",
            "        self.wall = wall",
            "        self.get_grid()",
            "        # self.init_cost()",
            "    def get_grid(self):",
            "        grid = [self.wall * (self.w + 2)]",
            "        for i in range(self.h):",
            "            grid.append(self.wall + getS() + self.wall)",
            "        grid.append(self.wall * (self.w + 2))",
            "        self.grid = grid",
            "    def init_cost(self):",
            "        self.cost = [INF] * self.size",
            "    def pos(self, x, y):",
            "        # 壁も含めて0-indexed 元々の座標だけ考えると1-indexed",
            "        return y * (self.w + 2) + x",
            "    def getgrid(self, x, y):",
            "        return self.grid[y][x]",
            "    def get(self, x, y):",
            "        return self.cost[self.pos(x, y)]",
            "    def set(self, x, y, v):",
            "        self.cost[self.pos(x, y)] = v",
            "        return",
            "    def show(self):",
            "        for i in range(self.h+2):",
            "            print(self.cost[(self.w + 2) * i:(self.w + 2) * (i+1)])",
            "    def showsome(self, tgt):",
            "        for t in tgt:",
            "            print(t)",
            "        return",
            "    def showsomejoin(self, tgt):",
            "        for t in tgt:",
            "            print(\"\".join(t))",
            "        return",
            "    def search(self):",
            "        grid = self.grid",
            "        move = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
            "        move_eight = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]",
            "        # for i in range(1, self.h+1):",
            "        #     for j in range(1, self.w+1):",
            "        #         cx, cy = j, i",
            "        #         for dx, dy in move_eight:",
            "        #             nx, ny = dx + cx, dy + cy",
            "def solve():",
            "    s = getS()",
            "    x, y = getList()",
            "    ls = len(s)",
            "    hori = True",
            "    h,v = [],[]",
            "    cnt = 0",
            "    for c in s:",
            "        if c == \"F\":",
            "            cnt += 1",
            "        else:",
            "            if hori:",
            "                h.append(cnt)",
            "            else:",
            "                v.append(cnt)",
            "            cnt = 0",
            "            hori = not hori",
            "    if cnt != 0:",
            "        if hori:",
            "            h.append(cnt)",
            "        else:",
            "            v.append(cnt)",
            "    # print(h, v)",
            "    x -= h[0]",
            "    h[0] = 0",
            "    dp = [0] * (ls * 2 + 100)",
            "    dp[ls + 50] = 1",
            "    for num in h:",
            "        tmp = [0] * (len(dp))",
            "        for i, d in enumerate(dp):",
            "            if d == 1:",
            "                tmp[i - num] = 1",
            "                tmp[i + num] = 1",
            "        dp = tmp",
            "    # print(dp)",
            "    if dp[x + ls + 50] == 0:",
            "        print(\"No\")",
            "        return",
            "    dp = [0] * (ls * 2 + 100)",
            "    dp[ls + 50] = 1",
            "    for num in v:",
            "        tmp = [0] * (len(dp))",
            "        for i, d in enumerate(dp):",
            "            if d == 1:",
            "                tmp[i - num] = 1",
            "                tmp[i + num] = 1",
            "        dp = tmp",
            "    # print(dp)",
            "    if dp[y + ls + 50] == 0:",
            "        print(\"No\")",
            "        return",
            "    print(\"Yes\")",
            "    return",
            "def main():",
            "    n = getN()",
            "    for _ in range(n):",
            "        s = \"\".join([random.choice([\"F\", \"T\"]) for i in range(20)])",
            "        print(s)",
            "        solve(s, 1, 0)",
            "    return",
            "if __name__ == \"__main__\":",
            "    # main()",
            "    solve()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            1,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def change_to_all_pos_or_all_neg(L):",
            "        n = len(L)",
            "        M = max(L)",
            "        M_ind = L.index(M)",
            "        m = min(L)",
            "        m_ind = L.index(m)",
            "        assert M > 0 and m < 0",
            "        if M >= abs(m):",
            "            for i in range(n):",
            "                L[i] += M",
            "            command = [[M_ind+1, i+1] for i in range(n)]",
            "        else:",
            "            for i in range(n):",
            "                L[i] += m",
            "            command = [[m_ind+1, i+1] for i in range(n)]",
            "        # print(L)    # kesu",
            "        return command",
            "    def change_to_non_increasing(L):",
            "        assert all(map(lambda x: x>=0, L)) or all(map(lambda x: x<=0, L))",
            "        all_positive = all(map(lambda x: x>=0, L))",
            "        pivot = max(L) if all_positive else min(L)",
            "        pivot_ind = L.index(pivot)",
            "        if all_positive:",
            "            command = [[pivot_ind+1, 1]] + [[i, i+1] for i in range(1, n)]",
            "        else:",
            "            command = [[pivot_ind+1, n]] + [[i, i-1] for i in range(n, 1, -1)]",
            "        return command",
            "    n = ii()",
            "    L = lmi()",
            "    command = []",
            "    if all(map(lambda x: x>=0, L)):",
            "        cnt = n",
            "        command += change_to_non_increasing(L)",
            "    elif all(map(lambda x: x<=0, L)):",
            "        cnt = n",
            "        command += change_to_non_increasing(L)",
            "    else:",
            "        cnt = 2 * n",
            "        command += change_to_all_pos_or_all_neg(L)",
            "        command += change_to_non_increasing(L)",
            "    print(cnt)",
            "    for a, b in command:",
            "        print(\"{} {}\".format(a, b))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# -*- coding: utf-8 -*-",
            "import io",
            "import sys",
            "import math",
            "# 0 - 2N回まで実行できる",
            "def add_x_to_y():",
            "    pass",
            "def is_condition_ok(lst):",
            "    for i in range(len(lst)-1):",
            "        if lst[i] > lst[i+1]:",
            "            return False",
            "    return True",
            "def check_plus_minus(lst):",
            "    # 戻り値：",
            "    # 正の値のみ：1, 負の値のみ：-1, 正負混在：0",
            "    p_flag = False",
            "    m_flag = False",
            "    for a in lst:",
            "        if a >= 0:",
            "            p_flag = True",
            "        else:",
            "            m_flag = True",
            "        if p_flag and m_flag:",
            "            return 0",
            "    return 1 if p_flag else -1",
            "# 経路が発見出来たら出力を整形する。",
            "def format_multi_answer(lst):",
            "    ans = \"\"",
            "    ans += f\"{len(lst)}\\n\"",
            "    for y in lst:",
            "        ans += f\"{y[0]} {y[1]}\\n\"",
            "    return ans",
            "def solve(n,a_lst):",
            "    \"\"\"",
            "    戦略A：",
            "    [全て正の場合]",
            "    ・左から、NGとなる値のiを得る。",
            "    ・その値に正の値を足し込む",
            "    　・リスト中、最大の正の値を足し込む",
            "    　　・iの値が最大となる",
            "    　・以後、右の値を全て更新する。最大でN-1回のオペレーションになる。",
            "    [全て負の場合]",
            "    ・同様に、右から探査し、最小の負の数を更新していく。最大でN-1回のオペレーションになる。",
            "    [正負混在する場合]",
            "    ・最大値/最小値を取る。",
            "    ・正負いずれかに揃える。（絶対値の大きい側に、全ての値を揃える）（最大でN-1回）",
            "    ・上記の正負処理をする。（最大でN-1回）",
            "    \"\"\"",
            "    # implement process",
            "    if is_condition_ok(a_lst):",
            "        return 0",
            "    plus_minus = check_plus_minus(a_lst)",
            "    ans_lst = []",
            "    if plus_minus == 1:",
            "        y = 0",
            "        for i in range(len(a_lst)-1):",
            "            if a_lst[i] > a_lst[i+1]:",
            "                y = i+1",
            "                break",
            "        x = -1",
            "        a_max = -1",
            "        for i in range(len(a_lst)):",
            "            if a_max < a_lst[i]:",
            "                a_max = a_lst[i]",
            "                x = i",
            "        ans_lst.append([x+1,y+1])",
            "        for i in range(y, len(a_lst)-1):",
            "            ans_lst.append([i+1,i+2])",
            "    elif plus_minus == -1:",
            "        y = 0",
            "        for i in range(len(a_lst)-1,0,-1):",
            "            if a_lst[i] < a_lst[i-1]:",
            "                y = i-1",
            "                break",
            "        x = +1",
            "        a_min = +1",
            "        for i in range(len(a_lst)):",
            "            if a_min > a_lst[i]:",
            "                a_min = a_lst[i]",
            "                x = i",
            "        ans_lst.append([x+1,y+1])",
            "        for i in range(y,0,-1):",
            "            ans_lst.append([i+1,i])",
            "    elif plus_minus == 0:",
            "        # get max / min value and index",
            "        i_max, a_max = -1,-1",
            "        i_min, a_min = +1,+1",
            "        for i in range(len(a_lst)):",
            "            if a_max < a_lst[i]:",
            "                a_max = a_lst[i]",
            "                i_max = i",
            "            if a_min > a_lst[i]:",
            "                a_min = a_lst[i]",
            "                i_min = i",
            "        if a_max > abs(a_min):",
            "            # まず、全ての負の値にmax値を足し込み、正の値にする。",
            "            # 次に、plus時の処理を行う。",
            "            for i in range(len(a_lst)):",
            "                if a_lst[i] < 0:",
            "                    a_lst[i] += a_max",
            "                    ans_lst.append([i_max+1,i+1])",
            "            if _DEB: logd(f\"lst: {a_lst}\")",
            "            y = -1",
            "            for i in range(len(a_lst)-1):",
            "                if a_lst[i] > a_lst[i+1]:",
            "                    y = i+1",
            "                    break",
            "            if y != -1:",
            "                ans_lst.append([i_max+1,y+1])",
            "                for i in range(y, len(a_lst)-1):",
            "                    ans_lst.append([i+1,i+2])",
            "        else:",
            "            # 全ての正の値を負の値にし、minus時の処理を行う。",
            "            for i in range(len(a_lst)):",
            "                if a_lst[i] >= 0:",
            "                    a_lst[i] += a_min",
            "                    ans_lst.append([i_min+1,i+1])",
            "            if _DEB: logd(f\"lst: {a_lst}\")",
            "            y = -1",
            "            for i in range(len(a_lst)-1,0,-1):",
            "                if a_lst[i] < a_lst[i-1]:",
            "                    y = i-1",
            "                    break",
            "            if y != -1:",
            "                ans_lst.append([i_min+1,y+1])",
            "                for i in range(y,0,-1):",
            "                    ans_lst.append([i+1,i])",
            "    return format_multi_answer(ans_lst)",
            "def main():",
            "    # input",
            "    n = int(input())",
            "    a_lst = list(map(int, input().split()))",
            "    # process",
            "    if _DEB: logd(f\"a_lst: {a_lst}\")",
            "    ans = str( solve(n,a_lst) ).strip()",
            "    # output",
            "    print(ans)",
            "    return ans",
            "### DEBUG I/O ###",
            "_DEB = 0   # 1:ON / 0:OFF",
            "_INPUT = \"\"\"\\",
            "2",
            "-1 -3",
            "\"\"\"",
            "_EXPECTED = \"\"\"\\",
            "2",
            "2 3",
            "3 3",
            "\"\"\"",
            "def logd(str):",
            "    \"\"\"usage:",
            "    if _DEB: logd(f\"{str}\")",
            "    \"\"\"",
            "    if _DEB: print(f\"[deb] {str}\")",
            "### MAIN ###",
            "if __name__ == \"__main__\":",
            "    if _DEB:",
            "        sys.stdin = io.StringIO(_INPUT)",
            "        print(\"!! Debug Mode !!\")",
            "    ans = main()",
            "    if _DEB:",
            "        print()",
            "        if _EXPECTED.strip() == ans.strip(): print(\"!! Success !!\")",
            "        else: print(f\"!! Failed... !!\\nANSWER:   {ans}\\nExpected: {_EXPECTED}\")"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def count_both_opened(pattern, seq):",
            "        cnt = 0",
            "        for i in range(len(pattern)):",
            "            if pattern[i] == 1 and seq[i] == 1:",
            "                cnt += 1",
            "        return cnt",
            "    n = ii()",
            "    opened = [lmi() for _ in range(n)]",
            "    profit = [lmi() for _ in range(n)]",
            "    max_profit = -inf",
            "    for pattern in product([1, 0], repeat=10):",
            "        money = 0",
            "        if any(pattern):",
            "            for i in range(n):",
            "                cnt = count_both_opened(pattern, opened[i])",
            "                money += profit[i][cnt]",
            "            # print(f\"{pattern} {money}\")",
            "            max_profit = max(max_profit, money)",
            "    print(max_profit)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def channel_seamless_join(channel):",
            "    \"\"\"",
            "    >>> channel_seamless_join([(1, 2), (2, 3), (7, 10), (5, 6), (10, 11)])",
            "    [(1, 3), (5, 6), (7, 11)]",
            "    \"\"\"",
            "    size = len(channel)",
            "    concatnated = []",
            "    channel.sort(key=itemgetter(0))",
            "    s_memo = -1",
            "    for i in range(size):",
            "        if s_memo < 0:",
            "            s_memo = channel[i][0]",
            "        if i != size - 1:",
            "            if channel[i][1] != channel[i+1][0]:",
            "                concatnated.append((s_memo, channel[i][1]))",
            "                s_memo = -1",
            "        else:",
            "            concatnated.append((s_memo, channel[i][1]))",
            "    return concatnated",
            "def calc_min_machine(seq):",
            "    h = []",
            "    cnt = 0",
            "    for s, t in seq:",
            "        if len(h) == 0 or h[0] > s:",
            "            cnt += 1",
            "        else:",
            "            heappop(h)",
            "        heappush(h, t+1)",
            "    return cnt",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, c = mi()",
            "    channels_list = [[] for _ in range(c)]",
            "    for _ in range(n):",
            "        s, t, c = mi()",
            "        c -= 1",
            "        channels_list[c].append((s, t))",
            "    seq = sum([channel_seamless_join(channel) for channel in channels_list], [])",
            "    # print(seq)",
            "    seq.sort(key=itemgetter(0))",
            "    print(calc_min_machine(seq))",
            "if __name__ == \"__main__\":",
            "    # import doctest",
            "    # doctest.testmod()",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    a, b = input().split()",
            "    if a < b:",
            "        print('<')",
            "    elif a == b:",
            "        print('=')",
            "    else:",
            "        print('>')",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n = ii()",
            "    k = ii()",
            "    num = 1",
            "    for _ in range(n):",
            "        num = min(num * 2, num + k)",
            "    print(num)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math, cmath",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import _heapify_max, _heappop_max, _siftdown_max",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    Num = Union[int, float]",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def isp():   return input().split()",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    # def _heappush_max(h, item): h.append(item); _siftdown_max(h, 0, len(h)-1)",
            "    n = ii()",
            "    L = lmi()",
            "    odd_count = 1",
            "    for i in range(n):",
            "        if L[i] % 2 == 0:",
            "            odd_count *= 2",
            "    print(pow(3, n) - odd_count)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math, cmath",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import _heapify_max, _heappop_max, _siftdown_max",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    Num = Union[int, float]",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def isp():   return input().split()",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def debug(x):print(x, file=sys.stderr)",
            "    # def _heappush_max(h, item): h.append(item); _siftdown_max(h, 0, len(h)-1)",
            "    def check_palindrome(s):",
            "        n = len(s)",
            "        for i in range(n//2):",
            "            if s[i] != s[n-1-i]:",
            "                return False",
            "        return True",
            "    def find_center(s, cnt):",
            "        num = 0",
            "        n = len(s)",
            "        for i in range(n):",
            "            if s[i] != 'x':",
            "                num += 1",
            "            if num == cnt:",
            "                return i",
            "    def find_center_even(s, cnt):",
            "        num = 0",
            "        n = len(s)",
            "        left, right = -1, -1",
            "        for i in range(n):",
            "            if s[i] != 'x':",
            "                num += 1",
            "            if num == cnt:",
            "                if left == -1:",
            "                    left = i",
            "                    debug(f\"left {left}\")",
            "            if num == cnt + 1:",
            "                right = i",
            "                debug(f\"right {right}\")",
            "                return (left + right) / 2",
            "    def not_x_split(s):",
            "        buf = []",
            "        s += 'E'",
            "        n = len(s)",
            "        x_cnt = 0",
            "        for i in range(n):",
            "            if s[i] != 'x':",
            "                buf.append(x_cnt)",
            "                x_cnt = 0",
            "            else:",
            "                x_cnt += 1",
            "        return buf",
            "    def solve(s, buf):",
            "        bufsize = len(buf)",
            "        if bufsize % 2 == 0:",
            "            cnt = bufsize // 2",
            "            ind = find_center_even(s, cnt)",
            "        else:",
            "            cnt = (bufsize + 1) // 2",
            "            ind = find_center(s, cnt)",
            "        if ind % 1 == 0:",
            "            left_s = s[:int(ind)][::-1]",
            "            right_s = s[int(ind)+1:]",
            "        else:",
            "            left_s = s[:int(ind)+1][::-1]",
            "            right_s = s[int(ind)+1:]",
            "        # print(f\"ind {ind}\")",
            "        # print(left_s)",
            "        # print(right_s)",
            "        left = not_x_split(left_s)",
            "        right = not_x_split(right_s)",
            "        # print(left)",
            "        # print(right)",
            "        assert len(left) == len(right)",
            "        ans = 0",
            "        for i in range(len(left)):",
            "            ans += max(left[i], right[i]) - min(left[i], right[i])",
            "        return ans",
            "    s = input()",
            "    if check_palindrome(s):",
            "        print(0)",
            "    else:",
            "        buf = [char for char in s if char != 'x']",
            "        if not check_palindrome(buf):",
            "            print(-1)",
            "        else:",
            "            # print('solve')",
            "            print(solve(s, buf))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "class Graph:",
            "    #入力定義",
            "    def __init__(self,vertex=[]):",
            "        self.vertex=list(vertex)",
            "        self.edge_number=0",
            "        self.adjacent={v:set() for v in vertex}",
            "    #頂点の追加",
            "    def add_vertex(self,*adder):",
            "        k=len(self.vertex)",
            "        m=0",
            "        for u in adder:",
            "            if u not in self.adjacent:",
            "                self.adjacent[u]=set()",
            "                self.vertex.append(u)",
            "    #辺の追加",
            "    def add_edge(self,From,To):",
            "        for w in [From,To]:",
            "            if w not in self.adjacent:",
            "                self.add_vertex(w)",
            "        if To not in self.adjacent[From]:",
            "            self.adjacent[From].add(To)",
            "            self.adjacent[To].add(From)",
            "            self.edge_number+=1",
            "    #辺を除く",
            "    def remove_edge(self,u,v):",
            "        for w in [u,v]:",
            "            if w not in self.adjacent:",
            "                self.add_vertex(w)",
            "        if u in self.adjacent[v]:",
            "            self.adjacent[u].remove(v)",
            "            self.adjacent[v].remove(u)",
            "            self.edge_number-=1",
            "    #頂点を除く",
            "    def remove_vertex(self,*v):",
            "        for w in v:",
            "            if w in self.adjacent:",
            "                self.edge_number-=len(self.adjacent[w])",
            "                for u in self.adjacent[w]:",
            "                    self.adjacent[u].remove(w)",
            "                del self.adjacent[w]",
            "    #Walkの追加",
            "    def add_walk(self,*walk):",
            "        n=len(walk)",
            "        for i in range(n-1):",
            "            self.add_edge(walk[i],walk[i+1])",
            "    #Cycleの追加",
            "    def add_cycle(self,*cycle):",
            "        self.add_walk(*cycle)",
            "        self.add_edge(cycle[-1],cycle[0])",
            "    #頂点の交換",
            "    def __vertex_swap(self,p,q):",
            "        self.vertex.sort()",
            "    #グラフに頂点が存在するか否か",
            "    def vertex_exist(self,v):",
            "        return v in self.adjacent",
            "    #グラフに辺が存在するか否か",
            "    def edge_exist(self,u,v):",
            "        if not(self.vertex_exist(u) and self.vertex_exist(v)):",
            "            return False",
            "        return u in self.adjacent[v]",
            "    #近傍",
            "    def neighbohood(self,v):",
            "        if not self.vertex_exist(v):",
            "            return []",
            "        return list(self.adjacent[v])",
            "    #次数",
            "    def degree(self,v):",
            "        if not self.vertex_exist(v):",
            "            return 0",
            "        return len(self.adjacent[v])",
            "    #頂点数",
            "    def vertex_count(self):",
            "        return len(self.vertex)",
            "    #辺数",
            "    def edge_count(self):",
            "        return self.edge_number",
            "    #頂点vを含む連結成分",
            "    def connected_component(self,v):",
            "        if v not in self.adjacent:",
            "            return []",
            "        from collections import deque",
            "        T={u:False for u in self.adjacent}",
            "        T[v]=True",
            "        S=deque([v])",
            "        while S:",
            "            u=S.popleft()",
            "            for w in self.adjacent[u]:",
            "                if not T[w]:",
            "                    T[w]=True",
            "                    S.append(w)",
            "        return [x for x in self.adjacent if T[x]]",
            "    #距離",
            "    def distance(self,u,v):",
            "        from collections import deque",
            "        inf=float(\"inf\")",
            "        T={v:inf  for v in G.vertex}",
            "        if u==v:",
            "            return 0",
            "        Q=deque([u])",
            "        T[u]=0",
            "        while Q:",
            "            w=Q.popleft()",
            "            for x in G.adjacent[w]:",
            "                if T[x]==inf:",
            "                    T[x]=T[w]+1",
            "                    Q.append(x)",
            "                    if x==v:",
            "                        return T[x]",
            "        return inf",
            "    #最短路",
            "    def shortest_path(self,u,v):",
            "        from collections import deque",
            "        inf=float(\"inf\")",
            "        T={v:[] for v in G.vertex}",
            "        if u==v:",
            "            return 0",
            "        Q=deque([u])",
            "        T[u]=[u]",
            "        while Q:",
            "            w=Q.popleft()",
            "            for x in G.adjacent[w]:",
            "                if not T[x]:",
            "                    T[x]=T[w]+[x]",
            "                    Q.append(x)",
            "                    if x==v:",
            "                        return T[x]",
            "        return None",
            "#連結成分の個数",
            "def Connected_Component_Number(G):",
            "    T={v:False for v in G.vertex}",
            "    C=0",
            "    for v in G.vertex:",
            "        if not T[v]:",
            "            X=G.connected_component(v)",
            "            for x in X:",
            "                T[x]=True",
            "            C+=1",
            "    return C",
            "#---------------------------------------------------------------------",
            "N,M=map(int,input().split())",
            "G=Graph(list(range(1,N+1)))",
            "E=[]",
            "for _ in range(M):",
            "    a,b=map(int,input().split())",
            "    G.add_edge(a,b)",
            "    E.append((a,b))",
            "K=Connected_Component_Number(G)",
            "X=0",
            "for a,b in E:",
            "    G.remove_edge(a,b)",
            "    if Connected_Component_Number(G)!=K:",
            "        X+=1",
            "    G.add_edge(a,b)",
            "print(X)"
        ],
        "label": [
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2
        ]
    },
    {
        "content": [
            "import sys, math",
            "from collections import defaultdict",
            "from itertools import product",
            "sys.setrecursionlimit(500000)",
            "MOD = 10**9+7",
            "def input():",
            "    return sys.stdin.readline()[:-1]",
            "def mi():",
            "    return map(int, input().split())",
            "def ii():",
            "    return int(input())",
            "def i2(n):",
            "    tmp = [list(mi()) for i in range(n)]",
            "    return [list(i) for i in zip(*tmp)]",
            "class Graph:",
            "    #グラフを表す",
            "    # 頂点につけるlabelの初期値（ラベリングされていないことを示す値）",
            "    no_labeling_num = -1",
            "    class Vertex:",
            "        # 頂点を表す",
            "        def __init__(self, g, no, label):",
            "            \"\"\"",
            "            :param g: グラフを表す。またVertexを所有するオブジェクトでもある",
            "            :param no: 頂点にグラフのなかで一意に割り振られた識別用の番号",
            "            :param label: 探索された順番を表す番号。ラベル。",
            "            \"\"\"",
            "            self.no = no",
            "            self.g = g",
            "            self.label = label",
            "        def __str__(self):",
            "            \"\"\"",
            "            \"\"\"",
            "            return \"no:{0},label:{1}\".format(self.no,self.label)",
            "        def adjacentVs(self):",
            "            \"\"\" selfと隣接している頂点のリストを返す",
            "            :return:",
            "            \"\"\"",
            "            result = []",
            "            for c in range(self.g.order):",
            "                if self.g.aDJM[self.no][c] == 1:",
            "                    result.append((self.g.vs[c]))",
            "            return result",
            "        def back_to_previous(self):",
            "            \"\"\" 前に探索した頂点を返す（厳密な表現ではない）",
            "            詳細",
            "            ・この頂点に隣接する頂点において、ラベル付けされていない（未探索）なものがないときに、",
            "            次に探索する頂点を返す関数",
            "            ・自身のラベル番号より小さい頂点の中で一番近いものを返す",
            "            ・存在しないときは「None」を返す",
            "            :return:",
            "            \"\"\"",
            "            result = None",
            "            vs = list(filter(lambda x: self.label > x.label, self.adjacentVs()))",
            "            if vs != []:",
            "                result = vs[0]",
            "                key0 = self.label - result.label",
            "                for v in vs:",
            "                    key1 = self.label - v.label",
            "                    if (key1 < key0):",
            "                        key0 = key1",
            "                        result = v",
            "            return result",
            "    def __init__(self, aDJM):",
            "        \"\"\"",
            "        :param aDJM:隣接行列",
            "        \"\"\"",
            "        self.aDJM = aDJM",
            "        self.order = len(aDJM)",
            "        self.vs = [Graph.Vertex(self, i, self.no_labeling_num) for i in range(self.order)]",
            "    def no_labelingVs(self, vs):",
            "        \"\"\" 渡された頂点リストにおいてlabelingされていない頂点のリストを返す",
            "        :return:",
            "        \"\"\"",
            "        result = []",
            "        for v in vs:",
            "            if v.label == self.no_labeling_num:",
            "                result.append(v)",
            "        return result",
            "    def isconnected(self):",
            "        \"\"\" このグラフが連結グラフであるかどうかを判定する",
            "        :return:",
            "        \"\"\"",
            "        label = 0",
            "        v = self.vs[0]",
            "        v.label = label",
            "        # 最初に探索した頂点が孤立点である場合に対処するための条件",
            "        if v.adjacentVs()==[]:",
            "            v=None",
            "        else:",
            "            v = v.adjacentVs()[0]",
            "            label += 1",
            "            v.label = label",
            "        while (v != None):  # 現在探索中の頂点のラベルが0かつその点に隣接する頂点すべてが探索ずみだったら終了するようにする",
            "            vs = self.no_labelingVs(v.adjacentVs())",
            "            if vs == []:",
            "                v = v.back_to_previous()",
            "            else:",
            "                v = vs[0]",
            "                label += 1",
            "                v.label = label",
            "        return not(self.no_labeling_num in list(map(lambda x:x.label,self.vs)))",
            "def main():",
            "    N, M = mi()",
            "    aDJM = [[0]*N for i in range(N)]",
            "    a, b = i2(M)",
            "    cnt = 0",
            "    for i in range(M):",
            "        aDJM[a[i]-1][b[i]-1] = 1",
            "        aDJM[b[i]-1][a[i]-1] = 1",
            "    for i in range(M):",
            "        aDJM[a[i]-1][b[i]-1] = 0",
            "        aDJM[b[i]-1][a[i]-1] = 0",
            "        if not Graph(aDJM).isconnected():",
            "            cnt += 1",
            "        aDJM[a[i]-1][b[i]-1] = 1",
            "        aDJM[b[i]-1][a[i]-1] = 1",
            "    print(cnt)",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "#####################################################################################################",
            "##### Low Link (橋、関節点)",
            "#####################################################################################################",
            "\"\"\"",
            "計算量",
            "O(V+E)",
            "参考",
            "https://algo-logic.info/bridge-lowlink/",
            "\"\"\"",
            "import sys",
            "input = sys.stdin.readline",
            "import marshal",
            "class Graph:",
            "    def __init__(self, n, dictated=False, decrement=True, destroy=False, edges=[]):",
            "        self.n = n",
            "        self.dictated = dictated",
            "        self.decrement = decrement",
            "        self.destroy = destroy",
            "        self.edges = [set() for _ in range(self.n)]",
            "        self.parent = [-1]*self.n",
            "        for x, y in edges:",
            "            self.add_edge(x,y)",
            "    def add_edge(self, x, y):",
            "        if self.decrement:",
            "            x -= 1",
            "            y -= 1",
            "        self.edges[x].add(y)",
            "        if self.dictated == False:",
            "            self.edges[y].add(x)",
            "    def add_adjacent_list(self, i, adjacent_list):",
            "        if self.decrement:",
            "            self.edges[i] = set(map(lambda x: x - 1, adjacent_list))",
            "        else:",
            "            self.edges[i] = set(adjacent_list)",
            "    def bridge_detector(self, articular_list=False):",
            "        \"\"\"",
            "        :param p: スタート地点",
            "        :param save: True = 前回の探索結果を保持する",
            "        :param articular_list: True = 関節点のリストを返す",
            "        :return: 各点までの距離と何番目に発見したかを返す",
            "        \"\"\"",
            "        if self.destroy:",
            "            edge2 = self.edges",
            "        else:",
            "            edge2 = marshal.loads(marshal.dumps(self.edges))",
            "        start, time = 0, 0",
            "        p, t = start, time",
            "        self.parent[p] = -2",
            "        ord = [-1]*self.n       # ord = DFS で頂点 q を何番目に探索したか",
            "        ord[p] = t",
            "        low = [-1]*self.n       # low = q からの 0 回以上木辺を使って前進し、後退辺を1回以下使って後退する事で到達できる頂点 p について、ord[p] の最小値",
            "        low[p] = 0",
            "        articular = []          # 関節点の集合",
            "        bridge = []             # 橋の集合",
            "        if len(edge2[p]) >= 2:",
            "            \"\"\" 根に子が二つ異常存在する場合は、根も関節点 \"\"\"",
            "            articular.append(p)",
            "        while True:",
            "            if edge2[p]:",
            "                q = edge2[p].pop()",
            "                if q == self.parent[p] and not self.dictated:",
            "                    \"\"\" 逆流した時の処理 \"\"\"",
            "                    \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"",
            "                    continue",
            "                if self.parent[q] != -1:",
            "                    \"\"\" サイクルで同一点を訪れた時の処理 \"\"\"",
            "                    if ord[q] < low[p]:",
            "                        low[p] = ord[q]",
            "                    \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"",
            "                    continue",
            "                \"\"\" p から q への引継ぎ\"\"\"",
            "                \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"",
            "                ord[q] = low[q] = t + 1",
            "                self.parent[q] = p",
            "                p, t = q, t + 1",
            "            else:",
            "                if p == start and t == time:",
            "                    break",
            "                \"\"\" p から進める点がもう無い時の点 p における処理 \"\"\"",
            "                parent_p = self.parent[p]",
            "                if low[p] < low[parent_p]:",
            "                    low[parent_p] = low[p]",
            "                \"\"\" この時点でlow[p]が確定するので、ord[parent[p]] ≤ low[p] を判定しておく\"\"\"",
            "                if ord[parent_p] <= low[p]:",
            "                    if ord[parent_p]:",
            "                        articular.append(parent_p + self.decrement)",
            "                    if ord[parent_p] < low[p]:",
            "                        bridge.append((parent_p + self.decrement, p + self.decrement))",
            "                \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"",
            "                p, t = self.parent[p], t - 1",
            "                \"\"\" 点 p から親ノードに戻ってきた時の親ノードにおける処理 \"\"\"",
            "                \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"",
            "        if articular_list == False:",
            "            return bridge",
            "        else:",
            "            return articular",
            "    def draw(self):",
            "        \"\"\"",
            "        :return: グラフを可視化",
            "        \"\"\"",
            "        import matplotlib.pyplot as plt",
            "        import networkx as nx",
            "        if self.dictated:",
            "            G = nx.DiGraph()",
            "        else:",
            "            G = nx.Graph()",
            "        for x in range(self.n):",
            "            for y in self.edges[x]:",
            "                G.add_edge(x + self.decrement, y + self.decrement)",
            "        nx.draw_networkx(G)",
            "        plt.show()",
            "def inc(A):",
            "    return list(map(lambda x: x+1, A))",
            "def dec(A):",
            "    return list(map(lambda x: x-1, A))",
            "###############################################################################################",
            "N, M = map(int, input().split())",
            "graph = Graph(N, dictated=False, decrement=True, destroy=False)",
            "for _ in range(M):",
            "    x, y = map(int, input().split())",
            "    graph.add_edge(x, y)",
            "print(len(graph.bridge_detector(articular_list=False)))",
            "# graph.draw()",
            "\"\"\"",
            "9 10",
            "7 8",
            "8 9",
            "3 6",
            "9 2",
            "1 2",
            "2 3",
            "3 4",
            "4 5",
            "5 6",
            "6 7",
            "\"\"\""
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "import sys",
            "from sys import exit",
            "from collections import deque",
            "from copy import deepcopy",
            "from bisect import bisect_left, bisect_right, insort_left, insort_right",
            "from heapq import heapify, heappop, heappush",
            "from itertools import product, permutations, combinations, combinations_with_replacement",
            "from functools import reduce",
            "from math import gcd, sin, cos, tan, asin, acos, atan, degrees, radians",
            "sys.setrecursionlimit(10**6)",
            "INF = 10**20",
            "eps = 1.0e-20",
            "MOD = 10**9+7",
            "def lcm(x,y):",
            "    return x*y//gcd(x,y)",
            "def lgcd(l):",
            "    return reduce(gcd,l)",
            "def llcm(l):",
            "    return reduce(lcm,l)",
            "def powmod(n,i,mod=MOD):",
            "    return pow(n,mod-1+i,mod) if i<0 else pow(n,i,mod)",
            "def div2(x):",
            "    return x.bit_length()",
            "def div10(x):",
            "    return len(str(x))-(x==0)",
            "def intput():",
            "    return int(input())",
            "def mint():",
            "    return map(int,input().split())",
            "def lint():",
            "    return list(map(int,input().split()))",
            "def ilint():",
            "    return int(input()), list(map(int,input().split()))",
            "def judge(x, l=['Yes', 'No']):",
            "    print(l[0] if x else l[1])",
            "def lprint(l, sep='\\n'):",
            "    for x in l:",
            "        print(x, end=sep)",
            "def ston(c, c0='a'):",
            "    return ord(c)-ord(c0)",
            "def ntos(x, c0='a'):",
            "    return chr(x+ord(c0))",
            "class counter(dict):",
            "    def __init__(self, *args):",
            "        super().__init__(args)",
            "    def add(self,x,d=1):",
            "        self.setdefault(x,0)",
            "        self[x] += d",
            "    def list(self):",
            "        l = []",
            "        for k in self:",
            "            l.extend([k]*self[k])",
            "        return l",
            "class comb():",
            "    def __init__(self, n, mod=None):",
            "        self.l = [1]",
            "        self.n = n",
            "        self.mod = mod",
            "    def get(self,k):",
            "        l,n,mod = self.l, self.n, self.mod",
            "        k = n-k if k>n//2 else k",
            "        while len(l)<=k:",
            "            i = len(l)",
            "            l.append(l[i-1]*(n+1-i)//i if mod==None else (l[i-1]*(n+1-i)*powmod(i,-1,mod))%mod)",
            "        return l[k]",
            "def pf(x,mode='counter'):",
            "    C = counter()",
            "    p = 2",
            "    while x>1:",
            "        k = 0",
            "        while x%p==0:",
            "            x //= p",
            "            k += 1",
            "        if k>0:",
            "            C.add(p,k)",
            "        p = p+2-(p==2) if p*p<x else x",
            "    if mode=='counter':",
            "        return C",
            "    S = set([1])",
            "    for k in C:",
            "        T = deepcopy(S)",
            "        for x in T:",
            "            for i in range(1,C[k]+1):",
            "                S.add(x*(k**i))",
            "    if mode=='set':",
            "        return S",
            "    if mode=='list':",
            "        return sorted(list(S))",
            "class UnionFind():",
            "    # インデックスは0-start",
            "    # 初期化",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parents = [-1]*n",
            "        self.group = n",
            "    # private function",
            "    def root(self, x):",
            "        if self.parents[x]<0:",
            "            return x",
            "        else:",
            "            self.parents[x] = self.root(self.parents[x])",
            "            return self.parents[x]",
            "    # x,yが属するグループの結合",
            "    def union(self, x, y):",
            "        x = self.root(x)",
            "        y = self.root(y)",
            "        if x==y:",
            "            return",
            "        if self.parents[x]>self.parents[y]:",
            "            x,y = y,x",
            "        self.parents[x] += self.parents[y]",
            "        self.parents[y] = x",
            "        self.group -= 1",
            "    # x,yが同グループか判定",
            "    def same(self, x, y):",
            "        return self.root(x)==self.root(y)",
            "    # xと同じグループの要素数を取得",
            "    def size(self, x):",
            "        return -self.parents[self.root(x)]",
            "######################################################",
            "N,M=mint()",
            "node=[]",
            "for _ in range(M):",
            "    node.append(lint())",
            "ans=0",
            "for i in range(M):",
            "    t=UnionFind(N)",
            "    for j in range(M):",
            "        if j!=i:",
            "            t.union(node[j][0]-1,node[j][1]-1)",
            "    if t.size(0)<N:",
            "        ans+=1",
            "print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            0,
            2,
            1,
            2,
            1,
            2,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            2,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            0,
            2
        ]
    },
    {
        "content": [
            "import math",
            "#import sys",
            "#input = sys.stdin.readline",
            "def make_divisors(n):",
            "    divisors = []",
            "    for i in range(1, int(n**0.5)+1):",
            "        if n % i == 0:",
            "            divisors.append(i)",
            "            if i != n // i:",
            "                divisors.append(n//i)",
            "    # divisors.sort()",
            "    return divisors",
            "def ValueToBits(x,digit):",
            "    res = [0 for i in range(digit)]",
            "    now = x",
            "    for i in range(digit):",
            "        res[i]=now%2",
            "        now = now >> 1",
            "    return res",
            "def BitsToValue(arr):",
            "    n = len(arr)",
            "    ans = 0",
            "    for i in range(n):",
            "        ans+= arr[i] * 2**i",
            "    return ans",
            "def ZipArray(a):",
            "    aa = [[a[i],i]for i in range(n)]",
            "    aa.sort(key = lambda x : x[0])",
            "    for i in range(n):",
            "        aa[i][0]=i+1",
            "    aa.sort(key = lambda x : x[1])",
            "    b=[aa[i][0] for i in range(len(a))]",
            "    return b",
            "def ValueToArray10(x, digit):",
            "    ans = [0 for i in range(digit)]",
            "    now = x",
            "    for i in range(digit):",
            "        ans[digit-i-1] = now%10",
            "        now = now //10",
            "    return ans",
            "def Zeros(a,b):",
            "    if(b<=-1):",
            "        return [0 for i in range(a)]",
            "    else:",
            "        return [[0 for i in range(b)] for i in range(a)]",
            "def AddV2(v,w):",
            "    return [v[0]+w[0],v[1]+w[1]]",
            "dir4 = [[1,0],[0,1],[-1,0],[0,-1]]",
            "def clamp(x,y,z):",
            "    return max(y,min(z,x))",
            "class Bit:",
            "    def __init__(self, n):",
            "        self.size = n",
            "        self.tree = [0] * (n + 1)",
            "    def sum(self, i):",
            "        s = 0",
            "        while i > 0:",
            "            s += self.tree[i]",
            "            i -= i & -i",
            "        return s",
            "    def add(self, i, x):",
            "        while i <= self.size:",
            "            self.tree[i] += x",
            "            i += i & -i",
            "#",
            "def Zaatsu(a):",
            "    a.sort()",
            "    now = a[0][0]",
            "    od = 0",
            "    for i in range(n):",
            "        if(now==a[i][0]):",
            "            a[i][0]=od",
            "        else:",
            "            now = a[i][0]",
            "            od+=1",
            "            a[i][0] = od",
            "    a.sort(key = lambda x : x[1])",
            "    return a",
            "class UnionFind:",
            "    def __init__(self, n):",
            "        self.par = [i for i in range(n+1)]",
            "        self.rank = [0] * (n+1)",
            "    # 検索",
            "    def find(self, x):",
            "        if self.par[x] == x:",
            "            return x",
            "        else:",
            "            self.par[x] = self.find(self.par[x])",
            "            return self.par[x]",
            "    # 併合",
            "    def union(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "        if self.rank[x] < self.rank[y]:",
            "            self.par[x] = y",
            "        else:",
            "            self.par[y] = x",
            "            if self.rank[x] == self.rank[y]:",
            "                self.rank[x] += 1",
            "    # 同じ集合に属するか判定",
            "    def same_check(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "'''",
            "def cmb(n, r, p):",
            "    if (r < 0) or (n < r):",
            "        return 0",
            "    r = min(r, n - r)",
            "    return fact[n] * factinv[r] * factinv[n-r] % p",
            "p = 2",
            "N = 10 ** 6 + 2",
            "fact = [1, 1]  # fact[n] = (n! mod p)",
            "factinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)",
            "inv = [0, 1]  # factinv 計算用",
            "for i in range(2, N + 1):",
            "    fact.append((fact[-1] * i) % p)",
            "    inv.append((-inv[p % i] * (p // i)) % p)",
            "    factinv.append((factinv[-1] * inv[-1]) % p)",
            "'''",
            "def rl(x):",
            "    return range(len(x))",
            "# a = list(map(int, input().split()))",
            "#################################################",
            "#################################################",
            "#################################################",
            "#################################################",
            "#46-",
            "n,K = list(map(int, input().split()))",
            "xy = []",
            "xs = {}",
            "ys = {}",
            "for i in range(n):",
            "    xy.append(list(map(int, input().split())))",
            "    xs[xy[-1][0]]=1",
            "    ys[xy[-1][1]]=1",
            "xs = list(xs)",
            "ys = list(ys)",
            "xs.sort()",
            "ys.sort()",
            "nx = len(xs)",
            "ny = len(ys)",
            "ans = 10**19",
            "#print(xs)",
            "#print(ys)",
            "for i1 in range(ny):",
            "    for i2 in range(i1):",
            "        yd = ys[i2]",
            "        yu = ys[i1]",
            "        li = 0",
            "        ri = 1",
            "        t=0",
            "        while(True):",
            "            count = 0",
            "            t+=1",
            "            l = xs[li]",
            "            r = xs[ri]",
            "            #print(i2,i1,li,ri)",
            "            for j in range(n):",
            "                if(xy[j][0]>=l and xy[j][0]<=r and xy[j][1]>=yd and xy[j][1] <= yu):",
            "                    count += 1",
            "            #print('count',count,K)",
            "            if(count == K):",
            "                ans = min(ans,(r-l)*(yu-yd))",
            "            if(count<K):",
            "                #print('ri',ri)",
            "                if(ri == n-1):",
            "                    #print('b')",
            "                    break",
            "                else:",
            "                    ri+=1",
            "                    continue",
            "            elif(count >= K):",
            "                li += 1",
            "                #print('li',li)",
            "                continue",
            "print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            0,
            1,
            0,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2
        ]
    },
    {
        "content": [
            "# -*- coding: utf-8 -*-",
            "import sys",
            "import math",
            "import os",
            "import itertools",
            "import string",
            "import heapq",
            "import _collections",
            "from collections import Counter",
            "from collections import defaultdict",
            "from functools import lru_cache",
            "import bisect",
            "import re",
            "import queue",
            "class Scanner():",
            "    @staticmethod",
            "    def int():",
            "        return int(sys.stdin.readline().rstrip())",
            "    @staticmethod",
            "    def string():",
            "        return sys.stdin.readline().rstrip()",
            "    @staticmethod",
            "    def map_int():",
            "        return [int(x) for x in Scanner.string().split()]",
            "    @staticmethod",
            "    def string_list(n):",
            "        return [input() for i in range(n)]",
            "    @staticmethod",
            "    def int_list_list(n):",
            "        return [Scanner.map_int() for i in range(n)]",
            "    @staticmethod",
            "    def int_cols_list(n):",
            "        return [int(input()) for i in range(n)]",
            "class Math():",
            "    @staticmethod",
            "    def gcd(a, b):",
            "        if b == 0:",
            "            return a",
            "        return Math.gcd(b, a % b)",
            "    @staticmethod",
            "    def lcm(a, b):",
            "        return (a * b) // Math.gcd(a, b)",
            "    @staticmethod",
            "    def roundUp(a, b):",
            "        return -(-a // b)",
            "    @staticmethod",
            "    def toUpperMultiple(a, x):",
            "        return Math.roundUp(a, x) * x",
            "    @staticmethod",
            "    def toLowerMultiple(a, x):",
            "        return (a // x) * x",
            "    @staticmethod",
            "    def nearPow2(n):",
            "        if n <= 0:",
            "            return 0",
            "        if n & (n - 1) == 0:",
            "            return n",
            "        ret = 1",
            "        while(n > 0):",
            "            ret <<= 1",
            "            n >>= 1",
            "        return ret",
            "    @staticmethod",
            "    def sign(n):",
            "        if n == 0:",
            "            return 0",
            "        if n < 0:",
            "            return -1",
            "        return 1",
            "    @staticmethod",
            "    def isPrime(n):",
            "        if n < 2:",
            "            return False",
            "        if n == 2:",
            "            return True",
            "        if n % 2 == 0:",
            "            return False",
            "        d = int(n ** 0.5) + 1",
            "        for i in range(3, d + 1, 2):",
            "            if n % i == 0:",
            "                return False",
            "        return True",
            "class PriorityQueue:",
            "    def __init__(self, l=[]):",
            "        self.__q = l",
            "        heapq.heapify(self.__q)",
            "        return",
            "    def push(self, n):",
            "        heapq.heappush(self.__q, n)",
            "        return",
            "    def pop(self):",
            "        return heapq.heappop(self.__q)",
            "sys.setrecursionlimit(1000000)",
            "MOD = int(1e09) + 7",
            "INF = int(1e30)",
            "def main():",
            "    # sys.stdin = open(\"Sample.txt\")",
            "    N, K = Scanner.map_int()",
            "    X = [0] * N",
            "    Y = [0] * N",
            "    for i in range(N):",
            "        x, y = Scanner.map_int()",
            "        X[i] = x",
            "        Y[i] = y",
            "    sx = sorted(X)",
            "    sy = sorted(Y)",
            "    ans = INF",
            "    for l in range(N-1):",
            "        for r in range(l+1, N):",
            "            for b in range(N-1):",
            "                for t in range(b+1, N):",
            "                    left = sx[l]",
            "                    right = sx[r]",
            "                    bottom = sy[b]",
            "                    top = sy[t]",
            "                    cnt = 0",
            "                    for i in range(N):",
            "                        if left <= X[i] <= right and bottom <= Y[i] <= top:",
            "                            cnt += 1",
            "                    if cnt >= K:",
            "                        ans = min(ans, (right-left)*(top-bottom))",
            "    print(ans)",
            "    return",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "from collections import defaultdict",
            "from collections import deque",
            "from heapq import heappush, heappop",
            "import sys",
            "import math",
            "import bisect",
            "import random",
            "import itertools",
            "sys.setrecursionlimit(10**5)",
            "stdin = sys.stdin",
            "bisect_left = bisect.bisect_left",
            "bisect_right = bisect.bisect_right",
            "def LI(): return list(map(int, stdin.readline().split()))",
            "def LF(): return list(map(float, stdin.readline().split()))",
            "def LI_(): return list(map(lambda x: int(x)-1, stdin.readline().split()))",
            "def II(): return int(stdin.readline())",
            "def IF(): return float(stdin.readline())",
            "def LS(): return list(map(list, stdin.readline().split()))",
            "def S(): return list(stdin.readline().rstrip())",
            "def IR(n): return [II() for _ in range(n)]",
            "def LIR(n): return [LI() for _ in range(n)]",
            "def FR(n): return [IF() for _ in range(n)]",
            "def LFR(n): return [LI() for _ in range(n)]",
            "def LIR_(n): return [LI_() for _ in range(n)]",
            "def SR(n): return [S() for _ in range(n)]",
            "def LSR(n): return [LS() for _ in range(n)]",
            "mod = 1000000007",
            "inf = float('INF')",
            "move = [(0, 1), (1, 1), (-1, 1), (0, -1), (1, -1), (-1, -1), (1, 0), (-1, 0)]",
            "#A",
            "def A():",
            "    a, b, c = LI()",
            "    if a == b:",
            "        print(c)",
            "    if b == c:",
            "        print(a)",
            "    if a == c:",
            "        print(b)",
            "    return",
            "#B",
            "def B():",
            "    h, w = LI()",
            "    s = SR(h)",
            "    for y in range(h):",
            "        for x in range(w):",
            "            if s[y][x] == \".\":",
            "                b = 0",
            "                for my, mx in move:",
            "                    ym = my + y",
            "                    xm = mx + x",
            "                    if 0 <= ym < h and 0 <= xm < w:",
            "                        if s[ym][xm] == \"#\":",
            "                            b += 1",
            "                s[y][x] = b",
            "    for i in range(h):",
            "        print(\"\".join(map(str, s[i])))",
            "    return",
            "#C",
            "def C():",
            "    n, m = LI()",
            "    edg = [[] for i in range(n)]",
            "    ab = LIR_(m)",
            "    for a,b in ab:",
            "        edg[a].append(b)",
            "        edg[b].append(a)",
            "    ans = 0",
            "    for a, b in ab:",
            "        c = [True] * n",
            "        ed = defaultdict(int)",
            "        q = deque()",
            "        q.append(0)",
            "        c[0] = False",
            "        ed[(a,b)] = True",
            "        while q:",
            "            now = q.pop()",
            "            for e in edg[now]:",
            "                if ed[(now,e)] or ed[(e,now)]:",
            "                    continue",
            "                ed[(now, e)] = True",
            "                c[e] = False",
            "                q.appendleft(e)",
            "        if True in c:",
            "            ans += 1",
            "    print(ans)",
            "    return",
            "#D",
            "def D():",
            "    n, k = LI()",
            "    xy = LIR(n)",
            "    fullserch = list(itertools.combinations(range(n), 2))",
            "    ans = inf",
            "    for a, b in fullserch:",
            "        minx = min(xy[a][0], xy[b][0])",
            "        maxx = max(xy[a][0], xy[b][0])",
            "        for c, d in fullserch:",
            "            miny = min(xy[c][1], xy[d][1])",
            "            maxy = max(xy[c][1], xy[d][1])",
            "            x = 0",
            "            for i in range(n):",
            "                if minx <= xy[i][0] <= maxx and miny <= xy[i][1] <= maxy:",
            "                    x += 1",
            "            if x >= k:",
            "                ans = min(ans, (maxx - minx) * (maxy - miny))",
            "    print(ans)",
            "    return",
            "#Solve",
            "if __name__ == '__main__':",
            "    D()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math, cmath",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import _heapify_max, _heappop_max, _siftdown_max",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    Num = Union[int, float]",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input():  return sys.stdin.readline().rstrip()",
            "    def ii():     return int(input())",
            "    def isp():    return input().split()",
            "    def mi():     return map(int, input().split())",
            "    def mi_0():   return map(lambda x: int(x)-1, input().split())",
            "    def lmi():    return list(map(int, input().split()))",
            "    def lmi_0():  return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():     return list(input())",
            "    def debug(x): print(x, file=sys.stderr)",
            "    # def _heappush_max(h, item): h.append(item); _siftdown_max(h, 0, len(h)-1)",
            "    n = ii()",
            "    A = []",
            "    B = []",
            "    for _ in range(n):",
            "        a, b = mi()",
            "        A.append(a)",
            "        B.append(b)",
            "    M = max(A)",
            "    ind = A.index(M)",
            "    print(M + B[ind])",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env pypy",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    Num = Union[int, float]",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def isp():   return input().split()",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def check(n, m, k):",
            "        for i in range(n + 1):",
            "            for j in range(m + 1):",
            "                if i * j + (n - i) * (m - j) == k:",
            "                    return True",
            "        return False",
            "    n, m, k = mi()",
            "    print('Yes') if check(n, m, k) else print('No')",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "from heapq import _heapify_max, _heappop_max, _siftdown_max",
            "from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    Num = Union[int, float]",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def isp():   return input().split()",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def _heappush_max(heap, item):",
            "        heap.append(item)",
            "        _siftdown_max(heap, 0, len(heap)-1)",
            "    def check(hp, mul4, mul2, mul1):",
            "        while hp:",
            "            if mul4:",
            "                top = _heappop_max(hp)",
            "                if top < 4:",
            "                    return False",
            "                top -= 4",
            "                mul4 -= 1",
            "                if top:",
            "                    _heappush_max(hp, top)",
            "            elif mul2:",
            "                top = _heappop_max(hp)",
            "                if top < 2:",
            "                    return False",
            "                top -= 2",
            "                mul2 -= 1",
            "                if top:",
            "                    _heappush_max(hp, top)",
            "            elif mul1:",
            "                top = _heappop_max(hp)",
            "                if top < 1:",
            "                    return False",
            "                top -= 1",
            "                mul1 -= 1",
            "                if top:",
            "                    _heappush_max(hp, top)",
            "            else:",
            "                raise RuntimeError",
            "        return True",
            "    h, w = mi()",
            "    c = Counter()",
            "    for _ in range(h):",
            "        c += Counter(input())",
            "    hp = list(c.values())",
            "    _heapify_max(hp)",
            "    if h % 2 == 0 and w % 2 == 0:",
            "        mul4, mul2, mul1 = h * w // 4, 0, 0",
            "    elif h % 2 == 0:",
            "        mul4, mul2, mul1 = h * (w-1) // 4, h//2, 0",
            "    elif w % 2 == 0:",
            "        mul4, mul2, mul1 = (h-1) * w //4, w//2, 0",
            "    else:",
            "        mul2, mul1 = (h-1)//2 + (w-1)//2, 1",
            "        mul4 = (h * w - mul2 * 2 + mul1) // 4",
            "    print('Yes') if check(hp, mul4, mul2, mul1) else print('No')",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "def main():",
            "    examB()",
            "def examA():",
            "    S = SI()",
            "    S = \">\" + S + \"<\"",
            "    N = len(S)",
            "    A = [0]*N",
            "    i = 0",
            "    while(i<N-1):",
            "        r = i + 1",
            "        if S[i]==\">\" and S[i+1]==\"<\":",
            "            A[i] = 0",
            "            l = i-1",
            "            cur = 0",
            "            while(1<=l):",
            "                cur += 1",
            "                A[l] = max(A[l], cur)",
            "                l -= 1",
            "                if S[l+1]==\"<\":",
            "                    #print(\"break\",l,A)",
            "                    break",
            "            r = i+1",
            "            cur = 0",
            "            while(r<N-1):",
            "                cur += 1",
            "                A[r] = max(A[r], cur)",
            "                r += 1",
            "                if r==N-1:",
            "                    break",
            "                if S[r]==\">\":",
            "                    break",
            "        #print(i,A)",
            "        i = r",
            "    #print(A)",
            "    A[0] = 0; A[-1] = 0",
            "    ans = sum(A)",
            "    print(ans)",
            "    return",
            "def examB():",
            "    H, W = LI()",
            "    A = [SI()for _ in range(H)]",
            "    C = defaultdict(int)",
            "    for a in A:",
            "        for s in a:",
            "            C[s] += 1",
            "    B = sorted(C.items())",
            "    # print(B)",
            "    flag_odd = not (H%2==1 and W%2==1)",
            "    upper_2 = (H%2==1) * (W//2) + (W%2==1) * (H//2)",
            "    for s,c in B:",
            "        if c%2==1:",
            "            if flag_odd:",
            "                print(\"No\")",
            "                return",
            "            flag_odd = True",
            "        elif c%4==2:",
            "            upper_2 -= 1",
            "            if upper_2<0:",
            "                print(\"No\")",
            "                return",
            "    print(\"Yes\")",
            "    return",
            "def examC():",
            "    N, K = LI()",
            "    P = LI()",
            "    C = LI()",
            "    if max(C)<0:",
            "        print(max(C))",
            "        return",
            "    loop = [[0,0]for _ in range(N)]",
            "    for i in range(N):",
            "        checked = set()",
            "        now = i",
            "        score = 0",
            "        while(now not in checked):",
            "            checked.add(now)",
            "            now = P[now]-1",
            "            score += C[now]",
            "        n = len(checked)",
            "        for j in checked:",
            "            loop[j] = [n,score]",
            "    # print(loop)",
            "    ans = 0",
            "    for i in range(N):",
            "        n,s = loop[i]",
            "        score = 0",
            "        if s>0:",
            "            score += (K//n - 1) * s",
            "        ans = max(ans,score)",
            "        now = i",
            "        for j in range(n + K%n):",
            "            now = P[now] - 1",
            "            score += C[now]",
            "            ans = max(ans,score)",
            "    print(ans)",
            "    return",
            "def examD():",
            "    ans = 0",
            "    print(ans)",
            "    return",
            "def examE():",
            "    ans = 0",
            "    print(ans)",
            "    return",
            "def examF():",
            "    ans = 0",
            "    print(ans)",
            "    return",
            "def test():",
            "    i = I()",
            "    li = LI()",
            "    lsi = LSI()",
            "    si = LS()",
            "    print(i)",
            "    print(li)",
            "    print(lsi)",
            "    print(si)",
            "    return",
            "from decimal import getcontext,Decimal as dec",
            "import sys,bisect,itertools,heapq,math,random",
            "from copy import deepcopy",
            "from heapq import heappop,heappush,heapify",
            "from collections import Counter,defaultdict,deque",
            "read = sys.stdin.buffer.read",
            "readline = sys.stdin.buffer.readline",
            "readlines = sys.stdin.buffer.readlines",
            "def I(): return int(input())",
            "def LI(): return list(map(int,sys.stdin.readline().split()))",
            "def DI(): return dec(input())",
            "def LDI(): return list(map(dec,sys.stdin.readline().split()))",
            "def LSI(): return list(map(str,sys.stdin.readline().split()))",
            "def LS(): return sys.stdin.readline().split()",
            "def SI(): return sys.stdin.readline().strip()",
            "global mod,mod2,inf,alphabet,alphabet_convert,_ep",
            "mod = 10**9 + 7",
            "mod2 = 998244353",
            "inf = 1<<31",
            "_ep = dec(\"0.000000000001\")",
            "alphabet = [chr(ord('a') + i) for i in range(26)]",
            "alphabet_convert = {chr(ord('a') + i): i for i in range(26)}",
            "getcontext().prec = 28",
            "sys.setrecursionlimit(10**7)",
            "if __name__ == '__main__':",
            "    main()",
            "\"\"\"",
            "142",
            "12 9 1445 0 1",
            "asd dfg hj o o",
            "aidn",
            "\"\"\""
        ],
        "label": [
            2,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "from collections import Counter",
            "H,W,*n = open(0).read().split()",
            "H = int(H)",
            "W = int(W)",
            "c = Counter([])",
            "for x in n:",
            "    c += Counter(x)",
            "if H % 2 == 0 and W % 2 == 0:",
            "    for x in c.values():",
            "        if x % 4 != 0:",
            "            print('No')",
            "            break",
            "    else:",
            "        print('Yes')",
            "elif H % 2 == 1 and W % 2 == 1:",
            "    center = 0",
            "    cross = H + W - 1",
            "    corner = (H*W) - cross",
            "    corner_filled = 0",
            "    cross_filled = 0",
            "    for x in c.values():",
            "        if x % 2 == 1:",
            "            if center == 0:",
            "                center = 1",
            "                y = x - 1",
            "            else:",
            "                print('No')",
            "                break",
            "        else:",
            "            y = x",
            "        if y % 4 == 0:",
            "            if corner_filled + x < corner:",
            "                corner_filled += x",
            "            elif corner_filled == corner:",
            "                if cross_filled + x > cross:",
            "                    print('No')",
            "                    break",
            "                else:",
            "                    cross_filled += x",
            "            else:",
            "                cross_filled += corner_filled + x - corner",
            "                corner_filled = corner",
            "        else:",
            "            temp = (x//4) * 4",
            "            if corner_filled + temp < corner:",
            "                corner_filled += temp",
            "            elif corner_filled == corner:",
            "                if cross_filled + temp > cross:",
            "                    print('No')",
            "                    break",
            "                else:",
            "                    cross_filled += temp",
            "            else:",
            "                cross_filled += corner_filled + temp - corner",
            "                corner_filled = corner",
            "            if cross_filled + 2 > cross:",
            "                print('No')",
            "                break",
            "            else:",
            "                cross_filled += 2",
            "    else:",
            "        print('Yes')",
            "else:",
            "    if H % 2 == 1:",
            "        center = W",
            "        sides = (H*W) - W",
            "    else:",
            "        center = H",
            "        sides = (H*W) - H",
            "    center_filled = 0",
            "    sides_filled = 0",
            "    for x in c.values():",
            "        if x % 4 == 0:",
            "            if sides_filled + x < sides:",
            "                sides_filled += x",
            "            elif sides_filled == sides:",
            "                if center_filled + x > center:",
            "                    print('No')",
            "                    break",
            "                else:",
            "                    center_filled += x",
            "            else:",
            "                center_filled += sides_filled + x - sides",
            "                sides_filled = sides",
            "        elif x % 2 == 0:",
            "            temp = (x//4) * 4",
            "            if sides_filled + temp < sides:",
            "                sides_filled += temp",
            "            elif sides_filled == sides:",
            "                if center_filled + temp > center:",
            "                    print('No')",
            "                    break",
            "                else:",
            "                    center_filled += temp",
            "            else:",
            "                center_filled += sides_filled + temp - sides",
            "                sides_filled = sides",
            "            if center_filled + 2 > center:",
            "                print('No')",
            "                break",
            "            else:",
            "                center_filled += 2",
            "        else:",
            "            print('No')",
            "            break",
            "    else:",
            "        print('Yes')"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            2,
            1,
            2,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            2,
            1
        ]
    },
    {
        "content": [
            "# input()",
            "# int(input())",
            "# map(int, input().split())",
            "# list(map(int, input().split()))",
            "# list(map(int, list(input()))) # スペースがない数字リストを読み込み",
            "import math",
            "import fractions",
            "import sys",
            "import bisect",
            "import heapq  # 優先度付きキュー(最小値取り出し)",
            "import collections",
            "from collections import Counter",
            "from collections import deque",
            "import pprint",
            "import itertools",
            "sr = lambda: input()",
            "ir = lambda: int(sr())",
            "lr = lambda: list(map(int, sr().split()))",
            "\"\"\"nを素因数分解\"\"\"",
            "\"\"\"2以上の整数n => [[素因数, 指数], ...]の2次元リスト\"\"\"",
            "def factorization(n):",
            "    arr = []",
            "    temp = n",
            "    if n == 1:",
            "        return arr",
            "    for i in range(2, int(-(-n ** 0.5 // 1)) + 1):",
            "        if temp % i == 0:",
            "            cnt = 0",
            "            while temp % i == 0:",
            "                cnt += 1",
            "                temp //= i",
            "            arr.append([i, cnt])",
            "    if temp != 1:",
            "        arr.append([temp, 1])",
            "    if arr == []:",
            "        arr.append([n, 1])",
            "    return arr",
            "# a^n",
            "def power(a, n, mod):",
            "    x = 1",
            "    while n:",
            "        if n & 1:",
            "            x *= a % mod",
            "        n >>= 1",
            "        a *= a % mod",
            "    return x % mod",
            "# n*(n-1)*...*(l+1)*l",
            "def kaijo(n, l, mod):",
            "    if n == 0:",
            "        return 1",
            "    a = n",
            "    tmp = n - 1",
            "    while (tmp >= l):",
            "        a = a * tmp % mod",
            "        tmp -= 1",
            "    return a",
            "# Union Find",
            "class UnionFind():",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parents = [-1] * n",
            "    def find(self, x):",
            "        if self.parents[x] < 0:",
            "            return x",
            "        else:",
            "            self.parents[x] = self.find(self.parents[x])",
            "            return self.parents[x]",
            "    def union(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "        if x == y:",
            "            return",
            "        if self.parents[x] > self.parents[y]:",
            "            x, y = y, x",
            "        self.parents[x] += self.parents[y]",
            "        self.parents[y] = x",
            "    def size(self, x):",
            "        return -self.parents[self.find(x)]",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "    def members(self, x):",
            "        root = self.find(x)",
            "        return [i for i in range(self.n) if self.find(i) == root]",
            "    def roots(self):",
            "        return [i for i, x in enumerate(self.parents) if x < 0]",
            "    def group_count(self):",
            "        return len(self.roots())",
            "    def all_group_members(self):",
            "        return {r: self.members(r) for r in self.roots()}",
            "    def __str__(self):",
            "        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())",
            "# 約数生成",
            "def make_divisors(n):",
            "    divisors = []",
            "    for i in range(1, int(n**0.5)+1):",
            "        if n % i == 0:",
            "            divisors.append(i)",
            "            if i != n // i:",
            "                divisors.append(n//i)",
            "    divisors.sort()",
            "    return divisors",
            "inf = 10 ** 18",
            "mod = 10 ** 9 + 7",
            "h,w = lr()",
            "a = [x for i in range(h) for x in sr()]",
            "a_set = Counter(a)",
            "n4 = 0",
            "n2 = 0",
            "n1 = 0",
            "for _,v in a_set.items():",
            "    if v%4 == 0:",
            "        n4+=1",
            "    elif v%2 == 0:",
            "        n2+=1",
            "    else:",
            "        n1+=1",
            "if h%2==0 and w%2==0:",
            "    if n1 != 0:",
            "        print('No')",
            "        sys.exit()",
            "    if n2 != 0:",
            "        print('No')",
            "        sys.exit()",
            "elif h%2==0:",
            "    if n1 != 0:",
            "        print('No')",
            "        sys.exit()",
            "    if n2 > h//2:",
            "        print('No')",
            "        sys.exit()",
            "elif w%2==0:",
            "    if n1 != 0:",
            "        print('No')",
            "        sys.exit()",
            "    if n2 > w//2:",
            "        print('No')",
            "        sys.exit()",
            "else:",
            "    if n1 != 1:",
            "        print('No')",
            "        sys.exit()",
            "    if n2 > (w-1)//2+(h-1)//2:",
            "        print('No')",
            "        sys.exit()",
            "print('Yes')"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            2
        ]
    },
    {
        "content": [
            "mod = 10 ** 9 + 7",
            "mod2 = 2 ** 61 + 1",
            "from collections import deque",
            "import heapq",
            "from bisect import bisect_left, insort_left, bisect_right",
            "_NUMINT_ALL = list(range(10))",
            "def main():",
            "    ans = solve()",
            "    if ans in [True, False]:",
            "        YesNo(ans)",
            "    elif ans is not None:",
            "        print(ans)",
            "def solve():",
            "    H, W = iip(False)",
            "    A = []",
            "    for i in range(H):",
            "        A.extend([i for i in input()])",
            "    d = count_elements(A)",
            "    a = 0",
            "    b = 0",
            "    for i in d.values():",
            "        if i % 4 == 1:",
            "            a += 1",
            "        elif i % 4 == 2:",
            "            b += 1",
            "        elif i % 4 == 3:",
            "            a += 1",
            "            b += 1",
            "    ans = True",
            "    h = H % 2 == 0",
            "    w = W % 2 == 0",
            "    #print(a, b)",
            "    if h and w:",
            "        if a == 0 and b == 0:",
            "            return True",
            "        else:",
            "            return False",
            "    elif w:",
            "        if b <= W/2 and a == 0:",
            "            return True",
            "        else:",
            "            return False",
            "    elif h:",
            "        if b <= H/2 and a == 0:",
            "            return True",
            "        else:",
            "            return False",
            "    else:",
            "        if b <= (H+W)/2 -1 and a <= 1:",
            "            return True",
            "        else:",
            "            return False",
            "#####################################################ライブラリ集ここから",
            "def iip(listed=True, num_only=True):  # 数字のinputをlistで受け取る",
            "    if num_only:",
            "        ret = [int(i) for i in input().split()]",
            "    else:",
            "        ret = [int(i) if i in _NUMINT_ALL else i for i in input().split()]",
            "    if len(ret) == 1 and not listed:",
            "        return ret[0]",
            "    return ret",
            "def saidai_kouyakusuu(A):  # 最大公約数",
            "    l = len(A)",
            "    while True:",
            "        m = min(A)",
            "        mx = max(A)",
            "        if m == mx:",
            "            return m",
            "        for i in range(l):",
            "            if A[i] % m == 0:",
            "                A[i] = m",
            "            else:",
            "                A[i] %= m",
            "def sort_tuples(l, index):  # タプルのリストを特定のインデックスでソートする",
            "    if isinstance(l, list):",
            "        l.sort(key=lambda x: x[index])",
            "        return l",
            "    else:",
            "        l = list(l)",
            "        return sorted(l, key=lambda x: x[index])",
            "def count_elements(l):  # リストの中身の個数を種類分けして辞書で返す",
            "    d = {}",
            "    for i in l:",
            "        if i in d:",
            "            d[i] += 1",
            "        else:",
            "            d[i] = 1",
            "    return d",
            "def safeget(l, index, default=\"exception\"):  # listの中身を取り出す時、listからはみ出たり",
            "    if index >= len(l):                      # マイナスインデックスになったりするのを防ぐ",
            "        if default == \"exception\":",
            "            raise Exception(\"\".join([\"safegetに不正な値 \", index, \"が渡されました。配列の長さは\", len(l), \"です\"]))",
            "        else:",
            "            return default",
            "    elif index < 0:",
            "        if default == \"exception\":",
            "            raise Exception(\"\".join([\"safegetに不正な値 \", index, \"が渡されました。負の値は許可されていません\"]))",
            "        else:",
            "            return default",
            "    else:",
            "        return l[index]",
            "def iipt(l, listed=False, num_only=True):  # 縦向きに並んでいるデータをリストに落とし込む(iip利用)",
            "    ret = []",
            "    for i in range(l):",
            "        ret.append(iip(listed=listed, num_only=num_only))",
            "    return ret",
            "def sortstr(s):  # 文字列をソートする",
            "    return \"\".join(sorted(s))",
            "def iip_ord(startcode=\"a\"):  # 文字列を数字の列に変換する(数字と文字は1:1対応)",
            "    if isinstance(startcode, str):",
            "        startcode = ord(startcode)",
            "    return [ord(i) - startcode for i in input()]",
            "def YesNo(s):  # TrueFalseや1, 0をYesNoに変換する",
            "    if s:",
            "        print(\"Yes\")",
            "    else:",
            "        print(\"No\")",
            "def fprint(s):  # リストを平たくしてprintする(二次元リストを見やすくしたりとか)",
            "    for i in s:",
            "        print(i)",
            "def bitall(N):  # ビット全探索用のインデックスを出力",
            "    ret = []",
            "    for i in range(2 ** N):",
            "        a = []",
            "        for j in range(N):",
            "            a.append(i % 2)",
            "            i //= 2",
            "        ret.append(a)",
            "    return ret",
            "def split_print_space(s):  # リストの中身をスペース区切りで出力する",
            "    print(\" \".join([str(i) for i in s]))",
            "def split_print_enter(s):  # リストの中身を改行区切りで出力する",
            "    print(\"\\n\".join([str(i) for i in s]))",
            "def soinsuu_bunkai(n):  # 素因数分解",
            "    ret = []",
            "    for i in range(2, int(n ** 0.5) + 1):",
            "        while n % i == 0:",
            "            n //= i",
            "            ret.append(i)",
            "        if i > n:",
            "            break",
            "    if n != 1:",
            "        ret.append(n)",
            "    return ret",
            "def conbination(n, r, mod, test=False):  # nCrをmodを使って計算する",
            "    if n <= 0:",
            "        return 0",
            "    if r == 0:",
            "        return 1",
            "    if r < 0:",
            "        return 0",
            "    if r == 1:",
            "        return n",
            "    ret = 1",
            "    for i in range(n - r + 1, n + 1):",
            "        ret *= i",
            "        ret = ret % mod",
            "    bunbo = 1",
            "    for i in range(1, r + 1):",
            "        bunbo *= i",
            "        bunbo = bunbo % mod",
            "    ret = (ret * inv(bunbo, mod)) % mod",
            "    if test:",
            "        # print(f\"{n}C{r} = {ret}\")",
            "        pass",
            "    return ret",
            "def inv(n, mod):  #  modnにおける逆元を計算",
            "    return power(n, mod - 2)",
            "def power(n, p, mod_=mod):  # 繰り返し二乗法でn**p % modを計算",
            "    if p == 0:",
            "        return 1",
            "    if p % 2 == 0:",
            "        return (power(n, p // 2, mod_) ** 2) % mod_",
            "    if p % 2 == 1:",
            "        return (n * power(n, p - 1, mod_)) % mod_",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys, bisect, math, itertools, string, queue, copy",
            "# import numpy as np",
            "# import scipy",
            "from collections import Counter,defaultdict,deque",
            "from itertools import permutations, combinations",
            "from heapq import heappop, heappush",
            "input = sys.stdin.readline",
            "sys.setrecursionlimit(10**8)",
            "mod = 10**9+7",
            "def inp(): return int(input()) # n=1",
            "def inpm(): return map(int,input().split()) # x=1,y=2",
            "def inpl(): return list(map(int, input().split())) # a=[1,2,3,4,5,...,n]",
            "def inpls(): return list(input().split())  # a=['1','2','3',...,'n']",
            "def inplm(n): return list(int(input()) for _ in range(n)) # x=[] 複数行",
            "def inplL(n): return [list(input()) for _ in range(n)]",
            "def inplT(n): return [tuple(input()) for _ in range(n)]",
            "def inpll(n): return [list(map(int, input().split())) for _ in range(n)] # [[1,1,1,1],[2,2,2,2],[3,3,3,3]]",
            "def inplls(n): return sorted([list(map(int, input().split())) for _ in range(n)]) # [[1,1,1,1],[2,2,2,2],[3,3,3,3]]",
            "def graph():",
            "    n=inp()",
            "    g=[[] for _ in range(n)]",
            "    for i in range(n):",
            "        a = inp()",
            "        a -= 1",
            "        g[i].append(a)",
            "        g[a].append(i)",
            "    return n,g",
            "def main():",
            "    h,w = inpm()",
            "    a = inplT(h)",
            "    dic = defaultdict(int)",
            "    for i in range(h):",
            "        for j in range(w):",
            "            x = ord(a[i][j])",
            "            dic[x] += 1",
            "    aaa = 0",
            "    q = 0",
            "    for e in dic:",
            "        if dic[e] != 1 and dic[e]%2 == 1:",
            "            aaa += 1",
            "            q = dic[e]",
            "            if aaa == 2:",
            "                print('No')",
            "                return",
            "    if h%2 == 0 and w%2 == 0:",
            "        for e in dic:",
            "            if dic[e]%4 != 0:",
            "                print('No')",
            "                return",
            "    if (h%2 == 0 and w%2 == 1) or (h%2 == 1 and w%2 == 0):",
            "        cnt = 0",
            "        if aaa:",
            "            print('No')",
            "            return",
            "        else:",
            "            for e in dic:",
            "                if dic[e]%2 != 0:",
            "                    print('No')",
            "                    return",
            "                if dic[e]%4 == 2:",
            "                    cnt += 1",
            "            if h%2 == 0:",
            "                key = h//2",
            "            else:",
            "                key = w//2",
            "            if (key-cnt) < 0 or (key-cnt)%2 != 0:",
            "                print('No')",
            "                return",
            "    if h%2 == 1 and w%2 == 1:",
            "        cnt1 = 0",
            "        cnt2 = 0",
            "        if aaa:",
            "            for e in dic:",
            "                if dic[e]%2 == 1:",
            "                    cnt1 += 1",
            "                elif dic[e]%4 == 2:",
            "                    cnt2 += 1",
            "            if cnt1 != 1:",
            "                print('No')",
            "                return",
            "            key = (h//2) + (w//2)",
            "            if (key-cnt2) < 0 or (key-cnt2)%2 != 0:",
            "                print('No')",
            "                return",
            "        else:",
            "            for e in dic:",
            "                if dic[e] == 1:",
            "                    cnt1 += 1",
            "                elif dic[e]%4 == 2:",
            "                    cnt2 += 1",
            "            if cnt1 != 1:",
            "                print('No')",
            "                return",
            "            q -= 1",
            "            if q%4 == 2:",
            "                cnt2 += 1",
            "            key = (h//2) + (w//2)",
            "            if (key-cnt2) < 0 or (key-cnt2)%2 != 0:",
            "                print('No')",
            "                return",
            "    print('Yes')",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "import math",
            "import copy",
            "import heapq",
            "from functools import cmp_to_key",
            "from bisect import bisect_left, bisect_right",
            "from collections import defaultdict, deque, Counter",
            "sys.setrecursionlimit(1000000)",
            "# input aliases",
            "input = sys.stdin.readline",
            "getS = lambda: input().strip()",
            "getN = lambda: int(input())",
            "getList = lambda: list(map(int, input().split()))",
            "getZList = lambda: [int(x) - 1 for x in input().split()]",
            "INF = float(\"inf\")",
            "MOD = 10**9 + 7",
            "divide = lambda x: pow(x, MOD-2, MOD)",
            "def nck(n, k, kaijyo):",
            "    return (npk(n, k, kaijyo) * divide(kaijyo[k])) % MOD",
            "def npk(n, k, kaijyo):",
            "    if k == 0 or k == n:",
            "        return n % MOD",
            "    return (kaijyo[n] * divide(kaijyo[n-k])) % MOD",
            "def fact_and_inv(SIZE):",
            "    inv = [0] * SIZE  # inv[j] = j^{-1} mod MOD",
            "    fac = [0] * SIZE  # fac[j] = j! mod MOD",
            "    finv = [0] * SIZE  # finv[j] = (j!)^{-1} mod MOD",
            "    inv[1] = 1",
            "    fac[0] = fac[1] = 1",
            "    finv[0] = finv[1] = 1",
            "    for i in range(2, SIZE):",
            "        inv[i] = MOD - (MOD // i) * inv[MOD % i] % MOD",
            "        fac[i] = fac[i - 1] * i % MOD",
            "        finv[i] = finv[i - 1] * inv[i] % MOD",
            "    return fac, finv",
            "def renritsu(A, Y):",
            "    # example 2x + y = 3, x + 3y = 4",
            "    # A = [[2,1], [1,3]])",
            "    # Y = [[3],[4]] または [3,4]",
            "    A = np.matrix(A)",
            "    Y = np.matrix(Y)",
            "    Y = np.reshape(Y, (-1, 1))",
            "    X = np.linalg.solve(A, Y)",
            "    # [1.0, 1.0]",
            "    return X.flatten().tolist()[0]",
            "class TwoDimGrid:",
            "    # 2次元座標 -> 1次元",
            "    def __init__(self, h, w, wall=\"#\"):",
            "        self.h = h",
            "        self.w = w",
            "        self.size = (h+2) * (w+2)",
            "        self.wall = wall",
            "        self.get_grid()",
            "        # self.init_cost()",
            "    def get_grid(self):",
            "        grid = [self.wall * (self.w + 2)]",
            "        for i in range(self.h):",
            "            grid.append(self.wall + getS() + self.wall)",
            "        grid.append(self.wall * (self.w + 2))",
            "        self.grid = grid",
            "    def init_cost(self):",
            "        self.cost = [INF] * self.size",
            "    def pos(self, x, y):",
            "        # 壁も含めて0-indexed 元々の座標だけ考えると1-indexed",
            "        return y * (self.w + 2) + x",
            "    def getgrid(self, x, y):",
            "        return self.grid[y][x]",
            "    def get(self, x, y):",
            "        return self.cost[self.pos(x, y)]",
            "    def set(self, x, y, v):",
            "        self.cost[self.pos(x, y)] = v",
            "        return",
            "    def show(self):",
            "        for i in range(self.h+2):",
            "            print(self.cost[(self.w + 2) * i:(self.w + 2) * (i+1)])",
            "    def showsome(self, tgt):",
            "        for t in tgt:",
            "            print(t)",
            "        return",
            "    def showsomejoin(self, tgt):",
            "        for t in tgt:",
            "            print(\"\".join(t))",
            "        return",
            "    def search(self):",
            "        grid = self.grid",
            "        move = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
            "        move_eight = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]",
            "        # for i in range(1, self.h+1):",
            "        #     for j in range(1, self.w+1):",
            "        #         cx, cy = j, i",
            "        #         for dx, dy in move_eight:",
            "        #             nx, ny = dx + cx, dy + cy",
            "def soinsu(n):",
            "    ret = defaultdict(int)",
            "    for i in range(2, int(math.sqrt(n) + 2)):",
            "        if n % i == 0:",
            "            while True:",
            "                if n % i == 0:",
            "                    ret[i] += 1",
            "                    n //= i",
            "                else:",
            "                    break",
            "    if not ret:",
            "        return {n: 1}",
            "    return ret",
            "def solve():",
            "    h,  w = getList()",
            "    cnt = defaultdict(int)",
            "    for i in range(h):",
            "        for k, v in Counter(getS()).items():",
            "            cnt[k] += v",
            "    yon, ni, ichi = 0,0,0",
            "    # print(cnt)",
            "    for v in cnt.values():",
            "        yon += v // 4",
            "        v %= 4",
            "        ni += v // 2",
            "        v %= 2",
            "        ichi += v",
            "    # print(yon, ni, ichi)",
            "    if h % 2 == 1 and w % 2 == 1:",
            "        if ichi != 1:",
            "            print(\"No\")",
            "            return",
            "        if ni > h // 2 + w // 2:",
            "            print(\"No\")",
            "            return",
            "        print(\"Yes\")",
            "        return",
            "    if h % 2 == 0 and w % 2 == 0:",
            "        if ichi or ni:",
            "            print(\"No\")",
            "            return",
            "        print(\"Yes\")",
            "        return",
            "    if h % 2 == 1:",
            "        # print(yon, ni, ichi)",
            "        if ichi or ni > w // 2:",
            "            print(\"No\")",
            "            return",
            "        print(\"Yes\")",
            "        return",
            "    if ichi or ni > h // 2:",
            "        print(\"No\")",
            "        return",
            "    print(\"Yes\")",
            "    return",
            "def main():",
            "    n = getN()",
            "    for _ in range(n):",
            "        solve()",
            "    return",
            "if __name__ == \"__main__\":",
            "    # main()",
            "    solve()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            2,
            1,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n = ii()",
            "    k = ii()",
            "    ball_place = lmi()",
            "    total_dist = 0",
            "    for x in ball_place:",
            "        total_dist += min(x, abs(k - x)) * 2",
            "    print(total_dist)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def calc_possible_gram(x, y, f):",
            "        \"\"\"f 以下の範囲で x, y を任意回足して作れるグラム数を列挙しソートして返す (0 は除く)\"\"\"",
            "        table = [False] * (f + 1)",
            "        table[0] = True",
            "        iteration = f // x",
            "        for _ in range(iteration):",
            "            for i in range(f):",
            "                if table[i]:",
            "                    if i + x <= f:",
            "                        table[i+x] = True",
            "                    if i + y <= f:",
            "                        table[i+y] = True",
            "        return [ind for ind in range(f+1) if table[ind]][1:]",
            "    a, b, c, d, e, f = mi()",
            "    water = calc_possible_gram(100*a, 100*b, f)",
            "    sugar = calc_possible_gram(c, d, f)",
            "    # print(water)",
            "    # print(sugar)",
            "    concentration_max = 0",
            "    water_memo = 100*a",
            "    sugar_memo = 0",
            "    for w in water:",
            "        soluble_sugar = min(f - w, (w * e) // 100)",
            "        ind = bisect_right(sugar, soluble_sugar)",
            "        s = sugar[ind-1] if ind != 0 else 0",
            "        c = (100*s)/(w+s)",
            "        if concentration_max <= c:",
            "            # print(f\"{w} {soluble_sugar} {s} {c}\")",
            "            concentration_max = c",
            "            water_memo, sugar_memo = w, s",
            "    print(\"{} {}\".format(water_memo+sugar_memo, sugar_memo))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import math",
            "#import sys",
            "#input = sys.stdin.readline",
            "def make_divisors(n):",
            "    divisors = []",
            "    for i in range(1, int(n**0.5)+1):",
            "        if n % i == 0:",
            "            divisors.append(i)",
            "            if i != n // i:",
            "                divisors.append(n//i)",
            "    # divisors.sort()",
            "    return divisors",
            "def ValueToBits(x,digit):",
            "    res = [0 for i in range(digit)]",
            "    now = x",
            "    for i in range(digit):",
            "        res[i]=now%2",
            "        now = now >> 1",
            "    return res",
            "def BitsToValue(arr):",
            "    n = len(arr)",
            "    ans = 0",
            "    for i in range(n):",
            "        ans+= arr[i] * 2**i",
            "    return ans",
            "def ZipArray(a):",
            "    aa = [[a[i],i]for i in range(n)]",
            "    aa.sort(key = lambda x : x[0])",
            "    for i in range(n):",
            "        aa[i][0]=i+1",
            "    aa.sort(key = lambda x : x[1])",
            "    b=[aa[i][0] for i in range(len(a))]",
            "    return b",
            "def ValueToArray10(x, digit):",
            "    ans = [0 for i in range(digit)]",
            "    now = x",
            "    for i in range(digit):",
            "        ans[digit-i-1] = now%10",
            "        now = now //10",
            "    return ans",
            "def Zeros(a,b):",
            "    if(b<=-1):",
            "        return [0 for i in range(a)]",
            "    else:",
            "        return [[0 for i in range(b)] for i in range(a)]",
            "def AddV2(v,w):",
            "    return [v[0]+w[0],v[1]+w[1]]",
            "dir4 = [[1,0],[0,1],[-1,0],[0,-1]]",
            "def clamp(x,y,z):",
            "    return max(y,min(z,x))",
            "class Bit:",
            "    def __init__(self, n):",
            "        self.size = n",
            "        self.tree = [0] * (n + 1)",
            "    def sum(self, i):",
            "        s = 0",
            "        while i > 0:",
            "            s += self.tree[i]",
            "            i -= i & -i",
            "        return s",
            "    def add(self, i, x):",
            "        while i <= self.size:",
            "            self.tree[i] += x",
            "            i += i & -i",
            "#",
            "def Zaatsu(a):",
            "    a.sort()",
            "    now = a[0][0]",
            "    od = 0",
            "    for i in range(n):",
            "        if(now==a[i][0]):",
            "            a[i][0]=od",
            "        else:",
            "            now = a[i][0]",
            "            od+=1",
            "            a[i][0] = od",
            "    a.sort(key = lambda x : x[1])",
            "    return a",
            "class UnionFind:",
            "    def __init__(self, n):",
            "        self.par = [i for i in range(n+1)]",
            "        self.rank = [0] * (n+1)",
            "    # 検索",
            "    def find(self, x):",
            "        if self.par[x] == x:",
            "            return x",
            "        else:",
            "            self.par[x] = self.find(self.par[x])",
            "            return self.par[x]",
            "    # 併合",
            "    def union(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "        if self.rank[x] < self.rank[y]:",
            "            self.par[x] = y",
            "        else:",
            "            self.par[y] = x",
            "            if self.rank[x] == self.rank[y]:",
            "                self.rank[x] += 1",
            "    # 同じ集合に属するか判定",
            "    def same_check(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "'''",
            "def cmb(n, r, p):",
            "    if (r < 0) or (n < r):",
            "        return 0",
            "    r = min(r, n - r)",
            "    return fact[n] * factinv[r] * factinv[n-r] % p",
            "p = 2",
            "N = 10 ** 6 + 2",
            "fact = [1, 1]  # fact[n] = (n! mod p)",
            "factinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)",
            "inv = [0, 1]  # factinv 計算用",
            "for i in range(2, N + 1):",
            "    fact.append((fact[-1] * i) % p)",
            "    inv.append((-inv[p % i] * (p // i)) % p)",
            "    factinv.append((factinv[-1] * inv[-1]) % p)",
            "'''",
            "def rl(x):",
            "    return range(len(x))",
            "# a = list(map(int, input().split()))",
            "#################################################",
            "#################################################",
            "#################################################",
            "#################################################",
            "#21-",
            "a,b,c,d,e,f= list(map(int, input().split()))",
            "ans = [100,-1]",
            "maxim = -0.1",
            "for i in range(30):",
            "    for j in range(30):",
            "        for k in range(1500):",
            "            water = 100*(a*i+b*j)",
            "            if(water==0):",
            "                continue",
            "            sugar = c*k",
            "            maxSugar = min(e*water//100,f-water)",
            "            l = (maxSugar - sugar)//d",
            "            if(l<0):",
            "                continue",
            "            sugar = c*k + d*l",
            "            ratio = [sugar,(sugar+water)]",
            "            #if(i==1 and j==0):print(i,j,k,l)",
            "            if(sugar+water>f):",
            "                continue",
            "            #if(i==1 and j==0): print(i,j,k,l)",
            "            if(ratio[1]*ans[1]<ratio[0]*ans[0] and sugar+water<=f):",
            "                maxim = ratio",
            "                ans = [water+sugar,sugar]",
            "                #print(i,j,k,l)",
            "print(*ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            0,
            1,
            0,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def warshall_floyd(adj_mat_with_weight):",
            "        '''",
            "        Warshall-Floyd 法 (O(V^3), 1 sec だと v~500 とかが限界)",
            "        全点対間の最短経路を三次元 DP で求める",
            "            - 定式化",
            "            - dp[k+1][i][j] を 0...k, i, j なる頂点を使用できる時の i~j 最短距離とする (k+1=0 の時は e(i,j))",
            "            - dp[k+1][i][j] = min(dp[k][i][j], dp[k][i][k+1]+dp[k][k+1][j])",
            "            - 最後に必要なのは dp[V][i][j] 。上の漸化式をみるに 2 次元 array があれば使いまわしてメモリ節約できる。",
            "        Args:",
            "            adj_mat_with_weight (list): 重みを記録した隣接行列 (非接続頂点は inf)",
            "        Returns:",
            "            dp (list): dp[i][j] を見れば全頂点を使用可能な時の i j 最短距離がわかる。最後に dp[i][i] が負になっていたら負サイクルが存在するということ",
            "        '''",
            "        V = len(adj_mat_with_weight)",
            "        # テーブル初期化",
            "        dp = deepcopy(adj_mat_with_weight)",
            "        for i in range(V):",
            "            dp[i][i] = 0",
            "        # 漸化式を解く",
            "        for k in range(1, V+1):",
            "            for i in range(V):",
            "                for j in range(V):",
            "                    # new 2d-table # old 2d-table",
            "                    dp[i][j] = min(dp[i][j], dp[i][k-1]+dp[k-1][j])",
            "        return dp",
            "    def check_possible_structure(dp, adj_mat):",
            "        n = len(adj_mat)",
            "        for i in range(n):",
            "            for j in range(i+1, n):",
            "                if dp[i][j] < adj_mat[i][j]:",
            "                    return False",
            "        return True",
            "    def calc_minimum_street(dp, adj_mat):",
            "        n = len(adj_mat)",
            "        total_dist = 0",
            "        for i in range(n):",
            "            for j in range(i+1, n):",
            "                total_dist += adj_mat[i][j]",
            "        # 削除していく",
            "        for i in range(n):",
            "            for j in range(i+1, n):",
            "                # (i, j) の距離について",
            "                dist = adj_mat[i][j]",
            "                for k in range(n):",
            "                    if k != i and k != j and dp[i][k] + dp[k][j] == dist:",
            "                        total_dist -= dist",
            "                        break",
            "        return total_dist",
            "    n = ii()",
            "    adj_mat = [lmi() for _ in range(n)]",
            "    dp = warshall_floyd(adj_mat)",
            "    if not check_possible_structure(dp, adj_mat):",
            "        print(-1)",
            "    else:",
            "        print(calc_minimum_street(dp, adj_mat))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "import math",
            "import copy",
            "from heapq import heappush, heappop, heapify",
            "from functools import cmp_to_key",
            "from bisect import bisect_left, bisect_right",
            "from collections import defaultdict, deque, Counter",
            "# sys.setrecursionlimit(1000000)",
            "# input aliases",
            "input = sys.stdin.readline",
            "getS = lambda: input().strip()",
            "getN = lambda: int(input())",
            "getList = lambda: list(map(int, input().split()))",
            "getZList = lambda: [int(x) - 1 for x in input().split()]",
            "INF = float(\"inf\")",
            "MOD = 10**9 + 7",
            "divide = lambda x: pow(x, MOD-2, MOD)",
            "def nck(n, k, kaijyo):",
            "    return (npk(n, k, kaijyo) * divide(kaijyo[k])) % MOD",
            "def npk(n, k, kaijyo):",
            "    if k == 0 or k == n:",
            "        return n % MOD",
            "    return (kaijyo[n] * divide(kaijyo[n-k])) % MOD",
            "def fact_and_inv(SIZE):",
            "    inv = [0] * SIZE  # inv[j] = j^{-1} mod MOD",
            "    fac = [0] * SIZE  # fac[j] = j! mod MOD",
            "    finv = [0] * SIZE  # finv[j] = (j!)^{-1} mod MOD",
            "    inv[1] = 1",
            "    fac[0] = fac[1] = 1",
            "    finv[0] = finv[1] = 1",
            "    for i in range(2, SIZE):",
            "        inv[i] = MOD - (MOD // i) * inv[MOD % i] % MOD",
            "        fac[i] = fac[i - 1] * i % MOD",
            "        finv[i] = finv[i - 1] * inv[i] % MOD",
            "    return fac, finv",
            "def renritsu(A, Y):",
            "    # example 2x + y = 3, x + 3y = 4",
            "    # A = [[2,1], [1,3]])",
            "    # Y = [[3],[4]] または [3,4]",
            "    A = np.matrix(A)",
            "    Y = np.matrix(Y)",
            "    Y = np.reshape(Y, (-1, 1))",
            "    X = np.linalg.solve(A, Y)",
            "    # [1.0, 1.0]",
            "    return X.flatten().tolist()[0]",
            "class TwoDimGrid:",
            "    # 2次元座標 -> 1次元",
            "    def __init__(self, h, w, wall=\"#\"):",
            "        self.h = h",
            "        self.w = w",
            "        self.size = (h+2) * (w+2)",
            "        self.wall = wall",
            "        self.get_grid()",
            "        # self.init_cost()",
            "    def get_grid(self):",
            "        grid = [self.wall * (self.w + 2)]",
            "        for i in range(self.h):",
            "            grid.append(self.wall + getS() + self.wall)",
            "        grid.append(self.wall * (self.w + 2))",
            "        self.grid = grid",
            "    def init_cost(self):",
            "        self.cost = [INF] * self.size",
            "    def pos(self, x, y):",
            "        # 壁も含めて0-indexed 元々の座標だけ考えると1-indexed",
            "        return y * (self.w + 2) + x",
            "    def getgrid(self, x, y):",
            "        return self.grid[y][x]",
            "    def get(self, x, y):",
            "        return self.cost[self.pos(x, y)]",
            "    def set(self, x, y, v):",
            "        self.cost[self.pos(x, y)] = v",
            "        return",
            "    def show(self):",
            "        for i in range(self.h+2):",
            "            print(self.cost[(self.w + 2) * i:(self.w + 2) * (i+1)])",
            "    def showsome(self, tgt):",
            "        for t in tgt:",
            "            print(t)",
            "        return",
            "    def showsomejoin(self, tgt):",
            "        for t in tgt:",
            "            print(\"\".join(t))",
            "        return",
            "    def search(self):",
            "        grid = self.grid",
            "        move = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
            "        move_eight = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]",
            "        # for i in range(1, self.h+1):",
            "        #     for j in range(1, self.w+1):",
            "        #         cx, cy = j, i",
            "        #         for dx, dy in move_eight:",
            "        #             nx, ny = dx + cx, dy + cy",
            "def solve():",
            "    n = getN()",
            "    g = []",
            "    for i in range(n):",
            "        g.append(getList())",
            "    ans = 0",
            "    for i in range(n):",
            "        for j in range(i+1, n):",
            "            cc = g[i][j]",
            "            fl = True",
            "            for k in range(n):",
            "                if k == i or k == j:",
            "                    continue",
            "                if g[i][k] + g[j][k] < cc:",
            "                    print(-1)",
            "                    return",
            "                elif g[i][k] + g[j][k] == cc:",
            "                    fl = False",
            "            if fl:",
            "                ans += cc",
            "    print(ans)",
            "def main():",
            "    n = getN()",
            "    for _ in range(n):",
            "        solve()",
            "    return",
            "if __name__ == \"__main__\":",
            "    # main()",
            "    solve()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            2,
            1,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n = ii()",
            "    ans = 0",
            "    for _ in range(n):",
            "        l, r = mi()",
            "        ans += (r - l + 1)",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    from copy import deepcopy",
            "    def warshall_floyd(adj_mat_with_weight):",
            "        '''",
            "        Warshall-Floyd 法 (O(V^3), 1 sec だと v~500 とかが限界)",
            "        全点対間の最短経路を三次元 DP で求める",
            "        Args:",
            "            adj_mat_with_weight (list): 重みを記録した隣接行列 (非接続頂点は inf)",
            "        Returns:",
            "            dp (list): dp[i][j] を見れば全頂点を使用可能な時の i j 最短距離がわかる。最後に dp[i][i] が負になっていたら負サイクルが存在するということ",
            "        '''",
            "        V = len(adj_mat_with_weight)",
            "        # テーブル初期化",
            "        dp = deepcopy(adj_mat_with_weight)",
            "        for i in range(V):",
            "            dp[i][i] = 0",
            "        # 漸化式を解く",
            "        for k in range(1, V+1):",
            "            for i in range(V):",
            "                for j in range(V):",
            "                    # new 2d-table # old 2d-table",
            "                    dp[i][j] = min(dp[i][j], dp[i][k-1]+dp[k-1][j])",
            "        return dp",
            "    n, m, r = mi()",
            "    R = lmi_0()",
            "    adj_mat_with_weight = [[inf] * n for _ in range(n)]",
            "    for _ in range(m):",
            "        a, b, dist = mi_0()",
            "        dist += 1",
            "        adj_mat_with_weight[a][b] = dist",
            "        adj_mat_with_weight[b][a] = dist",
            "    dp = warshall_floyd(adj_mat_with_weight)",
            "    ans = inf",
            "    for pattern in permutations(R):",
            "        total_dist = 0",
            "        for i in range(1, r):",
            "            total_dist += dp[pattern[i-1]][pattern[i]]",
            "        ans = min(ans, total_dist)",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "class Digraph:",
            "    #入力定義",
            "    def __init__(self,vertex=[]):",
            "        self.vertex=set(vertex)",
            "        self.edge_number=0",
            "        self.vertex_number=len(vertex)",
            "        self.adjacent_out={v:{} for v in vertex} #出近傍(vが始点)",
            "        self.adjacent_in={v:{} for v in vertex} #入近傍(vが終点)",
            "    #頂点の追加",
            "    def add_vertex(self,*adder):",
            "        for v in adder:",
            "            if v not in self.vertex:",
            "                self.adjacent_in[v]={}",
            "                self.adjacent_out[v]={}",
            "                self.vertex_number+=1",
            "                self.vertex.add(v)",
            "    #辺の追加(更新)",
            "    def add_edge(self,From,To,weight=1):",
            "        for v in [From,To]:",
            "            if v not in self.vertex:",
            "                self.add_vertex(v)",
            "        if To not in self.adjacent_in[From]:",
            "            self.edge_number+=1",
            "        self.adjacent_out[From][To]=weight",
            "        self.adjacent_in[To][From]=weight",
            "    #辺を除く",
            "    def remove_edge(self,From,To):",
            "        for v in [From,To]:",
            "            if v not in self.vertex:",
            "                self.add_vertex(v)",
            "        if To in self.adjacent_out[From]:",
            "            del self.adjacent_out[From][To]",
            "            del self.adjacent_in[To][From]",
            "            self.edge_number-=1",
            "    #頂点を除く",
            "    def remove_vertex(self,*vertexes):",
            "        for  v in vertexes:",
            "            if v in self.vertex:",
            "                self.vertex_number-=1",
            "                for u in self.adjacent_out[v]:",
            "                    del self.adjacent_in[u][v]",
            "                    self.edge_number-=1",
            "                del self.adjacent_out[v]",
            "                for u in self.adjacent_in[v]:",
            "                    del self.adjacent_out[u][v]",
            "                    self.edge_number-=1",
            "                del self.adjacent_in[v]",
            "    #Walkの追加",
            "    def add_walk(self,*walk):",
            "        pass",
            "    #Cycleの追加",
            "    def add_cycle(self,*cycle):",
            "        pass",
            "    #頂点の交換",
            "    def __vertex_swap(self,p,q):",
            "        self.vertex.sort()",
            "    #グラフに頂点が存在するか否か",
            "    def vertex_exist(self,v):",
            "        return v in self.vertex",
            "    #グラフに辺が存在するか否か",
            "    def edge_exist(self,From,To):",
            "        if not(self.vertex_exist(From) and self.vertex_exist(To)):",
            "            return False",
            "        return To in self.adjacent_out[From]",
            "    #近傍",
            "    def neighbohood(self,v):",
            "        if not self.vertex_exist(v):",
            "            return []",
            "        return list(self.adjacent[v])",
            "    #出次数",
            "    def out_degree(self,v):",
            "        if not self.vertex_exist(v):",
            "            return 0",
            "        return len(self.adjacent_out[v])",
            "    #入次数",
            "    def in_degree(self,v):",
            "        if not self.vertex_exist(v):",
            "            return 0",
            "        return len(self.adjacent_in[v])",
            "    #次数",
            "    def degree(self,v):",
            "        if not self.vertex_exist(v):",
            "            return 0",
            "        return self.out_degree(v)-self.in_degree(v)",
            "    #頂点数",
            "    def vertex_count(self):",
            "        return len(self.vertex)",
            "    #辺数",
            "    def edge_count(self):",
            "        return self.edge_number",
            "    #頂点vを含む連結成分",
            "    def connected_component(self,v):",
            "        pass",
            "#Warshall–Floyd",
            "def Warshall_Floyd(D):",
            "    \"\"\"Warshall–Floyd法を用いて,全点間距離を求める.",
            "    D:負Cycleを含まない有向グラフ",
            "    \"\"\"",
            "    T={v:{} for v in D.vertex} #T[u][v]:uからvへ",
            "    for u in D.vertex:",
            "        for v in D.vertex:",
            "            if v==u:",
            "                T[u][v]=0",
            "            elif v in D.adjacent_out[u]:",
            "                T[u][v]=D.adjacent_out[u][v]",
            "            else:",
            "                T[u][v]=float(\"inf\")",
            "    for u in D.vertex:",
            "        for v in D.vertex:",
            "            for w in D.vertex:",
            "                T[v][w]=min(T[v][w],T[v][u]+T[u][w])",
            "    return T",
            "#================================================",
            "from itertools import permutations",
            "N,M,R=map(int,input().split())",
            "Y=list(map(int,input().split()))",
            "D=Digraph(list(range(1,N+1)))",
            "for _ in range(M):",
            "    a,b,c=map(int,input().split())",
            "    D.add_edge(a,b,c)",
            "    D.add_edge(b,a,c)",
            "Dist=Warshall_Floyd(D)",
            "Z=float(\"inf\")",
            "for P in permutations(Y):",
            "    X=0",
            "    for i in range(R-1):",
            "        X+=Dist[P[i]][P[i+1]]",
            "    Z=min(Z,X)",
            "print(Z)"
        ],
        "label": [
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2
        ]
    },
    {
        "content": [
            "# -*- coding: utf-8 -*-",
            "import sys",
            "import math",
            "import os",
            "import itertools",
            "import string",
            "import heapq",
            "import _collections",
            "from collections import Counter",
            "from collections import defaultdict",
            "from functools import lru_cache",
            "import bisect",
            "import re",
            "import queue",
            "class Scanner():",
            "    @staticmethod",
            "    def int():",
            "        return int(sys.stdin.readline().rstrip())",
            "    @staticmethod",
            "    def string():",
            "        return sys.stdin.readline().rstrip()",
            "    @staticmethod",
            "    def map_int():",
            "        return [int(x) for x in Scanner.string().split()]",
            "    @staticmethod",
            "    def string_list(n):",
            "        return [input() for i in range(n)]",
            "    @staticmethod",
            "    def int_list_list(n):",
            "        return [Scanner.map_int() for i in range(n)]",
            "    @staticmethod",
            "    def int_cols_list(n):",
            "        return [int(input()) for i in range(n)]",
            "class Math():",
            "    @staticmethod",
            "    def gcd(a, b):",
            "        if b == 0:",
            "            return a",
            "        return Math.gcd(b, a % b)",
            "    @staticmethod",
            "    def lcm(a, b):",
            "        return (a * b) // Math.gcd(a, b)",
            "    @staticmethod",
            "    def roundUp(a, b):",
            "        return -(-a // b)",
            "    @staticmethod",
            "    def toUpperMultiple(a, x):",
            "        return Math.roundUp(a, x) * x",
            "    @staticmethod",
            "    def toLowerMultiple(a, x):",
            "        return (a // x) * x",
            "    @staticmethod",
            "    def nearPow2(n):",
            "        if n <= 0:",
            "            return 0",
            "        if n & (n - 1) == 0:",
            "            return n",
            "        ret = 1",
            "        while(n > 0):",
            "            ret <<= 1",
            "            n >>= 1",
            "        return ret",
            "    @staticmethod",
            "    def sign(n):",
            "        if n == 0:",
            "            return 0",
            "        if n < 0:",
            "            return -1",
            "        return 1",
            "    @staticmethod",
            "    def isPrime(n):",
            "        if n < 2:",
            "            return False",
            "        if n == 2:",
            "            return True",
            "        if n % 2 == 0:",
            "            return False",
            "        d = int(n ** 0.5) + 1",
            "        for i in range(3, d + 1, 2):",
            "            if n % i == 0:",
            "                return False",
            "        return True",
            "class PriorityQueue:",
            "    def __init__(self, l=[]):",
            "        self.__q = l",
            "        heapq.heapify(self.__q)",
            "        return",
            "    def push(self, n):",
            "        heapq.heappush(self.__q, n)",
            "        return",
            "    def pop(self):",
            "        return heapq.heappop(self.__q)",
            "sys.setrecursionlimit(1000000)",
            "MOD = int(1e09) + 7",
            "INF = int(1e15)",
            "def main():",
            "    # sys.stdin = open(\"Sample.txt\")",
            "    N, M, R = Scanner.map_int()",
            "    r = Scanner.map_int()",
            "    for i in range(R):",
            "        r[i] -= 1",
            "    G = [[] for _ in range(N)]",
            "    d = [[INF for _ in range(N)]for _ in range(N)]",
            "    for i in range(N):",
            "        d[i][i] = 0",
            "    for i in range(M):",
            "        a, b, c = Scanner.map_int()",
            "        a -= 1",
            "        b -= 1",
            "        G[a].append((b, c))",
            "        G[b].append((a, c))",
            "        d[a][b] = c",
            "        d[b][a] = c",
            "    for k in range(N):",
            "        for i in range(N):",
            "            for j in range(N):",
            "                d[i][j] = min(d[i][j], d[i][k] + d[k][j])",
            "    r.sort()",
            "    ans = INF",
            "    for v in itertools.permutations(r):",
            "        now = 0",
            "        for i in range(len(v)-1):",
            "            now += d[v[i]][v[i+1]]",
            "        ans = min(ans, now)",
            "    print(ans)",
            "    return",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n = ii()",
            "    L = lmi_0()",
            "    cnt = 0",
            "    for i in range(n-1):",
            "        if L[i] == i and L[i+1] == i+1:",
            "            cnt += 1",
            "            L[i], L[i+1] = L[i+1], L[i]",
            "    for i in range(n):",
            "        if L[i] == i:",
            "            cnt += 1",
            "            if i != n - 1:",
            "                L[i], L[i+1] = L[i+1], L[i]",
            "            else:",
            "                L[i], L[i-1] = L[i-1], L[i]",
            "    print(cnt)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n = ii()",
            "    up = input()",
            "    bottom = input()",
            "    standing = []",
            "    i = 0",
            "    while i < n:",
            "        if up[i] == bottom[i]:",
            "            standing.append(True)",
            "        else:",
            "            standing.append(False)",
            "            i += 1",
            "        i += 1",
            "    # print(standing)",
            "    ans = 1",
            "    for i in range(len(standing)):",
            "        if i == 0:",
            "            if standing[i]:",
            "                ans *= 3",
            "            else:",
            "                ans *= 6",
            "        elif standing[i]:",
            "            if standing[i-1]:",
            "                ans = (ans * 2) % mod",
            "            else:",
            "                continue",
            "        else:",
            "            if standing[i-1]:",
            "                ans = (ans * 2) % mod",
            "            else:",
            "                ans = (ans * 3) % mod",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    a, b, c, d = mi()",
            "    cnt = 0",
            "    for i in range(101):",
            "        if a <= i <= b-1 and c <= i <= d-1:",
            "            cnt += 1",
            "    print(cnt)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n = ii()",
            "    adj = [[] for _ in range(n)]",
            "    for _ in range(n-1):",
            "        a, b, dist = mi()",
            "        a -= 1",
            "        b -= 1",
            "        adj[a].append((b, dist))",
            "        adj[b].append((a, dist))",
            "    q, k = mi()",
            "    k -= 1",
            "    query = [lmi_0() for _ in range(q)]",
            "    dist_from_k = [0] * n",
            "    visited = [False] * n",
            "    def bfs_queue_traverse(start):",
            "        queue = deque()    # ind, dist",
            "        queue.append([start, 0])",
            "        while queue:",
            "            current, dist = queue.popleft()",
            "            if not visited[current]:",
            "                visited[current] = True",
            "                dist_from_k[current] = dist",
            "                for v, next_dist in adj[current]:",
            "                    if not visited[v]:",
            "                        queue.append((v, dist + next_dist))",
            "    bfs_queue_traverse(k)",
            "    for x, y in query:",
            "        print(dist_from_k[x] + dist_from_k[y])",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "import heapq",
            "from itertools import permutations",
            "from bisect import bisect_left, bisect_right",
            "from collections import Counter, deque",
            "from fractions import gcd",
            "from math import factorial, sqrt",
            "INF = 1 << 60",
            "sys.setrecursionlimit(10 ** 7)",
            "input = sys.stdin.readline",
            "class UnionFind():",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parents = [-1] * n",
            "    def find(self, x):",
            "        if self.parents[x] < 0:",
            "            return x",
            "        else:",
            "            self.parents[x] = self.find(self.parents[x])",
            "            return self.parents[x]",
            "    def union(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "        if x == y:",
            "            return",
            "        if self.parents[x] > self.parents[y]:",
            "            x, y = y, x",
            "        self.parents[x] += self.parents[y]",
            "        self.parents[y] = x",
            "    def size(self, x):",
            "        return -self.parents[self.find(x)]",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "    def members(self, x):",
            "        root = self.find(x)",
            "        return [i for i in range(self.n) if self.find(i) == root]",
            "    def roots(self):",
            "        return [i for i, x in enumerate(self.parents) if x < 0]",
            "    def group_count(self):",
            "        return len(self.roots())",
            "    def all_group_members(self):",
            "        return {r: self.members(r) for r in self.roots()}",
            "    def __str__(self):",
            "        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())",
            "def dijkstra_heap(s,edge):",
            "    #始点sから各頂点への最短距離",
            "    d = [10**20] * n",
            "    used = [True] * n #True:未確定",
            "    d[s] = 0",
            "    used[s] = False",
            "    edgelist = []",
            "    for a,b in edge[s]:",
            "        heapq.heappush(edgelist,a*(10**6)+b)",
            "    while len(edgelist):",
            "        minedge = heapq.heappop(edgelist)",
            "        #まだ使われてない頂点の中から最小の距離のものを探す",
            "        if not used[minedge%(10**6)]:",
            "            continue",
            "        v = minedge%(10**6)",
            "        d[v] = minedge//(10**6)",
            "        used[v] = False",
            "        for e in edge[v]:",
            "            if used[e[1]]:",
            "                heapq.heappush(edgelist,(e[0]+d[v])*(10**6)+e[1])",
            "    return d",
            "def factorization(n):",
            "    arr = []",
            "    temp = n",
            "    for i in range(2, int(-(-n**0.5//1))+1):",
            "        if temp%i==0:",
            "            cnt=0",
            "            while temp%i==0:",
            "                cnt+=1",
            "                temp //= i",
            "            arr.append([i, cnt])",
            "    if temp!=1:",
            "        arr.append([temp, 1])",
            "    if arr==[]:",
            "        arr.append([n, 1])",
            "    return arr",
            "#ここから書き始める",
            "# def dfs(current, goal, cost, visited):",
            "#     if current == goal:",
            "#         return cost",
            "#     if len(tree[current]) == 0:",
            "#         return 0",
            "#     for i in tree[current]:",
            "#         # print(\"i =\", i)",
            "#         if visited[i[0]] == 0:",
            "#             return dfs(i[0], goal, cost + i[1])",
            "def bfs(queue):",
            "    visited = [0] * n",
            "    while queue:",
            "        # print(\"dist =\", dist)",
            "        node = queue.popleft()",
            "        # print(\"node =\", node)",
            "        current = node[0]",
            "        if visited[current] == 0:",
            "            new_cost = node[1]",
            "            cost = node[2]",
            "            cost += new_cost",
            "            dist[current] = min(dist[current], cost)",
            "            visited[current] = 1",
            "            for i in tree[current]:",
            "                queue.append([i[0], i[1], cost])",
            "n = int(input())",
            "tree = [[] for i in range(n)]",
            "for i in range(n - 1):",
            "    a, b, c = map(int, input().split())",
            "    a -= 1",
            "    b -= 1",
            "    tree[a].append([b, c])",
            "    tree[b].append([a, c])",
            "# print(tree)",
            "q, k = map(int, input().split())",
            "k -= 1",
            "dist = [INF] * n",
            "# visited = [0] * n",
            "queue = deque([[k, 0, 0]])",
            "# print(queue)",
            "bfs(queue)",
            "# print(\"dist =\", dist)",
            "ans = [0] * q",
            "for i in range(q):",
            "    x, y = map(int, input().split())",
            "    x -= 1",
            "    y -= 1",
            "    ans[i] = dist[x] + dist[y]",
            "for i in ans:",
            "    print(i)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            1
        ]
    },
    {
        "content": [
            "import heapq",
            "class Graph:",
            "    def __init__(self,v,edgelist,w_v = None,directed = False):",
            "        super().__init__()",
            "        self.v = v",
            "        self.w_e = [{} for _ in [0]*self.v]",
            "        self.neighbor = [[] for _ in [0]*self.v]",
            "        self.w_v = w_v",
            "        self.directed = directed",
            "        for i,j,w in edgelist:",
            "            self.w_e[i][j] = w",
            "            self.neighbor[i].append(j)",
            "    def dijkstra(self,v_n):",
            "        d = [float('inf')]*self.v",
            "        d[v_n] = 0",
            "        prev = [-1]*self.v",
            "        queue = []",
            "        for i,d_i in enumerate(d): heapq.heappush(queue,(d_i,i))",
            "        while len(queue)>0:",
            "            d_u,u = queue.pop()",
            "            if d[u]<d_u :continue",
            "            for v in self.neighbor[u]:",
            "                alt = d[u]+self.w_e[u][v]",
            "                if d[v]>alt:",
            "                    d[v] = alt",
            "                    prev[v] = u",
            "                    heapq.heappush(queue,(alt,v))",
            "        return d,prev",
            "    def warshallFloyd(self):",
            "        d = [[10**18]*self.v for _ in [0]*self.v]",
            "        for i in range(self.v):",
            "            d[i][i] = 0",
            "        for i in range(self.v):",
            "            for j in self.neighbor[i]:",
            "                d[i][j] = self.w_e[i][j]",
            "        for i in range(self.v):",
            "            for j in self.neighbor[i]:",
            "                d[i][j] = self.w_e[i][j]",
            "        for k in range(self.v):",
            "            for i in range(self.v):",
            "                for j in range(self.v):",
            "                    check = d[i][k] + d[k][j]",
            "                    if d[i][j] > check:",
            "                        d[i][j] = check",
            "        return d",
            "    def prim(self):",
            "        gb = GraphBuilder(self.v,self.directed)",
            "        queue = []",
            "        for i,w in self.w_e[0].items(): heapq.heappush(queue,(w,0,i))",
            "        rest = [True]*self.v",
            "        rest[0] = False",
            "        v = 1",
            "        while len(queue)>0:",
            "            w,i,j = heapq.heappop(queue)",
            "            if rest[j]:",
            "                gb.addEdge(i,j,w)",
            "                rest[j] = False",
            "                for k,w in self.w_e[j].items():",
            "                    if rest[k]:heapq.heappush(queue,(w,j,k))",
            "        return gb",
            "class Tree():",
            "    def __init__(self,v,e):",
            "        pass",
            "class GraphBuilder():",
            "    def __init__(self,v,directed = False):",
            "        self.v = v",
            "        self.directed = directed",
            "        self.edge = []",
            "    def addEdge(self,i,j,w=1):",
            "        if not self.directed:",
            "            self.edge.append((j,i,w))",
            "        self.edge.append((i,j,w))",
            "    def addEdges(self,edgelist,weight = True):",
            "        if weight:",
            "            if self.directed:",
            "                for i,j,w in edgelist:",
            "                    self.edge.append((i,j,w))",
            "            else:",
            "                for i,j,w in edgelist:",
            "                    self.edge.append((i,j,w))",
            "                    self.edge.append((j,i,w))",
            "        else:",
            "            if self.directed:",
            "                for i,j,w in edgelist:",
            "                    self.edge.append((i,j,1))",
            "            else:",
            "                for i,j,w in edgelist:",
            "                    self.edge.append((i,j,1))",
            "                    self.edge.append((j,i,1))",
            "    def addAdjMat(self, mat):",
            "        for i,mat_i in enumerate(mat):",
            "            for j,w in enumerate(mat_i):",
            "                self.edge.append((i,j,w))",
            "    def buildTree(self):",
            "        pass",
            "    def buildGraph(self):",
            "        return Graph(self.v,self.edge,directed=self.directed)",
            "def main():",
            "    n = int(input())",
            "    edge = []",
            "    for _ in range(n-1):",
            "        a,b,w = tuple([int(t)for t in input().split()])",
            "        edge.append((a-1,b-1,w))",
            "    gb = GraphBuilder(n)",
            "    gb.addEdges(edge)",
            "    g = gb.buildGraph()",
            "    q,k = tuple([int(t)for t in input().split()])",
            "    dijk = g.dijkstra(k-1)[0]",
            "    ans = []",
            "    for _ in range(q):",
            "        x,y = tuple([int(t)-1 for t in input().split()])",
            "        ans.append(dijk[x]+dijk[y])",
            "    for a_i in ans:",
            "        print(a_i)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            1,
            0,
            1,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            1,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "# input()",
            "# int(input())",
            "# map(int, input().split())",
            "# list(map(int, input().split()))",
            "# list(map(int, list(input()))) # スペースがない数字リストを読み込み",
            "import math",
            "import fractions",
            "import sys",
            "import bisect",
            "import heapq  # 優先度付きキュー(最小値取り出し)",
            "import collections",
            "from collections import Counter",
            "from collections import deque",
            "import pprint",
            "import itertools",
            "sr = lambda: input()",
            "ir = lambda: int(sr())",
            "lr = lambda: list(map(int, sr().split()))",
            "\"\"\"nを素因数分解\"\"\"",
            "\"\"\"2以上の整数n => [[素因数, 指数], ...]の2次元リスト\"\"\"",
            "def factorization(n):",
            "    arr = []",
            "    temp = n",
            "    if n == 1:",
            "        return arr",
            "    for i in range(2, int(-(-n ** 0.5 // 1)) + 1):",
            "        if temp % i == 0:",
            "            cnt = 0",
            "            while temp % i == 0:",
            "                cnt += 1",
            "                temp //= i",
            "            arr.append([i, cnt])",
            "    if temp != 1:",
            "        arr.append([temp, 1])",
            "    if arr == []:",
            "        arr.append([n, 1])",
            "    return arr",
            "# a^n",
            "def power(a, n, mod):",
            "    x = 1",
            "    while n:",
            "        if n & 1:",
            "            x *= a % mod",
            "        n >>= 1",
            "        a *= a % mod",
            "    return x % mod",
            "# n*(n-1)*...*(l+1)*l",
            "def kaijo(n, l, mod):",
            "    if n == 0:",
            "        return 1",
            "    a = n",
            "    tmp = n - 1",
            "    while (tmp >= l):",
            "        a = a * tmp % mod",
            "        tmp -= 1",
            "    return a",
            "# Union Find",
            "class UnionFind():",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parents = [-1] * n",
            "    def find(self, x):",
            "        if self.parents[x] < 0:",
            "            return x",
            "        else:",
            "            self.parents[x] = self.find(self.parents[x])",
            "            return self.parents[x]",
            "    def union(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "        if x == y:",
            "            return",
            "        if self.parents[x] > self.parents[y]:",
            "            x, y = y, x",
            "        self.parents[x] += self.parents[y]",
            "        self.parents[y] = x",
            "    def size(self, x):",
            "        return -self.parents[self.find(x)]",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "    def members(self, x):",
            "        root = self.find(x)",
            "        return [i for i in range(self.n) if self.find(i) == root]",
            "    def roots(self):",
            "        return [i for i, x in enumerate(self.parents) if x < 0]",
            "    def group_count(self):",
            "        return len(self.roots())",
            "    def all_group_members(self):",
            "        return {r: self.members(r) for r in self.roots()}",
            "    def __str__(self):",
            "        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())",
            "# 約数生成",
            "def make_divisors(n):",
            "    divisors = []",
            "    for i in range(1, int(n**0.5)+1):",
            "        if n % i == 0:",
            "            divisors.append(i)",
            "            if i != n // i:",
            "                divisors.append(n//i)",
            "    divisors.sort()",
            "    return divisors",
            "inf = 10 ** 18",
            "mod = 10 ** 9 + 7",
            "n = ir()",
            "maps = [[] for i in range(n)]",
            "for i in range(n-1):",
            "    a,b,c = lr()",
            "    maps[a-1].append([b-1,c])",
            "    maps[b-1].append([a-1,c])",
            "Q,k  = lr()",
            "k-=1",
            "ans = [inf for i in range(n)]",
            "visited = [False for i in range(n)]",
            "visited[k] = True",
            "q = [[k,0]]",
            "q = deque(q)",
            "while q:",
            "    nown, dist = q.popleft()",
            "    for nn, d in maps[nown]:",
            "        if visited[nn] == False:",
            "            ans[nn] = min(ans[nn], dist+d)",
            "            q.append([nn, dist+d])",
            "            visited[nn] = True",
            "for i in range(Q):",
            "    x,y = lr()",
            "    x-=1",
            "    y-=1",
            "    print(ans[x]+ans[y])"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            1,
            1,
            1,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n = ii()",
            "    L = lmi()",
            "    odd = 0",
            "    two_multiple = 0",
            "    four_multiple = 0",
            "    for num in L:",
            "        if num % 2 == 1:",
            "            odd += 1",
            "        elif num % 4 == 0:",
            "            four_multiple += 1",
            "        else:",
            "            two_multiple += 1",
            "    if odd <= four_multiple or (odd == four_multiple + 1 and two_multiple == 0):",
            "        print('Yes')",
            "    else:",
            "        print('No')",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    h, w = mi()",
            "    n = ii()",
            "    L = lmi()",
            "    color_command = []",
            "    for i in range(n):",
            "        for _ in range(L[i]):",
            "            color_command.append(i+1)",
            "    grid = [color_command[i:i+w] if (i//w)%2 == 0 else list(reversed(color_command[i:i+w])) for i in range(0, (h-1)*w+1, w)]",
            "    for line in grid:",
            "        print(*line)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def simulate(seq, num):",
            "        for _ in range(num):",
            "            minimum, min_ind = inf, -1",
            "            for i in range(50):",
            "                if seq[i] < minimum:",
            "                    minimum, min_ind = seq[i], i",
            "            for i in range(50):",
            "                if i == min_ind:",
            "                    seq[i] += 50",
            "                else:",
            "                    seq[i] -= 1",
            "    k = ii()",
            "    q, res = divmod(k, 50)",
            "    ans = list(range(q, q+50))",
            "    simulate(ans, res)",
            "    print(50)",
            "    print(*ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def restore_path(seq, start, goal):",
            "        buf = []",
            "        current = goal",
            "        while current != start:",
            "            buf.append(current)",
            "            current = seq[current]",
            "        buf.append(start)",
            "        buf.reverse()",
            "        return buf",
            "    def calc_dist_path_in_bfs(adj, start, goal):",
            "        q = deque()",
            "        q.append([[start, None], 0])",
            "        prev_memo = [None] * n",
            "        while q:",
            "            (u, prev), dist = q.popleft()",
            "            if u == goal:",
            "                prev_memo[u] = prev",
            "                return dist, restore_path(prev_memo, start, goal)",
            "            if not visited[u]:",
            "                visited[u] = True",
            "                prev_memo[u] = prev",
            "                for v in adj[u]:",
            "                    if not visited[v]:",
            "                        q.append([[v, u], dist+1])",
            "    def calc_node_in_dfs(adj, start):",
            "        cnt = 1",
            "        stack = [start]",
            "        visited[start] = True",
            "        while stack:",
            "            # print(stack)",
            "            u = stack[-1]",
            "            for v in adj[u]:",
            "                if not visited[v]:",
            "                    stack.append(v)",
            "                    visited[v] = True",
            "                    cnt += 1",
            "                    break",
            "            else:",
            "                stack.pop()",
            "        return cnt",
            "    n = ii()",
            "    adj = [[] for _ in range(n)]",
            "    for _ in range(n-1):",
            "        a, b = mi_0()",
            "        adj[a].append(b)",
            "        adj[b].append(a)",
            "    visited = [False] * n",
            "    dist, path = calc_dist_path_in_bfs(adj, start=0, goal=n-1)",
            "    # print(dist)",
            "    # print(path)",
            "    visited = [False] * n",
            "    if dist % 2 == 1:",
            "        i = path[(dist-1)//2]",
            "        j = path[(dist-1)//2 + 1]",
            "        adj[i].remove(j)",
            "        adj[j].remove(i)",
            "        # i 彩色数 > j 彩色数 で Fennec 勝ち",
            "        i_color = calc_node_in_dfs(adj, i)",
            "        j_color = calc_node_in_dfs(adj, j)",
            "        print('Fennec') if i_color > j_color else print('Snuke')",
            "    else:",
            "        i = path[dist//2]",
            "        j = path[dist//2+1]",
            "        adj[i].remove(j)",
            "        adj[j].remove(i)",
            "        # i 彩色数 >= j 彩色数 で Fennec 勝ち",
            "        i_color = calc_node_in_dfs(adj, i)",
            "        j_color = calc_node_in_dfs(adj, j)",
            "        print('Fennec') if i_color >= j_color else print('Snuke')",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "import math",
            "import copy",
            "from heapq import heappush, heappop, heapify",
            "from functools import cmp_to_key",
            "from bisect import bisect_left, bisect_right",
            "from collections import defaultdict, deque, Counter",
            "# sys.setrecursionlimit(1000000)",
            "# input aliases",
            "input = sys.stdin.readline",
            "getS = lambda: input().strip()",
            "getN = lambda: int(input())",
            "getList = lambda: list(map(int, input().split()))",
            "getZList = lambda: [int(x) - 1 for x in input().split()]",
            "INF = float(\"inf\")",
            "MOD = 10**9 + 7",
            "divide = lambda x: pow(x, MOD-2, MOD)",
            "def nck(n, k, kaijyo):",
            "    return (npk(n, k, kaijyo) * divide(kaijyo[k])) % MOD",
            "def npk(n, k, kaijyo):",
            "    if k == 0 or k == n:",
            "        return n % MOD",
            "    return (kaijyo[n] * divide(kaijyo[n-k])) % MOD",
            "def fact_and_inv(SIZE):",
            "    inv = [0] * SIZE  # inv[j] = j^{-1} mod MOD",
            "    fac = [0] * SIZE  # fac[j] = j! mod MOD",
            "    finv = [0] * SIZE  # finv[j] = (j!)^{-1} mod MOD",
            "    inv[1] = 1",
            "    fac[0] = fac[1] = 1",
            "    finv[0] = finv[1] = 1",
            "    for i in range(2, SIZE):",
            "        inv[i] = MOD - (MOD // i) * inv[MOD % i] % MOD",
            "        fac[i] = fac[i - 1] * i % MOD",
            "        finv[i] = finv[i - 1] * inv[i] % MOD",
            "    return fac, finv",
            "def renritsu(A, Y):",
            "    # example 2x + y = 3, x + 3y = 4",
            "    # A = [[2,1], [1,3]])",
            "    # Y = [[3],[4]] または [3,4]",
            "    A = np.matrix(A)",
            "    Y = np.matrix(Y)",
            "    Y = np.reshape(Y, (-1, 1))",
            "    X = np.linalg.solve(A, Y)",
            "    # [1.0, 1.0]",
            "    return X.flatten().tolist()[0]",
            "class TwoDimGrid:",
            "    # 2次元座標 -> 1次元",
            "    def __init__(self, h, w, wall=\"#\"):",
            "        self.h = h",
            "        self.w = w",
            "        self.size = (h+2) * (w+2)",
            "        self.wall = wall",
            "        self.get_grid()",
            "        # self.init_cost()",
            "    def get_grid(self):",
            "        grid = [self.wall * (self.w + 2)]",
            "        for i in range(self.h):",
            "            grid.append(self.wall + getS() + self.wall)",
            "        grid.append(self.wall * (self.w + 2))",
            "        self.grid = grid",
            "    def init_cost(self):",
            "        self.cost = [INF] * self.size",
            "    def pos(self, x, y):",
            "        # 壁も含めて0-indexed 元々の座標だけ考えると1-indexed",
            "        return y * (self.w + 2) + x",
            "    def getgrid(self, x, y):",
            "        return self.grid[y][x]",
            "    def get(self, x, y):",
            "        return self.cost[self.pos(x, y)]",
            "    def set(self, x, y, v):",
            "        self.cost[self.pos(x, y)] = v",
            "        return",
            "    def show(self):",
            "        for i in range(self.h+2):",
            "            print(self.cost[(self.w + 2) * i:(self.w + 2) * (i+1)])",
            "    def showsome(self, tgt):",
            "        for t in tgt:",
            "            print(t)",
            "        return",
            "    def showsomejoin(self, tgt):",
            "        for t in tgt:",
            "            print(\"\".join(t))",
            "        return",
            "    def search(self):",
            "        grid = self.grid",
            "        move = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
            "        move_eight = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]",
            "        # for i in range(1, self.h+1):",
            "        #     for j in range(1, self.w+1):",
            "        #         cx, cy = j, i",
            "        #         for dx, dy in move_eight:",
            "        #             nx, ny = dx + cx, dy + cy",
            "def solve():",
            "    n = getN()",
            "    g = [[] for i in range(n)]",
            "    for i in range(n - 1):",
            "        a, b = getZList()",
            "        g[a].append(b)",
            "        g[b].append(a)",
            "    cf = [INF for i in range(n)]",
            "    cf[0] = 0",
            "    cs = [INF for i in range(n)]",
            "    cs[-1] = 0",
            "    d = deque()",
            "    d.append(0)",
            "    while d:",
            "        cur = d.popleft()",
            "        cc = cf[cur]",
            "        for nx in g[cur]:",
            "            if cf[nx] > cc + 1:",
            "                cf[nx] = cc + 1",
            "                d.append(nx)",
            "    d = deque()",
            "    d.append(n-1)",
            "    while d:",
            "        cur = d.popleft()",
            "        cc = cs[cur]",
            "        for nx in g[cur]:",
            "            if cs[nx] > cc + 1:",
            "                cs[nx] = cc + 1",
            "                d.append(nx)",
            "    pf, ps = 0, 0",
            "    for i in range(n):",
            "        if cf[i] <= cs[i]:",
            "            pf += 1",
            "        else:",
            "            ps += 1",
            "    if pf > ps:",
            "        print(\"Fennec\")",
            "    else:",
            "        print(\"Snuke\")",
            "    return",
            "def main():",
            "    n = getN()",
            "    for _ in range(n):",
            "        solve()",
            "    return",
            "if __name__ == \"__main__\":",
            "    # main()",
            "    solve()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            2,
            1,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "from itertools import accumulate",
            "def input(): return sys.stdin.readline().strip()",
            "sys.setrecursionlimit(10**6)",
            "class UnionFind():",
            "    \"\"\"",
            "    https://note.nkmk.me/python-union-find/",
            "    DFSの上位互換と考えて良い",
            "    ２要素x, yがpath-connectedかどうかをlogオーダーで判定する（螺旋本の14.1節参照）",
            "    さらに連結成分の要素数がO(1)で取得可能なように改造してある",
            "    \"\"\"",
            "    def __init__(self, n):",
            "        \"\"\"",
            "        要素数をnとして、各ノードを0,1,...,(n-1)の番号で管理する",
            "        parentsは各ノードの属する木の根を表す",
            "        ただし根ノードのparentには(その木のノード数)*(-1)を格納する",
            "        \"\"\"",
            "        self.n = n",
            "        self.parents = [-1] * n",
            "    def find(self, x):",
            "        \"\"\"",
            "        xの属する木の根を返す",
            "        このとき同時に経路圧縮して、探索途中のノードを全て根に繋ぎ直す",
            "        \"\"\"",
            "        if self.parents[x] < 0:",
            "            return x",
            "        else:",
            "            self.parents[x] = self.find(self.parents[x])",
            "            return self.parents[x]",
            "    def union(self, x, y):",
            "        \"\"\"",
            "        x, yのそれぞれ属する木Tx, Tyの根同士を繋ぐ",
            "        このとき木の要素数が小さい方を大きい方に繋ぐ（rankではなくsizeを用いる）",
            "        \"\"\"",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "        if x == y:",
            "            return",
            "        if self.parents[x] > self.parents[y]:",
            "            x, y = y, x",
            "        self.parents[x] += self.parents[y]",
            "        self.parents[y] = x",
            "    def size(self, x):",
            "        \"\"\"",
            "        xの属する木の要素数を返す",
            "        根の親を要素数の(-1)倍で定めておいたおかげでO(1)で取得可能",
            "        \"\"\"",
            "        return -self.parents[self.find(x)]",
            "    def same(self, x, y):",
            "        \"\"\"",
            "        xとyがpath-connectedかを判定する",
            "        \"\"\"",
            "        return self.find(x) == self.find(y)",
            "    def members(self, x):",
            "        \"\"\"",
            "        xの属する木の要素を列挙する",
            "        \"\"\"",
            "        root = self.find(x)",
            "        return [i for i in range(self.n) if self.find(i) == root]",
            "    def roots(self):",
            "        \"\"\"",
            "        連結成分の代表元のリストを返す",
            "        \"\"\"",
            "        return [i for i, x in enumerate(self.parents) if x < 0]",
            "    def group_count(self):",
            "        \"\"\"",
            "        連結成分の個数を返す",
            "        \"\"\"",
            "        return len(self.roots())",
            "    def all_group_members(self):",
            "         \"\"\"",
            "         連結成分およびそれぞれの代表元をまとめた辞書を返す",
            "         代表元がキーになってる",
            "         \"\"\"",
            "         return {r: self.members(r) for r in self.roots()}",
            "    def __str__(self):",
            "        \"\"\"",
            "        連結成分およびその代表元を出力",
            "        \"\"\"",
            "        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())",
            "def main():",
            "    N = int(input())",
            "    repn = [[] for _ in range(N)]",
            "    edge = []",
            "    for _ in range(N - 1):",
            "        a, b = map(int, input().split())",
            "        repn[a - 1].append(b - 1)",
            "        repn[b - 1].append(a - 1)",
            "        if a > b: a, b = b, a",
            "        edge.append((a - 1, b - 1))",
            "    \"\"\"",
            "    まさかの問題を読み間違えていた。。。",
            "    （プレイヤーがマスの上を１マスずつ動くと思っていた）",
            "    「最適に行動した時」＝「どちらかに必勝法が存在する」と言い換える。",
            "    あとはその戦略を見出せば勝ち。見抜けなければ相手の全行動パターンに勝つ手の存在を示す。",
            "    同じ色が隣接していればどのマスでも塗れるなら、最初に一気に２人が距離を詰めた方がいいに決まってる。",
            "    \"\"\"",
            "    # 頂点０からのdepthを求める",
            "    depth_from_0 = [-1] * N",
            "    parent = [-1] * N",
            "    depth_from_0[0] = 0",
            "    def dfs(u):",
            "        for v in repn[u]:",
            "            if depth_from_0[v] != -1: continue",
            "            depth_from_0[v] = depth_from_0[u] + 1",
            "            parent[v] = u",
            "            dfs(v)",
            "    dfs(0)",
            "    # ２人を結ぶパスの同定",
            "    path = [N - 1]",
            "    while path[-1] != 0: path.append(parent[path[-1]])",
            "    l = len(path)",
            "    # ２人が互いに塗るマスの数を計算",
            "    tree = UnionFind(N)",
            "    a0, b0 = path[l // 2 - 1], path[l // 2]",
            "    if a0 > b0: a0, b0 = b0, a0",
            "    for a, b in edge:",
            "        if a != a0 or b != b0: tree.union(a, b)",
            "    Fennec = tree.size(0)",
            "    Snuke = tree.size(N - 1)",
            "    if Fennec > Snuke:",
            "        print(\"Fennec\")",
            "    else:",
            "        print(\"Snuke\")",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "class Graph:",
            "    #入力定義",
            "    def __init__(self,vertex=[]):",
            "        self.vertex=list(vertex)",
            "        self.edge_number=0",
            "        self.adjacent={v:set() for v in vertex}",
            "    #頂点の追加",
            "    def add_vertex(self,*adder):",
            "        k=len(self.vertex)",
            "        m=0",
            "        for u in adder:",
            "            if u not in self.adjacent:",
            "                self.adjacent[u]=set()",
            "                self.vertex.append(u)",
            "    #辺の追加",
            "    def add_edge(self,From,To):",
            "        for w in [From,To]:",
            "            if w not in self.adjacent:",
            "                self.add_vertex(w)",
            "        if To not in self.adjacent[From]:",
            "            self.adjacent[From].add(To)",
            "            self.adjacent[To].add(From)",
            "            self.edge_number+=1",
            "    #辺を除く",
            "    def remove_edge(self,u,v):",
            "        for w in [u,v]:",
            "            if w not in self.adjacent:",
            "                self.add_vertex(w)",
            "        if u in self.adjacent[v]:",
            "            self.adjacent[u].remove(v)",
            "            self.adjacent[v].remove(u)",
            "            self.edge_number-=1",
            "    #頂点を除く",
            "    def remove_vertex(self,*v):",
            "        for w in v:",
            "            if w in self.adjacent:",
            "                self.edge_number-=len(self.adjacent[w])",
            "                for u in self.adjacent[w]:",
            "                    self.adjacent[u].remove(w)",
            "                del self.adjacent[w]",
            "    #Walkの追加",
            "    def add_walk(self,*walk):",
            "        n=len(walk)",
            "        for i in range(n-1):",
            "            self.add_edge(walk[i],walk[i+1])",
            "    #Cycleの追加",
            "    def add_cycle(self,*cycle):",
            "        self.add_walk(*cycle)",
            "        self.add_edge(cycle[-1],cycle[0])",
            "    #頂点の交換",
            "    def __vertex_swap(self,p,q):",
            "        self.vertex.sort()",
            "    #グラフに頂点が存在するか否か",
            "    def vertex_exist(self,v):",
            "        return v in self.adjacent",
            "    #グラフに辺が存在するか否か",
            "    def edge_exist(self,u,v):",
            "        if not(self.vertex_exist(u) and self.vertex_exist(v)):",
            "            return False",
            "        return u in self.adjacent[v]",
            "    #近傍",
            "    def neighbohood(self,v):",
            "        if not self.vertex_exist(v):",
            "            return []",
            "        return list(self.adjacent[v])",
            "    #次数",
            "    def degree(self,v):",
            "        if not self.vertex_exist(v):",
            "            return 0",
            "        return len(self.adjacent[v])",
            "    #頂点数",
            "    def vertex_count(self):",
            "        return len(self.vertex)",
            "    #辺数",
            "    def edge_count(self):",
            "        return self.edge_number",
            "    #頂点vを含む連結成分",
            "    def connected_component(self,v):",
            "        if v not in self.adjacent:",
            "            return []",
            "        from collections import deque",
            "        T={u:False for u in self.adjacent}",
            "        T[v]=True",
            "        S=deque([v])",
            "        while S:",
            "            u=S.popleft()",
            "            for w in self.adjacent[u]:",
            "                if not T[w]:",
            "                    T[w]=True",
            "                    S.append(w)",
            "        return [x for x in self.adjacent if T[x]]",
            "    #距離",
            "    def distance(self,u,v):",
            "        from collections import deque",
            "        inf=float(\"inf\")",
            "        T={v:inf  for v in self.adjacent}",
            "        if u==v:",
            "            return 0",
            "        Q=deque([u])",
            "        T[u]=0",
            "        while Q:",
            "            w=Q.popleft()",
            "            for x in self.adjacent[w]:",
            "                if T[x]==inf:",
            "                    T[x]=T[w]+1",
            "                    Q.append(x)",
            "                    if x==v:",
            "                        return T[x]",
            "        return inf",
            "    #ある1点からの距離",
            "    def distance_all(self,u):",
            "        from collections import deque",
            "        inf=float(\"inf\")",
            "        T={v:inf  for v in self.adjacent}",
            "        Q=deque([u])",
            "        T[u]=0",
            "        while Q:",
            "            w=Q.popleft()",
            "            for x in self.adjacent[w]:",
            "                if T[x]==inf:",
            "                    T[x]=T[w]+1",
            "                    Q.append(x)",
            "        return T",
            "    #最短路",
            "    def shortest_path(self,u,v):",
            "        from collections import deque",
            "        T={v:None for v in self.vertex}",
            "        if u==v:",
            "            return [u]",
            "        Q=deque([u])",
            "        T[u]=u",
            "        while Q:",
            "            w=Q.popleft()",
            "            for x in self.adjacent[w]:",
            "                if not T[x]:",
            "                    T[x]=w",
            "                    Q.append(x)",
            "                    if x==v:",
            "                        P=[v]",
            "                        a=v",
            "                        while a!=u:",
            "                            a=T[a]",
            "                            P.append(a)",
            "                        return P[::-1]",
            "        return None",
            "#================================================",
            "from collections import deque",
            "N=int(input())",
            "G=Graph(range(1,N+1))",
            "for _ in range(N-1):",
            "    a,b=map(int,input().split())",
            "    G.add_edge(a,b)",
            "sp=G.shortest_path(1,N)",
            "dist=len(sp)-1",
            "u,v=sp[dist//2],sp[dist//2+1]",
            "G.remove_edge(u,v)",
            "A=len(G.connected_component(1))",
            "B=len(G.connected_component(N))",
            "if A>B:",
            "    print(\"Fennec\")",
            "else:",
            "    print(\"Snuke\")"
        ],
        "label": [
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "import heapq",
            "class Graph:",
            "    def __init__(self,v,edgelist,w_v = None,directed = False):",
            "        super().__init__()",
            "        self.v = v",
            "        self.w_e = [{} for _ in [0]*self.v]",
            "        self.neighbor = [[] for _ in [0]*self.v]",
            "        self.w_v = w_v",
            "        self.directed = directed",
            "        for i,j,w in edgelist:",
            "            self.w_e[i][j] = w",
            "            self.neighbor[i].append(j)",
            "    def dijkstra(self,v_n):",
            "        d = [float('inf')]*self.v",
            "        d[v_n] = 0",
            "        prev = [-1]*self.v",
            "        queue = []",
            "        for i,d_i in enumerate(d): heapq.heappush(queue,(d_i,i))",
            "        while len(queue)>0:",
            "            d_u,u = queue.pop()",
            "            if d[u]<d_u :continue",
            "            for v in self.neighbor[u]:",
            "                alt = d[u]+self.w_e[u][v]",
            "                if d[v]>alt:",
            "                    d[v] = alt",
            "                    prev[v] = u",
            "                    heapq.heappush(queue,(alt,v))",
            "        return d,prev",
            "    def warshallFloyd(self):",
            "        d = [[10**18]*self.v for _ in [0]*self.v]",
            "        for i in range(self.v):",
            "            d[i][i] = 0",
            "        for i in range(self.v):",
            "            for j in self.neighbor[i]:",
            "                d[i][j] = self.w_e[i][j]",
            "        for i in range(self.v):",
            "            for j in self.neighbor[i]:",
            "                d[i][j] = self.w_e[i][j]",
            "        for k in range(self.v):",
            "            for i in range(self.v):",
            "                for j in range(self.v):",
            "                    check = d[i][k] + d[k][j]",
            "                    if d[i][j] > check:",
            "                        d[i][j] = check",
            "        return d",
            "    def prim(self):",
            "        gb = GraphBuilder(self.v,self.directed)",
            "        queue = []",
            "        for i,w in self.w_e[0].items(): heapq.heappush(queue,(w,0,i))",
            "        rest = [True]*self.v",
            "        rest[0] = False",
            "        while len(queue)>0:",
            "            w,i,j = heapq.heappop(queue)",
            "            if rest[j]:",
            "                gb.addEdge(i,j,w)",
            "                rest[j] = False",
            "                for k,w in self.w_e[j].items():",
            "                    if rest[k]:",
            "                        heapq.heappush(queue,(w,j,k))",
            "        return gb",
            "class Tree():",
            "    def __init__(self,v,e):",
            "        pass",
            "class GraphBuilder():",
            "    def __init__(self,v,directed = False):",
            "        self.v = v",
            "        self.directed = directed",
            "        self.edge = []",
            "    def addEdge(self,i,j,w=1):",
            "        if not self.directed:",
            "            self.edge.append((j,i,w))",
            "        self.edge.append((i,j,w))",
            "    def addEdges(self,edgelist,weight = True):",
            "        if weight:",
            "            if self.directed:",
            "                for i,j,w in edgelist:",
            "                    self.edge.append((i,j,w))",
            "            else:",
            "                for i,j,w in edgelist:",
            "                    self.edge.append((i,j,w))",
            "                    self.edge.append((j,i,w))",
            "        else:",
            "            if self.directed:",
            "                for i,j in edgelist:",
            "                    self.edge.append((i,j,1))",
            "            else:",
            "                for i,j in edgelist:",
            "                    self.edge.append((i,j,1))",
            "                    self.edge.append((j,i,1))",
            "    def addAdjMat(self, mat):",
            "        for i,mat_i in enumerate(mat):",
            "            for j,w in enumerate(mat_i):",
            "                self.edge.append((i,j,w))",
            "    def buildTree(self):",
            "        pass",
            "    def buildGraph(self):",
            "        return Graph(self.v,self.edge,directed=self.directed)",
            "def main():",
            "    n = int(input())",
            "    edge = [tuple([int(t)-1 for t in input().split()])for _ in [0]*(n-1)]",
            "    gb = GraphBuilder(n)",
            "    gb.addEdges(edge,False)",
            "    g = gb.buildGraph()",
            "    node = [0]*n",
            "    head = [0]",
            "    tail = [n-1]",
            "    while len(head)>0 or len(tail)>0:",
            "        t = []",
            "        while len(head)>0:",
            "            h = head.pop()",
            "            for i in g.neighbor[h]:",
            "                if node[i]==0:",
            "                    t.append(i)",
            "                    node[i] = 1",
            "        head = t",
            "        t = []",
            "        while len(tail)>0:",
            "            h = tail.pop()",
            "            for i in g.neighbor[h]:",
            "                if node[i]==0:",
            "                    t.append(i)",
            "                    node[i] = -1",
            "        tail = t",
            "    ans = sum(node)",
            "    if ans>0:",
            "        print(\"Fennec\")",
            "    else:",
            "        print(\"Snuke\")",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            1,
            0,
            1,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            0,
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "from collections import defaultdict",
            "class Tree:",
            "    def __init__(self, n, edges, weight=False):",
            "        self.n = n",
            "        self.adj = [[] for _ in range(n)]",
            "        self.parent = [-1] * self.n",
            "        self.children = [[] for _ in range(self.n)]",
            "        self.dist = [-1] * self.n  # 根からの距離",
            "        self.depth = [-1] * self.n  # 根からの深さ(cost=1での距離)",
            "        self.weight = defaultdict(lambda: 10**18)",
            "        if weight:",
            "            for u, v, weight in edges:",
            "                self.adj[u].append(v)",
            "                self.adj[v].append(u)",
            "                self.weight[(u, v)] = weight",
            "                self.weight[(v, u)] = weight",
            "        else:",
            "            for u, v in edges:",
            "                self.adj[u].append(v)",
            "                self.adj[v].append(u)",
            "                self.weight[(u, v)] = 1",
            "                self.weight[(v, u)] = 1",
            "    def set_root(self, root):  # O(n)",
            "        self.root = root",
            "        self.order = [root]",
            "        self.dist[root] = 0",
            "        self.depth[root] = 0",
            "        stack = [root]",
            "        while stack:",
            "            v = stack.pop()",
            "            for child in self.adj[v]:",
            "                if child == self.parent[v]:",
            "                    continue",
            "                else:",
            "                    self.parent[child] = v",
            "                    self.children[v].append(child)",
            "                    self.dist[child] = self.dist[v] + self.weight[(v, child)]",
            "                    self.depth[child] = self.depth[v] + 1",
            "                    self.order.append(child)",
            "                    stack.append(child)",
            "    def get_root_path(self, target):",
            "        path = [target]",
            "        v = target",
            "        while v != self.root:",
            "            path.append(self.parent[v])",
            "            v = self.parent[v]",
            "        path.reverse()",
            "        return path",
            "    def get_diameter(self, restore=False):  # double-sweepで求める  O(n)",
            "        u = self.dist.index(max(self.dist))  # 根から一番遠いものを根とし、そこから一番遠いものを見つける",
            "        dist_u = [-1] * self.n",
            "        dist_u[u] = 0",
            "        stack = [u]",
            "        parent_u = [None for _ in range(self.n)]",
            "        while stack:",
            "            v = stack.pop()",
            "            for child in self.adj[v]:",
            "                if dist_u[child] == -1:",
            "                    dist_u[child] = dist_u[v] + self.weight[(v, child)]",
            "                    parent_u[child] = v",
            "                    stack.append(child)",
            "        diameter = max(dist_u)",
            "        v = dist_u.index(diameter)",
            "        if restore:",
            "            path = [v]",
            "            while v != u:",
            "                v = parent_u[v]",
            "                path.append(v)",
            "            path.reverse()  # [u,...,v]",
            "            return diameter, path",
            "        else:",
            "            return diameter, u, v",
            "    # --- Heavy Light Decomposition --- #",
            "    def heavy_light_decompose(self):  # O(n)",
            "        self.subsize = [1] * self.n  # 部分木の要素数(自分含む)",
            "        self.head = [self.root] * self.n  # 分割された各部分木の先頭",
            "        self.tree_order = [0] * self.n",
            "        # 末端の方から各頂点の部分木の要素数(subsize)を計算していって、",
            "        # heavy-nodeがchildren[v][0]に来るようにする",
            "        for v in reversed(self.order):",
            "            v_kids = self.children[v]  # 名前が長いのでalias",
            "            for i, child in enumerate(v_kids):",
            "                self.subsize[v] += self.subsize[child]",
            "                if self.subsize[child] > self.subsize[v_kids[0]]:",
            "                    v_kids[i], v_kids[0] = v_kids[0], v_kids[i]",
            "        # それぞれのnodeについて分割されたchianの先頭(head)を記録",
            "        # また、DFSの行きがけ順をtree_orderとする headの浅い順でchainが入る",
            "        stack = [self.root]",
            "        tree_label = 0",
            "        while stack:",
            "            v = stack.pop()",
            "            self.tree_order[v] = tree_label",
            "            tree_label += 1",
            "            for child in reversed(self.children[v]):  # スタックを使ったdfsのため逆にしておく",
            "                if child == self.children[v][0]:",
            "                    self.head[child] = self.head[v]",
            "                else:",
            "                    self.head[child] = child  # light-nodeは切り離されたsub-treeのheadになる",
            "                stack.append(child)",
            "    def get_hld_chain_paths(self, u, v):  # (u,v)間の経路をchainごとに返す [l,r)",
            "        ret = []",
            "        while True:",
            "            if self.tree_order[u] > self.tree_order[v]:",
            "                u, v = v, u",
            "            if self.head[u] == self.head[v]:",
            "                ret.append((self.tree_order[u], self.tree_order[v] + 1))",
            "                return ret",
            "            else:",
            "                ret.append((self.tree_order[self.head[v]], self.tree_order[v] + 1))",
            "                v = self.parent[self.head[v]]",
            "    def get_hld_lca(self, u, v):  # Lowest Common Ancestor",
            "        while True:  # head[u] = head[v] になるまで遡る",
            "            if self.tree_order[u] > self.tree_order[v]:",
            "                u, v = v, u",
            "            if self.head[u] == self.head[v]:",
            "                return u",
            "            v = self.parent[self.head[v]]",
            "    def get_hld_distance(self, u, v):",
            "        return self.dist[u] + self.dist[v] - (2 * self.dist[self.get_hld_lca(u, v)])",
            "    def exist_on_path_hld(self, u, v, x):  # u,v間の最短経路上にxがあるかどうか",
            "        return self.get_hld_distance(u, x) + self.get_hld_distance(x, v) == self.get_hld_distance(u, v)",
            "# ---------------------- #",
            "n = int(input())",
            "edges = [tuple(int(x) - 1 for x in input().split()) for _ in range(n - 1)]",
            "tree = Tree(n, edges)",
            "tree.set_root(0)",
            "tree.heavy_light_decompose()",
            "dist = tree.get_hld_distance(0, n - 1)",
            "snuke = n - 1",
            "for _ in range((dist - 1) // 2):",
            "    snuke = tree.parent[snuke]",
            "snuke_size = tree.subsize[snuke]",
            "fennec_size = n - snuke_size",
            "if snuke_size >= fennec_size:",
            "    print(\"Snuke\")",
            "else:",
            "    print(\"Fennec\")"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            2,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "import math",
            "#import sys",
            "#input = sys.stdin.readline",
            "def make_divisors(n):",
            "    divisors = []",
            "    for i in range(1, int(n**0.5)+1):",
            "        if n % i == 0:",
            "            divisors.append(i)",
            "            if i != n // i:",
            "                divisors.append(n//i)",
            "    # divisors.sort()",
            "    return divisors",
            "def ValueToBits(x,digit):",
            "    res = [0 for i in range(digit)]",
            "    now = x",
            "    for i in range(digit):",
            "        res[i]=now%2",
            "        now = now >> 1",
            "    return res",
            "def BitsToValue(arr):",
            "    n = len(arr)",
            "    ans = 0",
            "    for i in range(n):",
            "        ans+= arr[i] * 2**i",
            "    return ans",
            "def ZipArray(a):",
            "    aa = [[a[i],i]for i in range(n)]",
            "    aa.sort(key = lambda x : x[0])",
            "    for i in range(n):",
            "        aa[i][0]=i+1",
            "    aa.sort(key = lambda x : x[1])",
            "    b=[aa[i][0] for i in range(len(a))]",
            "    return b",
            "def ValueToArray10(x, digit):",
            "    ans = [0 for i in range(digit)]",
            "    now = x",
            "    for i in range(digit):",
            "        ans[digit-i-1] = now%10",
            "        now = now //10",
            "    return ans",
            "def Zeros(a,b):",
            "    if(b<=-1):",
            "        return [0 for i in range(a)]",
            "    else:",
            "        return [[0 for i in range(b)] for i in range(a)]",
            "def AddV2(v,w):",
            "    return [v[0]+w[0],v[1]+w[1]]",
            "dir4 = [[1,0],[0,1],[-1,0],[0,-1]]",
            "def clamp(x,y,z):",
            "    return max(y,min(z,x))",
            "class Bit:",
            "    def __init__(self, n):",
            "        self.size = n",
            "        self.tree = [0] * (n + 1)",
            "    def sum(self, i):",
            "        s = 0",
            "        while i > 0:",
            "            s += self.tree[i]",
            "            i -= i & -i",
            "        return s",
            "    def add(self, i, x):",
            "        while i <= self.size:",
            "            self.tree[i] += x",
            "            i += i & -i",
            "#",
            "def Zaatsu(a):",
            "    a.sort()",
            "    now = a[0][0]",
            "    od = 0",
            "    for i in range(n):",
            "        if(now==a[i][0]):",
            "            a[i][0]=od",
            "        else:",
            "            now = a[i][0]",
            "            od+=1",
            "            a[i][0] = od",
            "    a.sort(key = lambda x : x[1])",
            "    return a",
            "class UnionFind:",
            "    def __init__(self, n):",
            "        self.par = [i for i in range(n+1)]",
            "        self.rank = [0] * (n+1)",
            "    # 検索",
            "    def find(self, x):",
            "        if self.par[x] == x:",
            "            return x",
            "        else:",
            "            self.par[x] = self.find(self.par[x])",
            "            return self.par[x]",
            "    # 併合",
            "    def union(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "        if self.rank[x] < self.rank[y]:",
            "            self.par[x] = y",
            "        else:",
            "            self.par[y] = x",
            "            if self.rank[x] == self.rank[y]:",
            "                self.rank[x] += 1",
            "    # 同じ集合に属するか判定",
            "    def same_check(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "'''",
            "def cmb(n, r, p):",
            "    if (r < 0) or (n < r):",
            "        return 0",
            "    r = min(r, n - r)",
            "    return fact[n] * factinv[r] * factinv[n-r] % p",
            "p = 2",
            "N = 10 ** 6 + 2",
            "fact = [1, 1]  # fact[n] = (n! mod p)",
            "factinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)",
            "inv = [0, 1]  # factinv 計算用",
            "for i in range(2, N + 1):",
            "    fact.append((fact[-1] * i) % p)",
            "    inv.append((-inv[p % i] * (p // i)) % p)",
            "    factinv.append((factinv[-1] * inv[-1]) % p)",
            "'''",
            "def rl(x):",
            "    return range(len(x))",
            "# a = list(map(int, input().split()))",
            "#################################################",
            "#################################################",
            "#################################################",
            "#################################################",
            "#52-",
            "n = int(input())",
            "nb = [[]for i in range(n)]",
            "for i in range(n-1):",
            "    a,b = list(map(int, input().split()))",
            "    a-=1",
            "    b-=1",
            "    nb[a].append(b)",
            "    nb[b].append(a)",
            "queue = [0,n-1]",
            "done=0",
            "col = [-1]*n",
            "col[0]=0",
            "col[n-1]=1",
            "while(len(queue)>done):",
            "    now = queue[done]",
            "    done+=1",
            "    for i in nb[now]:",
            "        if(col[i]==-1):",
            "            queue.append(i)",
            "            col[i] = col[now]",
            "print(\"Fennec\" if n-sum(col) > sum(col) else \"Snuke\")"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            1,
            0,
            1,
            0,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            2,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    x, a, b = mi()",
            "    if b <= a:",
            "        print('delicious')",
            "    elif b <= a + x:",
            "        print('safe')",
            "    else:",
            "        print('dangerous')",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def make_factorial_table(size, mod):",
            "        '''",
            "        fact_mod[i] は i! % mod を表す。fact_mod[0] ~ facto_mod[size] まで計算可能なテーブルを返す",
            "        >>> make_factorial_table(20, 10**9+7)",
            "        [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 227020758, 178290591, 674358851, 789741546, 425606191, 660911389, 557316307, 146326063]",
            "        '''",
            "        fact_mod = [1] * (size + 1)",
            "        for i in range(1, size + 1):",
            "            fact_mod[i] = (fact_mod[i - 1] * i) % mod",
            "        return fact_mod",
            "    n, m = mi()",
            "    n, m = min(n, m), max(n, m)",
            "    fact = make_factorial_table(m, mod)",
            "    if n == m-1:",
            "        print((fact[m]*fact[n]) % mod)",
            "    elif n == m:",
            "        print((2*fact[m]*fact[n]) % mod)",
            "    else:",
            "        print(0)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def preprocess(seq, n):",
            "        stripped = False",
            "        for i in range(n-1):",
            "            if seq[i] == '(' and seq[i+1] == ')':",
            "                new_seq = seq[:i] + seq[i+2:]",
            "                stripped = True",
            "                break",
            "        if stripped:",
            "            return preprocess(new_seq, n-2)",
            "        else:",
            "            return seq",
            "    n = ii()",
            "    initial = input()",
            "    L = list(initial)",
            "    stripped = preprocess(L, n)",
            "    # print(stripped)",
            "    left_p = stripped.count(')')",
            "    right_p = stripped.count('(')",
            "    print('(' * left_p + initial + ')' * right_p)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n = ii()",
            "    scores = [ii() for _ in range(n)]",
            "    scores.sort()",
            "    if sum(scores) % 10 != 0:",
            "        print(sum(scores))",
            "    else:",
            "        dec = sum(scores)",
            "        for elm in scores:",
            "            if elm % 10 != 0:",
            "                dec = elm",
            "                break",
            "        print(sum(scores) - dec)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    # class MaxHeap:",
            "    #     def __init__(self, seq):",
            "    #         tmp = list(map(lambda x: -x, seq))",
            "    #         heapify(tmp)",
            "    #         self.h = tmp",
            "    #     def push(self, num):",
            "    #         heappush(self.h, - num)",
            "    #     def pop(self):",
            "    #         return -heappop(self.h)",
            "    # n, a, b = mi()",
            "    # hp = MaxHeap([ii() for _ in range(n)])",
            "    # cnt = 0",
            "    # while True:",
            "    #     max_hp = hp.pop()",
            "    #     if max_hp <= cnt * b:",
            "    #         break",
            "    #     else:",
            "    #         hp.push(max_hp - (a - b))",
            "    #         cnt += 1",
            "    # print(cnt)",
            "    def ceil_div_alternative(x, y):",
            "        \"\"\"",
            "        Args:",
            "            x, y (int)",
            "        Returns:",
            "            int",
            "        ceil(x / y) を正確に返す (y を何整数倍すると x 以上になるか？の値)",
            "        >>> ceil_div_alternative(4, 2)",
            "        2",
            "        >>> ceil_div_alternative(4, 3)",
            "        2",
            "        > ceil() 、 floor() 、および modf() 関数については、非常に大きな浮動小数点数が 全て 整数そのものになるということに注意してください。",
            "        > 通常、Python の浮動小数点型は 53 ビット以上の精度をもたない (プラットフォームにおける C double 型と同じ) ので、",
            "        > 結果的に abs(x) >= 2**52 であるような浮動小数点型 x は小数部分を持たなくなるのです。",
            "        > 10 ** 15 + 0.2 == 10 ** 15",
            "        > False",
            "        > 10 ** 16 + 0.2 == 10 ** 16",
            "        > True",
            "        x / y が大きな浮動小数点数となる場合は ceil ではなく、この関数を使うようにする。",
            "        \"\"\"",
            "        assert (isinstance(x, int) and isinstance(y, int))",
            "        assert (x >= 0 and y > 0)",
            "        return (x + y - 1) // y",
            "    def can_defeat_predicate(hp_list, operation_times, a, b):",
            "        n = len(hp_list)",
            "        start = bisect_right(hp_list, b * operation_times)",
            "        if start == n:",
            "            return True",
            "        else:",
            "            res = [hp_list[i] - b * operation_times for i in range(start, n)]",
            "            cnt = 0",
            "            for elm in res:",
            "                cnt += ceil_div_alternative(elm, a - b)",
            "            return cnt <= operation_times",
            "    def binary_search(hp_list, a, b):",
            "        left = 0    # 絶対に倒せない操作回数",
            "        right = 10**9+1    # 絶対に倒せる操作回数",
            "        while right - left > 1:",
            "            mid = (right + left) // 2",
            "            if can_defeat_predicate(hp_list, mid, a, b):",
            "                right = mid",
            "            else:",
            "                left = mid",
            "        return right",
            "    n, a, b = mi()",
            "    hp = sorted([ii() for _ in range(n)])",
            "    print(binary_search(hp, a, b))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    x, y = mi()",
            "    s = [4, 6, 9, 11]",
            "    if x == 2 or y == 2:",
            "        print('No')",
            "    else:",
            "        if (x in s and y in s) or (x not in s and y not in s):",
            "            print('Yes')",
            "        else:",
            "            print('No')",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    h, w = mi()",
            "    grid = [input() for _ in range(h)]",
            "    print('#'*(w+2))",
            "    for i in range(h):",
            "        print('#' + grid[i] + '#')",
            "    print('#'*(w+2))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, m = mi()",
            "    adj = [[] for _ in range(n)]",
            "    for _ in range(m):",
            "        a, b = mi_0()",
            "        adj[a].append(b)",
            "        adj[b].append(a)",
            "    for i in range(n):",
            "        print(len(adj[i]))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, k = mi()",
            "    L = [lmi() for _ in range(n)]",
            "    L.sort(key=lambda x: x[0])",
            "    for a, b in L:",
            "        if k > b:",
            "            k -= b",
            "        else:",
            "            print(a)",
            "            exit()",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# -*- coding: utf-8 -*-",
            "import sys",
            "import math",
            "import os",
            "import itertools",
            "import string",
            "import heapq",
            "import _collections",
            "from collections import Counter",
            "from collections import defaultdict",
            "from functools import lru_cache",
            "import bisect",
            "class Scanner():",
            "    @staticmethod",
            "    def int():",
            "        return int(sys.stdin.readline().rstrip())",
            "    @staticmethod",
            "    def string():",
            "        return sys.stdin.readline().rstrip()",
            "    @staticmethod",
            "    def map_int():",
            "        return [int(x) for x in Scanner.string().split()]",
            "    @staticmethod",
            "    def string_list(n):",
            "        return [input() for i in range(n)]",
            "    @staticmethod",
            "    def int_list_list(n):",
            "        return [Scanner.map_int() for i in range(n)]",
            "    @staticmethod",
            "    def int_cols_list(n):",
            "        return [int(input()) for i in range(n)]",
            "class Math():",
            "    @staticmethod",
            "    def gcd(a, b):",
            "        if b == 0:",
            "            return a",
            "        return Math.gcd(b, a % b)",
            "    @staticmethod",
            "    def lcm(a, b):",
            "        return (a * b) // Math.gcd(a, b)",
            "    @staticmethod",
            "    def roundUp(a, b):",
            "        return -(-a // b)",
            "    @staticmethod",
            "    def toUpperMultiple(a, x):",
            "        return Math.roundUp(a, x) * x",
            "    @staticmethod",
            "    def toLowerMultiple(a, x):",
            "        return (a // x) * x",
            "    @staticmethod",
            "    def nearPow2(n):",
            "        if n <= 0:",
            "            return 0",
            "        if n & (n - 1) == 0:",
            "            return n",
            "        ret = 1",
            "        while(n > 0):",
            "            ret <<= 1",
            "            n >>= 1",
            "        return ret",
            "    @staticmethod",
            "    def sign(n):",
            "        if n == 0:",
            "            return 0",
            "        if n < 0:",
            "            return -1",
            "        return 1",
            "    @staticmethod",
            "    def isPrime(n):",
            "        if n < 2:",
            "            return False",
            "        if n == 2:",
            "            return True",
            "        if n % 2 == 0:",
            "            return False",
            "        d = int(n ** 0.5) + 1",
            "        for i in range(3, d + 1, 2):",
            "            if n % i == 0:",
            "                return False",
            "        return True",
            "MOD = int(1e09) + 7",
            "INF = int(1e15)",
            "def main():",
            "    # sys.stdin = open(\"sample.txt\")",
            "    N, M = Scanner.map_int()",
            "    class Edge():",
            "        def __init__(self, a, b, c):",
            "            self.from_ = a",
            "            self.to_ = b",
            "            self.cost_ = c",
            "    edges = [Edge] * M",
            "    for i in range(M):",
            "        a, b, c = Scanner.map_int()",
            "        a -= 1",
            "        b -= 1",
            "        c = -c",
            "        edges[i] = Edge(a, b, c)",
            "    dist = [INF] * N",
            "    dist[0] = 0",
            "    for loop in range(N-1):",
            "        for i in range(M):",
            "            e = edges[i]",
            "            if dist[e.from_] == INF:",
            "                continue",
            "            if dist[e.to_] > dist[e.from_] + e.cost_:",
            "                dist[e.to_] = dist[e.from_] + e.cost_",
            "    ans = dist[N-1]",
            "    negatives = [False] * N",
            "    for loop in range(N):",
            "        for i in range(M):",
            "            e = edges[i]",
            "            if dist[e.from_] == INF:",
            "                continue",
            "            if dist[e.to_] > dist[e.from_] + e.cost_:",
            "                dist[e.to_] = dist[e.from_] + e.cost_",
            "                negatives[e.to_] = True",
            "            if negatives[e.from_]:",
            "                negatives[e.to_] = True",
            "    if negatives[N-1]:",
            "        print(\"inf\")",
            "    else:",
            "        print(-ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, w = mi()",
            "    L = [lmi() for _ in range(n)]",
            "    w1 = L[0][0]",
            "    if n * (w1 + 3) <= w:",
            "        print(sum(map(lambda x: x[1], L)))",
            "    elif n * w <= 10**6:",
            "        # 普通の dp 戦略",
            "        dp = [0 for _ in range(w+1)]",
            "        for i in range(n):",
            "            weight, value = L[i]",
            "            for j in range(w, 0, -1):",
            "                if j - weight >= 0:",
            "                    dp[j] = max(dp[j], dp[j - weight] + value)",
            "        print(dp[w])",
            "    else:",
            "        group_by_weight = [[] for _ in range(4)]",
            "        for weight, value in L:",
            "            group_by_weight[weight - w1].append(value)",
            "        w1_0 = sorted(group_by_weight[0], reverse=True)",
            "        w1_1 = sorted(group_by_weight[1], reverse=True)",
            "        w1_2 = sorted(group_by_weight[2], reverse=True)",
            "        w1_3 = sorted(group_by_weight[3], reverse=True)",
            "        accum_0, accum_1, accum_2, accum_3 = map(lambda x: [0] + list(accumulate(x)), [w1_0, w1_1, w1_2, w1_3])",
            "        ans = -1",
            "        for i in range(len(w1_0)+1):",
            "            for j in range(len(w1_1)+1):",
            "                for k in range(len(w1_2)+1):",
            "                    for l in range(len(w1_3)+1):",
            "                        if (i+j+k+l)*w1 + j + 2*k + 3*l <= w:",
            "                            ans = max(ans, accum_0[i] + accum_1[j] + accum_2[k] + accum_3[l])",
            "        print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "import heapq",
            "import re",
            "from itertools import permutations",
            "from bisect import bisect_left, bisect_right",
            "from collections import Counter, deque",
            "from fractions import gcd",
            "from math import factorial, sqrt, ceil",
            "from functools import lru_cache, reduce",
            "INF = 1 << 60",
            "MOD = 1000000007",
            "sys.setrecursionlimit(10 ** 7)",
            "# UnionFind",
            "class UnionFind():",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parents = [-1] * n",
            "    def find(self, x):",
            "        if self.parents[x] < 0:",
            "            return x",
            "        else:",
            "            self.parents[x] = self.find(self.parents[x])",
            "            return self.parents[x]",
            "    def union(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "        if x == y:",
            "            return",
            "        if self.parents[x] > self.parents[y]:",
            "            x, y = y, x",
            "        self.parents[x] += self.parents[y]",
            "        self.parents[y] = x",
            "    def size(self, x):",
            "        return -self.parents[self.find(x)]",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "    def members(self, x):",
            "        root = self.find(x)",
            "        return [i for i in range(self.n) if self.find(i) == root]",
            "    def roots(self):",
            "        return [i for i, x in enumerate(self.parents) if x < 0]",
            "    def group_count(self):",
            "        return len(self.roots())",
            "    def all_group_members(self):",
            "        return {r: self.members(r) for r in self.roots()}",
            "    def __str__(self):",
            "        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())",
            "def is_prime(n):",
            "    if n == 1:",
            "        return False",
            "    for i in range(2,int(n**0.5)+1):",
            "        if n % i == 0:",
            "            return False",
            "    return True",
            "# ワーシャルフロイド (任意の2頂点の対に対して最短経路を求める)",
            "# 計算量n^3 (nは頂点の数)",
            "def warshall_floyd(d, n):",
            "    #d[i][j]: iからjへの最短距離",
            "    for k in range(n):",
            "        for i in range(n):",
            "            for j in range(n):",
            "                d[i][j] = min(d[i][j],d[i][k] + d[k][j])",
            "    return d",
            "# ダイクストラ",
            "def dijkstra_heap(s, edge, n):",
            "    #始点sから各頂点への最短距離",
            "    d = [10**20] * n",
            "    used = [True] * n #True:未確定",
            "    d[s] = 0",
            "    used[s] = False",
            "    edgelist = []",
            "    for a,b in edge[s]:",
            "        heapq.heappush(edgelist,a*(10**6)+b)",
            "    while len(edgelist):",
            "        minedge = heapq.heappop(edgelist)",
            "        #まだ使われてない頂点の中から最小の距離のものを探す",
            "        if not used[minedge%(10**6)]:",
            "            continue",
            "        v = minedge%(10**6)",
            "        d[v] = minedge//(10**6)",
            "        used[v] = False",
            "        for e in edge[v]:",
            "            if used[e[1]]:",
            "                heapq.heappush(edgelist,(e[0]+d[v])*(10**6)+e[1])",
            "    return d",
            "# 素因数分解",
            "def factorization(n):",
            "    arr = []",
            "    temp = n",
            "    for i in range(2, int(-(-n**0.5//1))+1):",
            "        if temp%i==0:",
            "            cnt=0",
            "            while temp%i==0:",
            "                cnt+=1",
            "                temp //= i",
            "            arr.append([i, cnt])",
            "    if temp!=1:",
            "        arr.append([temp, 1])",
            "    if arr==[]:",
            "        arr.append([n, 1])",
            "    return arr",
            "# 2数の最小公倍数",
            "def lcm(x, y):",
            "    return (x * y) // gcd(x, y)",
            "# リストの要素の最小公倍数",
            "def lcm_list(numbers):",
            "    return reduce(lcm, numbers, 1)",
            "# リストの要素の最大公約数",
            "def gcd_list(numbers):",
            "    return reduce(gcd, numbers)",
            "# 素数判定",
            "# limit以下の素数を列挙",
            "def eratosthenes(limit):",
            "    A = [i for i in range(2, limit+1)]",
            "    P = []",
            "    while True:",
            "        prime = min(A)",
            "        if prime > sqrt(limit):",
            "            break",
            "        P.append(prime)",
            "        i = 0",
            "        while i < len(A):",
            "            if A[i] % prime == 0:",
            "                A.pop(i)",
            "                continue",
            "            i += 1",
            "    for a in A:",
            "        P.append(a)",
            "    return P",
            "# 同じものを含む順列",
            "def permutation_with_duplicates(L):",
            "    if L == []:",
            "        return [[]]",
            "    else:",
            "        ret = []",
            "        # set（集合）型で重複を削除、ソート",
            "        S = sorted(set(L))",
            "        for i in S:",
            "            data = L[:]",
            "            data.remove(i)",
            "            for j in permutation_with_duplicates(data):",
            "                ret.append([i] + j)",
            "        return ret",
            "# ここから書き始める",
            "N, W = map(int, input().split())",
            "v = [[] for i in range(4)]",
            "w1 = 0",
            "for i in range(N):",
            "    a, b = map(int, input().split())",
            "    if i == 0:",
            "        w1 = a",
            "    v[a - w1].append(b)",
            "for i in range(4):",
            "    v[i].sort(reverse=True)",
            "# print(v)",
            "ans = 0",
            "for i in range(N + 1):",
            "    for j in range(N - i + 1):",
            "        for k in range(N - i - j + 1):",
            "            for l in range(N - i - j - k + 1):",
            "                if w1 * (i + j + k + l) + j + 2 * k + 3 * l > W:",
            "                    continue",
            "                ans = max(ans, sum(v[0][:i]) + sum(v[1][:j]) + sum(v[2][:k]) + sum(v[3][:l]))",
            "print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            1,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            2,
            1,
            2,
            2,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    a = ii()",
            "    b = ii()",
            "    if a > b:",
            "        print('GREATER')",
            "    elif a == b:",
            "        print('EQUAL')",
            "    else:",
            "        print('LESS')",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def calc_cost_pos_neg(seq):",
            "        n = len(seq)",
            "        cnt = 0",
            "        total = 0",
            "        for i in range(n):",
            "            if i % 2 == 0 and seq[i] + total <= 0:",
            "                cnt += (1 - (seq[i] + total))",
            "                total += (1 - (seq[i] + total))",
            "            elif i % 2 == 1 and seq[i] + total >= 0:",
            "                cnt += ((seq[i] + total) - (-1))",
            "                total -= ((seq[i] + total) - (-1))",
            "        return cnt",
            "    def calc_cost_neg_pos(seq):",
            "        n = len(seq)",
            "        cnt = 0",
            "        total = 0",
            "        for i in range(n):",
            "            if i % 2 == 1 and seq[i] + total <= 0:",
            "                cnt += (1 - (seq[i] + total))",
            "                total += (1 - (seq[i] + total))",
            "            elif i % 2 == 0 and seq[i] + total >= 0:",
            "                cnt += ((seq[i] + total) - (-1))",
            "                total -= ((seq[i] + total) - (-1))",
            "        return cnt",
            "    n = ii()",
            "    L = lmi()",
            "    accum = list(accumulate(L))",
            "    print(min(calc_cost_pos_neg(accum), calc_cost_neg_pos(accum)))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "# input()",
            "# int(input())",
            "# map(int, input().split())",
            "# list(map(int, input().split()))",
            "# list(map(int, list(input()))) # スペースがない数字リストを読み込み",
            "import math",
            "import fractions",
            "import sys",
            "import bisect",
            "import heapq  # 優先度付きキュー(最小値取り出し)",
            "import collections",
            "from collections import Counter",
            "from collections import deque",
            "import pprint",
            "sr = lambda: input()",
            "ir = lambda: int(sr())",
            "lr = lambda: list(map(int, sr().split()))",
            "\"\"\"nを素因数分解\"\"\"",
            "\"\"\"2以上の整数n => [[素因数, 指数], ...]の2次元リスト\"\"\"",
            "def factorization(n):",
            "    arr = []",
            "    temp = n",
            "    if n == 1:",
            "        return arr",
            "    for i in range(2, int(-(-n ** 0.5 // 1)) + 1):",
            "        if temp % i == 0:",
            "            cnt = 0",
            "            while temp % i == 0:",
            "                cnt += 1",
            "                temp //= i",
            "            arr.append([i, cnt])",
            "    if temp != 1:",
            "        arr.append([temp, 1])",
            "    if arr == []:",
            "        arr.append([n, 1])",
            "    return arr",
            "# a^n",
            "def power(a, n, mod):",
            "    x = 1",
            "    while n:",
            "        if n & 1:",
            "            x *= a % mod",
            "        n >>= 1",
            "        a *= a % mod",
            "    return x % mod",
            "# n*(n-1)*...*(l+1)*l",
            "def kaijo(n, l, mod):",
            "    if n == 0:",
            "        return 1",
            "    a = n",
            "    tmp = n - 1",
            "    while (tmp >= l):",
            "        a = a * tmp % mod",
            "        tmp -= 1",
            "    return a",
            "inf = 10 ** 18",
            "mod = 10 ** 9 + 7",
            "# segment tree",
            "class SegmentTree:",
            "    # 初期化処理",
            "    # f : SegmentTreeにのせるモノイド",
            "    # default : fに対する単位元",
            "    def __init__(self, size, f=lambda x, y: x + y, default=0):",
            "        self.size = 2 ** (size - 1).bit_length()  # 簡単のため要素数Nを2冪にする",
            "        self.default = default",
            "        self.dat = [default] * (self.size * 2)  # 要素を単位元で初期化",
            "        self.f = f",
            "    def update(self, i, x):",
            "        i += self.size",
            "        self.dat[i] = x",
            "        while i > 0:",
            "            i >>= 1",
            "            self.dat[i] = self.f(self.dat[i * 2], self.dat[i * 2 + 1])",
            "    def query(self, l, r):",
            "        l += self.size",
            "        r += self.size",
            "        lres, rres = self.default, self.default",
            "        while l < r:",
            "            if l & 1:",
            "                lres = self.f(lres, self.dat[l])",
            "                l += 1",
            "            if r & 1:",
            "                r -= 1",
            "                rres = self.f(self.dat[r], rres)  # モノイドでは可換律は保証されていないので演算の方向に注意",
            "            l >>= 1",
            "            r >>= 1",
            "        res = self.f(lres, rres)",
            "        return res",
            "n = ir()",
            "a = lr()",
            "seg1 = SegmentTree(n, lambda x, y: x + y, 0)",
            "seg2 = SegmentTree(n, lambda x, y: x + y, 0)",
            "for i, num in enumerate(a):",
            "    seg1.update(i, num)  # 0オリジンのi個目をnumに更新 O(n)",
            "    seg2.update(i, num)  # 0オリジンのi個目をnumに更新 O(n)",
            "ans1 = 0",
            "ans2 = 0",
            "pflag = True",
            "pflag2 = False",
            "for i in range(1,n+1):",
            "    now1 = seg1.query(0,i)",
            "    if pflag and now1 <= 0:",
            "        seg1.update(i-1, a[i-1]-now1+1)",
            "        ans1+=(1-now1)",
            "    elif (not pflag) and now1 >= 0:",
            "        seg1.update(i-1, a[i-1]-now1-1)",
            "        ans1+=(now1+1)",
            "    now2 = seg2.query(0,i)",
            "    if pflag2 and now2 <= 0:",
            "        seg2.update(i-1, a[i-1]-now2+1)",
            "        ans2+=(1-now2)",
            "    elif (not pflag2) and now2 >= 0:",
            "        seg2.update(i-1, a[i-1]-now2-1)",
            "        ans2+=(now2+1)",
            "    pflag = not pflag",
            "    pflag2 = not pflag2",
            "print(min(ans1,ans2))"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            2
        ]
    },
    {
        "content": [
            "# coding: utf-8",
            "# hello worldと表示する",
            "import sys",
            "import numpy",
            "input = sys.stdin.readline",
            "sys.setrecursionlimit(10**7)",
            "from collections import Counter, deque",
            "from collections import defaultdict",
            "from itertools import combinations, permutations, accumulate, groupby, product",
            "from bisect import bisect_left,bisect_right",
            "from heapq import heapify, heappop, heappush",
            "from math import floor, ceil,pi,factorial",
            "from operator import itemgetter",
            "from copy import deepcopy",
            "def I(): return int(input())",
            "def MI(): return map(int, input().split())",
            "def LI(): return list(map(int, input().split()))",
            "def LI2(): return [int(input()) for i in range(n)]",
            "def MXI(): return [[LI()]for i in range(n)]",
            "def SI(): return input().rstrip()",
            "def printns(x): print('\\n'.join(x))",
            "def printni(x): print('\\n'.join(list(map(str,x))))",
            "inf = 10**17",
            "mod = 10**9 + 7",
            "n=I()",
            "seq=LI()",
            "'''if seq[0]>0:",
            "    pm=-1",
            "    sm=seq[0]",
            "    count=0",
            "    for i in range(n-1):",
            "        sm=sm+seq[i+1]",
            "        if pm>0:",
            "            if sm<=0:",
            "                count+=1-sm",
            "                sm=1",
            "            pm=-1",
            "        else:",
            "            if sm>=0:",
            "                count+=1+sm",
            "                sm=-1",
            "            pm=1",
            "    print(count)",
            "elif seq[0]<0:",
            "    pm=1",
            "    sm=seq[0]",
            "    count=0",
            "    for i in range(n-1):",
            "        sm=sm+seq[i+1]",
            "        if pm>0:",
            "            if sm<=0:",
            "                count+=1-sm",
            "                sm=1",
            "            pm=-1",
            "        else:",
            "            if sm>=0:",
            "                count+=1+sm",
            "                sm=-1",
            "            pm=1",
            "    print(count)'''",
            "if seq[0]>0:",
            "    pm=-1",
            "    sm=seq[0]",
            "    count=0",
            "    for i in range(n-1):",
            "        sm=sm+seq[i+1]",
            "        if pm>0:",
            "            if sm<=0:",
            "                count+=1-sm",
            "                sm=1",
            "            pm=-1",
            "        else:",
            "            if sm>=0:",
            "                count+=1+sm",
            "                sm=-1",
            "            pm=1",
            "    count1=count",
            "    pm=1",
            "    sm=-1",
            "    count=1+seq[0]",
            "    for i in range(n-1):",
            "        sm=sm+seq[i+1]",
            "        if pm>0:",
            "            if sm<=0:",
            "                count+=1-sm",
            "                sm=1",
            "            pm=-1",
            "        else:",
            "            if sm>=0:",
            "                count+=1+sm",
            "                sm=-1",
            "            pm=1",
            "    count2=count",
            "    print(min(count1,count2))",
            "elif seq[0]<0:",
            "    pm=1",
            "    sm=seq[0]",
            "    count=0",
            "    for i in range(n-1):",
            "        sm=sm+seq[i+1]",
            "        if pm>0:",
            "            if sm<=0:",
            "                count+=1-sm",
            "                sm=1",
            "            pm=-1",
            "        else:",
            "            if sm>=0:",
            "                count+=1+sm",
            "                sm=-1",
            "            pm=1",
            "    count1=count",
            "    pm=-1",
            "    sm=1",
            "    count=1-seq[0]",
            "    for i in range(n-1):",
            "        sm=sm+seq[i+1]",
            "        if pm>0:",
            "            if sm<=0:",
            "                count+=1-sm",
            "                sm=1",
            "            pm=-1",
            "        else:",
            "            if sm>=0:",
            "                count+=1+sm",
            "                sm=-1",
            "            pm=1",
            "    count2=count",
            "    print(min(count1,count2))",
            "else:",
            "    pm=-1",
            "    sm=1",
            "    count=1",
            "    for i in range(n-1):",
            "        sm=sm+seq[i+1]",
            "        if pm>0:",
            "            if sm<=0:",
            "                count+=1-sm",
            "                sm=1",
            "            pm=-1",
            "        else:",
            "            if sm>=0:",
            "                count+=1+sm",
            "                sm=-1",
            "            pm=1",
            "    count1=count",
            "    pm=1",
            "    sm=-1",
            "    count=1",
            "    for i in range(n-1):",
            "        sm=sm+seq[i+1]",
            "        if pm>0:",
            "            if sm<=0:",
            "                count+=1-sm",
            "                sm=1",
            "            pm=-1",
            "        else:",
            "            if sm>=0:",
            "                count+=1+sm",
            "                sm=-1",
            "            pm=1",
            "    count2=count",
            "    print(min(count1,count2))"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def count_min_num(seq, char):",
            "        min_num = 2 ** 64 - 1",
            "        for s in seq:",
            "            min_num = min(min_num, s.count(char))",
            "            if min_num == 0:",
            "                return min_num",
            "        return min_num",
            "    n = ii()",
            "    L = [input() for _ in range(n)]",
            "    d = dict()",
            "    for char in string.ascii_lowercase:",
            "        d[char] = count_min_num(L, char)",
            "    s = ''",
            "    for char in string.ascii_lowercase:",
            "        s += char * d[char]",
            "    print(s)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, m = mi()",
            "    X = lmi()",
            "    Y = lmi()",
            "    tmp = 0",
            "    for j in range(m - 1):",
            "        tmp = (tmp + (j + 1) * (m - j - 1) * (Y[j+1] - Y[j])) % mod",
            "    ans = 0",
            "    for i in range(n - 1):",
            "        ans = (ans + (i + 1) * (n - i - 1) * (X[i+1] - X[i]) * tmp) % mod",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "sys.setrecursionlimit(10**7) #再帰関数の上限,10**5以上の場合python",
            "import math",
            "from copy import copy, deepcopy",
            "from copy import deepcopy as dcp",
            "from operator import itemgetter",
            "from bisect import bisect_left, bisect, bisect_right#2分探索",
            "#bisect_left(l,x), bisect(l,x)#aはソート済みである必要あり。aの中からx未満の要素数を返す。rightだと以下",
            "from collections import deque, defaultdict",
            "#deque(l), pop(), append(x), popleft(), appendleft(x)",
            "#q.rotate(n)で → にn回ローテート",
            "from collections import Counter#文字列を個数カウント辞書に、",
            "#S=Counter(l),S.most_common(x),S.keys(),S.values(),S.items()",
            "from itertools import accumulate,combinations,permutations,product#累積和",
            "#list(accumulate(l))",
            "from heapq import heapify,heappop,heappush",
            "#heapify(q),heappush(q,a),heappop(q) #q=heapify(q)としないこと、返り値はNone",
            "from functools import reduce,lru_cache#pypyでもうごく",
            "#@lru_cache(maxsize = None)#maxsizeは保存するデータ数の最大値、2**nが最も高効率",
            "from decimal import Decimal",
            "from argparse import ArgumentParser",
            "def input():",
            "    x=sys.stdin.readline()",
            "    return x[:-1] if x[-1]==\"\\n\" else x",
            "def printe(*x):print(\"## \",*x,file=sys.stderr)",
            "def printl(li): _=print(*li, sep=\"\\n\") if li else None",
            "def argsort(s, return_sorted=False):",
            "    inds=sorted(range(len(s)), key=lambda k: s[k])",
            "    if return_sorted: return inds, [s[i] for i in inds]",
            "    return inds",
            "def alp2num(c,cap=False): return ord(c)-97 if not cap else ord(c)-65",
            "def num2alp(i,cap=False): return chr(i+97) if not cap else chr(i+65)",
            "def matmat(A,B):",
            "    K,N,M=len(B),len(A),len(B[0])",
            "    return [[sum([(A[i][k]*B[k][j]) for k in range(K)]) for j in range(M)] for i in range(N)]",
            "def matvec(M,v):",
            "    N,size=len(v),len(M)",
            "    return [sum([M[i][j]*v[j] for j in range(N)]) for i in range(size)]",
            "def T(M):",
            "    n,m=len(M),len(M[0])",
            "    return [[M[j][i] for j in range(n)] for i in range(m)]",
            "def binr(x): return bin(x)[2:]",
            "def bitcount(x): #xは64bit整数",
            "    x= x - ((x >> 1) & 0x5555555555555555)",
            "    x= (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)",
            "    x= (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f",
            "    x+= (x >> 8); x+= (x >> 16); x+= (x >> 32)",
            "    return x & 0x7f",
            "def main():",
            "    mod = 1000000007",
            "    #w.sort(key=itemgetter(1),reverse=True)  #二個目の要素で降順並び替え",
            "    #N = int(input())",
            "    N,A,B = map(int, input().split())",
            "    vs = list(map(int, input().split())) #1行ベクトル",
            "    #L = tuple(int(input()) for i in range(N)) #改行ベクトル",
            "    #S = tuple(tuple(map(int, input().split())) for i in range(N)) #改行行列",
            "    vs.sort(reverse=True)",
            "    cs=Counter(vs)",
            "    tot=0",
            "    cnt=0",
            "    pr=-1",
            "    for i in range(A):",
            "        cur=vs[i]",
            "        tot+=cur",
            "        if cur!=pr:",
            "            cnt=1",
            "        else:",
            "            cnt+=1",
            "        pr=cur",
            "    ave=tot/A",
            "    print(ave)",
            "        #float計算用のcombination, 最後にexpを取るのを忘れない、積は和でとること",
            "    maxn=N",
            "    lfact=[1]*(maxn+1)#NはnCrの最大のn",
            "    for i in range(1,maxn+1):",
            "        lfact[i]=lfact[i-1]*i",
            "    def lcomb(n,r): return lfact[n]//lfact[n-r]//lfact[r]",
            "    tc=cs[cur]",
            "    if cnt==A:",
            "        ans=0",
            "        for cnt in range(A,B+1):",
            "            ans+=(lcomb(tc,cnt))",
            "    else:",
            "        ans=(lcomb(tc,cnt))",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    class Pascal:",
            "        def __init__(self, num):",
            "            self.n = num",
            "            self.pascal = [[1] * (i+1) for i in range(num+1)]",
            "            for i in range(2, num+1):    # i 段目 iC0 ... iCi",
            "                for j in range(1, i):",
            "                    self.pascal[i][j] = self.pascal[i-1][j-1] + self.pascal[i-1][j]",
            "        def comb(self, a, b):",
            "            return self.pascal[a][b]",
            "    n, a, b = mi()",
            "    value = lmi()",
            "    value.sort(reverse=True)",
            "    first_choice = value[:a]",
            "    max_avg = sum(first_choice) / a",
            "    print(max_avg)",
            "    i = a - 1",
            "    while i > 0 and first_choice[i-1] == first_choice[-1]:",
            "        i -= 1",
            "    j = a - 1",
            "    while j < n - 1 and value[j+1] == first_choice[-1]:",
            "        j += 1",
            "    # value[i]...value[j] は first_choice[-1] と一致している",
            "    p = Pascal(51)",
            "    ans = 0",
            "    if i == 0:",
            "        # j+1 C x (x = a to min(b, j+1))",
            "        for k in range(a, min(b + 1, j + 2)):",
            "            ans += p.comb(j + 1, k)",
            "        print(ans)",
            "    else:",
            "        # j-i+1 C a-i",
            "        print(p.comb(j - i + 1, a - i))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    x = ii()",
            "    for i in range(x+1):",
            "        if i * (i + 1) // 2 >= x:",
            "            print(i)",
            "            exit()",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, m = mi()",
            "    if m <= n * 2:",
            "        print(m // 2)",
            "    else:",
            "        # c の方が余分にある場合",
            "        print(n + (m - 2 * n) // 4)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    a, b = mi()",
            "    if a == 1 and b == 1:",
            "        print('Draw')",
            "    elif a == 1:",
            "        print('Alice')",
            "    elif b == 1:",
            "        print('Bob')",
            "    else:",
            "        if a > b:",
            "            print('Alice')",
            "        elif a == b:",
            "            print('Draw')",
            "        else:",
            "            print('Bob')",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def compare(s_list, t_list):",
            "        assert(len(s_list) == len(t_list))",
            "        assert(len(s_list[0]) == len(t_list[0]))",
            "        assert(len(s_list) == len(s_list[0]))",
            "        size = len(s_list)",
            "        for i in range(size):",
            "            if s_list[i] != t_list[i]:",
            "                return False",
            "        return True",
            "    def contain(A, B, n, m):",
            "        diff = n - m",
            "        for i in range(diff+1):",
            "            for j in range(diff+1):",
            "                new_A = [s[j:n-diff+j] for s in A[i:n-diff+i]]",
            "                if compare(new_A, B):",
            "                    return True",
            "        return False",
            "    n, m = mi()",
            "    A = [input() for _ in range(n)]",
            "    B = [input() for _ in range(m)]",
            "    print('Yes') if contain(A, B, n, m) else print('No')",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, ma, mb = mi()",
            "    a_list = []",
            "    b_list = []",
            "    c_list = []",
            "    for _ in range(n):",
            "        a, b, c = mi()",
            "        a_list.append(a)",
            "        b_list.append(b)",
            "        c_list.append(c)",
            "    # dp[i+1][x][y] = i 番目までを使用して a を x[g], b を y[g] にする時のコスト",
            "    dp = [[inf] * (sum(b_list) + 1) for _ in range(sum(a_list) + 1)]",
            "    dp[0][0] = 0",
            "    for i in range(n):",
            "        for x in range(sum(a_list), 0, -1):",
            "            for y in range(sum(b_list), 0, -1):",
            "                i_a, i_b, i_c = a_list[i], b_list[i], c_list[i]",
            "                if x - i_a >= 0 and y - i_b >= 0:",
            "                    dp[x][y] = min(dp[x][y], dp[x-i_a][y-i_b] + i_c)",
            "    # for line in dp:",
            "    #     print(*line)",
            "    ans = inf",
            "    mul = min(sum(a_list) // ma, sum(b_list) // mb)",
            "    for i in range(1, mul+1):",
            "        # print(i)",
            "        ans = min(ans, dp[i * ma][i * mb])",
            "    print(ans) if ans != inf else print(-1)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    x = ii()",
            "    if x <= 6:",
            "        print(1)",
            "    elif x <= 11:",
            "        print(2)",
            "    else:",
            "        cnt = x // 11",
            "        res = x % 11",
            "        if res == 0:",
            "            tmp = 0",
            "        elif res <= 6:",
            "            tmp = 1",
            "        else:",
            "            tmp = 2",
            "        print(cnt * 2 + tmp)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n = ii()",
            "    L = lmi()",
            "    L.sort()",
            "    ans = n",
            "    two_cnt = 0",
            "    for _, g in groupby(L):",
            "        num = len(list(g))",
            "        if num % 2 == 1:",
            "            ans -= (num - 1)",
            "        else:",
            "            ans -= (num - 2)",
            "            two_cnt += 1",
            "    if two_cnt % 2 == 0:",
            "        ans -= two_cnt",
            "    else:",
            "        ans -= (two_cnt - 1)",
            "        ans -= 2",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    import math",
            "    class Eratos:",
            "        def __init__(self, num):",
            "            '''",
            "            O(nlglgn) で num までの素数判定テーブルを作る",
            "            >>> e = Eratos(10)",
            "            >>> e.table",
            "            [False, False, True, True, False, True, False, True, False, False, False]",
            "            '''",
            "            assert(num >= 1)",
            "            self.table_max = num",
            "            # self.table[i] は i が素数かどうかを示す (bool)",
            "            self.table = [False if i == 0 or i == 1 else True for i in range(num+1)]",
            "            for i in range(2, int(math.sqrt(num)) + 1):",
            "                if self.table[i]:",
            "                    for j in range(i ** 2, num + 1, i):    # i**2 からスタートすることで定数倍高速化できる",
            "                        self.table[j] = False",
            "        def is_prime(self, num):",
            "            '''",
            "            O(1) で素数判定を行う",
            "            >>> e = Eratos(100)",
            "            >>> [i for i in range(1, 101) if e.is_prime(i)]",
            "            [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]",
            "            '''",
            "            assert(num >= 1)",
            "            if num > self.table_max:",
            "                raise ValueError('Eratos.is_prime(): exceed table_max({}). got {}'.format(self.table_max, num))",
            "            return self.table[num]",
            "        def prime_factorize(self, num):",
            "            '''",
            "            O(√n) で素因数分解を行う",
            "            >>> e = Eratos(10000)",
            "            >>> e.prime_factorize(6552)",
            "            {2: 3, 3: 2, 7: 1, 13: 1}",
            "            '''",
            "            assert(num >= 1)",
            "            if int(math.sqrt(num)) > self.table_max:",
            "                raise ValueError('Eratos.prime_factorize(): exceed prime table size. got {}'.format(num))",
            "            # 素因数分解の結果を記録する辞書",
            "            factorized_dict = dict()",
            "            candidate_prime_numbers = [i for i in range(2, int(math.sqrt(num)) + 1) if self.is_prime(i)]",
            "            # n について、√n 以下の素数で割り続けると最後には 1 or 素数となる",
            "            # 背理法を考えれば自明 (残された数が √n より上の素数の積であると仮定。これは自明に n を超えるため矛盾)",
            "            for p in candidate_prime_numbers:",
            "                if num == 1:    # これ以上調査は無意味",
            "                    break",
            "                if num % p == 0:",
            "                    cnt = 0",
            "                    while num % p == 0:",
            "                        num //= p",
            "                        cnt += 1",
            "                    factorized_dict[p] = cnt",
            "            if num != 1:",
            "                factorized_dict[num] = 1",
            "            return factorized_dict",
            "        def enum_divisor(self, num):",
            "            '''",
            "            O(√n) で約数列挙を行う",
            "            >>> e = Eratos(10000)",
            "            >>> e.enum_divisor(4)",
            "            [1, 2, 4]",
            "            >>> e.enum_divisor(19)",
            "            [1, 19]",
            "            >>> e.enum_divisor(100)",
            "            [1, 2, 4, 5, 10, 20, 25, 50, 100]",
            "            '''",
            "            divisor_small = []",
            "            divisor_large = []",
            "            for i in range(1, int(math.sqrt(num)) + 1):",
            "                if num % i == 0:",
            "                    divisor_small.append(i)",
            "                    if i != num // i:",
            "                        divisor_large.append(num // i)",
            "            divisor_large.reverse()",
            "            return divisor_small + divisor_large",
            "    n = ii()",
            "    eratos = Eratos(n)",
            "    if n == 1:",
            "        print(1)",
            "    else:",
            "        c = Counter()",
            "        for i in range(2, n+1):",
            "            d = eratos.prime_factorize(i)",
            "            c += Counter(d)",
            "        ans = 1",
            "        for k, v in c.items():",
            "            ans = (ans * (v + 1)) % mod",
            "        print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, a, b = mi()",
            "    L = lmi()",
            "    diff = [L[i] - L[i-1] for i in range(1, n)]",
            "    cost = 0",
            "    for elm in diff:",
            "        cost += min(elm * a, b)",
            "    print(cost)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    k, s = mi()",
            "    cnt = 0",
            "    for i in range(k + 1):",
            "        for j in range(k + 1):",
            "            if 0 <= s - (i + j) <= k:",
            "                cnt += 1",
            "    print(cnt)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "import heapq",
            "import re",
            "from itertools import permutations",
            "from bisect import bisect_left, bisect_right",
            "from collections import Counter, deque",
            "from fractions import gcd",
            "from math import factorial, sqrt, ceil",
            "from functools import lru_cache, reduce",
            "INF = 1 << 60",
            "MOD = 1000000007",
            "sys.setrecursionlimit(10 ** 7)",
            "# UnionFind",
            "class UnionFind():",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parents = [-1] * n",
            "    def find(self, x):",
            "        if self.parents[x] < 0:",
            "            return x",
            "        else:",
            "            self.parents[x] = self.find(self.parents[x])",
            "            return self.parents[x]",
            "    def union(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "        if x == y:",
            "            return",
            "        if self.parents[x] > self.parents[y]:",
            "            x, y = y, x",
            "        self.parents[x] += self.parents[y]",
            "        self.parents[y] = x",
            "    def size(self, x):",
            "        return -self.parents[self.find(x)]",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "    def members(self, x):",
            "        root = self.find(x)",
            "        return [i for i in range(self.n) if self.find(i) == root]",
            "    def roots(self):",
            "        return [i for i, x in enumerate(self.parents) if x < 0]",
            "    def group_count(self):",
            "        return len(self.roots())",
            "    def all_group_members(self):",
            "        return {r: self.members(r) for r in self.roots()}",
            "    def __str__(self):",
            "        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())",
            "def is_prime(n):",
            "    if n == 1:",
            "        return False",
            "    for i in range(2,int(n**0.5)+1):",
            "        if n % i == 0:",
            "            return False",
            "    return True",
            "# ワーシャルフロイド (任意の2頂点の対に対して最短経路を求める)",
            "# 計算量n^3 (nは頂点の数)",
            "def warshall_floyd(d, n):",
            "    #d[i][j]: iからjへの最短距離",
            "    for k in range(n):",
            "        for i in range(n):",
            "            for j in range(n):",
            "                d[i][j] = min(d[i][j],d[i][k] + d[k][j])",
            "    return d",
            "# ダイクストラ",
            "def dijkstra_heap(s, edge, n):",
            "    #始点sから各頂点への最短距離",
            "    d = [10**20] * n",
            "    used = [True] * n #True:未確定",
            "    d[s] = 0",
            "    used[s] = False",
            "    edgelist = []",
            "    for a,b in edge[s]:",
            "        heapq.heappush(edgelist,a*(10**6)+b)",
            "    while len(edgelist):",
            "        minedge = heapq.heappop(edgelist)",
            "        #まだ使われてない頂点の中から最小の距離のものを探す",
            "        if not used[minedge%(10**6)]:",
            "            continue",
            "        v = minedge%(10**6)",
            "        d[v] = minedge//(10**6)",
            "        used[v] = False",
            "        for e in edge[v]:",
            "            if used[e[1]]:",
            "                heapq.heappush(edgelist,(e[0]+d[v])*(10**6)+e[1])",
            "    return d",
            "# 素因数分解",
            "def factorization(n):",
            "    arr = []",
            "    temp = n",
            "    for i in range(2, int(-(-n**0.5//1))+1):",
            "        if temp%i==0:",
            "            cnt=0",
            "            while temp%i==0:",
            "                cnt+=1",
            "                temp //= i",
            "            arr.append([i, cnt])",
            "    if temp!=1:",
            "        arr.append([temp, 1])",
            "    if arr==[]:",
            "        arr.append([n, 1])",
            "    return arr",
            "# 2数の最小公倍数",
            "def lcm(x, y):",
            "    return (x * y) // gcd(x, y)",
            "# リストの要素の最小公倍数",
            "def lcm_list(numbers):",
            "    return reduce(lcm, numbers, 1)",
            "# リストの要素の最大公約数",
            "def gcd_list(numbers):",
            "    return reduce(gcd, numbers)",
            "# 素数判定",
            "# limit以下の素数を列挙",
            "def eratosthenes(limit):",
            "    A = [i for i in range(2, limit+1)]",
            "    P = []",
            "    while True:",
            "        prime = min(A)",
            "        if prime > sqrt(limit):",
            "            break",
            "        P.append(prime)",
            "        i = 0",
            "        while i < len(A):",
            "            if A[i] % prime == 0:",
            "                A.pop(i)",
            "                continue",
            "            i += 1",
            "    for a in A:",
            "        P.append(a)",
            "    return P",
            "# 同じものを含む順列",
            "def permutation_with_duplicates(L):",
            "    if L == []:",
            "        return [[]]",
            "    else:",
            "        ret = []",
            "        # set（集合）型で重複を削除、ソート",
            "        S = sorted(set(L))",
            "        for i in S:",
            "            data = L[:]",
            "            data.remove(i)",
            "            for j in permutation_with_duplicates(data):",
            "                ret.append([i] + j)",
            "        return ret",
            "# ここから書き始める",
            "n, m = map(int, input().split())",
            "d = [[INF for j in range(n)] for i in range(n)]",
            "x = []",
            "for i in range(m):",
            "    a, b, c = map(int, input().split())",
            "    x.append([a - 1, b - 1, c])",
            "    d[a - 1][b - 1] = c",
            "    d[b - 1][a - 1] = c",
            "d2 = warshall_floyd(d, n)",
            "# print(d2)",
            "ans = 0",
            "for i in x:",
            "    if d2[i[0]][i[1]] != i[2]:",
            "        ans += 1",
            "print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            2,
            2,
            1,
            0,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            0,
            2
        ]
    },
    {
        "content": [
            "'''",
            "ダイクストラ法。",
            "始点を固定した時にすべての頂点に対する最短経路を計算する。",
            "O(|E|log|V|)でベルマンフォードより速いが、",
            "負の辺が含まれる場合は使えない。",
            "'''",
            "import collections",
            "import heapq",
            "class Dijkstra():",
            "    def __init__(self):",
            "        self.e = collections.defaultdict(list)",
            "    def add(self, u, v, d, directed=False):",
            "        \"\"\"",
            "        Parameters",
            "        ----------",
            "        u:int",
            "            from node",
            "        v:int",
            "            to node",
            "        d:int",
            "            cost",
            "        directed:bool",
            "            there is direction",
            "        \"\"\"",
            "        if directed is False:",
            "            self.e[u].append([v, d])",
            "            self.e[v].append([u, d])",
            "        else:",
            "            self.e[u].append([v, d])",
            "    def delete(self, u, v):",
            "        \"\"\"",
            "        Parameters",
            "        ----------",
            "        u:int",
            "            from node",
            "        v:int",
            "            to node",
            "        \"\"\"",
            "        self.e[u] = [_ for _ in self.e[u] if _[0] != v]",
            "        self.e[v] = [_ for _ in self.e[v] if _[0] != u]",
            "    def Dijkstra_search(self, s):",
            "        \"\"\"",
            "        Parameters",
            "        ----------",
            "        s:int",
            "            始点",
            "        Return",
            "        ----------",
            "        d:dict(int:int)",
            "            shortest cost from start node to each node",
            "            {to : cost}",
            "        prev:dict(int:int)",
            "            previous node on the shortest path",
            "            {from : to}",
            "        \"\"\"",
            "        d = collections.defaultdict(lambda: float('inf'))",
            "        prev = collections.defaultdict(lambda: None)",
            "        d[s] = 0",
            "        q = []",
            "        heapq.heappush(q, (0, s))",
            "        v = collections.defaultdict(bool)",
            "        while len(q):",
            "            k, u = heapq.heappop(q)",
            "            if v[u]:",
            "                continue",
            "            v[u] = True",
            "            for uv, ud in self.e[u]:",
            "                if v[uv]:",
            "                    continue",
            "                vd = k + ud",
            "                if d[uv] > vd:",
            "                    d[uv] = vd",
            "                    prev[uv] = u",
            "                    heapq.heappush(q, (vd, uv))",
            "        return d, prev",
            "    def getDijkstraShortestPath(self, start, goal):",
            "        \"\"\"",
            "        Parameters",
            "        ----------",
            "        start:int",
            "            start node",
            "        goal:int",
            "            goal node",
            "        Return",
            "        ----------",
            "        ShortestPath:list(int)",
            "            shortest path",
            "        \"\"\"",
            "        _, prev = self.Dijkstra_search(start)",
            "        shortestPath = []",
            "        node = goal",
            "        while node is not None:",
            "            shortestPath.append(node)",
            "            node = prev[node]",
            "        return shortestPath[::-1]",
            "'''",
            "ABC051-D",
            "N頂点M辺の重み付き無向連結グラフがあり、",
            "頂点a_iから頂点b_iを重みc_iで結んでいる。",
            "どの最短経路にも含まれない辺の数を求めよ。",
            "term:",
            "2<=N<=100",
            "N-1<=M<=min(N(N-1)/2,1000)",
            "1<=a_i,b_i<=N",
            "1<=c_i<=10**3",
            "input:",
            "3 3",
            "1 2 1",
            "1 3 1",
            "2 3 3",
            "output:",
            "    1",
            "'''",
            "N, M = map(int, input().split())",
            "graph = Dijkstra()",
            "for i in range(M):",
            "    a, b, c = map(int, input().split())",
            "    graph.add(a, b, c, directed=False)",
            "usedPaths = collections.defaultdict(set)",
            "for i in range(1,N+1):",
            "    for j in range(i+1, N+1):",
            "        path = graph.getDijkstraShortestPath(i, j)",
            "        if len(path) == 2:",
            "            usedPaths[path[0]].add(path[1])",
            "            usedPaths[path[1]].add(path[0])",
            "        else:",
            "            for idx, v in enumerate(path[:-1]):",
            "                usedPaths[v].add(path[idx + 1])",
            "                usedPaths[path[idx + 1]].add(v)",
            "ans = M - sum([len(a) for a in list(usedPaths.values())])//2",
            "print(ans)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            2,
            2,
            2
        ]
    },
    {
        "content": [
            "from collections import defaultdict, deque, Counter",
            "from heapq import heappush, heappop, heapify",
            "from itertools import permutations, accumulate, combinations, combinations_with_replacement",
            "from math import sqrt, ceil, floor, factorial, gcd",
            "from bisect import bisect_left, bisect_right, insort_left, insort_right",
            "from copy import deepcopy",
            "from operator import itemgetter",
            "from functools import reduce, lru_cache  # @lru_cache(None)",
            "import sys  # def input(): return sys.stdin.readline().rstrip() # sys.setrecursionlimit(10**6)",
            "from collections import defaultdict, deque",
            "from heapq import heappush, heappop",
            "class DiGraph:",
            "    def __init__(self, n, edges, weight=False):",
            "        self.n = n",
            "        self.adj = [[] for _ in range(n)]",
            "        self.reverse_adj = [[] for _ in range(n)]",
            "        self.degree = [0] * n",
            "        self.weight = defaultdict(lambda: 10**18)",
            "        if weight:",
            "            for u, v, weight in edges:",
            "                self.adj[u].append(v)",
            "                self.reverse_adj[v].append(u)",
            "                self.degree[v] += 1",
            "                self.weight[(u, v)] = weight",
            "        else:",
            "            for u, v in edges:",
            "                self.adj[u].append(v)",
            "                self.reverse_adj[v].append(u)",
            "                self.degree[v] += 1",
            "                self.weight[(u, v)] = 1",
            "    def dijkstra(self, start, goal=None):  # O((V+E)logV)",
            "        INF = 10**18",
            "        dist = [INF] * self.n",
            "        dist[start] = 0",
            "        heap = [(0, start)]  # (dist, v)",
            "        sp_prev = [None] * self.n  # previous node in shortest path (sp)",
            "        while heap:",
            "            dist_v, v = heappop(heap)",
            "            if dist[v] < dist_v:",
            "                continue",
            "            for adj in self.adj[v]:",
            "                edge_weight = self.weight[(v, adj)]",
            "                if dist[v] + edge_weight < dist[adj]:",
            "                    dist[adj] = dist[v] + edge_weight",
            "                    sp_prev[adj] = v",
            "                    heappush(heap, (dist[adj], adj))",
            "        if goal is not None:",
            "            if dist[goal] == INF:",
            "                return dist, []",
            "            else:",
            "                path = [goal]",
            "                v = goal",
            "                while v != start:",
            "                    v = sp_prev[v]",
            "                    path.append(v)",
            "                path.reverse()",
            "                return dist, path",
            "        else:",
            "            return dist, sp_prev",
            "    def scc_decompose(self):  # strongly connected components decomposition (強連結成分分解) O(V+E)",
            "        used = [False] * self.n",
            "        order = []  # 帰りがけ順",
            "        for i in range(self.n):",
            "            if not used[i]:",
            "                stack = [i]",
            "                used[i] = True",
            "                while stack:",
            "                    u = stack.pop()",
            "                    u_movable = False",
            "                    for v in self.adj[u]:  # u -> v",
            "                        if not used[v]:",
            "                            u_movable = True",
            "                            used[v] = True",
            "                            stack.append(u)",
            "                            stack.append(v)",
            "                            break",
            "                    if not u_movable:",
            "                        order.append(u)",
            "        used = [False] * self.n",
            "        group = [None] * self.n",
            "        label = 0",
            "        for v in reversed(order):",
            "            if not used[v]:",
            "                stack = [v]",
            "                group[v] = label",
            "                while stack:",
            "                    v = stack.pop()",
            "                    used[v] = True",
            "                    for u in self.reverse_adj[v]:  # v -> u (reverse)",
            "                        if not used[u]:",
            "                            group[u] = label",
            "                            stack.append(u)",
            "                label += 1",
            "        # construct reduction graph",
            "        reduction_graph = [[] for _ in range(len(set(group)))]",
            "        reduction_components = [[] for _ in range(len(set(group)))]",
            "        for u in range(self.n):",
            "            for v in self.adj[u]:  # u -> v",
            "                if group[u] == group[v]:",
            "                    continue",
            "                reduction_graph[group[u]].append(group[v])",
            "            reduction_components[group[u]].append(u)",
            "        return reduction_graph, reduction_components, group",
            "# ---------------------- #",
            "def topological_sort(DAG):  # O(V+E)",
            "    n = len(DAG)",
            "    degree = [0] * n",
            "    for u in range(n):",
            "        for v in DAG[u]:  # u -> v",
            "            degree[v] += 1",
            "    ret = [i for i in range(n) if degree[i] == 0]",
            "    queue = deque(ret)",
            "    while queue:",
            "        u = queue.popleft()",
            "        for v in DAG[u]:",
            "            degree[v] -= 1",
            "            if degree[v] == 0:",
            "                queue.append(v)",
            "                ret.append(v)",
            "    return ret",
            "# ---------------------- #",
            "n, m = (int(x) for x in input().split())",
            "edges = []",
            "for _ in range(m):",
            "    a, b, c = (int(x) for x in input().split())",
            "    a -= 1",
            "    b -= 1",
            "    edges.append((a, b, c))",
            "    edges.append((b, a, c))",
            "G = DiGraph(n, edges, weight=True)",
            "ANS = set()",
            "for u, v in combinations(range(n), 2):",
            "    _, path = G.dijkstra(u, v)",
            "    for a, b in zip(path[:], path[1:]):",
            "        ANS.add((a, b))",
            "ans = 0",
            "for a, b, _ in edges:",
            "    if (a, b) in ANS or (b, a) in ANS:",
            "        continue",
            "    else:",
            "        ans += 1",
            "print(ans//2)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            2
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    class PQueueMin:",
            "        def __init__(self):",
            "            self.pq = []    # 第一要素に cost、第二要素に ind が来る様にする",
            "        def push(self, ind, cost):",
            "            heappush(self.pq, [cost, ind])",
            "        def pop(self):",
            "            cost, ind = heappop(self.pq)",
            "            return [ind, cost]",
            "        def is_empty(self):",
            "            return len(self.pq)==0",
            "    def dijkstra(adj_with_weight, start):",
            "        '''",
            "        Dijkstra 法 O((E+V)lgV) (頂点を回るときに最小のものを取り出していくのに VlgV, cost の更新で ElgV)",
            "        負辺を含まぬ重みつきグラフについて、ある頂点から他の頂点までの最短コストを貪欲に計算する",
            "        '''",
            "        V = len(adj_with_weight)",
            "        cost = [float('inf')] * V",
            "        previous = [None] * V",
            "        cost[start] = 0",
            "        fixed = [False] * V",
            "        pq = PQueueMin()",
            "        # 最初は始点が必ずコスト最小。pq に突っ込む",
            "        pq.push(start, cost[start])",
            "        while not pq.is_empty():",
            "            # 現段階で最短のコストとなっている頂点を選択",
            "            u, cost_of_u = pq.pop()",
            "            fixed[u] = True",
            "            for v, weight_of_uv in adj_with_weight[u]:",
            "                if not fixed[v] and cost[v] > cost_of_u + weight_of_uv:",
            "                    cost[v] = cost_of_u + weight_of_uv",
            "                    previous[v] = u",
            "                    pq.push(v, cost[v])",
            "        return cost, previous",
            "    n, m = mi()",
            "    adj_with_weight = [[] for _ in range(n)]",
            "    edge_matrix = [[False] * n for _ in range(n)]    # あとで最短経路として使ったかどうかのメモ",
            "    for _ in range(m):",
            "        a, b, c = mi()",
            "        a -= 1",
            "        b -= 1",
            "        adj_with_weight[a].append((b, c))",
            "        adj_with_weight[b].append((a, c))",
            "    for i in range(n):",
            "        _, previous = dijkstra(adj_with_weight, i)",
            "        # print(previous)",
            "        for j in range(n):",
            "            if j != i:",
            "                u = previous[j]",
            "                j, u = min(j, u), max(j, u)",
            "                edge_matrix[j][u] = True",
            "    # print(edge_matrix)",
            "    cnt = 0",
            "    for u in range(n):",
            "        for v, _ in adj_with_weight[u]:",
            "            if u < v and not edge_matrix[u][v]:",
            "                cnt += 1",
            "    print(cnt)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n = ii()",
            "    L = lmi()",
            "    s  = sum(L)",
            "    m = ii()",
            "    for _ in range(m):",
            "        p, x = mi()",
            "        p -= 1",
            "        print(s - L[p] + x)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def check(L, n):",
            "        # n 偶数 -> 1 1 3 3 5 5 ...",
            "        if n % 2 == 0:",
            "            for i in range(n):",
            "                if (i % 2 == 0 and L[i] != i + 1) or (i % 2 == 1 and L[i] != i):",
            "                    return False",
            "        # n 奇数 -> 0 2 2 4 4 6..",
            "        else:",
            "            for i in range(n):",
            "                if (i % 2 == 0 and L[i] != i) or (i % 2 == 1 and L[i] != i + 1):",
            "                    return False",
            "        return True",
            "    n = ii()",
            "    L = lmi()",
            "    L.sort()",
            "    if check(L, n):",
            "        if n % 2 == 1:",
            "            print(pow(2, (n - 1)//2, mod))",
            "        else:",
            "            print(pow(2, n//2, mod))",
            "    else:",
            "        print(0)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    h, w = mi()",
            "    for _ in range(h):",
            "        s = input()",
            "        print(s)",
            "        print(s)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "from collections import deque",
            "from collections import defaultdict",
            "from collections import Counter",
            "def conn(n,m,e):",
            "    d=dict(zip(range(1,n+1),range(-1,(-1)*n-1,-1)))",
            "    td=defaultdict(lambda:deque([])) #tdは同値類がキーで中の元が値",
            "    c=1",
            "    for edge in e:",
            "        a=edge[0]",
            "        b=edge[1]",
            "        da=d[a] #da,dbはa,bの含まれる同値流のラベル",
            "        db=d[b]",
            "        if da<0 and db<0:",
            "            d[a]=c",
            "            d[b]=c",
            "            td[c].append(a)",
            "            td[c].append(b)",
            "            c+=1",
            "        elif da>0 and db<0:",
            "            d[b]=da",
            "            td[d[a]].append(b)",
            "        elif da<0 and db>0:",
            "            d[a]=db",
            "            td[d[b]].append(a)",
            "        elif da>0 and db>0 and da!=db:",
            "            for x in td[db]:",
            "                d[x]=da",
            "                td[da].append(x)",
            "    return list(d.values())",
            "# def components(n,k,e):",
            "#     ed=defaultdict(lambda:deque())",
            "#     for edge in e:",
            "#         ed[edge[0]].append(edge[1])",
            "#     c=0",
            "#     s=[0]*n",
            "#     label=[0]*n",
            "#     for i in range(1,n+1):",
            "#         if s[i-1]==0:",
            "#             c+=1",
            "#             label[c-1]=c",
            "#             stack=deque([i])",
            "#             while stack:",
            "#                 w=stack.pop()",
            "#                 s[w-1]=c",
            "#                 while ed[w]:",
            "#                     wn=ed[w].pop()",
            "#                     if s[wn-1]==0:",
            "#                         s[wn-1]=c",
            "#                         if ed[wn]:",
            "#                             stack.append(w)",
            "#                             w=wn",
            "#                     elif s[wn-1]<c:",
            "#                         label[s[wn-1]-1]=c",
            "#     print(s)",
            "#     print(label)",
            "#     return [label[s[i]-1] for i in range(n)]",
            "def components(n,k,e):",
            "    ed=defaultdict(lambda:deque())",
            "    for edge in e:",
            "        ed[edge[0]].append(edge[1])",
            "        ed[edge[1]].append(edge[0])",
            "    c=0",
            "    s=[0]*n",
            "    stack=deque()",
            "    for i in range(1,n+1):",
            "        if s[i-1]==0:",
            "            c+=1",
            "            stack.clear()",
            "            stack.append(i)",
            "            while stack:",
            "                w=stack.pop()",
            "                s[w-1]=c",
            "                while ed[w]:",
            "                    wn=ed[w].pop()",
            "                    if s[wn-1]==0:",
            "                        s[wn-1]=c",
            "                        if ed[wn]:",
            "                            stack.append(w)",
            "                            w=wn",
            "    return [s[i] for i in range(n)]",
            "def components2(n,k,e):",
            "    es=deque(set((edge[0],edge[1])) for edge in e)",
            "    c=0",
            "    s=deque()",
            "    stack=deque()",
            "    while es:",
            "        f=es.pop()",
            "        stack.clear()",
            "        while es:",
            "            l=len(es)",
            "            g=es.pop()",
            "            if g&f:",
            "                f|=g",
            "            else:",
            "                stack.append(g)",
            "            if l==len(stack):",
            "                s.append(f)",
            "                break",
            "            es=stack",
            "    t=[0]*n",
            "    c=0",
            "    while s:",
            "        for x in s.pop():",
            "            t[x-1]=c",
            "        c+=1",
            "    return t",
            "def main(n,k,l,e1,e2):",
            "    d1=components(n,k,e1)",
            "    d2=components(n,l,e2)",
            "    p=tuple(zip(iter(d1),iter(d2)))",
            "    d=Counter(p)",
            "    # print(d1,d2,d,p)",
            "    print(' '.join([str(d[x]) for x in p]))",
            "if __name__=='__main__':",
            "    ssr=sys.stdin.readline",
            "    n,k,l=map(int,ssr().strip().split())",
            "    e1=[]",
            "    e2=[]",
            "    for _ in range(k):",
            "        e1.append(tuple(map(int,ssr().strip().split())))",
            "    for _ in range(l):",
            "        e2.append(tuple(map(int,ssr().strip().split())))",
            "    main(n,k,l,e1,e2)"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "content": [
            "from heapq import heappush,heappop,heapify",
            "from collections import deque,defaultdict,Counter",
            "import itertools",
            "from functools import *",
            "from itertools import permutations,combinations,groupby",
            "import sys",
            "import bisect",
            "import string",
            "import math",
            "import time",
            "import random",
            "def Golf():",
            "    *a,=map(int,open(0))",
            "def S_():",
            "    return input()",
            "def IS():",
            "    return input().split()",
            "def LS():",
            "    return [i for i in input().split()]",
            "def I():",
            "    return int(input())",
            "def MI():",
            "    return map(int,input().split())",
            "def LI():",
            "    return [int(i) for i in input().split()]",
            "def LI_():",
            "    return [int(i)-1 for i in input().split()]",
            "def NI(n):",
            "    return [int(input()) for i in range(n)]",
            "def NI_(n):",
            "    return [int(input())-1 for i in range(n)]",
            "def StoI():",
            "    return [ord(i)-97 for i in input()]",
            "def ItoS(nn):",
            "    return chr(nn+97)",
            "def LtoS(ls):",
            "    return ''.join([chr(i+97) for i in ls])",
            "def GI(V,E,Directed=False,index=0):",
            "    org_inp=[]",
            "    g=[[] for i in range(n)]",
            "    for i in range(E):",
            "        inp=LI()",
            "        org_inp.append(inp)",
            "        if index==0:",
            "            inp[0]-=1",
            "            inp[1]-=1",
            "        if len(inp)==2:",
            "            a,b=inp",
            "            g[a].append(b)",
            "            if not Directed:",
            "                g[b].append(a)",
            "        elif len(inp)==3:",
            "            a,b,c=inp",
            "            aa=(inp[0],inp[2])",
            "            bb=(inp[1],inp[2])",
            "            g[a].append(bb)",
            "            if not Directed:",
            "                g[b].append(aa)",
            "    return g,org_inp",
            "def GGI(h,w,search=None,replacement_of_found='.',mp_def={'#':1,'.':0}):",
            "#h,w,g,sg=GGI(h,w,search=['S','G'],replacement_of_found='.',mp_def={'#':1,'.':0}) # sample usage",
            "    mp=[1]*(w+2)",
            "    found={}",
            "    for i in range(h):",
            "        s=input()",
            "        for char in search:",
            "            if char in s:",
            "                found[char]=((i+1)*(w+2)+s.index(char)+1)",
            "                mp_def[char]=mp_def[replacement_of_found]",
            "        mp+=[1]+[mp_def[j] for j in s]+[1]",
            "    mp+=[1]*(w+2)",
            "    return h+2,w+2,mp,found",
            "def bit_combination(k,n=2):",
            "    rt=[]",
            "    for tb in range(n**k):",
            "        s=[tb//(n**bt)%n for bt in range(k)]",
            "        rt+=[s]",
            "    return rt",
            "def show(*inp,end='\\n'):",
            "    if show_flg:",
            "        print(*inp,end=end)",
            "YN=['YES','NO']",
            "mo=10**9+7",
            "inf=float('inf')",
            "l_alp=string.ascii_lowercase",
            "u_alp=string.ascii_uppercase",
            "ts=time.time()",
            "#sys.setrecursionlimit(10**7)",
            "input=lambda: sys.stdin.readline().rstrip()",
            "def ran_input():",
            "    import random",
            "    n=random.randint(4,16)",
            "    rmin,rmax=1,10",
            "    a=[random.randint(rmin,rmax) for _ in range(n)]",
            "    return n,a",
            "class UnionFind:",
            "    def __init__(self, n):",
            "        # 負  : 根であることを示す。絶対値はランクを示す",
            "        # 非負: 根でないことを示す。値は親を示す",
            "        self.table = [-1] * n",
            "    def _root(self, x):",
            "        if self.table[x] < 0:",
            "            return x",
            "        else:",
            "            # 経路の圧縮",
            "            self.table[x] = self._root(self.table[x])",
            "            return self.table[x]",
            "    def find(self, x, y):",
            "        return self._root(x) == self._root(y)",
            "    def union(self, x, y):",
            "        r1 = self._root(x)",
            "        r2 = self._root(y)",
            "        if r1 == r2:",
            "            return",
            "        # ランクの取得",
            "        d1 = self.table[r1]",
            "        d2 = self.table[r2]",
            "        if d1 <= d2:",
            "            self.table[r2] = r1",
            "            if d1 == d2:",
            "                self.table[r1] -= 1",
            "        else:",
            "            self.table[r1] = r2",
            "    def __str__(self):",
            "        rt=[i if j<0 else j for i,j in enumerate(self.table)]",
            "        return str(rt)",
            "show_flg=False",
            "show_flg=True",
            "ans=0",
            "n,k,l=LI()",
            "ufr=UnionFind(n)",
            "ufh=UnionFind(n)",
            "for i in range(k):",
            "    a,b=LI_()",
            "    ufh.union(a,b)",
            "for i in range(l):",
            "    a,b=LI_()",
            "    ufr.union(a,b)",
            "con=[0]*n",
            "cnt=defaultdict(int)",
            "for i in range(n):",
            "    con[i]=ufr._root(i)*10**5+ufh._root(i)",
            "    cnt[con[i]]+=1",
            "for i in range(n):",
            "    print(cnt[con[i]])"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            2,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            1,
            1,
            0,
            0,
            1,
            2,
            1,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            1
        ]
    },
    {
        "content": [
            "import sys",
            "sys.setrecursionlimit(10**7) #再帰関数の上限,10**5以上の場合python",
            "import math",
            "from copy import copy, deepcopy",
            "from copy import deepcopy as dcp",
            "from operator import itemgetter",
            "from bisect import bisect_left, bisect, bisect_right#2分探索",
            "#bisect_left(l,x), bisect(l,x)#aはソート済みである必要あり。aの中からx未満の要素数を返す。rightだと以下",
            "from collections import deque, defaultdict",
            "#deque(l), pop(), append(x), popleft(), appendleft(x)",
            "#q.rotate(n)で → にn回ローテート",
            "from collections import Counter#文字列を個数カウント辞書に、",
            "#S=Counter(l),S.most_common(x),S.keys(),S.values(),S.items()",
            "from itertools import accumulate,combinations,permutations#累積和",
            "#list(accumulate(l))",
            "from heapq import heapify,heappop,heappush",
            "#heapify(q),heappush(q,a),heappop(q) #q=heapify(q)としないこと、返り値はNone",
            "#import fractions#古いatcoderコンテストの場合GCDなどはここからimportする",
            "from functools import reduce,lru_cache#pypyでもうごく",
            "#@lru_cache(maxsize = None)#maxsizeは保存するデータ数の最大値、2**nが最も高効率",
            "from decimal import Decimal",
            "def input():",
            "    x=sys.stdin.readline()",
            "    return x[:-1] if x[-1]==\"\\n\" else x",
            "def printe(*x):print(\"## \",*x,file=sys.stderr)",
            "def printl(li): _=print(*li, sep=\"\\n\") if li else None",
            "def argsort(s, return_sorted=False):",
            "    inds=sorted(range(len(s)), key=lambda k: s[k])",
            "    if return_sorted: return inds, [s[i] for i in inds]",
            "    return inds",
            "def alp2num(c,cap=False): return ord(c)-97 if not cap else ord(c)-65",
            "def num2alp(i,cap=False): return chr(i+97) if not cap else chr(i+65)",
            "def matmat(A,B):",
            "    K,N,M=len(B),len(A),len(B[0])",
            "    return [[sum([(A[i][k]*B[k][j]) for k in range(K)]) for j in range(M)] for i in range(N)]",
            "def matvec(M,v):",
            "    N,size=len(v),len(M)",
            "    return [sum([M[i][j]*v[j] for j in range(N)]) for i in range(size)]",
            "def T(M):",
            "    n,m=len(M),len(M[0])",
            "    return [[M[j][i] for j in range(n)] for i in range(m)]",
            "class unionfind:#早いunionfind,class[i]のように要素指定すると親を得ることができる",
            "    def __init__(self, elements=None):#elementsで初期化",
            "        if elements is None:",
            "            elements = ()",
            "        self.parents = {}",
            "        self.weights = {}",
            "        for x in elements:",
            "            self.weights[x] = 1",
            "            self.parents[x] = x",
            "    def __getitem__(self, i):",
            "        # check for previously unknown i",
            "        if i not in self.parents:",
            "            self.parents[i] = i",
            "            self.weights[i] = 1",
            "            return i",
            "        path = [i]",
            "        root = self.parents[i]",
            "        while root != path[-1]:",
            "            path.append(root)",
            "            root = self.parents[root]",
            "        for ancestor in path:#縮約",
            "            self.parents[ancestor] = root",
            "        return root",
            "    def __iter__(self):#for parent in Class:",
            "        return iter(self.parents)",
            "    def union(self, *objects):#オブジェクトをすべて結合",
            "        roots = [self[x] for x in objects]",
            "        heaviest = max(roots, key=lambda r: self.weights[r])",
            "        for r in roots:",
            "            if r != heaviest:",
            "                self.weights[heaviest] += self.weights[r]",
            "                self.parents[r] = heaviest",
            "    def __len__(self):",
            "        return len(self.parents)",
            "def main():",
            "    mod = 1000000007",
            "    #w.sort(key=itemgetter(1),reversed=True)  #二個目の要素で降順並び替え",
            "    #N = int(input())",
            "    N, K, L = map(int, input().split())",
            "    #A = tuple(map(int, input().split())) #1行ベクトル",
            "    #L = tuple(int(input()) for i in range(N)) #改行ベクトル",
            "     #改行行列",
            "    train=unionfind(range(N))",
            "    rail=unionfind(range(N))",
            "    for i in range(K):#木の場合M=N-1",
            "        a,b = map(int,input().split())",
            "        train.union(a-1,b-1)",
            "    S = tuple(tuple(map(int, input().split())) for i in range(L))",
            "    for a,b in S:#木の場合M=N-1",
            "        a-=1",
            "        b-=1",
            "        rail.union(a,b)",
            "    c=Counter()",
            "    ans=[0]*N",
            "    for i in range(N):",
            "        c[rail[i]*N+train[i]]+=1",
            "    for i in range(N):",
            "        ans[i]=c[rail[i]*N+train[i]]",
            "    print(*ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            1,
            1,
            2,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    a, b, x = mi()",
            "    if a == 0:",
            "        print(b // x + 1)",
            "    else:",
            "        print(b // x - (a - 1) // x)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, x = mi()",
            "    L = lmi()",
            "    ans = 0",
            "    sum_memo = 0",
            "    for i in range(n):",
            "        sum_memo += L[i]",
            "        if sum_memo > x:",
            "            diff = sum_memo - x",
            "            ans += diff",
            "            L[i] -= diff",
            "            sum_memo = x",
            "        if i != 0:",
            "            sum_memo -= L[i-1]",
            "    # print(L)",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    board = input()",
            "    n = len(board)",
            "    cnt = 0",
            "    for i in range(n-1):",
            "        if board[i] != board[i+1]:",
            "            cnt += 1",
            "    print(cnt)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, t = mi()",
            "    L = lmi()",
            "    diff = [L[i] - L[i-1] for i in range(n) if i > 0]",
            "    # print(diff)",
            "    # sum(diff[i:j]) は L[i] で買い L[j] で売ることを示す",
            "    max_subarray = -inf",
            "    max_subarray_indices = []",
            "    max_subarray_end_with_j = -inf",
            "    max_subarray_end_with_j_indices = [[], []]    # start_indices, j",
            "    # diff[0:1] から diff[0:n-1] までを考察する",
            "    for j in range(1, n):",
            "        if max_subarray_end_with_j + diff[j-1] > diff[j-1]:",
            "            max_subarray_end_with_j = max_subarray_end_with_j + diff[j-1]",
            "            max_subarray_end_with_j_indices[1] = [j]",
            "        elif max_subarray_end_with_j + diff[j-1] < diff[j-1]:",
            "            max_subarray_end_with_j = diff[j-1]",
            "            max_subarray_end_with_j_indices[0] = [j-1]",
            "            max_subarray_end_with_j_indices[1] = [j]",
            "        else:",
            "            max_subarray_end_with_j_indices[0].append(j-1)",
            "        if max_subarray < max_subarray_end_with_j:",
            "            max_subarray = max_subarray_end_with_j",
            "            max_subarray_indices = [(start, max_subarray_end_with_j_indices[1][0]) for start in max_subarray_end_with_j_indices[0]]",
            "        elif max_subarray > max_subarray_end_with_j:",
            "            continue",
            "        else:",
            "            max_subarray_indices.append(*[(start, max_subarray_end_with_j_indices[1][0]) for start in max_subarray_end_with_j_indices[0]])",
            "        # print(max_subarray_end_with_j)",
            "        # print(max_subarray_end_with_j_indices)",
            "        # print(max_subarray)",
            "        # print(max_subarray_indices)",
            "    # print(max_subarray)",
            "    # print(max_subarray_indices)",
            "    s = set(max_subarray_indices)",
            "    L1 = sorted(max_subarray_indices, key=lambda x: x[0])",
            "    for i, elm in enumerate(L1):",
            "        if i != 0 and elm[0] == L1[i-1][0]:",
            "            s.remove(elm)",
            "    L2 = sorted(max_subarray_indices, key=lambda x: x[1])",
            "    for i, elm in enumerate(L2):",
            "        if i != 0 and elm[1] == L2[i-1][1] and elm in s:",
            "            s.remove(elm)",
            "    print(len(list(s)))",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def isp():   return input().split()",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    k, t = mi()",
            "    cake = lmi()",
            "    if t == 0:",
            "        print(cake[0] - 1)",
            "    else:",
            "        M = max(cake)",
            "        others = sum(cake) - M",
            "        if M - 1 <= others:",
            "            print(0)",
            "        else:",
            "            print(M - 1 - others)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def isp():   return input().split()",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def solve():",
            "        ans = 1",
            "        for i in range(n):",
            "            if t_info[i] and a_info[i]:",
            "                # fixed 同士のチェック",
            "                if T[i] != A[i]:",
            "                    return 0",
            "            elif t_info[i]:",
            "                # a_info の条件は大丈夫か？",
            "                if T[i] > A[i]:",
            "                    return 0",
            "            elif a_info[i]:",
            "                # t_info の条件は大丈夫か？",
            "                if A[i] > T[i]:",
            "                    return 0",
            "            else:",
            "                # どちらも上界しか分からん",
            "                up_boundary = min(T[i], A[i])",
            "                ans = (ans * up_boundary) % mod",
            "        return ans",
            "    n = ii()",
            "    T = lmi()",
            "    A = lmi()",
            "    t_info = [False] * n    # bool (fixed?)",
            "    for i in range(n):",
            "        if i == 0 or T[i] > T[i-1]:",
            "            t_info[i] = True",
            "    a_info = [False] * n",
            "    for i in range(n-1, -1, -1):",
            "        if i == n - 1 or A[i] > A[i+1]:",
            "            a_info[i] = True",
            "    print(solve())",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#",
            "# 　　  ⋀_⋀",
            "#　　  (･ω･)",
            "# .／ Ｕ ∽ Ｕ＼",
            "#  │＊　合　＊│",
            "#  │＊　格　＊│",
            "#  │＊　祈　＊│",
            "#  │＊　願　＊│",
            "#  │＊　　　＊│",
            "#      ￣",
            "#",
            "import sys",
            "sys.setrecursionlimit(10**6)",
            "input=sys.stdin.readline",
            "from math import floor,sqrt,factorial,hypot,log #log2ないｙｐ",
            "from heapq import heappop, heappush, heappushpop",
            "from collections import Counter,defaultdict,deque",
            "from itertools import accumulate,permutations,combinations,product,combinations_with_replacement",
            "from bisect import bisect_left,bisect_right",
            "from copy import deepcopy",
            "from fractions import gcd",
            "from random import randint",
            "def ceil(a,b): return (a+b-1)//b",
            "inf=float('inf')",
            "mod = 10**9+7",
            "def pprint(*A):",
            "    for a in A:     print(*a,sep='\\n')",
            "def INT_(n): return int(n)-1",
            "def MI(): return map(int,input().split())",
            "def MF(): return map(float, input().split())",
            "def MI_(): return map(INT_,input().split())",
            "def LI(): return list(MI())",
            "def LI_(): return [int(x) - 1 for x in input().split()]",
            "def LF(): return list(MF())",
            "def LIN(n:int): return [I() for _ in range(n)]",
            "def LLIN(n: int): return [LI() for _ in range(n)]",
            "def LLIN_(n: int): return [LI_() for _ in range(n)]",
            "def LLI(): return [list(map(int, l.split() )) for l in input()]",
            "def I(): return int(input())",
            "def F(): return float(input())",
            "def ST(): return input().replace('\\n', '')",
            "#mint",
            "class ModInt:",
            "    def __init__(self, x):",
            "        self.x = x % mod",
            "    def __str__(self):",
            "        return str(self.x)",
            "    __repr__ = __str__",
            "    def __add__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(self.x + other.x)",
            "        else:",
            "            return ModInt(self.x + other)",
            "    __radd__ = __add__",
            "    def __sub__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(self.x - other.x)",
            "        else:",
            "            return ModInt(self.x - other)",
            "    def __rsub__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(other.x - self.x)",
            "        else:",
            "            return ModInt(other - self.x)",
            "    def __mul__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(self.x * other.x)",
            "        else:",
            "            return ModInt(self.x * other)",
            "    __rmul__ = __mul__",
            "    def __truediv__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(self.x * pow(other.x, mod-2,mod))",
            "        else:",
            "            return ModInt(self.x * pow(other, mod - 2, mod))",
            "    def __rtruediv(self, other):",
            "        if isinstance(other, self):",
            "            return ModInt(other * pow(self.x, mod - 2, mod))",
            "        else:",
            "            return ModInt(other.x * pow(self.x, mod - 2, mod))",
            "    def __pow__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(pow(self.x, other.x, mod))",
            "        else:",
            "            return ModInt(pow(self.x, other, mod))",
            "    def __rpow__(self, other):",
            "        if isinstance(other, ModInt):",
            "            return ModInt(pow(other.x, self.x, mod))",
            "        else:",
            "            return ModInt(pow(other, self.x, mod))",
            "def main():",
            "    N = I()",
            "    T = LI()",
            "    A = LI()",
            "    lim = [inf]*N",
            "    confirm = [None]*N",
            "    now = 0",
            "    for i,a in enumerate(T):",
            "        if now < a:",
            "            confirm[i] = a",
            "            now = a",
            "        lim[i] = a",
            "    now = 0",
            "    for i in range(N)[::-1]:",
            "        a = A[i]",
            "        if now < a:",
            "            if confirm[i] is not None:",
            "                if confirm[i] != a:",
            "                    print(0)",
            "                    return",
            "            if lim[i] < a:",
            "                print(0)",
            "                return",
            "            confirm[i] = a",
            "            now = a",
            "        lim[i] = min(lim[i], a)",
            "        if confirm[i] is not None:",
            "            if confirm[i] > lim[i]:",
            "                print(0)",
            "                return",
            "    ans = ModInt(1)",
            "    for i,(l,c) in enumerate(zip(lim, confirm)):",
            "        if c is None:",
            "            ans *= l",
            "    print(ans)",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import time",
            "import math",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def calc_minimum_card_pair(a, b, s, t):",
            "        \"\"\"",
            "        現在 a, b 枚であるとする",
            "        カードを増やす操作を行い比を s : t にするとき、変化後のカード枚数を返す",
            "        \"\"\"",
            "        # multiply_rate = max(math.ceil(a / s), math.ceil(b / t))",
            "        multiply_rate = max((a + s - 1) // s, (b + t - 1) // t)",
            "        return (s * multiply_rate, t * multiply_rate)",
            "    n = ii()",
            "    L = [lmi() for _ in range(n)]",
            "    a, b = 1, 1",
            "    for s, t in L:",
            "        a, b = calc_minimum_card_pair(a, b, s, t)",
            "        # print(a, b)",
            "    # print('')",
            "    print(a + b)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math, cmath",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import _heapify_max, _heappop_max, _siftdown_max",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    Num = Union[int, float]",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def isp():   return input().split()",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    # def _heappush_max(h, item): h.append(item); _siftdown_max(h, 0, len(h)-1)",
            "    n = ii()",
            "    L = lmi_0()",
            "    cnt = 0",
            "    for i in range(n):",
            "        if L[L[i]] == i:",
            "            cnt += 1",
            "    assert cnt % 2 == 0",
            "    print(cnt // 2)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "from typing import Any, Callable, Deque, Dict, List, Mapping, Optional, Sequence, Set, Tuple, TypeVar, Union",
            "# import time",
            "# import math, cmath",
            "# import numpy as np",
            "# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
            "# import random                                # random, uniform, randint, randrange, shuffle, sample",
            "# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
            "# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
            "# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
            "# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import _heapify_max, _heappop_max, _siftdown_max",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from fractions import Fraction               # Fraction(a, b) => a / b ∈ Q. note: Fraction(0.1) do not returns Fraciton(1, 10). Fraction('0.1') returns Fraction(1, 10)",
            "def main():",
            "    Num = Union[int, float]",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79e+308",
            "    # inf = 2 ** 63 - 1             # (for fast JIT compile in PyPy) 9.22e+18",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def isp():   return input().split()",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    # def _heappush_max(h, item): h.append(item); _siftdown_max(h, 0, len(h)-1)",
            "    def calc_rotate_min(L, rotate):",
            "        n = len(L)",
            "        for i in range(n):",
            "            # print(i, L, rotate)",
            "            if rotate == 0:",
            "                return",
            "            if i == n - 1:",
            "                # この文字をグルグルするしかない",
            "                L[i] = (L[i] + rotate % 26) % 26",
            "                return",
            "            if L[i] != 0 and 26 - L[i] <= rotate:",
            "                rotate -= (26 - L[i])",
            "                L[i] = 0    # 'a' にする",
            "    s = input()",
            "    k = ii()",
            "    L = list(map(lambda x: ord(x)-ord('a'), s))",
            "    calc_rotate_min(L, rotate=k)",
            "    for num in L:",
            "        print(chr(num+ord('a')), end='')",
            "    print('')",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def contained_in_dict_set(d, i, j):",
            "        if i in d:",
            "            if j in d[i]:",
            "                return True",
            "        return False",
            "    def register_dict_set(d, i, j):",
            "        if i not in d:",
            "            d[i] = set()",
            "        d[i].add(j)",
            "    def count_black_around_center(point_dict, i, j):",
            "        cnt = 0",
            "        for s in range(i-1, i+2):",
            "            for t in range(j-1, j+2):",
            "                if contained_in_dict_set(point_dict, s, t):",
            "                    cnt += 1",
            "        return cnt",
            "    h, w, n = mi()",
            "    points = [lmi() for _ in range(n)]",
            "    num_of_grids_contains_black = [0] * 10",
            "    point_dict = dict()",
            "    visited_dict = dict()",
            "    for x, y in points:",
            "        register_dict_set(point_dict, x, y)",
            "    for x, y in points:",
            "        for i in range(x-1, x+2):",
            "            for j in range(y-1, y+2):",
            "                if 2<=i<=h-1 and 2<=j<=w-1 and not contained_in_dict_set(visited_dict, i, j):",
            "                    cnt = count_black_around_center(point_dict, i, j)",
            "                    num_of_grids_contains_black[cnt] += 1",
            "                    register_dict_set(visited_dict, i, j)",
            "    num_of_grids_contains_black[0] = (h - 2) * (w - 2) - sum(num_of_grids_contains_black[1:])",
            "    print(*num_of_grids_contains_black, sep='\\n')",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    n, a = mi()",
            "    L = lmi()",
            "    diff = [elm - a for elm in L]",
            "    # dp[i][num] = (diff から i 番目までを使用して和を num - 2500 にする場合の数)",
            "    dp = [[0] * 5001 for _ in range(n + 1)]",
            "    dp[0][2500] = 1",
            "    for i in range(n):",
            "        for j in range(5001):",
            "            if dp[i][j]:",
            "                dp[i+1][j + diff[i]] += dp[i][j]",
            "            dp[i+1][j] += dp[i][j]",
            "    print(dp[n][2500] - 1)    # n 番目までを使用して和を 0 にするには？ 最初の何も選ばない 1 通りを除く",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            2,
            1
        ]
    },
    {
        "content": [
            "#!/usr/bin/env python3",
            "import sys",
            "# import math",
            "# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits",
            "# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
            "# from operator import itemgetter              # itemgetter(1), itemgetter('key')",
            "# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
            "# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
            "# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
            "# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
            "# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
            "# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
            "# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
            "# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
            "# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
            "# from itertools import combinations, combinations_with_replacement",
            "# from itertools import accumulate             # accumulate(iter[, f])",
            "# from functools import reduce                 # reduce(f, iter[, init])",
            "# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",
            "# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",
            "# from copy import deepcopy                    # to copy multi-dimentional matrix without reference",
            "# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
            "def main():",
            "    mod = 1000000007                # 10^9+7",
            "    inf = float('inf')              # sys.float_info.max = 1.79...e+308",
            "    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19",
            "    sys.setrecursionlimit(10**6)    # 1000 -> 1000000",
            "    def input(): return sys.stdin.readline().rstrip()",
            "    def ii():    return int(input())",
            "    def mi():    return map(int, input().split())",
            "    def mi_0():  return map(lambda x: int(x)-1, input().split())",
            "    def lmi():   return list(map(int, input().split()))",
            "    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
            "    def li():    return list(input())",
            "    def make_factorial_table(size, mod):",
            "        '''",
            "        fact_mod[i] は i! % mod を表す。fact_mod[0] ~ facto_mod[size] まで計算可能なテーブルを返す",
            "        >>> make_factorial_table(20, 10**9+7)",
            "        [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 227020758, 178290591, 674358851, 789741546, 425606191, 660911389, 557316307, 146326063]",
            "        '''",
            "        fact_mod = [1] * (size + 1)",
            "        for i in range(1, size + 1):",
            "            fact_mod[i] = (fact_mod[i - 1] * i) % mod",
            "        return fact_mod",
            "    def combination(n, r, mod, fact_table):",
            "        '''",
            "        フェルマーの小定理",
            "        a ^ p-1 ≡ 1 (mod p)",
            "        a ^ p-2 ≡ 1/a (mod p) (逆元)",
            "        nCr = (n!) / ((n-r)! * r!) だが、mod p の世界ではこの分母を逆元を用いて計算しておくことが可能",
            "        >>> m = 1000000007",
            "        >>> fact_table = make_factorial_table(100, m)",
            "        >>> combination(10, 5, m, fact_table)",
            "        252",
            "        >>> combination(100, 50, m, fact_table)",
            "        538992043",
            "        '''",
            "        numerator = fact_table[n]",
            "        denominator = (fact_table[n-r] * fact_table[r]) % mod",
            "        # pow はすでに繰り返し二乗法で効率的に実装されている",
            "        return (numerator * pow(denominator, mod-2, mod)) % mod",
            "    h, w, a, b = mi()",
            "    # sigma {k = b to w-1} h-1-a+kCh-1-a * a-1+w-1-kCa-1",
            "    # sample 2 だと {k=4to6} 6+kC6 * 2+6-kC2 = (10C6 * 4C2 + 11C6 * 3C2 + 12C6 * 2C2)",
            "    fact_table = make_factorial_table(2 * h + 2 * w, mod)",
            "    ans = 0",
            "    for k in range(b, w):",
            "        # print(f\"{h-1-a+k} {h-1-a} / {a-1+w-1-k} {a-1}\")",
            "        ans = (ans + combination(h-1-a+k, h-1-a, mod, fact_table) * combination(a-1+w-1-k, a-1, mod, fact_table)) % mod",
            "    print(ans)",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "label": [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            2,
            2,
            2,
            1
        ]
    }
]